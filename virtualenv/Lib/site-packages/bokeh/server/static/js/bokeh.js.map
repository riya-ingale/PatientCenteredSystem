{"version":3,"sources":["src/js/prelude.js","build/js/tree/base.js","build/js/tree/client.js","build/js/tree/core/bokeh_events.js","build/js/tree/core/build_views.js","build/js/tree/core/dom.js","build/js/tree/core/dom_view.js","build/js/tree/core/enums.js","build/js/tree/core/has_props.js","build/js/tree/core/hittest.js","build/js/tree/core/layout/layout_canvas.js","build/js/tree/core/layout/side_panel.js","build/js/tree/core/layout/solver.js","build/js/tree/core/logging.js","build/js/tree/core/properties.js","build/js/tree/core/property_mixins.js","build/js/tree/core/selection_manager.js","build/js/tree/core/selector.js","build/js/tree/core/settings.js","build/js/tree/core/signaling.js","build/js/tree/core/ui_events.js","build/js/tree/core/util/array.js","build/js/tree/core/util/bbox.js","build/js/tree/core/util/callback.js","build/js/tree/core/util/canvas.js","build/js/tree/core/util/color.js","build/js/tree/core/util/data_structures.js","build/js/tree/core/util/eq.js","build/js/tree/core/util/math.js","build/js/tree/core/util/object.js","build/js/tree/core/util/proj4.js","build/js/tree/core/util/projections.js","build/js/tree/core/util/refs.js","build/js/tree/core/util/selection.js","build/js/tree/core/util/serialization.js","build/js/tree/core/util/spatial.js","build/js/tree/core/util/string.js","build/js/tree/core/util/svg_colors.js","build/js/tree/core/util/templating.js","build/js/tree/core/util/text.js","build/js/tree/core/util/throttle.js","build/js/tree/core/util/types.js","build/js/tree/core/util/wheel.js","build/js/tree/core/util/zoom.js","build/js/tree/core/view.js","build/js/tree/core/visuals.js","build/js/tree/document.js","build/js/tree/embed.js","build/js/tree/main.js","build/js/tree/model.js","build/js/tree/models/annotations/annotation.js","build/js/tree/models/annotations/arrow.js","build/js/tree/models/annotations/arrow_head.js","build/js/tree/models/annotations/band.js","build/js/tree/models/annotations/box_annotation.js","build/js/tree/models/annotations/color_bar.js","build/js/tree/models/annotations/index.js","build/js/tree/models/annotations/label.js","build/js/tree/models/annotations/label_set.js","build/js/tree/models/annotations/legend.js","build/js/tree/models/annotations/legend_item.js","build/js/tree/models/annotations/poly_annotation.js","build/js/tree/models/annotations/span.js","build/js/tree/models/annotations/text_annotation.js","build/js/tree/models/annotations/title.js","build/js/tree/models/annotations/tooltip.js","build/js/tree/models/annotations/whisker.js","build/js/tree/models/axes/axis.js","build/js/tree/models/axes/categorical_axis.js","build/js/tree/models/axes/continuous_axis.js","build/js/tree/models/axes/datetime_axis.js","build/js/tree/models/axes/index.js","build/js/tree/models/axes/linear_axis.js","build/js/tree/models/axes/log_axis.js","build/js/tree/models/callbacks/customjs.js","build/js/tree/models/callbacks/index.js","build/js/tree/models/callbacks/open_url.js","build/js/tree/models/canvas/canvas.js","build/js/tree/models/canvas/cartesian_frame.js","build/js/tree/models/canvas/index.js","build/js/tree/models/formatters/basic_tick_formatter.js","build/js/tree/models/formatters/categorical_tick_formatter.js","build/js/tree/models/formatters/datetime_tick_formatter.js","build/js/tree/models/formatters/func_tick_formatter.js","build/js/tree/models/formatters/index.js","build/js/tree/models/formatters/log_tick_formatter.js","build/js/tree/models/formatters/mercator_tick_formatter.js","build/js/tree/models/formatters/numeral_tick_formatter.js","build/js/tree/models/formatters/printf_tick_formatter.js","build/js/tree/models/formatters/tick_formatter.js","build/js/tree/models/glyphs/annular_wedge.js","build/js/tree/models/glyphs/annulus.js","build/js/tree/models/glyphs/arc.js","build/js/tree/models/glyphs/bezier.js","build/js/tree/models/glyphs/circle.js","build/js/tree/models/glyphs/ellipse.js","build/js/tree/models/glyphs/glyph.js","build/js/tree/models/glyphs/hbar.js","build/js/tree/models/glyphs/image.js","build/js/tree/models/glyphs/image_rgba.js","build/js/tree/models/glyphs/image_url.js","build/js/tree/models/glyphs/index.js","build/js/tree/models/glyphs/line.js","build/js/tree/models/glyphs/multi_line.js","build/js/tree/models/glyphs/oval.js","build/js/tree/models/glyphs/patch.js","build/js/tree/models/glyphs/patches.js","build/js/tree/models/glyphs/quad.js","build/js/tree/models/glyphs/quadratic.js","build/js/tree/models/glyphs/ray.js","build/js/tree/models/glyphs/rect.js","build/js/tree/models/glyphs/segment.js","build/js/tree/models/glyphs/text.js","build/js/tree/models/glyphs/vbar.js","build/js/tree/models/glyphs/wedge.js","build/js/tree/models/glyphs/xy_glyph.js","build/js/tree/models/grids/grid.js","build/js/tree/models/grids/index.js","build/js/tree/models/index.js","build/js/tree/models/layouts/box.js","build/js/tree/models/layouts/column.js","build/js/tree/models/layouts/index.js","build/js/tree/models/layouts/layout_dom.js","build/js/tree/models/layouts/row.js","build/js/tree/models/layouts/spacer.js","build/js/tree/models/layouts/widget_box.js","build/js/tree/models/mappers/categorical_color_mapper.js","build/js/tree/models/mappers/color_mapper.js","build/js/tree/models/mappers/index.js","build/js/tree/models/mappers/linear_color_mapper.js","build/js/tree/models/mappers/log_color_mapper.js","build/js/tree/models/markers/index.js","build/js/tree/models/markers/marker.js","build/js/tree/models/plots/gmap_plot.js","build/js/tree/models/plots/gmap_plot_canvas.js","build/js/tree/models/plots/index.js","build/js/tree/models/plots/plot.js","build/js/tree/models/plots/plot_canvas.js","build/js/tree/models/ranges/data_range.js","build/js/tree/models/ranges/data_range1d.js","build/js/tree/models/ranges/factor_range.js","build/js/tree/models/ranges/index.js","build/js/tree/models/ranges/range.js","build/js/tree/models/ranges/range1d.js","build/js/tree/models/renderers/glyph_renderer.js","build/js/tree/models/renderers/guide_renderer.js","build/js/tree/models/renderers/index.js","build/js/tree/models/renderers/renderer.js","build/js/tree/models/scales/categorical_scale.js","build/js/tree/models/scales/index.js","build/js/tree/models/scales/linear_scale.js","build/js/tree/models/scales/log_scale.js","build/js/tree/models/scales/scale.js","build/js/tree/models/sources/ajax_data_source.js","build/js/tree/models/sources/column_data_source.js","build/js/tree/models/sources/columnar_data_source.js","build/js/tree/models/sources/data_source.js","build/js/tree/models/sources/geojson_data_source.js","build/js/tree/models/sources/index.js","build/js/tree/models/sources/remote_data_source.js","build/js/tree/models/tickers/adaptive_ticker.js","build/js/tree/models/tickers/basic_ticker.js","build/js/tree/models/tickers/categorical_ticker.js","build/js/tree/models/tickers/composite_ticker.js","build/js/tree/models/tickers/continuous_ticker.js","build/js/tree/models/tickers/datetime_ticker.js","build/js/tree/models/tickers/days_ticker.js","build/js/tree/models/tickers/fixed_ticker.js","build/js/tree/models/tickers/index.js","build/js/tree/models/tickers/log_ticker.js","build/js/tree/models/tickers/mercator_ticker.js","build/js/tree/models/tickers/months_ticker.js","build/js/tree/models/tickers/single_interval_ticker.js","build/js/tree/models/tickers/ticker.js","build/js/tree/models/tickers/util.js","build/js/tree/models/tickers/years_ticker.js","build/js/tree/models/tiles/bbox_tile_source.js","build/js/tree/models/tiles/dynamic_image_renderer.js","build/js/tree/models/tiles/image_pool.js","build/js/tree/models/tiles/image_source.js","build/js/tree/models/tiles/index.js","build/js/tree/models/tiles/mercator_tile_source.js","build/js/tree/models/tiles/quadkey_tile_source.js","build/js/tree/models/tiles/tile_renderer.js","build/js/tree/models/tiles/tile_source.js","build/js/tree/models/tiles/tile_utils.js","build/js/tree/models/tiles/tms_tile_source.js","build/js/tree/models/tiles/wmts_tile_source.js","build/js/tree/models/tools/actions/action_tool.js","build/js/tree/models/tools/actions/help_tool.js","build/js/tree/models/tools/actions/redo_tool.js","build/js/tree/models/tools/actions/reset_tool.js","build/js/tree/models/tools/actions/save_tool.js","build/js/tree/models/tools/actions/undo_tool.js","build/js/tree/models/tools/actions/zoom_in_tool.js","build/js/tree/models/tools/actions/zoom_out_tool.js","build/js/tree/models/tools/button_tool.js","build/js/tree/models/tools/gestures/box_select_tool.js","build/js/tree/models/tools/gestures/box_zoom_tool.js","build/js/tree/models/tools/gestures/gesture_tool.js","build/js/tree/models/tools/gestures/lasso_select_tool.js","build/js/tree/models/tools/gestures/pan_tool.js","build/js/tree/models/tools/gestures/poly_select_tool.js","build/js/tree/models/tools/gestures/resize_tool.js","build/js/tree/models/tools/gestures/select_tool.js","build/js/tree/models/tools/gestures/tap_tool.js","build/js/tree/models/tools/gestures/wheel_pan_tool.js","build/js/tree/models/tools/gestures/wheel_zoom_tool.js","build/js/tree/models/tools/index.js","build/js/tree/models/tools/inspectors/crosshair_tool.js","build/js/tree/models/tools/inspectors/hover_tool.js","build/js/tree/models/tools/inspectors/inspect_tool.js","build/js/tree/models/tools/on_off_button.js","build/js/tree/models/tools/tool.js","build/js/tree/models/tools/tool_events.js","build/js/tree/models/tools/tool_proxy.js","build/js/tree/models/tools/toolbar.js","build/js/tree/models/tools/toolbar_base.js","build/js/tree/models/tools/toolbar_box.js","build/js/tree/models/tools/toolbar_template.js","build/js/tree/models/transforms/customjs_transform.js","build/js/tree/models/transforms/index.js","build/js/tree/models/transforms/interpolator.js","build/js/tree/models/transforms/jitter.js","build/js/tree/models/transforms/linear_interpolator.js","build/js/tree/models/transforms/step_interpolator.js","build/js/tree/models/transforms/transform.js","build/js/tree/polyfill.js","build/js/tree/safely.js","build/js/tree/version.js","node_modules/canvas2svg/canvas2svg.js","node_modules/d/auto-bind.js","node_modules/d/index.js","node_modules/es5-ext/array/#/clear.js","node_modules/es5-ext/array/#/e-index-of.js","node_modules/es5-ext/array/from/index.js","node_modules/es5-ext/array/from/is-implemented.js","node_modules/es5-ext/array/from/shim.js","node_modules/es5-ext/function/is-arguments.js","node_modules/es5-ext/function/is-function.js","node_modules/es5-ext/function/noop.js","node_modules/es5-ext/global.js","node_modules/es5-ext/math/sign/index.js","node_modules/es5-ext/math/sign/is-implemented.js","node_modules/es5-ext/math/sign/shim.js","node_modules/es5-ext/number/to-integer.js","node_modules/es5-ext/number/to-pos-integer.js","node_modules/es5-ext/object/_iterate.js","node_modules/es5-ext/object/assign/index.js","node_modules/es5-ext/object/assign/is-implemented.js","node_modules/es5-ext/object/assign/shim.js","node_modules/es5-ext/object/copy.js","node_modules/es5-ext/object/create.js","node_modules/es5-ext/object/for-each.js","node_modules/es5-ext/object/is-callable.js","node_modules/es5-ext/object/is-object.js","node_modules/es5-ext/object/keys/index.js","node_modules/es5-ext/object/keys/is-implemented.js","node_modules/es5-ext/object/keys/shim.js","node_modules/es5-ext/object/map.js","node_modules/es5-ext/object/normalize-options.js","node_modules/es5-ext/object/set-prototype-of/index.js","node_modules/es5-ext/object/set-prototype-of/is-implemented.js","node_modules/es5-ext/object/set-prototype-of/shim.js","node_modules/es5-ext/object/valid-callable.js","node_modules/es5-ext/object/valid-object.js","node_modules/es5-ext/object/valid-value.js","node_modules/es5-ext/string/#/contains/index.js","node_modules/es5-ext/string/#/contains/is-implemented.js","node_modules/es5-ext/string/#/contains/shim.js","node_modules/es5-ext/string/is-string.js","node_modules/es5-ext/string/random-uniq.js","node_modules/es6-iterator/array.js","node_modules/es6-iterator/for-of.js","node_modules/es6-iterator/get.js","node_modules/es6-iterator/index.js","node_modules/es6-iterator/is-iterable.js","node_modules/es6-iterator/string.js","node_modules/es6-iterator/valid-iterable.js","node_modules/es6-promise/dist/es6-promise.js","node_modules/es6-set/implement.js","node_modules/es6-set/is-implemented.js","node_modules/es6-set/is-native-implemented.js","node_modules/es6-set/lib/iterator.js","node_modules/es6-set/polyfill.js","node_modules/es6-symbol/index.js","node_modules/es6-symbol/is-implemented.js","node_modules/es6-symbol/is-symbol.js","node_modules/es6-symbol/polyfill.js","node_modules/es6-symbol/validate-symbol.js","node_modules/es6-weak-map/implement.js","node_modules/es6-weak-map/is-implemented.js","node_modules/es6-weak-map/is-native-implemented.js","node_modules/es6-weak-map/polyfill.js","node_modules/event-emitter/index.js","node_modules/hammerjs/hammer.js","node_modules/kiwi/build/constraint.js","node_modules/kiwi/build/expression.js","node_modules/kiwi/build/index.js","node_modules/kiwi/build/maptype.js","node_modules/kiwi/build/solver.js","node_modules/kiwi/build/strength.js","node_modules/kiwi/build/tsu/algorithm.js","node_modules/kiwi/build/tsu/array_base.js","node_modules/kiwi/build/tsu/associative_array.js","node_modules/kiwi/build/tsu/index.js","node_modules/kiwi/build/tsu/iterator.js","node_modules/kiwi/build/tsu/pair.js","node_modules/kiwi/build/variable.js","node_modules/numbro/numbro.js","node_modules/process/browser.js","node_modules/proj4/lib/Proj.js","node_modules/proj4/lib/adjust_axis.js","node_modules/proj4/lib/common/adjust_lon.js","node_modules/proj4/lib/common/msfnz.js","node_modules/proj4/lib/common/phi2z.js","node_modules/proj4/lib/common/sign.js","node_modules/proj4/lib/common/toPoint.js","node_modules/proj4/lib/common/tsfnz.js","node_modules/proj4/lib/constants/Datum.js","node_modules/proj4/lib/constants/Ellipsoid.js","node_modules/proj4/lib/constants/PrimeMeridian.js","node_modules/proj4/lib/constants/units.js","node_modules/proj4/lib/core.js","node_modules/proj4/lib/datum.js","node_modules/proj4/lib/datumUtils.js","node_modules/proj4/lib/datum_transform.js","node_modules/proj4/lib/defs.js","node_modules/proj4/lib/deriveConstants.js","node_modules/proj4/lib/extend.js","node_modules/proj4/lib/global.js","node_modules/proj4/lib/parseCode.js","node_modules/proj4/lib/projString.js","node_modules/proj4/lib/projections.js","node_modules/proj4/lib/projections/longlat.js","node_modules/proj4/lib/projections/merc.js","node_modules/proj4/lib/transform.js","node_modules/proj4/lib/wkt.js","node_modules/quickselect/index.js","node_modules/rbush/index.js","node_modules/sprintf/lib/sprintf.js","node_modules/timezone/index.js","node_modules/tslib/tslib.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACriBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1zBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1mBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClLA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACv+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACltCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACv8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnlFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACn5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACp4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bokeh.js","sourcesContent":["(function outer(modules, cache, entry) {\n    function newRequire(name) {\n        if (!cache[name]) {\n            if (!modules[name]) {\n                var err = new Error('Cannot find module \\'' + name + '\\'');\n                err.code = 'MODULE_NOT_FOUND';\n                throw err;\n            }\n\n            var m = cache[name] = {exports: {}};\n\n            var moduleRequire = function foo(x) {\n                var id = modules[name][1][x];\n                return newRequire(id ? id : x);\n            }\n            moduleRequire.modules = newRequire.modules;\n\n            modules[name][0].call(m.exports, moduleRequire, m, m.exports, outer, modules, cache, entry);\n        }\n\n        return cache[name].exports;\n    }\n\n    newRequire.modules = modules;\n\n    var main = newRequire(entry[0]);\n    main.require = newRequire;\n    return main;\n})\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _all_models, hasProp = {}.hasOwnProperty;\nvar models = require(\"./models/index\");\nvar object_1 = require(\"./core/util/object\");\nexports.overrides = {};\n_all_models = object_1.clone(models);\nexports.Models = function (name) {\n    var model, ref;\n    model = (ref = exports.overrides[name]) != null ? ref : _all_models[name];\n    if (model == null) {\n        throw new Error(\"Model `\" + name + \"' does not exist. This could be due to a widget or a custom model not being registered before first usage.\");\n    }\n    return model;\n};\nexports.Models.register = function (name, model) {\n    return exports.overrides[name] = model;\n};\nexports.Models.unregister = function (name) {\n    return delete exports.overrides[name];\n};\nexports.Models.register_models = function (models, force, errorFn) {\n    var model, name, results;\n    if (force == null) {\n        force = false;\n    }\n    if (errorFn == null) {\n        errorFn = null;\n    }\n    if (models == null) {\n        return;\n    }\n    results = [];\n    for (name in models) {\n        if (!hasProp.call(models, name))\n            continue;\n        model = models[name];\n        if (force || !_all_models.hasOwnProperty(name)) {\n            results.push(_all_models[name] = model);\n        }\n        else {\n            results.push(typeof errorFn === \"function\" ? errorFn(name) : void 0);\n        }\n    }\n    return results;\n};\nexports.Models.registered_names = function () {\n    return Object.keys(_all_models);\n};\nexports.index = {};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ClientConnection, ClientSession, Message, message_handlers;\nvar es6_promise_1 = require(\"es6-promise\");\nvar logging_1 = require(\"./core/logging\");\nvar string_1 = require(\"./core/util/string\");\nvar object_1 = require(\"./core/util/object\");\nvar document_1 = require(\"./document\");\nexports.DEFAULT_SERVER_WEBSOCKET_URL = \"ws://localhost:5006/ws\";\nexports.DEFAULT_SESSION_ID = \"default\";\nMessage = (function () {\n    function Message(header1, metadata1, content1) {\n        this.header = header1;\n        this.metadata = metadata1;\n        this.content = content1;\n        this.buffers = [];\n    }\n    Message.assemble = function (header_json, metadata_json, content_json) {\n        var content, header, metadata;\n        header = JSON.parse(header_json);\n        metadata = JSON.parse(metadata_json);\n        content = JSON.parse(content_json);\n        return new Message(header, metadata, content);\n    };\n    Message.create_header = function (msgtype, options) {\n        var header;\n        header = {\n            'msgid': string_1.uniqueId(),\n            'msgtype': msgtype\n        };\n        return object_1.extend(header, options);\n    };\n    Message.create = function (msgtype, header_options, content) {\n        var header;\n        if (content == null) {\n            content = {};\n        }\n        header = Message.create_header(msgtype, header_options);\n        return new Message(header, {}, content);\n    };\n    Message.prototype.send = function (socket) {\n        var content_json, header_json, metadata_json;\n        header_json = JSON.stringify(this.header);\n        metadata_json = JSON.stringify(this.metadata);\n        content_json = JSON.stringify(this.content);\n        socket.send(header_json);\n        socket.send(metadata_json);\n        return socket.send(content_json);\n    };\n    Message.prototype.complete = function () {\n        if ((this.header != null) && (this.metadata != null) && (this.content != null)) {\n            if ('num_buffers' in this.header) {\n                return this.buffers.length === this.header['num_buffers'];\n            }\n            else {\n                return true;\n            }\n        }\n        else {\n            return false;\n        }\n    };\n    Message.prototype.add_buffer = function (buffer) {\n        return this.buffers.push(buffer);\n    };\n    Message.prototype._header_field = function (field) {\n        if (field in this.header) {\n            return this.header[field];\n        }\n        else {\n            return null;\n        }\n    };\n    Message.prototype.msgid = function () {\n        return this._header_field('msgid');\n    };\n    Message.prototype.msgtype = function () {\n        return this._header_field('msgtype');\n    };\n    Message.prototype.sessid = function () {\n        return this._header_field('sessid');\n    };\n    Message.prototype.reqid = function () {\n        return this._header_field('reqid');\n    };\n    Message.prototype.problem = function () {\n        if (!('msgid' in this.header)) {\n            return \"No msgid in header\";\n        }\n        else if (!('msgtype' in this.header)) {\n            return \"No msgtype in header\";\n        }\n        else {\n            return null;\n        }\n    };\n    return Message;\n})();\nmessage_handlers = {\n    'PATCH-DOC': function (connection, message) {\n        return connection._for_session(function (session) {\n            return session._handle_patch(message);\n        });\n    },\n    'OK': function (connection, message) {\n        return logging_1.logger.trace(\"Unhandled OK reply to \" + (message.reqid()));\n    },\n    'ERROR': function (connection, message) {\n        return logging_1.logger.error(\"Unhandled ERROR reply to \" + (message.reqid()) + \": \" + message.content['text']);\n    }\n};\nClientConnection = (function () {\n    ClientConnection._connection_count = 0;\n    function ClientConnection(url1, id, args_string1, _on_have_session_hook, _on_closed_permanently_hook) {\n        this.url = url1;\n        this.id = id;\n        this.args_string = args_string1;\n        this._on_have_session_hook = _on_have_session_hook;\n        this._on_closed_permanently_hook = _on_closed_permanently_hook;\n        this._number = ClientConnection._connection_count;\n        ClientConnection._connection_count = this._number + 1;\n        if (this.url == null) {\n            this.url = exports.DEFAULT_SERVER_WEBSOCKET_URL;\n        }\n        if (this.id == null) {\n            this.id = exports.DEFAULT_SESSION_ID;\n        }\n        logging_1.logger.debug(\"Creating websocket \" + this._number + \" to '\" + this.url + \"' session '\" + this.id + \"'\");\n        this.socket = null;\n        this.closed_permanently = false;\n        this._fragments = [];\n        this._partial = null;\n        this._current_handler = null;\n        this._pending_ack = null;\n        this._pending_replies = {};\n        this.session = null;\n    }\n    ClientConnection.prototype._for_session = function (f) {\n        if (this.session !== null) {\n            return f(this.session);\n        }\n    };\n    ClientConnection.prototype.connect = function () {\n        var error, ref, versioned_url;\n        if (this.closed_permanently) {\n            return es6_promise_1.Promise.reject(new Error(\"Cannot connect() a closed ClientConnection\"));\n        }\n        if (this.socket != null) {\n            return es6_promise_1.Promise.reject(new Error(\"Already connected\"));\n        }\n        this._fragments = [];\n        this._partial = null;\n        this._pending_replies = {};\n        this._current_handler = null;\n        try {\n            versioned_url = this.url + \"?bokeh-protocol-version=1.0&bokeh-session-id=\" + this.id;\n            if (((ref = this.args_string) != null ? ref.length : void 0) > 0) {\n                versioned_url += \"&\" + this.args_string;\n            }\n            if (window.MozWebSocket != null) {\n                this.socket = new MozWebSocket(versioned_url);\n            }\n            else {\n                this.socket = new WebSocket(versioned_url);\n            }\n            return new es6_promise_1.Promise((function (_this) {\n                return function (resolve, reject) {\n                    _this.socket.binaryType = \"arraybuffer\";\n                    _this.socket.onopen = function () {\n                        return _this._on_open(resolve, reject);\n                    };\n                    _this.socket.onmessage = function (event) {\n                        return _this._on_message(event);\n                    };\n                    _this.socket.onclose = function (event) {\n                        return _this._on_close(event);\n                    };\n                    return _this.socket.onerror = function () {\n                        return _this._on_error(reject);\n                    };\n                };\n            })(this));\n        }\n        catch (error1) {\n            error = error1;\n            logging_1.logger.error(\"websocket creation failed to url: \" + this.url);\n            logging_1.logger.error(\" - \" + error);\n            return es6_promise_1.Promise.reject(error);\n        }\n    };\n    ClientConnection.prototype.close = function () {\n        if (!this.closed_permanently) {\n            logging_1.logger.debug(\"Permanently closing websocket connection \" + this._number);\n            this.closed_permanently = true;\n            if (this.socket != null) {\n                this.socket.close(1000, \"close method called on ClientConnection \" + this._number);\n            }\n            this._for_session(function (session) {\n                return session._connection_closed();\n            });\n            if (this._on_closed_permanently_hook != null) {\n                this._on_closed_permanently_hook();\n                return this._on_closed_permanently_hook = null;\n            }\n        }\n    };\n    ClientConnection.prototype._schedule_reconnect = function (milliseconds) {\n        var retry;\n        retry = (function (_this) {\n            return function () {\n                if (true || _this.closed_permanently) {\n                    if (!_this.closed_permanently) {\n                        logging_1.logger.info(\"Websocket connection \" + _this._number + \" disconnected, will not attempt to reconnect\");\n                    }\n                }\n                else {\n                    logging_1.logger.debug(\"Attempting to reconnect websocket \" + _this._number);\n                    return _this.connect();\n                }\n            };\n        })(this);\n        return setTimeout(retry, milliseconds);\n    };\n    ClientConnection.prototype.send = function (message) {\n        if (this.socket === null) {\n            throw new Error(\"not connected so cannot send \" + message);\n        }\n        return message.send(this.socket);\n    };\n    ClientConnection.prototype.send_event = function (event) {\n        var message;\n        message = Message.create('EVENT', {}, JSON.stringify(event));\n        return this.send(message);\n    };\n    ClientConnection.prototype.send_with_reply = function (message) {\n        var promise;\n        promise = new es6_promise_1.Promise((function (_this) {\n            return function (resolve, reject) {\n                _this._pending_replies[message.msgid()] = [resolve, reject];\n                return _this.send(message);\n            };\n        })(this));\n        return promise.then(function (message) {\n            if (message.msgtype() === 'ERROR') {\n                throw new Error(\"Error reply \" + message.content['text']);\n            }\n            else {\n                return message;\n            }\n        }, function (error) {\n            throw error;\n        });\n    };\n    ClientConnection.prototype._pull_doc_json = function () {\n        var message, promise;\n        message = Message.create('PULL-DOC-REQ', {});\n        promise = this.send_with_reply(message);\n        return promise.then(function (reply) {\n            if (!('doc' in reply.content)) {\n                throw new Error(\"No 'doc' field in PULL-DOC-REPLY\");\n            }\n            return reply.content['doc'];\n        }, function (error) {\n            throw error;\n        });\n    };\n    ClientConnection.prototype._repull_session_doc = function () {\n        if (this.session === null) {\n            logging_1.logger.debug(\"Pulling session for first time\");\n        }\n        else {\n            logging_1.logger.debug(\"Repulling session\");\n        }\n        return this._pull_doc_json().then((function (_this) {\n            return function (doc_json) {\n                var document, patch, patch_message;\n                if (_this.session === null) {\n                    if (_this.closed_permanently) {\n                        return logging_1.logger.debug(\"Got new document after connection was already closed\");\n                    }\n                    else {\n                        document = document_1.Document.from_json(doc_json);\n                        patch = document_1.Document._compute_patch_since_json(doc_json, document);\n                        if (patch.events.length > 0) {\n                            logging_1.logger.debug(\"Sending \" + patch.events.length + \" changes from model construction back to server\");\n                            patch_message = Message.create('PATCH-DOC', {}, patch);\n                            _this.send(patch_message);\n                        }\n                        _this.session = new ClientSession(_this, document, _this.id);\n                        logging_1.logger.debug(\"Created a new session from new pulled doc\");\n                        if (_this._on_have_session_hook != null) {\n                            _this._on_have_session_hook(_this.session);\n                            return _this._on_have_session_hook = null;\n                        }\n                    }\n                }\n                else {\n                    _this.session.document.replace_with_json(doc_json);\n                    return logging_1.logger.debug(\"Updated existing session with new pulled doc\");\n                }\n            };\n        })(this), function (error) {\n            throw error;\n        })[\"catch\"](function (error) {\n            if (console.trace != null) {\n                console.trace(error);\n            }\n            return logging_1.logger.error(\"Failed to repull session \" + error);\n        });\n    };\n    ClientConnection.prototype._on_open = function (resolve, reject) {\n        logging_1.logger.info(\"Websocket connection \" + this._number + \" is now open\");\n        this._pending_ack = [resolve, reject];\n        return this._current_handler = (function (_this) {\n            return function (message) {\n                return _this._awaiting_ack_handler(message);\n            };\n        })(this);\n    };\n    ClientConnection.prototype._on_message = function (event) {\n        return this._on_message_unchecked(event);\n    };\n    ClientConnection.prototype._on_message_unchecked = function (event) {\n        var msg, problem;\n        if (this._current_handler == null) {\n            logging_1.logger.error(\"got a message but haven't set _current_handler\");\n        }\n        if (event.data instanceof ArrayBuffer) {\n            if ((this._partial != null) && !this._partial.complete()) {\n                this._partial.add_buffer(event.data);\n            }\n            else {\n                this._close_bad_protocol(\"Got binary from websocket but we were expecting text\");\n            }\n        }\n        else if (this._partial != null) {\n            this._close_bad_protocol(\"Got text from websocket but we were expecting binary\");\n        }\n        else {\n            this._fragments.push(event.data);\n            if (this._fragments.length === 3) {\n                this._partial = Message.assemble(this._fragments[0], this._fragments[1], this._fragments[2]);\n                this._fragments = [];\n                problem = this._partial.problem();\n                if (problem !== null) {\n                    this._close_bad_protocol(problem);\n                }\n            }\n        }\n        if ((this._partial != null) && this._partial.complete()) {\n            msg = this._partial;\n            this._partial = null;\n            return this._current_handler(msg);\n        }\n    };\n    ClientConnection.prototype._on_close = function (event) {\n        var pop_pending, promise_funcs;\n        logging_1.logger.info(\"Lost websocket \" + this._number + \" connection, \" + event.code + \" (\" + event.reason + \")\");\n        this.socket = null;\n        if (this._pending_ack != null) {\n            this._pending_ack[1](new Error(\"Lost websocket connection, \" + event.code + \" (\" + event.reason + \")\"));\n            this._pending_ack = null;\n        }\n        pop_pending = (function (_this) {\n            return function () {\n                var promise_funcs, ref, reqid;\n                ref = _this._pending_replies;\n                for (reqid in ref) {\n                    promise_funcs = ref[reqid];\n                    delete _this._pending_replies[reqid];\n                    return promise_funcs;\n                }\n                return null;\n            };\n        })(this);\n        promise_funcs = pop_pending();\n        while (promise_funcs !== null) {\n            promise_funcs[1](\"Disconnected\");\n            promise_funcs = pop_pending();\n        }\n        if (!this.closed_permanently) {\n            return this._schedule_reconnect(2000);\n        }\n    };\n    ClientConnection.prototype._on_error = function (reject) {\n        logging_1.logger.debug(\"Websocket error on socket  \" + this._number);\n        return reject(new Error(\"Could not open websocket\"));\n    };\n    ClientConnection.prototype._close_bad_protocol = function (detail) {\n        logging_1.logger.error(\"Closing connection: \" + detail);\n        if (this.socket != null) {\n            return this.socket.close(1002, detail);\n        }\n    };\n    ClientConnection.prototype._awaiting_ack_handler = function (message) {\n        if (message.msgtype() === \"ACK\") {\n            this._current_handler = (function (_this) {\n                return function (message) {\n                    return _this._steady_state_handler(message);\n                };\n            })(this);\n            this._repull_session_doc();\n            if (this._pending_ack != null) {\n                this._pending_ack[0](this);\n                return this._pending_ack = null;\n            }\n        }\n        else {\n            return this._close_bad_protocol(\"First message was not an ACK\");\n        }\n    };\n    ClientConnection.prototype._steady_state_handler = function (message) {\n        var promise_funcs;\n        if (message.reqid() in this._pending_replies) {\n            promise_funcs = this._pending_replies[message.reqid()];\n            delete this._pending_replies[message.reqid()];\n            return promise_funcs[0](message);\n        }\n        else if (message.msgtype() in message_handlers) {\n            return message_handlers[message.msgtype()](this, message);\n        }\n        else {\n            return logging_1.logger.debug(\"Doing nothing with message \" + (message.msgtype()));\n        }\n    };\n    return ClientConnection;\n})();\nClientSession = (function () {\n    function ClientSession(_connection, document1, id) {\n        this._connection = _connection;\n        this.document = document1;\n        this.id = id;\n        this.document_listener = (function (_this) {\n            return function (event) {\n                return _this._document_changed(event);\n            };\n        })(this);\n        this.document.on_change(this.document_listener);\n        this.event_manager = this.document.event_manager;\n        this.event_manager.session = this;\n    }\n    ClientSession.prototype.close = function () {\n        return this._connection.close();\n    };\n    ClientSession.prototype.send_event = function (type) {\n        return this._connection.send_event(type);\n    };\n    ClientSession.prototype._connection_closed = function () {\n        return this.document.remove_on_change(this.document_listener);\n    };\n    ClientSession.prototype.request_server_info = function () {\n        var message, promise;\n        message = Message.create('SERVER-INFO-REQ', {});\n        promise = this._connection.send_with_reply(message);\n        return promise.then(function (reply) {\n            return reply.content;\n        });\n    };\n    ClientSession.prototype.force_roundtrip = function () {\n        return this.request_server_info().then(function (ignored) {\n            return void 0;\n        });\n    };\n    ClientSession.prototype._document_changed = function (event) {\n        var patch;\n        if (event.setter_id === this.id) {\n            return;\n        }\n        if (event instanceof document_1.ModelChangedEvent && !(event.attr in event.model.serializable_attributes())) {\n            return;\n        }\n        patch = Message.create('PATCH-DOC', {}, this.document.create_json_patch([event]));\n        return this._connection.send(patch);\n    };\n    ClientSession.prototype._handle_patch = function (message) {\n        return this.document.apply_json_patch(message.content, this.id);\n    };\n    return ClientSession;\n})();\nexports.pull_session = function (url, session_id, args_string) {\n    var connection, promise, rejecter;\n    rejecter = null;\n    connection = null;\n    promise = new es6_promise_1.Promise(function (resolve, reject) {\n        connection = new ClientConnection(url, session_id, args_string, function (session) {\n            var e;\n            try {\n                return resolve(session);\n            }\n            catch (error1) {\n                e = error1;\n                logging_1.logger.error(\"Promise handler threw an error, closing session \" + error);\n                session.close();\n                throw e;\n            }\n        }, function () {\n            return reject(new Error(\"Connection was closed before we successfully pulled a session\"));\n        });\n        return connection.connect().then(function (whatever) { }, function (error) {\n            logging_1.logger.error(\"Failed to connect to Bokeh server \" + error);\n            throw error;\n        });\n    });\n    promise.close = function () {\n        return connection.close();\n    };\n    return promise;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar logging_1 = require(\"./logging\");\nvar object_1 = require(\"./util/object\");\nvar event_classes = {};\nfunction register_event_class(event_name) {\n    return function (event_cls) {\n        event_cls.prototype.event_name = event_name;\n        event_classes[event_name] = event_cls;\n    };\n}\nexports.register_event_class = register_event_class;\nfunction register_with_event(event_cls) {\n    var models = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        models[_i - 1] = arguments[_i];\n    }\n    var applicable_models = event_cls.prototype.applicable_models.concat(models);\n    event_cls.prototype.applicable_models = applicable_models;\n}\nexports.register_with_event = register_with_event;\nvar BokehEvent = (function () {\n    function BokehEvent(options) {\n        if (options === void 0) { options = {}; }\n        this.model_id = null;\n        this._options = options;\n        if (options.model_id) {\n            this.model_id = options.model_id;\n        }\n    }\n    BokehEvent.prototype.set_model_id = function (id) {\n        this._options.model_id = id;\n        this.model_id = id;\n        return this;\n    };\n    BokehEvent.prototype.is_applicable_to = function (obj) {\n        return this.applicable_models.some(function (model) { return obj instanceof model; });\n    };\n    BokehEvent.event_class = function (e) {\n        // Given an event with a type attribute matching the event_name,\n        // return the appropriate BokehEvent class\n        if (e.type) {\n            return event_classes[e.type];\n        }\n        else {\n            logging_1.logger.warn('BokehEvent.event_class required events with a string type attribute');\n        }\n    };\n    BokehEvent.prototype.toJSON = function () {\n        return {\n            event_name: this.event_name,\n            event_values: object_1.clone(this._options),\n        };\n    };\n    BokehEvent.prototype._customize_event = function (_model) {\n        return this;\n    };\n    return BokehEvent;\n}());\nexports.BokehEvent = BokehEvent;\nBokehEvent.prototype.applicable_models = [];\nvar ButtonClick = (function (_super) {\n    tslib_1.__extends(ButtonClick, _super);\n    function ButtonClick() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ButtonClick;\n}(BokehEvent));\nButtonClick = tslib_1.__decorate([\n    register_event_class(\"button_click\")\n], ButtonClick);\nexports.ButtonClick = ButtonClick;\n// A UIEvent is an event originating on a PlotCanvas this includes\n// DOM events such as keystrokes as well as hammer events and LOD events.\nvar UIEvent = (function (_super) {\n    tslib_1.__extends(UIEvent, _super);\n    function UIEvent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return UIEvent;\n}(BokehEvent));\nexports.UIEvent = UIEvent;\nvar LODStart = (function (_super) {\n    tslib_1.__extends(LODStart, _super);\n    function LODStart() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return LODStart;\n}(UIEvent));\nLODStart = tslib_1.__decorate([\n    register_event_class(\"lodstart\")\n], LODStart);\nexports.LODStart = LODStart;\nvar LODEnd = (function (_super) {\n    tslib_1.__extends(LODEnd, _super);\n    function LODEnd() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return LODEnd;\n}(UIEvent));\nLODEnd = tslib_1.__decorate([\n    register_event_class(\"lodend\")\n], LODEnd);\nexports.LODEnd = LODEnd;\nvar PointEvent = (function (_super) {\n    tslib_1.__extends(PointEvent, _super);\n    function PointEvent(options) {\n        var _this = _super.call(this, options) || this;\n        _this.sx = options.sx;\n        _this.sy = options.sy;\n        _this.x = null;\n        _this.y = null;\n        return _this;\n    }\n    PointEvent.from_event = function (e, model_id) {\n        if (model_id === void 0) { model_id = null; }\n        return new this({ sx: e.bokeh['sx'], sy: e.bokeh['sy'], model_id: model_id });\n    };\n    PointEvent.prototype._customize_event = function (plot) {\n        var xscale = plot.plot_canvas.frame.xscales['default'];\n        var yscale = plot.plot_canvas.frame.yscales['default'];\n        this.x = xscale.invert(plot.plot_canvas.canvas.sx_to_vx(this.sx));\n        this.y = yscale.invert(plot.plot_canvas.canvas.sy_to_vy(this.sy));\n        this._options['x'] = this.x;\n        this._options['y'] = this.y;\n        return this;\n    };\n    return PointEvent;\n}(UIEvent));\nexports.PointEvent = PointEvent;\nvar Pan = (function (_super) {\n    tslib_1.__extends(Pan, _super);\n    function Pan(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, options) || this;\n        _this.delta_x = options.delta_x;\n        _this.delta_y = options.delta_y;\n        return _this;\n    }\n    Pan.from_event = function (e, model_id) {\n        if (model_id === void 0) { model_id = null; }\n        return new this({\n            sx: e.bokeh['sx'],\n            sy: e.bokeh['sy'],\n            delta_x: e.deltaX,\n            delta_y: e.deltaY,\n            direction: e.direction,\n            model_id: model_id\n        });\n    };\n    return Pan;\n}(PointEvent));\nPan = tslib_1.__decorate([\n    register_event_class(\"pan\")\n], Pan);\nexports.Pan = Pan;\nvar Pinch = (function (_super) {\n    tslib_1.__extends(Pinch, _super);\n    function Pinch(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, options) || this;\n        _this.scale = options.scale;\n        return _this;\n    }\n    Pinch.from_event = function (e, model_id) {\n        if (model_id === void 0) { model_id = null; }\n        return new this({\n            sx: e.bokeh['sx'],\n            sy: e.bokeh['sy'],\n            scale: e.scale,\n            model_id: model_id,\n        });\n    };\n    return Pinch;\n}(PointEvent));\nPinch = tslib_1.__decorate([\n    register_event_class(\"pinch\")\n], Pinch);\nexports.Pinch = Pinch;\nvar MouseWheel = (function (_super) {\n    tslib_1.__extends(MouseWheel, _super);\n    function MouseWheel(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, options) || this;\n        _this.delta = options.delta;\n        return _this;\n    }\n    MouseWheel.from_event = function (e, model_id) {\n        if (model_id === void 0) { model_id = null; }\n        return new this({\n            sx: e.bokeh['sx'],\n            sy: e.bokeh['sy'],\n            delta: e.bokeh['delta'],\n            model_id: model_id,\n        });\n    };\n    return MouseWheel;\n}(PointEvent));\nMouseWheel = tslib_1.__decorate([\n    register_event_class(\"wheel\")\n], MouseWheel);\nexports.MouseWheel = MouseWheel;\nvar MouseMove = (function (_super) {\n    tslib_1.__extends(MouseMove, _super);\n    function MouseMove() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return MouseMove;\n}(PointEvent));\nMouseMove = tslib_1.__decorate([\n    register_event_class(\"mousemove\")\n], MouseMove);\nexports.MouseMove = MouseMove;\nvar MouseEnter = (function (_super) {\n    tslib_1.__extends(MouseEnter, _super);\n    function MouseEnter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return MouseEnter;\n}(PointEvent));\nMouseEnter = tslib_1.__decorate([\n    register_event_class(\"mouseenter\")\n], MouseEnter);\nexports.MouseEnter = MouseEnter;\nvar MouseLeave = (function (_super) {\n    tslib_1.__extends(MouseLeave, _super);\n    function MouseLeave() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return MouseLeave;\n}(PointEvent));\nMouseLeave = tslib_1.__decorate([\n    register_event_class(\"mouseleave\")\n], MouseLeave);\nexports.MouseLeave = MouseLeave;\nvar Tap = (function (_super) {\n    tslib_1.__extends(Tap, _super);\n    function Tap() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return Tap;\n}(PointEvent));\nTap = tslib_1.__decorate([\n    register_event_class(\"tap\")\n], Tap);\nexports.Tap = Tap;\nvar DoubleTap = (function (_super) {\n    tslib_1.__extends(DoubleTap, _super);\n    function DoubleTap() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return DoubleTap;\n}(PointEvent));\nDoubleTap = tslib_1.__decorate([\n    register_event_class(\"doubletap\")\n], DoubleTap);\nexports.DoubleTap = DoubleTap;\nvar Press = (function (_super) {\n    tslib_1.__extends(Press, _super);\n    function Press() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return Press;\n}(PointEvent));\nPress = tslib_1.__decorate([\n    register_event_class(\"press\")\n], Press);\nexports.Press = Press;\nvar PanStart = (function (_super) {\n    tslib_1.__extends(PanStart, _super);\n    function PanStart() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return PanStart;\n}(PointEvent));\nPanStart = tslib_1.__decorate([\n    register_event_class(\"panstart\")\n], PanStart);\nexports.PanStart = PanStart;\nvar PanEnd = (function (_super) {\n    tslib_1.__extends(PanEnd, _super);\n    function PanEnd() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return PanEnd;\n}(PointEvent));\nPanEnd = tslib_1.__decorate([\n    register_event_class(\"panend\")\n], PanEnd);\nexports.PanEnd = PanEnd;\nvar PinchStart = (function (_super) {\n    tslib_1.__extends(PinchStart, _super);\n    function PinchStart() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return PinchStart;\n}(PointEvent));\nPinchStart = tslib_1.__decorate([\n    register_event_class(\"pinchstart\")\n], PinchStart);\nexports.PinchStart = PinchStart;\nvar PinchEnd = (function (_super) {\n    tslib_1.__extends(PinchEnd, _super);\n    function PinchEnd() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return PinchEnd;\n}(PointEvent));\nPinchEnd = tslib_1.__decorate([\n    register_event_class(\"pinchend\")\n], PinchEnd);\nexports.PinchEnd = PinchEnd;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar array_1 = require(\"./util/array\");\nvar object_1 = require(\"./util/object\");\nexports.build_views = function (view_storage, view_models, options, view_types) {\n    var created_views, i, j, k, len, len1, model, model_id, new_models, ref, to_remove, view, view_cls, view_options;\n    if (view_types == null) {\n        view_types = [];\n    }\n    to_remove = array_1.difference(Object.keys(view_storage), (function () {\n        var j, len, results;\n        results = [];\n        for (j = 0, len = view_models.length; j < len; j++) {\n            model = view_models[j];\n            results.push(model.id);\n        }\n        return results;\n    })());\n    for (j = 0, len = to_remove.length; j < len; j++) {\n        model_id = to_remove[j];\n        view_storage[model_id].remove();\n        delete view_storage[model_id];\n    }\n    created_views = [];\n    new_models = view_models.filter(function (model) {\n        return view_storage[model.id] == null;\n    });\n    for (i = k = 0, len1 = new_models.length; k < len1; i = ++k) {\n        model = new_models[i];\n        view_cls = (ref = view_types[i]) != null ? ref : model.default_view;\n        view_options = object_1.extend({\n            model: model\n        }, options);\n        view_storage[model.id] = view = new view_cls(view_options);\n        created_views.push(view);\n    }\n    return created_views;\n};\nexports.remove_views = function (view_storage) {\n    var id, j, len, ref, results;\n    ref = object_1.keys(view_storage);\n    results = [];\n    for (j = 0, len = ref.length; j < len; j++) {\n        id = ref[j];\n        view_storage[id].remove();\n        results.push(delete view_storage[id]);\n    }\n    return results;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar types_1 = require(\"./util/types\");\nvar _createElement = function (tag) { return function (attrs) {\n    if (attrs === void 0) { attrs = {}; }\n    var children = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        children[_i - 1] = arguments[_i];\n    }\n    var element;\n    if (tag === \"fragment\") {\n        // XXX: this is wrong, but the the common super type of DocumentFragment and HTMLElement is\n        // Node, which doesn't support classList, style, etc. attributes.\n        element = document.createDocumentFragment();\n    }\n    else {\n        element = document.createElement(tag);\n        for (var attr in attrs) {\n            var value = attrs[attr];\n            if (value == null || types_1.isBoolean(value) && !value)\n                continue;\n            if (attr === \"class\" && types_1.isArray(value)) {\n                for (var _a = 0, _b = value; _a < _b.length; _a++) {\n                    var cls = _b[_a];\n                    if (cls != null)\n                        element.classList.add(cls);\n                }\n                continue;\n            }\n            if (attr === \"style\" && types_1.isObject(value)) {\n                for (var prop in value) {\n                    element.style[prop] = value[prop];\n                }\n                continue;\n            }\n            element.setAttribute(attr, value);\n        }\n    }\n    function append(child) {\n        if (child instanceof HTMLElement)\n            element.appendChild(child);\n        else if (types_1.isString(child))\n            element.appendChild(document.createTextNode(child));\n        else if (child != null && child !== false)\n            throw new Error(\"expected an HTMLElement, string, false or null, got \" + JSON.stringify(child));\n    }\n    for (var _c = 0, children_1 = children; _c < children_1.length; _c++) {\n        var child = children_1[_c];\n        if (types_1.isArray(child)) {\n            for (var _d = 0, child_1 = child; _d < child_1.length; _d++) {\n                var _child = child_1[_d];\n                append(_child);\n            }\n        }\n        else\n            append(child);\n    }\n    return element;\n}; };\nfunction createElement(tag, attrs) {\n    var children = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        children[_i - 2] = arguments[_i];\n    }\n    return _createElement(tag).apply(void 0, [attrs].concat(children));\n}\nexports.createElement = createElement;\nexports.div = _createElement(\"div\"), exports.span = _createElement(\"span\"), exports.link = _createElement(\"link\"), exports.style = _createElement(\"style\"), exports.a = _createElement(\"a\"), exports.p = _createElement(\"p\"), exports.pre = _createElement(\"pre\"), exports.button = _createElement(\"button\"), exports.input = _createElement(\"input\"), exports.label = _createElement(\"label\"), exports.canvas = _createElement(\"canvas\"), exports.ul = _createElement(\"ul\"), exports.ol = _createElement(\"ol\"), exports.li = _createElement(\"li\");\nexports.nbsp = document.createTextNode(\"\\u00a0\");\nfunction removeElement(element) {\n    var parent = element.parentNode;\n    if (parent != null) {\n        parent.removeChild(element);\n    }\n}\nexports.removeElement = removeElement;\nfunction replaceWith(element, replacement) {\n    var parent = element.parentNode;\n    if (parent != null) {\n        parent.replaceChild(replacement, element);\n    }\n}\nexports.replaceWith = replaceWith;\nfunction prepend(element) {\n    var nodes = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        nodes[_i - 1] = arguments[_i];\n    }\n    var first = element.firstChild;\n    for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {\n        var node = nodes_1[_a];\n        element.insertBefore(node, first);\n    }\n}\nexports.prepend = prepend;\nfunction empty(element) {\n    var child;\n    while (child = element.firstChild) {\n        element.removeChild(child);\n    }\n}\nexports.empty = empty;\nfunction show(element) {\n    element.style.display = \"\";\n}\nexports.show = show;\nfunction hide(element) {\n    element.style.display = \"none\";\n}\nexports.hide = hide;\nfunction position(element) {\n    return {\n        top: element.offsetTop,\n        left: element.offsetLeft,\n    };\n}\nexports.position = position;\nfunction offset(element) {\n    var rect = element.getBoundingClientRect();\n    return {\n        top: rect.top + window.pageYOffset - document.documentElement.clientTop,\n        left: rect.left + window.pageXOffset - document.documentElement.clientLeft,\n    };\n}\nexports.offset = offset;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar view_1 = require(\"./view\");\nvar DOM = require(\"./dom\");\nexports.DOMView = (function (superClass) {\n    extend(DOMView, superClass);\n    function DOMView() {\n        return DOMView.__super__.constructor.apply(this, arguments);\n    }\n    DOMView.prototype.tagName = 'div';\n    DOMView.prototype.initialize = function (options) {\n        DOMView.__super__.initialize.call(this, options);\n        this._has_finished = false;\n        return this.el = this._createElement();\n    };\n    DOMView.prototype.remove = function () {\n        DOM.removeElement(this.el);\n        return DOMView.__super__.remove.call(this);\n    };\n    DOMView.prototype.layout = function () { };\n    DOMView.prototype.render = function () { };\n    DOMView.prototype.renderTo = function (element, replace) {\n        if (replace == null) {\n            replace = false;\n        }\n        if (!replace) {\n            element.appendChild(this.el);\n        }\n        else {\n            DOM.replaceWith(element, this.el);\n        }\n        return this.layout();\n    };\n    DOMView.prototype.has_finished = function () {\n        return this._has_finished;\n    };\n    DOMView.prototype.notify_finished = function () {\n        return this.root.notify_finished();\n    };\n    DOMView.getters({\n        solver: function () {\n            if (this.is_root) {\n                return this._solver;\n            }\n            else {\n                return this.parent.solver;\n            }\n        },\n        is_idle: function () {\n            return this.has_finished();\n        }\n    });\n    DOMView.prototype._createElement = function () {\n        return DOM.createElement(this.tagName, {\n            id: this.id,\n            \"class\": this.className\n        });\n    };\n    return DOMView;\n})(view_1.View);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AngleUnits = [\"deg\", \"rad\"];\nexports.Dimension = [\"width\", \"height\"];\nexports.Dimensions = [\"width\", \"height\", \"both\"];\nexports.Direction = [\"clock\", \"anticlock\"];\nexports.FontStyle = [\"normal\", \"italic\", \"bold\"];\nexports.LatLon = [\"lat\", \"lon\"];\nexports.LineCap = [\"butt\", \"round\", \"square\"];\nexports.LineJoin = [\"miter\", \"round\", \"bevel\"];\nexports.Location = [\"above\", \"below\", \"left\", \"right\"];\nexports.LegendLocation = [\"top_left\", \"top_center\", \"top_right\", \"center_left\", \"center\", \"center_right\", \"bottom_left\", \"bottom_center\", \"bottom_right\"];\nexports.Orientation = [\"vertical\", \"horizontal\"];\nexports.OutputBackend = [\"canvas\", \"svg\", \"webgl\"];\nexports.RenderLevel = [\"image\", \"underlay\", \"glyph\", \"annotation\", \"overlay\"];\nexports.RenderMode = [\"canvas\", \"css\"];\nexports.Side = [\"left\", \"right\"];\nexports.SpatialUnits = [\"screen\", \"data\"];\nexports.StartEnd = [\"start\", \"end\"];\nexports.TextAlign = [\"left\", \"right\", \"center\"];\nexports.TextBaseline = [\"top\", \"middle\", \"bottom\", \"alphabetic\", \"hanging\", \"ideographic\"];\nexports.DistributionTypes = [\"uniform\", \"normal\"];\nexports.TransformStepModes = [\"after\", \"before\", \"center\"];\nexports.SizingMode = [\"stretch_both\", \"scale_width\", \"scale_height\", \"scale_both\", \"fixed\"];\nexports.PaddingUnits = [\"percent\", \"absolute\"];\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, slice = [].slice;\nvar logging_1 = require(\"./logging\");\nvar signaling_1 = require(\"./signaling\");\nvar property_mixins = require(\"./property_mixins\");\nvar refs = require(\"./util/refs\");\nvar p = require(\"./properties\");\nvar string_1 = require(\"./util/string\");\nvar array_1 = require(\"./util/array\");\nvar object_1 = require(\"./util/object\");\nvar types_1 = require(\"./util/types\");\nvar eq_1 = require(\"./util/eq\");\nexports.HasProps = (function () {\n    extend1(HasProps.prototype, signaling_1.Signalable);\n    HasProps.getters = function (specs) {\n        var fn, name, results;\n        results = [];\n        for (name in specs) {\n            fn = specs[name];\n            results.push(Object.defineProperty(this.prototype, name, {\n                get: fn\n            }));\n        }\n        return results;\n    };\n    HasProps.prototype.props = {};\n    HasProps.prototype.mixins = [];\n    HasProps.define = function (object) {\n        var name, prop, results;\n        results = [];\n        for (name in object) {\n            prop = object[name];\n            results.push((function (_this) {\n                return function (name, prop) {\n                    var default_value, internal, props, refined_prop, type;\n                    if (_this.prototype.props[name] != null) {\n                        throw new Error(\"attempted to redefine property '\" + _this.name + \".\" + name + \"'\");\n                    }\n                    if (_this.prototype[name] != null) {\n                        throw new Error(\"attempted to redefine attribute '\" + _this.name + \".\" + name + \"'\");\n                    }\n                    Object.defineProperty(_this.prototype, name, {\n                        get: function () {\n                            var value;\n                            value = this.getv(name);\n                            return value;\n                        },\n                        set: function (value) {\n                            this.setv(name, value);\n                            return this;\n                        }\n                    }, {\n                        configurable: false,\n                        enumerable: true\n                    });\n                    type = prop[0], default_value = prop[1], internal = prop[2];\n                    refined_prop = {\n                        type: type,\n                        default_value: default_value,\n                        internal: internal != null ? internal : false\n                    };\n                    props = object_1.clone(_this.prototype.props);\n                    props[name] = refined_prop;\n                    return _this.prototype.props = props;\n                };\n            })(this)(name, prop));\n        }\n        return results;\n    };\n    HasProps.internal = function (object) {\n        var _object, fn1, name, prop;\n        _object = {};\n        fn1 = (function (_this) {\n            return function (name, prop) {\n                var default_value, type;\n                type = prop[0], default_value = prop[1];\n                return _object[name] = [type, default_value, true];\n            };\n        })(this);\n        for (name in object) {\n            prop = object[name];\n            fn1(name, prop);\n        }\n        return this.define(_object);\n    };\n    HasProps.mixin = function () {\n        var mixins, names;\n        names = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        this.define(property_mixins.create(names));\n        mixins = this.prototype.mixins.concat(names);\n        return this.prototype.mixins = mixins;\n    };\n    HasProps.mixins = function (names) {\n        return this.mixin.apply(this, names);\n    };\n    HasProps.override = function (name_or_object, default_value) {\n        var name, object, results;\n        if (types_1.isString(name_or_object)) {\n            object = {};\n            object[name] = default_value;\n        }\n        else {\n            object = name_or_object;\n        }\n        results = [];\n        for (name in object) {\n            default_value = object[name];\n            results.push((function (_this) {\n                return function (name, default_value) {\n                    var props, value;\n                    value = _this.prototype.props[name];\n                    if (value == null) {\n                        throw new Error(\"attempted to override nonexistent '\" + _this.name + \".\" + name + \"'\");\n                    }\n                    props = object_1.clone(_this.prototype.props);\n                    props[name] = object_1.extend({}, value, {\n                        default_value: default_value\n                    });\n                    return _this.prototype.props = props;\n                };\n            })(this)(name, default_value));\n        }\n        return results;\n    };\n    HasProps.define({\n        id: [p.Any]\n    });\n    HasProps.prototype.toString = function () {\n        return this.type + \"(\" + this.id + \")\";\n    };\n    function HasProps(attributes, options) {\n        var default_value, name, ref, ref1, type;\n        if (attributes == null) {\n            attributes = {};\n        }\n        if (options == null) {\n            options = {};\n        }\n        this.document = null;\n        this.destroyed = new signaling_1.Signal(this, \"destroyed\");\n        this.change = new signaling_1.Signal(this, \"change\");\n        this.propchange = new signaling_1.Signal(this, \"propchange\");\n        this.transformchange = new signaling_1.Signal(this, \"transformchange\");\n        this.attributes = {};\n        this.properties = {};\n        ref = this.props;\n        for (name in ref) {\n            ref1 = ref[name], type = ref1.type, default_value = ref1.default_value;\n            if (type == null) {\n                throw new Error(\"undefined property type for \" + this.type + \".\" + name);\n            }\n            this.properties[name] = new type({\n                obj: this,\n                attr: name,\n                default_value: default_value\n            });\n        }\n        this._set_after_defaults = {};\n        if (attributes.id == null) {\n            this.setv(\"id\", string_1.uniqueId(), {\n                silent: true\n            });\n        }\n        this.setv(attributes, object_1.extend({\n            silent: true\n        }, options));\n        if (!options.defer_initialization) {\n            this.finalize(attributes, options);\n        }\n    }\n    HasProps.prototype.finalize = function (attributes, options) {\n        var name, prop, ref;\n        ref = this.properties;\n        for (name in ref) {\n            prop = ref[name];\n            prop.update();\n            if (prop.spec.transform) {\n                this.connect(prop.spec.transform.change, function () {\n                    return this.transformchange.emit();\n                });\n            }\n        }\n        this.initialize(attributes, options);\n        return this.connect_signals();\n    };\n    HasProps.prototype.initialize = function (attributes, options) { };\n    HasProps.prototype.connect_signals = function () { };\n    HasProps.prototype.disconnect_signals = function () {\n        return signaling_1.Signal.disconnectReceiver(this);\n    };\n    HasProps.prototype.destroy = function () {\n        this.disconnect_signals();\n        return this.destroyed.emit();\n    };\n    HasProps.prototype.clone = function () {\n        return new this.constructor(this.attributes);\n    };\n    HasProps.prototype._setv = function (attrs, options) {\n        var attr, changes, changing, current, i, j, ref, silent, val;\n        silent = options.silent;\n        changes = [];\n        changing = this._changing;\n        this._changing = true;\n        current = this.attributes;\n        for (attr in attrs) {\n            val = attrs[attr];\n            val = attrs[attr];\n            if (!eq_1.isEqual(current[attr], val)) {\n                changes.push(attr);\n            }\n            current[attr] = val;\n        }\n        if (!silent) {\n            if (changes.length) {\n                this._pending = true;\n            }\n            for (i = j = 0, ref = changes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                this.properties[changes[i]].change.emit(current[changes[i]]);\n            }\n        }\n        if (changing) {\n            return this;\n        }\n        if (!silent && !options.no_change) {\n            while (this._pending) {\n                this._pending = false;\n                this.change.emit();\n            }\n        }\n        this._pending = false;\n        this._changing = false;\n        return this;\n    };\n    HasProps.prototype.setv = function (key, value, options) {\n        var attrs, old, prop_name, results, val;\n        if (types_1.isObject(key) || key === null) {\n            attrs = key;\n            options = value;\n        }\n        else {\n            attrs = {};\n            attrs[key] = value;\n        }\n        if (options == null) {\n            options = {};\n        }\n        for (key in attrs) {\n            if (!hasProp.call(attrs, key))\n                continue;\n            val = attrs[key];\n            prop_name = key;\n            if (this.props[prop_name] == null) {\n                throw new Error(\"property \" + this.type + \".\" + prop_name + \" wasn't declared\");\n            }\n            if (!((options != null) && options.defaults)) {\n                this._set_after_defaults[key] = true;\n            }\n        }\n        if (!object_1.isEmpty(attrs)) {\n            old = {};\n            for (key in attrs) {\n                value = attrs[key];\n                old[key] = this.getv(key);\n            }\n            this._setv(attrs, options);\n            if ((options != null ? options.silent : void 0) == null) {\n                results = [];\n                for (key in attrs) {\n                    value = attrs[key];\n                    results.push(this._tell_document_about_change(key, old[key], this.getv(key), options));\n                }\n                return results;\n            }\n        }\n    };\n    HasProps.prototype.set = function (key, value, options) {\n        logging_1.logger.warn(\"HasProps.set('prop_name', value) is deprecated, use HasProps.prop_name = value instead\");\n        return this.setv(key, value, options);\n    };\n    HasProps.prototype.get = function (prop_name) {\n        logging_1.logger.warn(\"HasProps.get('prop_name') is deprecated, use HasProps.prop_name instead\");\n        return this.getv(prop_name);\n    };\n    HasProps.prototype.getv = function (prop_name) {\n        if (this.props[prop_name] == null) {\n            throw new Error(\"property \" + this.type + \".\" + prop_name + \" wasn't declared\");\n        }\n        else {\n            return this.attributes[prop_name];\n        }\n    };\n    HasProps.prototype.ref = function () {\n        return refs.create_ref(this);\n    };\n    HasProps.prototype.set_subtype = function (subtype) {\n        return this._subtype = subtype;\n    };\n    HasProps.prototype.attribute_is_serializable = function (attr) {\n        var prop;\n        prop = this.props[attr];\n        if (prop == null) {\n            throw new Error(this.type + \".attribute_is_serializable('\" + attr + \"'): \" + attr + \" wasn't declared\");\n        }\n        else {\n            return !prop.internal;\n        }\n    };\n    HasProps.prototype.serializable_attributes = function () {\n        var attrs, name, ref, value;\n        attrs = {};\n        ref = this.attributes;\n        for (name in ref) {\n            value = ref[name];\n            if (this.attribute_is_serializable(name)) {\n                attrs[name] = value;\n            }\n        }\n        return attrs;\n    };\n    HasProps._value_to_json = function (key, value, optional_parent_object) {\n        var i, j, len, ref_array, ref_obj, subkey, v;\n        if (value instanceof HasProps) {\n            return value.ref();\n        }\n        else if (types_1.isArray(value)) {\n            ref_array = [];\n            for (i = j = 0, len = value.length; j < len; i = ++j) {\n                v = value[i];\n                ref_array.push(HasProps._value_to_json(i, v, value));\n            }\n            return ref_array;\n        }\n        else if (types_1.isObject(value)) {\n            ref_obj = {};\n            for (subkey in value) {\n                if (!hasProp.call(value, subkey))\n                    continue;\n                ref_obj[subkey] = HasProps._value_to_json(subkey, value[subkey], value);\n            }\n            return ref_obj;\n        }\n        else {\n            return value;\n        }\n    };\n    HasProps.prototype.attributes_as_json = function (include_defaults, value_to_json) {\n        var attrs, key, ref, value;\n        if (include_defaults == null) {\n            include_defaults = true;\n        }\n        if (value_to_json == null) {\n            value_to_json = HasProps._value_to_json;\n        }\n        attrs = {};\n        ref = this.serializable_attributes();\n        for (key in ref) {\n            if (!hasProp.call(ref, key))\n                continue;\n            value = ref[key];\n            if (include_defaults) {\n                attrs[key] = value;\n            }\n            else if (key in this._set_after_defaults) {\n                attrs[key] = value;\n            }\n        }\n        return value_to_json(\"attributes\", attrs, this);\n    };\n    HasProps._json_record_references = function (doc, v, result, recurse) {\n        var elem, j, k, len, model, results, results1;\n        if (v == null) {\n        }\n        else if (refs.is_ref(v)) {\n            if (!(v.id in result)) {\n                model = doc.get_model_by_id(v.id);\n                return HasProps._value_record_references(model, result, recurse);\n            }\n        }\n        else if (types_1.isArray(v)) {\n            results = [];\n            for (j = 0, len = v.length; j < len; j++) {\n                elem = v[j];\n                results.push(HasProps._json_record_references(doc, elem, result, recurse));\n            }\n            return results;\n        }\n        else if (types_1.isObject(v)) {\n            results1 = [];\n            for (k in v) {\n                if (!hasProp.call(v, k))\n                    continue;\n                elem = v[k];\n                results1.push(HasProps._json_record_references(doc, elem, result, recurse));\n            }\n            return results1;\n        }\n    };\n    HasProps._value_record_references = function (v, result, recurse) {\n        var elem, immediate, j, k, l, len, len1, obj, results, results1, results2;\n        if (v == null) {\n        }\n        else if (v instanceof HasProps) {\n            if (!(v.id in result)) {\n                result[v.id] = v;\n                if (recurse) {\n                    immediate = v._immediate_references();\n                    results = [];\n                    for (j = 0, len = immediate.length; j < len; j++) {\n                        obj = immediate[j];\n                        results.push(HasProps._value_record_references(obj, result, true));\n                    }\n                    return results;\n                }\n            }\n        }\n        else if (v.buffer instanceof ArrayBuffer) {\n        }\n        else if (types_1.isArray(v)) {\n            results1 = [];\n            for (l = 0, len1 = v.length; l < len1; l++) {\n                elem = v[l];\n                results1.push(HasProps._value_record_references(elem, result, recurse));\n            }\n            return results1;\n        }\n        else if (types_1.isObject(v)) {\n            results2 = [];\n            for (k in v) {\n                if (!hasProp.call(v, k))\n                    continue;\n                elem = v[k];\n                results2.push(HasProps._value_record_references(elem, result, recurse));\n            }\n            return results2;\n        }\n    };\n    HasProps.prototype._immediate_references = function () {\n        var attrs, key, result, value;\n        result = {};\n        attrs = this.serializable_attributes();\n        for (key in attrs) {\n            value = attrs[key];\n            HasProps._value_record_references(value, result, false);\n        }\n        return object_1.values(result);\n    };\n    HasProps.prototype.references = function () {\n        var references;\n        references = {};\n        HasProps._value_record_references(this, references, true);\n        return object_1.values(references);\n    };\n    HasProps.prototype.attach_document = function (doc) {\n        if (this.document !== null && this.document !== doc) {\n            throw new Error(\"models must be owned by only a single document\");\n        }\n        this.document = doc;\n        if (this._doc_attached != null) {\n            return this._doc_attached();\n        }\n    };\n    HasProps.prototype.detach_document = function () {\n        return this.document = null;\n    };\n    HasProps.prototype._tell_document_about_change = function (attr, old, new_, options) {\n        var need_invalidate, new_id, new_ref, new_refs, old_id, old_ref, old_refs;\n        if (!this.attribute_is_serializable(attr)) {\n            return;\n        }\n        if (this.document !== null) {\n            new_refs = {};\n            HasProps._value_record_references(new_, new_refs, false);\n            old_refs = {};\n            HasProps._value_record_references(old, old_refs, false);\n            need_invalidate = false;\n            for (new_id in new_refs) {\n                new_ref = new_refs[new_id];\n                if (!(new_id in old_refs)) {\n                    need_invalidate = true;\n                    break;\n                }\n            }\n            if (!need_invalidate) {\n                for (old_id in old_refs) {\n                    old_ref = old_refs[old_id];\n                    if (!(old_id in new_refs)) {\n                        need_invalidate = true;\n                        break;\n                    }\n                }\n            }\n            if (need_invalidate) {\n                this.document._invalidate_all_models();\n            }\n            return this.document._notify_change(this, attr, old, new_, options);\n        }\n    };\n    HasProps.prototype.materialize_dataspecs = function (source) {\n        var data, name, prop, ref;\n        data = {};\n        ref = this.properties;\n        for (name in ref) {\n            prop = ref[name];\n            if (!prop.dataspec) {\n                continue;\n            }\n            if ((prop.optional || false) && prop.spec.value === null && (!(name in this._set_after_defaults))) {\n                continue;\n            }\n            data[\"_\" + name] = prop.array(source);\n            if ((prop.spec.field != null) && prop.spec.field in source._shapes) {\n                data[\"_\" + name + \"_shape\"] = source._shapes[prop.spec.field];\n            }\n            if (prop instanceof p.Distance) {\n                data[\"max_\" + name] = array_1.max(data[\"_\" + name]);\n            }\n        }\n        return data;\n    };\n    return HasProps;\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar dist_to_segment_squared, nullreturner, sqr;\nvar array_1 = require(\"./util/array\");\nvar object_1 = require(\"./util/object\");\nexports.point_in_poly = function (x, y, px, py) {\n    var i, inside, j, ref, x1, x2, y1, y2;\n    inside = false;\n    x1 = px[px.length - 1];\n    y1 = py[py.length - 1];\n    for (i = j = 0, ref = px.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n        x2 = px[i];\n        y2 = py[i];\n        if ((y1 < y) !== (y2 < y)) {\n            if (x1 + (y - y1) / (y2 - y1) * (x2 - x1) < x) {\n                inside = !inside;\n            }\n        }\n        x1 = x2;\n        y1 = y2;\n    }\n    return inside;\n};\nnullreturner = function () {\n    return null;\n};\nexports.HitTestResult = (function () {\n    function HitTestResult() {\n        this['0d'] = {\n            glyph: null,\n            get_view: nullreturner,\n            indices: []\n        };\n        this['1d'] = {\n            indices: []\n        };\n        this['2d'] = {\n            indices: {}\n        };\n    }\n    Object.defineProperty(HitTestResult.prototype, '_0d', {\n        get: function () {\n            return this['0d'];\n        }\n    });\n    Object.defineProperty(HitTestResult.prototype, '_1d', {\n        get: function () {\n            return this['1d'];\n        }\n    });\n    Object.defineProperty(HitTestResult.prototype, '_2d', {\n        get: function () {\n            return this['2d'];\n        }\n    });\n    HitTestResult.prototype.is_empty = function () {\n        return this._0d.indices.length === 0 && this._1d.indices.length === 0;\n    };\n    HitTestResult.prototype.update_through_union = function (other) {\n        this['0d'].indices = array_1.union(other['0d'].indices, this['0d'].indices);\n        this['0d'].glyph = other['0d'].glyph || this['0d'].glyph;\n        this['1d'].indices = array_1.union(other['1d'].indices, this['1d'].indices);\n        return this['2d'].indices = object_1.merge(other['2d'].indices, this['2d'].indices);\n    };\n    return HitTestResult;\n})();\nexports.create_hit_test_result = function () {\n    return new exports.HitTestResult();\n};\nexports.create_1d_hit_test_result = function (hits) {\n    var _dist, i, result;\n    result = new exports.HitTestResult();\n    result['1d'].indices = (function () {\n        var j, len, ref, ref1, results;\n        ref = array_1.sortBy(hits, function (arg) {\n            var _i, dist;\n            _i = arg[0], dist = arg[1];\n            return dist;\n        });\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n            ref1 = ref[j], i = ref1[0], _dist = ref1[1];\n            results.push(i);\n        }\n        return results;\n    })();\n    return result;\n};\nexports.validate_bbox_coords = function (arg, arg1) {\n    var ref, ref1, x0, x1, y0, y1;\n    x0 = arg[0], x1 = arg[1];\n    y0 = arg1[0], y1 = arg1[1];\n    if (x0 > x1) {\n        ref = [x1, x0], x0 = ref[0], x1 = ref[1];\n    }\n    if (y0 > y1) {\n        ref1 = [y1, y0], y0 = ref1[0], y1 = ref1[1];\n    }\n    return {\n        minX: x0,\n        minY: y0,\n        maxX: x1,\n        maxY: y1\n    };\n};\nsqr = function (x) {\n    return x * x;\n};\nexports.dist_2_pts = function (vx, vy, wx, wy) {\n    return sqr(vx - wx) + sqr(vy - wy);\n};\ndist_to_segment_squared = function (p, v, w) {\n    var l2, t;\n    l2 = exports.dist_2_pts(v.x, v.y, w.x, w.y);\n    if (l2 === 0) {\n        return exports.dist_2_pts(p.x, p.y, v.x, v.y);\n    }\n    t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\n    if (t < 0) {\n        return exports.dist_2_pts(p.x, p.y, v.x, v.y);\n    }\n    if (t > 1) {\n        return exports.dist_2_pts(p.x, p.y, w.x, w.y);\n    }\n    return exports.dist_2_pts(p.x, p.y, v.x + t * (w.x - v.x), v.y + t * (w.y - v.y));\n};\nexports.dist_to_segment = function (p, v, w) {\n    return Math.sqrt(dist_to_segment_squared(p, v, w));\n};\nexports.check_2_segments_intersect = function (l0_x0, l0_y0, l0_x1, l0_y1, l1_x0, l1_y0, l1_x1, l1_y1) {\n    /* Check if 2 segments (l0 and l1) intersect. Returns a structure with\n      the following attributes:\n        * hit (boolean): whether the 2 segments intersect\n        * x (float): x coordinate of the intersection point\n        * y (float): y coordinate of the intersection point\n     */\n    var a, b, den, num1, num2, x, y;\n    den = ((l1_y1 - l1_y0) * (l0_x1 - l0_x0)) - ((l1_x1 - l1_x0) * (l0_y1 - l0_y0));\n    if (den === 0) {\n        return {\n            hit: false,\n            x: null,\n            y: null\n        };\n    }\n    else {\n        a = l0_y0 - l1_y0;\n        b = l0_x0 - l1_x0;\n        num1 = ((l1_x1 - l1_x0) * a) - ((l1_y1 - l1_y0) * b);\n        num2 = ((l0_x1 - l0_x0) * a) - ((l0_y1 - l0_y0) * b);\n        a = num1 / den;\n        b = num2 / den;\n        x = l0_x0 + (a * (l0_x1 - l0_x0));\n        y = l0_y0 + (a * (l0_y1 - l0_y0));\n        return {\n            hit: (a > 0 && a < 1) && (b > 0 && b < 1),\n            x: x,\n            y: y\n        };\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar solver_1 = require(\"./solver\");\nvar model_1 = require(\"../../model\");\nexports.LayoutCanvas = (function (superClass) {\n    extend(LayoutCanvas, superClass);\n    function LayoutCanvas() {\n        return LayoutCanvas.__super__.constructor.apply(this, arguments);\n    }\n    LayoutCanvas.prototype.type = 'LayoutCanvas';\n    LayoutCanvas.prototype.initialize = function (attrs, options) {\n        LayoutCanvas.__super__.initialize.call(this, attrs, options);\n        this._top = new solver_1.Variable(\"top \" + this.id);\n        this._left = new solver_1.Variable(\"left \" + this.id);\n        this._width = new solver_1.Variable(\"width \" + this.id);\n        this._height = new solver_1.Variable(\"height \" + this.id);\n        this._right = new solver_1.Variable(\"right \" + this.id);\n        return this._bottom = new solver_1.Variable(\"bottom \" + this.id);\n    };\n    LayoutCanvas.prototype.get_edit_variables = function () {\n        var editables;\n        editables = [];\n        editables.push({\n            edit_variable: this._top,\n            strength: solver_1.Strength.strong\n        });\n        editables.push({\n            edit_variable: this._left,\n            strength: solver_1.Strength.strong\n        });\n        editables.push({\n            edit_variable: this._width,\n            strength: solver_1.Strength.strong\n        });\n        editables.push({\n            edit_variable: this._height,\n            strength: solver_1.Strength.strong\n        });\n        return editables;\n    };\n    LayoutCanvas.prototype.get_constraints = function () {\n        return [];\n    };\n    LayoutCanvas.getters({\n        layout_bbox: function () {\n            return {\n                top: this._top.value,\n                left: this._left.value,\n                width: this._width.value,\n                height: this._height.value,\n                right: this._right.value,\n                bottom: this._bottom.value\n            };\n        }\n    });\n    LayoutCanvas.prototype.dump_layout = function () {\n        return console.log(this.toString(), this.layout_bbox);\n    };\n    return LayoutCanvas;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ALPHABETIC, BOTTOM, CENTER, HANGING, LEFT, MIDDLE, RIGHT, TOP, _align_lookup, _align_lookup_negative, _align_lookup_positive, _angle_lookup, _baseline_lookup, pi2, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar solver_1 = require(\"./solver\");\nvar layout_canvas_1 = require(\"./layout_canvas\");\nvar p = require(\"core/properties\");\nvar logging_1 = require(\"core/logging\");\nvar types_1 = require(\"core/util/types\");\npi2 = Math.PI / 2;\nALPHABETIC = 'alphabetic';\nTOP = 'top';\nBOTTOM = 'bottom';\nMIDDLE = 'middle';\nHANGING = 'hanging';\nLEFT = 'left';\nRIGHT = 'right';\nCENTER = 'center';\n_angle_lookup = {\n    above: {\n        parallel: 0,\n        normal: -pi2,\n        horizontal: 0,\n        vertical: -pi2\n    },\n    below: {\n        parallel: 0,\n        normal: pi2,\n        horizontal: 0,\n        vertical: pi2\n    },\n    left: {\n        parallel: -pi2,\n        normal: 0,\n        horizontal: 0,\n        vertical: -pi2\n    },\n    right: {\n        parallel: pi2,\n        normal: 0,\n        horizontal: 0,\n        vertical: pi2\n    }\n};\n_baseline_lookup = {\n    above: {\n        justified: TOP,\n        parallel: ALPHABETIC,\n        normal: MIDDLE,\n        horizontal: ALPHABETIC,\n        vertical: MIDDLE\n    },\n    below: {\n        justified: BOTTOM,\n        parallel: HANGING,\n        normal: MIDDLE,\n        horizontal: HANGING,\n        vertical: MIDDLE\n    },\n    left: {\n        justified: TOP,\n        parallel: ALPHABETIC,\n        normal: MIDDLE,\n        horizontal: MIDDLE,\n        vertical: ALPHABETIC\n    },\n    right: {\n        justified: TOP,\n        parallel: ALPHABETIC,\n        normal: MIDDLE,\n        horizontal: MIDDLE,\n        vertical: ALPHABETIC\n    }\n};\n_align_lookup = {\n    above: {\n        justified: CENTER,\n        parallel: CENTER,\n        normal: LEFT,\n        horizontal: CENTER,\n        vertical: LEFT\n    },\n    below: {\n        justified: CENTER,\n        parallel: CENTER,\n        normal: LEFT,\n        horizontal: CENTER,\n        vertical: LEFT\n    },\n    left: {\n        justified: CENTER,\n        parallel: CENTER,\n        normal: RIGHT,\n        horizontal: RIGHT,\n        vertical: CENTER\n    },\n    right: {\n        justified: CENTER,\n        parallel: CENTER,\n        normal: LEFT,\n        horizontal: LEFT,\n        vertical: CENTER\n    }\n};\n_align_lookup_negative = {\n    above: RIGHT,\n    below: LEFT,\n    left: RIGHT,\n    right: LEFT\n};\n_align_lookup_positive = {\n    above: LEFT,\n    below: RIGHT,\n    left: RIGHT,\n    right: LEFT\n};\nexports.update_panel_constraints = function (view) {\n    var s;\n    if ((view.model.props.visible != null) && !view.model.visible) {\n        return;\n    }\n    s = view.solver;\n    if ((view._size_constraint != null) && s.has_constraint(view._size_constraint)) {\n        s.remove_constraint(view._size_constraint);\n    }\n    view._size_constraint = solver_1.GE(view.model.panel._size, -view._get_size());\n    s.add_constraint(view._size_constraint);\n    if ((view._full_constraint != null) && s.has_constraint(view._full_constraint)) {\n        s.remove_constraint(view._full_constraint);\n    }\n    view._full_constraint = (function () {\n        switch (view.model.panel.side) {\n            case 'above':\n            case 'below':\n                return solver_1.EQ(view.model.panel._width, [-1, view.plot_model.canvas._width]);\n            case 'left':\n            case 'right':\n                return solver_1.EQ(view.model.panel._height, [-1, view.plot_model.canvas._height]);\n        }\n    })();\n    return s.add_constraint(view._full_constraint);\n};\nexports.SidePanel = (function (superClass) {\n    extend(SidePanel, superClass);\n    function SidePanel() {\n        return SidePanel.__super__.constructor.apply(this, arguments);\n    }\n    SidePanel.internal({\n        side: [p.String],\n        plot: [p.Instance]\n    });\n    SidePanel.prototype.initialize = function (attrs, options) {\n        SidePanel.__super__.initialize.call(this, attrs, options);\n        switch (this.side) {\n            case \"above\":\n                this._dim = 0;\n                this._normals = [0, -1];\n                return this._size = this._height;\n            case \"below\":\n                this._dim = 0;\n                this._normals = [0, 1];\n                return this._size = this._height;\n            case \"left\":\n                this._dim = 1;\n                this._normals = [-1, 0];\n                return this._size = this._width;\n            case \"right\":\n                this._dim = 1;\n                this._normals = [1, 0];\n                return this._size = this._width;\n            default:\n                return logging_1.logger.error(\"unrecognized side: '\" + this.side + \"'\");\n        }\n    };\n    SidePanel.prototype.get_constraints = function () {\n        return [solver_1.GE(this._top), solver_1.GE(this._bottom), solver_1.GE(this._left), solver_1.GE(this._right), solver_1.GE(this._width), solver_1.GE(this._height), solver_1.EQ(this._left, this._width, [-1, this._right]), solver_1.EQ(this._bottom, this._height, [-1, this._top])];\n    };\n    SidePanel.prototype.apply_label_text_heuristics = function (ctx, orient) {\n        var align, baseline, side;\n        side = this.side;\n        if (types_1.isString(orient)) {\n            baseline = _baseline_lookup[side][orient];\n            align = _align_lookup[side][orient];\n        }\n        else if (orient === 0) {\n            baseline = _baseline_lookup[side][orient];\n            align = _align_lookup[side][orient];\n        }\n        else if (orient < 0) {\n            baseline = 'middle';\n            align = _align_lookup_negative[side];\n        }\n        else if (orient > 0) {\n            baseline = 'middle';\n            align = _align_lookup_positive[side];\n        }\n        ctx.textBaseline = baseline;\n        ctx.textAlign = align;\n        return ctx;\n    };\n    SidePanel.prototype.get_label_angle_heuristic = function (orient) {\n        var side;\n        side = this.side;\n        return _angle_lookup[side][orient];\n    };\n    return SidePanel;\n})(layout_canvas_1.LayoutCanvas);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar kiwi_1 = require(\"kiwi\");\nexports.Variable = kiwi_1.Variable;\nexports.Expression = kiwi_1.Expression;\nexports.Constraint = kiwi_1.Constraint;\nexports.Operator = kiwi_1.Operator;\nexports.Strength = kiwi_1.Strength;\nfunction _constrainer(op) {\n    return function () {\n        var terms = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            terms[_i] = arguments[_i];\n        }\n        return new kiwi_1.Constraint(new (kiwi_1.Expression.bind.apply(kiwi_1.Expression, [void 0].concat(terms)))(), op);\n    };\n}\nfunction _weak_constrainer(op) {\n    return function () {\n        var terms = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            terms[_i] = arguments[_i];\n        }\n        return new kiwi_1.Constraint(new (kiwi_1.Expression.bind.apply(kiwi_1.Expression, [void 0].concat(terms)))(), op, kiwi_1.Strength.weak);\n    };\n}\nexports.EQ = _constrainer(kiwi_1.Operator.Eq);\nexports.LE = _constrainer(kiwi_1.Operator.Le);\nexports.GE = _constrainer(kiwi_1.Operator.Ge);\nexports.WEAK_EQ = _weak_constrainer(kiwi_1.Operator.Eq);\nexports.WEAK_LE = _weak_constrainer(kiwi_1.Operator.Le);\nexports.WEAK_GE = _weak_constrainer(kiwi_1.Operator.Ge);\nvar Solver = (function () {\n    function Solver() {\n        this.solver = new kiwi_1.Solver();\n    }\n    Solver.prototype.clear = function () {\n        this.solver = new kiwi_1.Solver();\n    };\n    Solver.prototype.toString = function () {\n        return \"Solver(num_constraints=\" + this.num_constraints + \", num_edit_variables=\" + this.num_edit_variables + \")\";\n    };\n    Object.defineProperty(Solver.prototype, \"num_constraints\", {\n        get: function () {\n            return this.solver.numConstraints;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Solver.prototype, \"num_edit_variables\", {\n        get: function () {\n            return this.solver.numEditVariables;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Solver.prototype.update_variables = function () {\n        this.solver.updateVariables();\n    };\n    Solver.prototype.has_constraint = function (constraint) {\n        return this.solver.hasConstraint(constraint);\n    };\n    Solver.prototype.add_constraint = function (constraint) {\n        this.solver.addConstraint(constraint);\n    };\n    Solver.prototype.remove_constraint = function (constraint) {\n        this.solver.removeConstraint(constraint);\n    };\n    Solver.prototype.add_edit_variable = function (variable, strength) {\n        this.solver.addEditVariable(variable, strength);\n    };\n    Solver.prototype.remove_edit_variable = function (variable) {\n        this.solver.removeEditVariable(variable);\n    };\n    Solver.prototype.suggest_value = function (variable, value) {\n        this.solver.suggestValue(variable, value);\n    };\n    return Solver;\n}());\nexports.Solver = Solver;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar LogLevel, _loggers, _method_factory, noop, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar types_1 = require(\"./util/types\");\nnoop = function () { };\n_method_factory = function (method_name, logger_name) {\n    if (console[method_name] != null) {\n        return console[method_name].bind(console, logger_name);\n    }\n    else if (console.log != null) {\n        return console.log.bind(console, logger_name);\n    }\n    else {\n        return noop;\n    }\n};\n_loggers = {};\nLogLevel = (function () {\n    function LogLevel(name, level) {\n        this.name = name;\n        this.level = level;\n    }\n    return LogLevel;\n})();\nexports.Logger = (function () {\n    Logger.TRACE = new LogLevel(\"trace\", 0);\n    Logger.DEBUG = new LogLevel(\"debug\", 1);\n    Logger.INFO = new LogLevel(\"info\", 2);\n    Logger.WARN = new LogLevel(\"warn\", 6);\n    Logger.ERROR = new LogLevel(\"error\", 7);\n    Logger.FATAL = new LogLevel(\"fatal\", 8);\n    Logger.OFF = new LogLevel(\"off\", 9);\n    Logger.log_levels = {\n        trace: Logger.TRACE,\n        debug: Logger.DEBUG,\n        info: Logger.INFO,\n        warn: Logger.WARN,\n        error: Logger.ERROR,\n        fatal: Logger.FATAL,\n        off: Logger.OFF\n    };\n    Object.defineProperty(Logger, 'levels', {\n        get: function () {\n            return Object.keys(Logger.log_levels);\n        }\n    });\n    Logger.get = function (name, level) {\n        var logger;\n        if (level == null) {\n            level = Logger.INFO;\n        }\n        if (types_1.isString(name) && name.length > 0) {\n            logger = _loggers[name];\n            if (logger == null) {\n                logger = _loggers[name] = new Logger(name, level);\n            }\n            return logger;\n        }\n        else {\n            throw new TypeError(\"Logger.get() expects a string name and an optional log-level\");\n        }\n    };\n    function Logger(name, level) {\n        if (level == null) {\n            level = Logger.INFO;\n        }\n        this._name = name;\n        this.set_level(level);\n    }\n    Object.defineProperty(Logger.prototype, 'level', {\n        get: function () {\n            return this.get_level();\n        }\n    });\n    Logger.prototype.get_level = function () {\n        return this._log_level;\n    };\n    Logger.prototype.set_level = function (log_level) {\n        var __, logger_name, method_name, ref, results;\n        if (log_level instanceof LogLevel) {\n            this._log_level = log_level;\n        }\n        else if (types_1.isString(log_level) && (Logger.log_levels[log_level] != null)) {\n            this._log_level = Logger.log_levels[log_level];\n        }\n        else {\n            throw new Error(\"Logger.set_level() expects a log-level object or a string name of a log-level\");\n        }\n        logger_name = \"[\" + this._name + \"]\";\n        ref = Logger.log_levels;\n        results = [];\n        for (__ in ref) {\n            log_level = ref[__];\n            if (log_level === Logger.OFF) {\n                break;\n            }\n            else {\n                method_name = log_level.name;\n                if (log_level.level < this._log_level.level) {\n                    results.push(this[method_name] = noop);\n                }\n                else {\n                    results.push(this[method_name] = _method_factory(method_name, logger_name));\n                }\n            }\n        }\n        return results;\n    };\n    return Logger;\n})();\nexports.logger = exports.Logger.get(\"bokeh\");\nexports.set_log_level = function (level) {\n    if (indexOf.call(exports.Logger.levels, level) < 0) {\n        console.log(\"[bokeh] unrecognized logging level '\" + level + \"' passed to Bokeh.set_log_level(), ignoring\");\n        return console.log(\"[bokeh] valid log levels are: \" + (exports.Logger.levels.join(', ')));\n    }\n    else {\n        console.log(\"[bokeh] setting log level to: '\" + level + \"'\");\n        return exports.logger.set_level(level);\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar valueToString, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar signaling_1 = require(\"./signaling\");\nvar enums = require(\"./enums\");\nvar svg_colors = require(\"./util/svg_colors\");\nvar color_1 = require(\"./util/color\");\nvar array_1 = require(\"./util/array\");\nvar types_1 = require(\"./util/types\");\nvalueToString = function (value) {\n    try {\n        return JSON.stringify(value);\n    }\n    catch (error) {\n        return value.toString();\n    }\n};\nexports.Property = (function () {\n    extend(Property.prototype, signaling_1.Signalable);\n    Property.prototype.dataspec = false;\n    function Property(arg) {\n        this.obj = arg.obj, this.attr = arg.attr, this.default_value = arg.default_value;\n        this._init();\n        this.change = new signaling_1.Signal(this.obj, \"change\");\n        this.connect(this.change, (function (_this) {\n            return function () {\n                _this._init();\n                return _this.obj.propchange.emit();\n            };\n        })(this));\n    }\n    Property.prototype.update = function () {\n        return this._init();\n    };\n    Property.prototype.init = function () { };\n    Property.prototype.transform = function (values) {\n        return values;\n    };\n    Property.prototype.validate = function (value) { };\n    Property.prototype.value = function (do_spec_transform) {\n        var ret;\n        if (do_spec_transform == null) {\n            do_spec_transform = true;\n        }\n        if (this.spec.value === void 0) {\n            throw new Error(\"attempted to retrieve property value for property without value specification\");\n        }\n        ret = this.transform([this.spec.value])[0];\n        if ((this.spec.transform != null) && do_spec_transform) {\n            ret = this.spec.transform.compute(ret);\n        }\n        return ret;\n    };\n    Property.prototype.array = function (source) {\n        var data, i, length, ret, value;\n        if (!this.dataspec) {\n            throw new Error(\"attempted to retrieve property array for non-dataspec property\");\n        }\n        data = source.data;\n        if (this.spec.field != null) {\n            if (this.spec.field in data) {\n                ret = this.transform(source.get_column(this.spec.field));\n            }\n            else {\n                throw new Error(\"attempted to retrieve property array for nonexistent field '\" + this.spec.field + \"'\");\n            }\n        }\n        else {\n            length = source.get_length();\n            if (length == null) {\n                length = 1;\n            }\n            value = this.value(false);\n            ret = (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(value);\n                }\n                return results;\n            })();\n        }\n        if (this.spec.transform != null) {\n            ret = this.spec.transform.v_compute(ret);\n        }\n        return ret;\n    };\n    Property.prototype._init = function () {\n        var attr, attr_value, default_value, obj;\n        obj = this.obj;\n        if (obj == null) {\n            throw new Error(\"missing property object\");\n        }\n        if (obj.properties == null) {\n            throw new Error(\"property object must be a HasProps\");\n        }\n        attr = this.attr;\n        if (attr == null) {\n            throw new Error(\"missing property attr\");\n        }\n        attr_value = obj.getv(attr);\n        if (attr_value === void 0) {\n            default_value = this.default_value;\n            attr_value = (function () {\n                switch (false) {\n                    case default_value !== void 0:\n                        return null;\n                    case !types_1.isArray(default_value):\n                        return array_1.copy(default_value);\n                    case !types_1.isFunction(default_value):\n                        return default_value(obj);\n                    default:\n                        return default_value;\n                }\n            })();\n            obj.setv(attr, attr_value, {\n                silent: true,\n                defaults: true\n            });\n        }\n        if (types_1.isArray(attr_value)) {\n            this.spec = {\n                value: attr_value\n            };\n        }\n        else if (types_1.isObject(attr_value) && ((attr_value.value === void 0) !== (attr_value.field === void 0))) {\n            this.spec = attr_value;\n        }\n        else {\n            this.spec = {\n                value: attr_value\n            };\n        }\n        if ((this.spec.field != null) && !types_1.isString(this.spec.field)) {\n            throw new Error(\"field value for property '\" + attr + \"' is not a string\");\n        }\n        if (this.spec.value != null) {\n            this.validate(this.spec.value);\n        }\n        return this.init();\n    };\n    Property.prototype.toString = function () {\n        return this.name + \"(\" + this.obj + \".\" + this.attr + \", spec: \" + (valueToString(this.spec)) + \")\";\n    };\n    return Property;\n})();\nexports.simple_prop = function (name, pred) {\n    var Prop;\n    return Prop = (function (superClass) {\n        extend(Prop, superClass);\n        function Prop() {\n            return Prop.__super__.constructor.apply(this, arguments);\n        }\n        Prop.prototype.name = name;\n        Prop.prototype.validate = function (value) {\n            if (!pred(value)) {\n                throw new Error(name + \" property '\" + this.attr + \"' given invalid value: \" + (valueToString(value)));\n            }\n        };\n        return Prop;\n    })(exports.Property);\n};\nexports.Any = (function (superClass) {\n    extend(Any, superClass);\n    function Any() {\n        return Any.__super__.constructor.apply(this, arguments);\n    }\n    return Any;\n})(exports.simple_prop(\"Any\", function (x) {\n    return true;\n}));\nexports.Array = (function (superClass) {\n    extend(Array, superClass);\n    function Array() {\n        return Array.__super__.constructor.apply(this, arguments);\n    }\n    return Array;\n})(exports.simple_prop(\"Array\", function (x) {\n    return types_1.isArray(x) || x instanceof Float64Array;\n}));\nexports.Bool = (function (superClass) {\n    extend(Bool, superClass);\n    function Bool() {\n        return Bool.__super__.constructor.apply(this, arguments);\n    }\n    return Bool;\n})(exports.simple_prop(\"Bool\", types_1.isBoolean));\nexports.Boolean = exports.Bool;\nexports.Color = (function (superClass) {\n    extend(Color, superClass);\n    function Color() {\n        return Color.__super__.constructor.apply(this, arguments);\n    }\n    return Color;\n})(exports.simple_prop(\"Color\", function (x) {\n    return (svg_colors[x.toLowerCase()] != null) || x.substring(0, 1) === \"#\" || color_1.valid_rgb(x);\n}));\nexports.Instance = (function (superClass) {\n    extend(Instance, superClass);\n    function Instance() {\n        return Instance.__super__.constructor.apply(this, arguments);\n    }\n    return Instance;\n})(exports.simple_prop(\"Instance\", function (x) {\n    return x.properties != null;\n}));\nexports.Number = (function (superClass) {\n    extend(Number, superClass);\n    function Number() {\n        return Number.__super__.constructor.apply(this, arguments);\n    }\n    return Number;\n})(exports.simple_prop(\"Number\", function (x) {\n    return types_1.isNumber(x) || types_1.isBoolean(x);\n}));\nexports.Int = exports.Number;\nexports.Percent = (function (superClass) {\n    extend(Percent, superClass);\n    function Percent() {\n        return Percent.__super__.constructor.apply(this, arguments);\n    }\n    return Percent;\n})(exports.simple_prop(\"Number\", function (x) {\n    return (types_1.isNumber(x) || types_1.isBoolean(x)) && ((0 <= x && x <= 1.0));\n}));\nexports.String = (function (superClass) {\n    extend(String, superClass);\n    function String() {\n        return String.__super__.constructor.apply(this, arguments);\n    }\n    return String;\n})(exports.simple_prop(\"String\", types_1.isString));\nexports.Font = (function (superClass) {\n    extend(Font, superClass);\n    function Font() {\n        return Font.__super__.constructor.apply(this, arguments);\n    }\n    return Font;\n})(exports.String);\nexports.enum_prop = function (name, enum_values) {\n    var Enum;\n    return Enum = (function (superClass) {\n        extend(Enum, superClass);\n        function Enum() {\n            return Enum.__super__.constructor.apply(this, arguments);\n        }\n        Enum.prototype.name = name;\n        return Enum;\n    })(exports.simple_prop(name, function (x) {\n        return indexOf.call(enum_values, x) >= 0;\n    }));\n};\nexports.Anchor = (function (superClass) {\n    extend(Anchor, superClass);\n    function Anchor() {\n        return Anchor.__super__.constructor.apply(this, arguments);\n    }\n    return Anchor;\n})(exports.enum_prop(\"Anchor\", enums.LegendLocation));\nexports.AngleUnits = (function (superClass) {\n    extend(AngleUnits, superClass);\n    function AngleUnits() {\n        return AngleUnits.__super__.constructor.apply(this, arguments);\n    }\n    return AngleUnits;\n})(exports.enum_prop(\"AngleUnits\", enums.AngleUnits));\nexports.Direction = (function (superClass) {\n    extend(Direction, superClass);\n    function Direction() {\n        return Direction.__super__.constructor.apply(this, arguments);\n    }\n    Direction.prototype.transform = function (values) {\n        var i, j, ref, result;\n        result = new Uint8Array(values.length);\n        for (i = j = 0, ref = values.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            switch (values[i]) {\n                case 'clock':\n                    result[i] = false;\n                    break;\n                case 'anticlock':\n                    result[i] = true;\n            }\n        }\n        return result;\n    };\n    return Direction;\n})(exports.enum_prop(\"Direction\", enums.Direction));\nexports.Dimension = (function (superClass) {\n    extend(Dimension, superClass);\n    function Dimension() {\n        return Dimension.__super__.constructor.apply(this, arguments);\n    }\n    return Dimension;\n})(exports.enum_prop(\"Dimension\", enums.Dimension));\nexports.Dimensions = (function (superClass) {\n    extend(Dimensions, superClass);\n    function Dimensions() {\n        return Dimensions.__super__.constructor.apply(this, arguments);\n    }\n    return Dimensions;\n})(exports.enum_prop(\"Dimensions\", enums.Dimensions));\nexports.FontStyle = (function (superClass) {\n    extend(FontStyle, superClass);\n    function FontStyle() {\n        return FontStyle.__super__.constructor.apply(this, arguments);\n    }\n    return FontStyle;\n})(exports.enum_prop(\"FontStyle\", enums.FontStyle));\nexports.LatLon = (function (superClass) {\n    extend(LatLon, superClass);\n    function LatLon() {\n        return LatLon.__super__.constructor.apply(this, arguments);\n    }\n    return LatLon;\n})(exports.enum_prop(\"LatLon\", enums.LatLon));\nexports.LineCap = (function (superClass) {\n    extend(LineCap, superClass);\n    function LineCap() {\n        return LineCap.__super__.constructor.apply(this, arguments);\n    }\n    return LineCap;\n})(exports.enum_prop(\"LineCap\", enums.LineCap));\nexports.LineJoin = (function (superClass) {\n    extend(LineJoin, superClass);\n    function LineJoin() {\n        return LineJoin.__super__.constructor.apply(this, arguments);\n    }\n    return LineJoin;\n})(exports.enum_prop(\"LineJoin\", enums.LineJoin));\nexports.LegendLocation = (function (superClass) {\n    extend(LegendLocation, superClass);\n    function LegendLocation() {\n        return LegendLocation.__super__.constructor.apply(this, arguments);\n    }\n    return LegendLocation;\n})(exports.enum_prop(\"LegendLocation\", enums.LegendLocation));\nexports.Location = (function (superClass) {\n    extend(Location, superClass);\n    function Location() {\n        return Location.__super__.constructor.apply(this, arguments);\n    }\n    return Location;\n})(exports.enum_prop(\"Location\", enums.Location));\nexports.OutputBackend = (function (superClass) {\n    extend(OutputBackend, superClass);\n    function OutputBackend() {\n        return OutputBackend.__super__.constructor.apply(this, arguments);\n    }\n    return OutputBackend;\n})(exports.enum_prop(\"OutputBackend\", enums.OutputBackend));\nexports.Orientation = (function (superClass) {\n    extend(Orientation, superClass);\n    function Orientation() {\n        return Orientation.__super__.constructor.apply(this, arguments);\n    }\n    return Orientation;\n})(exports.enum_prop(\"Orientation\", enums.Orientation));\nexports.TextAlign = (function (superClass) {\n    extend(TextAlign, superClass);\n    function TextAlign() {\n        return TextAlign.__super__.constructor.apply(this, arguments);\n    }\n    return TextAlign;\n})(exports.enum_prop(\"TextAlign\", enums.TextAlign));\nexports.TextBaseline = (function (superClass) {\n    extend(TextBaseline, superClass);\n    function TextBaseline() {\n        return TextBaseline.__super__.constructor.apply(this, arguments);\n    }\n    return TextBaseline;\n})(exports.enum_prop(\"TextBaseline\", enums.TextBaseline));\nexports.RenderLevel = (function (superClass) {\n    extend(RenderLevel, superClass);\n    function RenderLevel() {\n        return RenderLevel.__super__.constructor.apply(this, arguments);\n    }\n    return RenderLevel;\n})(exports.enum_prop(\"RenderLevel\", enums.RenderLevel));\nexports.RenderMode = (function (superClass) {\n    extend(RenderMode, superClass);\n    function RenderMode() {\n        return RenderMode.__super__.constructor.apply(this, arguments);\n    }\n    return RenderMode;\n})(exports.enum_prop(\"RenderMode\", enums.RenderMode));\nexports.SizingMode = (function (superClass) {\n    extend(SizingMode, superClass);\n    function SizingMode() {\n        return SizingMode.__super__.constructor.apply(this, arguments);\n    }\n    return SizingMode;\n})(exports.enum_prop(\"SizingMode\", enums.SizingMode));\nexports.SpatialUnits = (function (superClass) {\n    extend(SpatialUnits, superClass);\n    function SpatialUnits() {\n        return SpatialUnits.__super__.constructor.apply(this, arguments);\n    }\n    return SpatialUnits;\n})(exports.enum_prop(\"SpatialUnits\", enums.SpatialUnits));\nexports.Distribution = (function (superClass) {\n    extend(Distribution, superClass);\n    function Distribution() {\n        return Distribution.__super__.constructor.apply(this, arguments);\n    }\n    return Distribution;\n})(exports.enum_prop(\"Distribution\", enums.DistributionTypes));\nexports.TransformStepMode = (function (superClass) {\n    extend(TransformStepMode, superClass);\n    function TransformStepMode() {\n        return TransformStepMode.__super__.constructor.apply(this, arguments);\n    }\n    return TransformStepMode;\n})(exports.enum_prop(\"TransformStepMode\", enums.TransformStepModes));\nexports.PaddingUnits = (function (superClass) {\n    extend(PaddingUnits, superClass);\n    function PaddingUnits() {\n        return PaddingUnits.__super__.constructor.apply(this, arguments);\n    }\n    return PaddingUnits;\n})(exports.enum_prop(\"PaddingUnits\", enums.PaddingUnits));\nexports.StartEnd = (function (superClass) {\n    extend(StartEnd, superClass);\n    function StartEnd() {\n        return StartEnd.__super__.constructor.apply(this, arguments);\n    }\n    return StartEnd;\n})(exports.enum_prop(\"StartEnd\", enums.StartEnd));\nexports.units_prop = function (name, valid_units, default_units) {\n    var UnitsProp;\n    return UnitsProp = (function (superClass) {\n        extend(UnitsProp, superClass);\n        function UnitsProp() {\n            return UnitsProp.__super__.constructor.apply(this, arguments);\n        }\n        UnitsProp.prototype.name = name;\n        UnitsProp.prototype.init = function () {\n            var units;\n            if (this.spec.units == null) {\n                this.spec.units = default_units;\n            }\n            this.units = this.spec.units;\n            units = this.spec.units;\n            if (indexOf.call(valid_units, units) < 0) {\n                throw new Error(name + \" units must be one of \" + valid_units + \", given invalid value: \" + units);\n            }\n        };\n        return UnitsProp;\n    })(exports.Number);\n};\nexports.Angle = (function (superClass) {\n    extend(Angle, superClass);\n    function Angle() {\n        return Angle.__super__.constructor.apply(this, arguments);\n    }\n    Angle.prototype.transform = function (values) {\n        var x;\n        if (this.spec.units === \"deg\") {\n            values = (function () {\n                var j, len, results;\n                results = [];\n                for (j = 0, len = values.length; j < len; j++) {\n                    x = values[j];\n                    results.push(x * Math.PI / 180.0);\n                }\n                return results;\n            })();\n        }\n        values = (function () {\n            var j, len, results;\n            results = [];\n            for (j = 0, len = values.length; j < len; j++) {\n                x = values[j];\n                results.push(-x);\n            }\n            return results;\n        })();\n        return Angle.__super__.transform.call(this, values);\n    };\n    return Angle;\n})(exports.units_prop(\"Angle\", enums.AngleUnits, \"rad\"));\nexports.Distance = (function (superClass) {\n    extend(Distance, superClass);\n    function Distance() {\n        return Distance.__super__.constructor.apply(this, arguments);\n    }\n    return Distance;\n})(exports.units_prop(\"Distance\", enums.SpatialUnits, \"data\"));\nexports.AngleSpec = (function (superClass) {\n    extend(AngleSpec, superClass);\n    function AngleSpec() {\n        return AngleSpec.__super__.constructor.apply(this, arguments);\n    }\n    AngleSpec.prototype.dataspec = true;\n    return AngleSpec;\n})(exports.Angle);\nexports.ColorSpec = (function (superClass) {\n    extend(ColorSpec, superClass);\n    function ColorSpec() {\n        return ColorSpec.__super__.constructor.apply(this, arguments);\n    }\n    ColorSpec.prototype.dataspec = true;\n    return ColorSpec;\n})(exports.Color);\nexports.DirectionSpec = (function (superClass) {\n    extend(DirectionSpec, superClass);\n    function DirectionSpec() {\n        return DirectionSpec.__super__.constructor.apply(this, arguments);\n    }\n    DirectionSpec.prototype.dataspec = true;\n    return DirectionSpec;\n})(exports.Distance);\nexports.DistanceSpec = (function (superClass) {\n    extend(DistanceSpec, superClass);\n    function DistanceSpec() {\n        return DistanceSpec.__super__.constructor.apply(this, arguments);\n    }\n    DistanceSpec.prototype.dataspec = true;\n    return DistanceSpec;\n})(exports.Distance);\nexports.FontSizeSpec = (function (superClass) {\n    extend(FontSizeSpec, superClass);\n    function FontSizeSpec() {\n        return FontSizeSpec.__super__.constructor.apply(this, arguments);\n    }\n    FontSizeSpec.prototype.dataspec = true;\n    return FontSizeSpec;\n})(exports.String);\nexports.NumberSpec = (function (superClass) {\n    extend(NumberSpec, superClass);\n    function NumberSpec() {\n        return NumberSpec.__super__.constructor.apply(this, arguments);\n    }\n    NumberSpec.prototype.dataspec = true;\n    return NumberSpec;\n})(exports.Number);\nexports.StringSpec = (function (superClass) {\n    extend(StringSpec, superClass);\n    function StringSpec() {\n        return StringSpec.__super__.constructor.apply(this, arguments);\n    }\n    StringSpec.prototype.dataspec = true;\n    return StringSpec;\n})(exports.String);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _fill_mixin, _gen_mixin, _line_mixin, _text_mixin;\nvar p = require(\"./properties\");\nvar object_1 = require(\"./util/object\");\n_gen_mixin = function (mixin, prefix) {\n    var name, result, type;\n    result = {};\n    if (prefix == null) {\n        prefix = \"\";\n    }\n    for (name in mixin) {\n        type = mixin[name];\n        result[prefix + name] = type;\n    }\n    return result;\n};\n_line_mixin = {\n    line_color: [p.ColorSpec, 'black'],\n    line_width: [p.NumberSpec, 1],\n    line_alpha: [p.NumberSpec, 1.0],\n    line_join: [p.LineJoin, 'miter'],\n    line_cap: [p.LineCap, 'butt'],\n    line_dash: [p.Array, []],\n    line_dash_offset: [p.Number, 0]\n};\nexports.line = function (prefix) {\n    return _gen_mixin(_line_mixin, prefix);\n};\n_fill_mixin = {\n    fill_color: [p.ColorSpec, 'gray'],\n    fill_alpha: [p.NumberSpec, 1.0]\n};\nexports.fill = function (prefix) {\n    return _gen_mixin(_fill_mixin, prefix);\n};\n_text_mixin = {\n    text_font: [p.Font, 'helvetica'],\n    text_font_size: [p.FontSizeSpec, '12pt'],\n    text_font_style: [p.FontStyle, 'normal'],\n    text_color: [p.ColorSpec, '#444444'],\n    text_alpha: [p.NumberSpec, 1.0],\n    text_align: [p.TextAlign, 'left'],\n    text_baseline: [p.TextBaseline, 'bottom']\n};\nexports.text = function (prefix) {\n    return _gen_mixin(_text_mixin, prefix);\n};\nexports.create = function (configs) {\n    var config, i, kind, len, prefix, ref, result;\n    result = {};\n    for (i = 0, len = configs.length; i < len; i++) {\n        config = configs[i];\n        ref = config.split(\":\"), kind = ref[0], prefix = ref[1];\n        if (this[kind] == null) {\n            throw new Error(\"Unknown property mixin kind '\" + kind + \"'\");\n        }\n        result = object_1.extend(result, this[kind](prefix));\n    }\n    return result;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar has_props_1 = require(\"./has_props\");\nvar logging_1 = require(\"./logging\");\nvar selector_1 = require(\"./selector\");\nvar hittest = require(\"./hittest\");\nvar p = require(\"./properties\");\nexports.SelectionManager = (function (superClass) {\n    extend(SelectionManager, superClass);\n    function SelectionManager() {\n        return SelectionManager.__super__.constructor.apply(this, arguments);\n    }\n    SelectionManager.prototype.type = 'SelectionManager';\n    SelectionManager.internal({\n        source: [p.Any]\n    });\n    SelectionManager.prototype.initialize = function (attrs, options) {\n        SelectionManager.__super__.initialize.call(this, attrs, options);\n        this.selector = new selector_1.Selector();\n        this.inspectors = {};\n        return this.last_inspection_was_empty = {};\n    };\n    SelectionManager.prototype.select = function (tool, renderer_views, geometry, final, append) {\n        var i, indices, indices_other, indices_renderers, j, len, r, source;\n        if (append == null) {\n            append = false;\n        }\n        source = this.source;\n        if (source !== renderer_views[0].model.data_source) {\n            logging_1.logger.warn('select called with mis-matched data sources');\n        }\n        indices_renderers = (function () {\n            var j, len, results;\n            results = [];\n            for (j = 0, len = renderer_views.length; j < len; j++) {\n                r = renderer_views[j];\n                results.push(r.hit_test(geometry));\n            }\n            return results;\n        })();\n        indices_renderers = (function () {\n            var j, len, results;\n            results = [];\n            for (j = 0, len = indices_renderers.length; j < len; j++) {\n                i = indices_renderers[j];\n                if (i !== null) {\n                    results.push(i);\n                }\n            }\n            return results;\n        })();\n        if (indices_renderers.length === 0) {\n            return false;\n        }\n        if (indices_renderers != null) {\n            indices = indices_renderers[0];\n            for (j = 0, len = indices_renderers.length; j < len; j++) {\n                indices_other = indices_renderers[j];\n                indices.update_through_union(indices_other);\n            }\n            this.selector.update(indices, final, append);\n            this.source.selected = this.selector.indices;\n            source.select.emit();\n            return !indices.is_empty();\n        }\n        else {\n            return false;\n        }\n    };\n    SelectionManager.prototype.inspect = function (tool, renderer_view, geometry, data) {\n        var indices, inspector, r_id, source;\n        source = this.source;\n        if (source !== renderer_view.model.data_source) {\n            logging_1.logger.warn('inspect called with mis-matched data sources');\n        }\n        indices = renderer_view.hit_test(geometry);\n        if (indices != null) {\n            r_id = renderer_view.model.id;\n            if (indices.is_empty()) {\n                if (this.last_inspection_was_empty[r_id] == null) {\n                    this.last_inspection_was_empty[r_id] = false;\n                }\n                if (this.last_inspection_was_empty[r_id]) {\n                    return;\n                }\n                else {\n                    this.last_inspection_was_empty[r_id] = true;\n                }\n            }\n            else {\n                this.last_inspection_was_empty[r_id] = false;\n            }\n            inspector = this._get_inspector(renderer_view);\n            inspector.update(indices, true, false, true);\n            this.source.setv({\n                inspected: inspector.indices\n            }, {\n                \"silent\": true\n            });\n            source.inspect.emit([indices, tool, renderer_view, source, data]);\n            return !indices.is_empty();\n        }\n        else {\n            return false;\n        }\n    };\n    SelectionManager.prototype.clear = function (rview) {\n        this.selector.clear();\n        return this.source.selected = hittest.create_hit_test_result();\n    };\n    SelectionManager.prototype._get_inspector = function (rview) {\n        var id;\n        id = rview.model.id;\n        if (this.inspectors[id] != null) {\n            return this.inspectors[id];\n        }\n        else {\n            return this.inspectors[id] = new selector_1.Selector();\n        }\n    };\n    return SelectionManager;\n})(has_props_1.HasProps);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar has_props_1 = require(\"./has_props\");\nvar hittest = require(\"./hittest\");\nvar p = require(\"./properties\");\nexports.Selector = (function (superClass) {\n    extend(Selector, superClass);\n    function Selector() {\n        return Selector.__super__.constructor.apply(this, arguments);\n    }\n    Selector.prototype.type = 'Selector';\n    Selector.prototype.update = function (indices, final, append, silent) {\n        if (silent == null) {\n            silent = false;\n        }\n        this.setv('timestamp', new Date(), {\n            silent: silent\n        });\n        this.setv('final', final, {\n            silent: silent\n        });\n        if (append) {\n            indices.update_through_union(this.indices);\n        }\n        return this.setv('indices', indices, {\n            silent: silent\n        });\n    };\n    Selector.prototype.clear = function () {\n        this.timestamp = new Date();\n        this.final = true;\n        return this.indices = hittest.create_hit_test_result();\n    };\n    Selector.internal({\n        indices: [\n            p.Any, function () {\n                return hittest.create_hit_test_result();\n            }\n        ],\n        final: [p.Boolean],\n        timestamp: [p.Any]\n    });\n    return Selector;\n})(has_props_1.HasProps);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Settings = (function () {\n    function Settings() {\n        this._dev = false;\n    }\n    Object.defineProperty(Settings.prototype, \"dev\", {\n        get: function () {\n            return this._dev;\n        },\n        set: function (dev) {\n            this._dev = dev;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Settings;\n}());\nexports.Settings = Settings;\nexports.settings = new Settings();\n","\"use strict\";\n// Based on https://github.com/phosphorjs/phosphor/blob/master/packages/signaling/src/index.ts\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar logging_1 = require(\"./logging\");\nvar callback_1 = require(\"./util/callback\");\nvar array_1 = require(\"./util/array\");\nvar Signal = (function () {\n    function Signal(sender, name) {\n        this.sender = sender;\n        this.name = name;\n    }\n    Signal.prototype.connect = function (slot, context) {\n        if (context === void 0) { context = null; }\n        if (!receiversForSender.has(this.sender)) {\n            receiversForSender.set(this.sender, []);\n        }\n        var receivers = receiversForSender.get(this.sender);\n        if (findConnection(receivers, this, slot, context) != null) {\n            return false;\n        }\n        var receiver = context || slot;\n        if (!sendersForReceiver.has(receiver)) {\n            sendersForReceiver.set(receiver, []);\n        }\n        var senders = sendersForReceiver.get(receiver);\n        var connection = { signal: this, slot: slot, context: context };\n        receivers.push(connection);\n        senders.push(connection);\n        return true;\n    };\n    Signal.prototype.disconnect = function (slot, context) {\n        if (context === void 0) { context = null; }\n        var receivers = receiversForSender.get(this.sender);\n        if (receivers == null || receivers.length === 0) {\n            return false;\n        }\n        var connection = findConnection(receivers, this, slot, context);\n        if (connection == null) {\n            return false;\n        }\n        var receiver = context || slot;\n        var senders = sendersForReceiver.get(receiver);\n        connection.signal = null;\n        scheduleCleanup(receivers);\n        scheduleCleanup(senders);\n        return true;\n    };\n    Signal.prototype.emit = function (args) {\n        var receivers = receiversForSender.get(this.sender) || [];\n        for (var _i = 0, receivers_1 = receivers; _i < receivers_1.length; _i++) {\n            var _a = receivers_1[_i], signal = _a.signal, slot = _a.slot, context = _a.context;\n            if (signal === this) {\n                slot.call(context, args, this.sender);\n            }\n        }\n    };\n    return Signal;\n}());\nexports.Signal = Signal;\n(function (Signal) {\n    function disconnectBetween(sender, receiver) {\n        var receivers = receiversForSender.get(sender);\n        if (receivers == null || receivers.length === 0)\n            return;\n        var senders = sendersForReceiver.get(receiver);\n        if (senders == null || senders.length === 0)\n            return;\n        for (var _i = 0, senders_1 = senders; _i < senders_1.length; _i++) {\n            var connection = senders_1[_i];\n            if (connection.signal == null)\n                return;\n            if (connection.signal.sender === sender)\n                connection.signal = null;\n        }\n        scheduleCleanup(receivers);\n        scheduleCleanup(senders);\n    }\n    Signal.disconnectBetween = disconnectBetween;\n    function disconnectSender(sender) {\n        var receivers = receiversForSender.get(sender);\n        if (receivers == null || receivers.length === 0)\n            return;\n        for (var _i = 0, receivers_2 = receivers; _i < receivers_2.length; _i++) {\n            var connection = receivers_2[_i];\n            if (connection.signal == null)\n                return;\n            var receiver = connection.context || connection.slot;\n            connection.signal = null;\n            scheduleCleanup(sendersForReceiver.get(receiver));\n        }\n        scheduleCleanup(receivers);\n    }\n    Signal.disconnectSender = disconnectSender;\n    function disconnectReceiver(receiver) {\n        var senders = sendersForReceiver.get(receiver);\n        if (senders == null || senders.length === 0)\n            return;\n        for (var _i = 0, senders_2 = senders; _i < senders_2.length; _i++) {\n            var connection = senders_2[_i];\n            if (connection.signal == null)\n                return;\n            var sender = connection.signal.sender;\n            connection.signal = null;\n            scheduleCleanup(receiversForSender.get(sender));\n        }\n        scheduleCleanup(senders);\n    }\n    Signal.disconnectReceiver = disconnectReceiver;\n    function disconnectAll(obj) {\n        var receivers = receiversForSender.get(obj);\n        if (receivers != null && receivers.length !== 0) {\n            for (var _i = 0, receivers_3 = receivers; _i < receivers_3.length; _i++) {\n                var connection = receivers_3[_i];\n                connection.signal = null;\n            }\n            scheduleCleanup(receivers);\n        }\n        var senders = sendersForReceiver.get(obj);\n        if (senders != null && senders.length !== 0) {\n            for (var _a = 0, senders_3 = senders; _a < senders_3.length; _a++) {\n                var connection = senders_3[_a];\n                connection.signal = null;\n            }\n            scheduleCleanup(senders);\n        }\n    }\n    Signal.disconnectAll = disconnectAll;\n})(Signal = exports.Signal || (exports.Signal = {}));\nexports.Signal = Signal;\nvar Signalable;\n(function (Signalable) {\n    function connect(signal, slot) {\n        return signal.connect(slot, this);\n    }\n    Signalable.connect = connect;\n    function listenTo(event, slot) {\n        logging_1.logger.warn(\"obj.listenTo('event', handler) is deprecated, use obj.connect(signal, slot)\");\n        var _a = event.split(\":\"), name = _a[0], attr = _a[1];\n        var signal = (attr == null) ? this[name] : this.properties[attr][name];\n        return signal.connect(slot, this);\n    }\n    Signalable.listenTo = listenTo;\n    function trigger(event, args) {\n        logging_1.logger.warn(\"obj.trigger('event', args) is deprecated, use signal.emit(args)\");\n        var _a = event.split(\":\"), name = _a[0], attr = _a[1];\n        var signal = (attr == null) ? this[name] : this.properties[attr][name];\n        return signal.emit(args);\n    }\n    Signalable.trigger = trigger;\n})(Signalable = exports.Signalable || (exports.Signalable = {}));\nvar receiversForSender = new WeakMap();\nvar sendersForReceiver = new WeakMap();\nfunction findConnection(conns, signal, slot, context) {\n    return array_1.find(conns, function (conn) { return conn.signal === signal && conn.slot === slot && conn.context === context; });\n}\nvar dirtySet = new Set();\nfunction scheduleCleanup(connections) {\n    if (dirtySet.size === 0) {\n        callback_1.defer(cleanupDirtySet);\n    }\n    dirtySet.add(connections);\n}\nfunction cleanupDirtySet() {\n    dirtySet.forEach(function (connections) {\n        array_1.removeBy(connections, function (connection) { return connection.signal == null; });\n    });\n    dirtySet.clear();\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Hammer = require(\"hammerjs\");\nvar signaling_1 = require(\"./signaling\");\nvar logging_1 = require(\"./logging\");\nvar dom_1 = require(\"./dom\");\nvar wheel_1 = require(\"./util/wheel\");\nvar object_1 = require(\"./util/object\");\nvar bokeh_events_1 = require(\"./bokeh_events\");\nexports.UIEvents = (function () {\n    function UIEvents(plot_view, toolbar, hit_area, plot) {\n        this.plot_view = plot_view;\n        this.toolbar = toolbar;\n        this.hit_area = hit_area;\n        this.plot = plot;\n        this.tap = new signaling_1.Signal(this, 'tap');\n        this.doubletap = new signaling_1.Signal(this, 'doubletap');\n        this.press = new signaling_1.Signal(this, 'press');\n        this.pan_start = new signaling_1.Signal(this, 'pan:start');\n        this.pan = new signaling_1.Signal(this, 'pan');\n        this.pan_end = new signaling_1.Signal(this, 'pan:end');\n        this.pinch_start = new signaling_1.Signal(this, 'pinch:start');\n        this.pinch = new signaling_1.Signal(this, 'pinch');\n        this.pinch_end = new signaling_1.Signal(this, 'pinch:end');\n        this.rotate_start = new signaling_1.Signal(this, 'rotate:start');\n        this.rotate = new signaling_1.Signal(this, 'rotate');\n        this.rotate_end = new signaling_1.Signal(this, 'rotate:end');\n        this.move_enter = new signaling_1.Signal(this, 'move:enter');\n        this.move = new signaling_1.Signal(this, 'move');\n        this.move_exit = new signaling_1.Signal(this, 'move:exit');\n        this.scroll = new signaling_1.Signal(this, 'scroll');\n        this.keydown = new signaling_1.Signal(this, 'keydown');\n        this.keyup = new signaling_1.Signal(this, 'keyup');\n        this._configure_hammerjs();\n    }\n    UIEvents.prototype._configure_hammerjs = function () {\n        this.hammer = new Hammer(this.hit_area);\n        this.hammer.get('doubletap').recognizeWith('tap');\n        this.hammer.get('tap').requireFailure('doubletap');\n        this.hammer.get('doubletap').dropRequireFailure('tap');\n        this.hammer.on('doubletap', (function (_this) {\n            return function (e) {\n                return _this._doubletap(e);\n            };\n        })(this));\n        this.hammer.on('tap', (function (_this) {\n            return function (e) {\n                return _this._tap(e);\n            };\n        })(this));\n        this.hammer.on('press', (function (_this) {\n            return function (e) {\n                return _this._press(e);\n            };\n        })(this));\n        this.hammer.get('pan').set({\n            direction: Hammer.DIRECTION_ALL\n        });\n        this.hammer.on('panstart', (function (_this) {\n            return function (e) {\n                return _this._pan_start(e);\n            };\n        })(this));\n        this.hammer.on('pan', (function (_this) {\n            return function (e) {\n                return _this._pan(e);\n            };\n        })(this));\n        this.hammer.on('panend', (function (_this) {\n            return function (e) {\n                return _this._pan_end(e);\n            };\n        })(this));\n        this.hammer.get('pinch').set({\n            enable: true\n        });\n        this.hammer.on('pinchstart', (function (_this) {\n            return function (e) {\n                return _this._pinch_start(e);\n            };\n        })(this));\n        this.hammer.on('pinch', (function (_this) {\n            return function (e) {\n                return _this._pinch(e);\n            };\n        })(this));\n        this.hammer.on('pinchend', (function (_this) {\n            return function (e) {\n                return _this._pinch_end(e);\n            };\n        })(this));\n        this.hammer.get('rotate').set({\n            enable: true\n        });\n        this.hammer.on('rotatestart', (function (_this) {\n            return function (e) {\n                return _this._rotate_start(e);\n            };\n        })(this));\n        this.hammer.on('rotate', (function (_this) {\n            return function (e) {\n                return _this._rotate(e);\n            };\n        })(this));\n        this.hammer.on('rotateend', (function (_this) {\n            return function (e) {\n                return _this._rotate_end(e);\n            };\n        })(this));\n        this.hit_area.addEventListener(\"mousemove\", (function (_this) {\n            return function (e) {\n                return _this._mouse_move(e);\n            };\n        })(this));\n        this.hit_area.addEventListener(\"mouseenter\", (function (_this) {\n            return function (e) {\n                return _this._mouse_enter(e);\n            };\n        })(this));\n        this.hit_area.addEventListener(\"mouseleave\", (function (_this) {\n            return function (e) {\n                return _this._mouse_exit(e);\n            };\n        })(this));\n        this.hit_area.addEventListener(\"wheel\", (function (_this) {\n            return function (e) {\n                return _this._mouse_wheel(e);\n            };\n        })(this));\n        document.addEventListener(\"keydown\", (function (_this) {\n            return function (e) {\n                return _this._key_down(e);\n            };\n        })(this));\n        return document.addEventListener(\"keyup\", (function (_this) {\n            return function (e) {\n                return _this._key_up(e);\n            };\n        })(this));\n    };\n    UIEvents.prototype.register_tool = function (tool_view) {\n        var et, id, type, v;\n        et = tool_view.model.event_type;\n        id = tool_view.model.id;\n        type = tool_view.model.type;\n        if (et == null) {\n            logging_1.logger.debug(\"Button tool: \" + type);\n            return;\n        }\n        v = tool_view;\n        switch (et) {\n            case \"pan\":\n                if (v._pan_start != null) {\n                    v.connect(this.pan_start, function (x) {\n                        if (x.id === id) {\n                            return v._pan_start(x.e);\n                        }\n                    });\n                }\n                if (v._pan != null) {\n                    v.connect(this.pan, function (x) {\n                        if (x.id === id) {\n                            return v._pan(x.e);\n                        }\n                    });\n                }\n                if (v._pan_end != null) {\n                    v.connect(this.pan_end, function (x) {\n                        if (x.id === id) {\n                            return v._pan_end(x.e);\n                        }\n                    });\n                }\n                break;\n            case \"pinch\":\n                if (v._pinch_start != null) {\n                    v.connect(this.pinch_start, function (x) {\n                        if (x.id === id) {\n                            return v._pinch_start(x.e);\n                        }\n                    });\n                }\n                if (v._pinch != null) {\n                    v.connect(this.pinch, function (x) {\n                        if (x.id === id) {\n                            return v._pinch(x.e);\n                        }\n                    });\n                }\n                if (v._pinch_end != null) {\n                    v.connect(this.pinch_end, function (x) {\n                        if (x.id === id) {\n                            return v._pinch_end(x.e);\n                        }\n                    });\n                }\n                break;\n            case \"rotate\":\n                if (v._rotate_start != null) {\n                    v.connect(this.rotate_start, function (x) {\n                        if (x.id === id) {\n                            return v._rotate_start(x.e);\n                        }\n                    });\n                }\n                if (v._rotate != null) {\n                    v.connect(this.rotate, function (x) {\n                        if (x.id === id) {\n                            return v._rotate(x.e);\n                        }\n                    });\n                }\n                if (v._rotate_end != null) {\n                    v.connect(this.rotate_end, function (x) {\n                        if (x.id === id) {\n                            return v._rotate_end(x.e);\n                        }\n                    });\n                }\n                break;\n            case \"move\":\n                if (v._move_enter != null) {\n                    v.connect(this.move_enter, function (x) {\n                        if (x.id === id) {\n                            return v._move_enter(x.e);\n                        }\n                    });\n                }\n                if (v._move != null) {\n                    v.connect(this.move, function (x) {\n                        if (x.id === id) {\n                            return v._move(x.e);\n                        }\n                    });\n                }\n                if (v._move_exit != null) {\n                    v.connect(this.move_exit, function (x) {\n                        if (x.id === id) {\n                            return v._move_exit(x.e);\n                        }\n                    });\n                }\n                break;\n            case \"tap\":\n                if (v._tap != null) {\n                    v.connect(this.tap, function (x) {\n                        if (x.id === id) {\n                            return v._tap(x.e);\n                        }\n                    });\n                }\n                break;\n            case \"press\":\n                if (v._press != null) {\n                    v.connect(this.press, function (x) {\n                        if (x.id === id) {\n                            return v._press(x.e);\n                        }\n                    });\n                }\n                break;\n            case \"scroll\":\n                if (v._scroll != null) {\n                    v.connect(this.scroll, function (x) {\n                        if (x.id === id) {\n                            return v._scroll(x.e);\n                        }\n                    });\n                }\n                break;\n            default:\n                throw new Error(\"unsupported event_type: \" + ev);\n        }\n        if (v._doubletap != null) {\n            v.connect(this.doubletap, function (x) {\n                return v._doubletap(x.e);\n            });\n        }\n        if (v._keydown != null) {\n            v.connect(this.keydown, function (x) {\n                return v._keydown(x.e);\n            });\n        }\n        if (v._keyup != null) {\n            v.connect(this.keyup, function (x) {\n                return v._keyup(x.e);\n            });\n        }\n        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {\n            if (et === 'pinch') {\n                logging_1.logger.debug(\"Registering scroll on touch screen\");\n                return v.connect(this.scroll, function (x) {\n                    if (x.id === id) {\n                        return v._scroll(x.e);\n                    }\n                });\n            }\n        }\n    };\n    UIEvents.prototype._hit_test_renderers = function (sx, sy) {\n        var i, ref, ref1, view;\n        ref = this.plot_view.get_renderer_views();\n        for (i = ref.length - 1; i >= 0; i += -1) {\n            view = ref[i];\n            if (((ref1 = view.model.level) === 'annotation' || ref1 === 'overlay') && (view.bbox != null)) {\n                if (view.bbox().contains(sx, sy)) {\n                    return view;\n                }\n            }\n        }\n        return null;\n    };\n    UIEvents.prototype._hit_test_frame = function (sx, sy) {\n        var canvas, vx, vy;\n        canvas = this.plot_view.canvas;\n        vx = canvas.sx_to_vx(sx);\n        vy = canvas.sy_to_vy(sy);\n        return this.plot_view.frame.contains(vx, vy);\n    };\n    UIEvents.prototype._trigger = function (signal, e) {\n        var active_gesture, active_inspectors, base, base_type, cursor, event_type, i, inspector, len, results, view;\n        event_type = signal.name;\n        base_type = event_type.split(\":\")[0];\n        view = this._hit_test_renderers(e.bokeh.sx, e.bokeh.sy);\n        switch (base_type) {\n            case \"move\":\n                active_inspectors = this.toolbar.inspectors.filter(function (t) {\n                    return t.active;\n                });\n                cursor = \"default\";\n                if (view != null) {\n                    if (view.model.cursor != null) {\n                        cursor = view.model.cursor();\n                    }\n                    if (!object_1.isEmpty(active_inspectors)) {\n                        signal = this.move_exit;\n                        event_type = signal.name;\n                    }\n                }\n                else if (this._hit_test_frame(e.bokeh.sx, e.bokeh.sy)) {\n                    if (!object_1.isEmpty(active_inspectors)) {\n                        cursor = \"crosshair\";\n                    }\n                }\n                this.plot_view.set_cursor(cursor);\n                results = [];\n                for (i = 0, len = active_inspectors.length; i < len; i++) {\n                    inspector = active_inspectors[i];\n                    results.push(this.trigger(signal, e, inspector.id));\n                }\n                return results;\n                break;\n            case \"tap\":\n                if (view != null) {\n                    if (typeof view.on_hit === \"function\") {\n                        view.on_hit(e.bokeh.sx, e.bokeh.sy);\n                    }\n                }\n                active_gesture = this.toolbar.gestures[base_type].active;\n                if (active_gesture != null) {\n                    return this.trigger(signal, e, active_gesture.id);\n                }\n                break;\n            case \"scroll\":\n                base = 'ontouchstart' in window || navigator.maxTouchPoints > 0 ? \"pinch\" : \"scroll\";\n                active_gesture = this.toolbar.gestures[base].active;\n                if (active_gesture != null) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    return this.trigger(signal, e, active_gesture.id);\n                }\n                break;\n            default:\n                active_gesture = this.toolbar.gestures[base_type].active;\n                if (active_gesture != null) {\n                    return this.trigger(signal, e, active_gesture.id);\n                }\n        }\n    };\n    UIEvents.prototype.trigger = function (signal, event, id) {\n        if (id == null) {\n            id = null;\n        }\n        return signal.emit({\n            id: id,\n            e: event\n        });\n    };\n    UIEvents.prototype._bokify_hammer = function (e, extras) {\n        var event_cls, left, ref, top, x, y;\n        if (extras == null) {\n            extras = {};\n        }\n        if (e.pointerType === 'mouse') {\n            x = e.srcEvent.pageX;\n            y = e.srcEvent.pageY;\n        }\n        else {\n            x = e.pointers[0].pageX;\n            y = e.pointers[0].pageY;\n        }\n        ref = dom_1.offset(e.target), left = ref.left, top = ref.top;\n        e.bokeh = {\n            sx: x - left,\n            sy: y - top\n        };\n        e.bokeh = object_1.extend(e.bokeh, extras);\n        event_cls = bokeh_events_1.BokehEvent.event_class(e);\n        if (event_cls != null) {\n            return this.plot.trigger_event(event_cls.from_event(e));\n        }\n        else {\n            return logging_1.logger.debug('Unhandled event of type ' + e.type);\n        }\n    };\n    UIEvents.prototype._bokify_point_event = function (e, extras) {\n        var event_cls, left, ref, top;\n        if (extras == null) {\n            extras = {};\n        }\n        ref = dom_1.offset(e.currentTarget), left = ref.left, top = ref.top;\n        e.bokeh = {\n            sx: e.pageX - left,\n            sy: e.pageY - top\n        };\n        e.bokeh = object_1.extend(e.bokeh, extras);\n        event_cls = bokeh_events_1.BokehEvent.event_class(e);\n        if (event_cls != null) {\n            return this.plot.trigger_event(event_cls.from_event(e));\n        }\n        else {\n            return logging_1.logger.debug('Unhandled event of type ' + e.type);\n        }\n    };\n    UIEvents.prototype._tap = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger(this.tap, e);\n    };\n    UIEvents.prototype._doubletap = function (e) {\n        this._bokify_hammer(e);\n        return this.trigger(this.doubletap, e);\n    };\n    UIEvents.prototype._press = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger(this.press, e);\n    };\n    UIEvents.prototype._pan_start = function (e) {\n        this._bokify_hammer(e);\n        e.bokeh.sx -= e.deltaX;\n        e.bokeh.sy -= e.deltaY;\n        return this._trigger(this.pan_start, e);\n    };\n    UIEvents.prototype._pan = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger(this.pan, e);\n    };\n    UIEvents.prototype._pan_end = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger(this.pan_end, e);\n    };\n    UIEvents.prototype._pinch_start = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger(this.pinch_start, e);\n    };\n    UIEvents.prototype._pinch = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger(this.pinch, e);\n    };\n    UIEvents.prototype._pinch_end = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger(this.pinch_end, e);\n    };\n    UIEvents.prototype._rotate_start = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger(this.rotate_start, e);\n    };\n    UIEvents.prototype._rotate = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger(this.rotate, e);\n    };\n    UIEvents.prototype._rotate_end = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger(this.rotate_end, e);\n    };\n    UIEvents.prototype._mouse_enter = function (e) {\n        this._bokify_point_event(e);\n        return this._trigger(this.move_enter, e);\n    };\n    UIEvents.prototype._mouse_move = function (e) {\n        this._bokify_point_event(e);\n        return this._trigger(this.move, e);\n    };\n    UIEvents.prototype._mouse_exit = function (e) {\n        this._bokify_point_event(e);\n        return this._trigger(this.move_exit, e);\n    };\n    UIEvents.prototype._mouse_wheel = function (e) {\n        this._bokify_point_event(e, {\n            delta: wheel_1.getDeltaY(e)\n        });\n        return this._trigger(this.scroll, e);\n    };\n    UIEvents.prototype._key_down = function (e) {\n        return this.trigger(this.keydown, e);\n    };\n    UIEvents.prototype._key_up = function (e) {\n        return this.trigger(this.keyup, e);\n    };\n    return UIEvents;\n})();\n","\"use strict\";\n//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar math_1 = require(\"./math\");\nvar slice = Array.prototype.slice;\nfunction copy(array /*| TypedArray*/) {\n    return slice.call(array);\n}\nexports.copy = copy;\nfunction concat(arrays) {\n    return (_a = []).concat.apply(_a, arrays);\n    var _a;\n}\nexports.concat = concat;\nfunction contains(array, value) {\n    return array.indexOf(value) >= 0;\n}\nexports.contains = contains;\nfunction nth(array, index) {\n    return array[index >= 0 ? index : array.length + index];\n}\nexports.nth = nth;\nfunction zip(As, Bs) {\n    var n = Math.min(As.length, Bs.length);\n    var ABs = new Array(n);\n    for (var i = 0; i < n; i++) {\n        ABs[i] = [As[i], Bs[i]];\n    }\n    return ABs;\n}\nexports.zip = zip;\nfunction unzip(ABs) {\n    var n = ABs.length;\n    var As = new Array(n);\n    var Bs = new Array(n);\n    for (var i = 0; i < n; i++) {\n        _a = ABs[i], As[i] = _a[0], Bs[i] = _a[1];\n    }\n    return [As, Bs];\n    var _a;\n}\nexports.unzip = unzip;\nfunction range(start, stop, step) {\n    if (step === void 0) { step = 1; }\n    if (stop == null) {\n        stop = start;\n        start = 0;\n    }\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n    for (var i = 0; i < length; i++, start += step) {\n        range[i] = start;\n    }\n    return range;\n}\nexports.range = range;\nfunction linspace(start, stop, num) {\n    if (num === void 0) { num = 100; }\n    var step = (stop - start) / (num - 1);\n    var array = new Array(num);\n    for (var i = 0; i < num; i++) {\n        array[i] = start + step * i;\n    }\n    return array;\n}\nexports.linspace = linspace;\nfunction transpose(array) {\n    var rows = array.length;\n    var cols = array[0].length;\n    var transposed = [];\n    for (var j = 0; j < cols; j++) {\n        transposed[j] = [];\n        for (var i = 0; i < rows; i++) {\n            transposed[j][i] = array[i][j];\n        }\n    }\n    return transposed;\n}\nexports.transpose = transpose;\nfunction sum(array) {\n    return array.reduce(function (a, b) { return a + b; }, 0);\n}\nexports.sum = sum;\nfunction cumsum(array) {\n    var result = [];\n    array.reduce(function (a, b, i) { return result[i] = a + b; }, 0);\n    return result;\n}\nexports.cumsum = cumsum;\nfunction min(array) {\n    var value;\n    var result = Infinity;\n    for (var i = 0, length_1 = array.length; i < length_1; i++) {\n        value = array[i];\n        if (value < result) {\n            result = value;\n        }\n    }\n    return result;\n}\nexports.min = min;\nfunction minBy(array, key) {\n    if (array.length == 0)\n        throw new Error(\"minBy() called with an empty array\");\n    var result = array[0];\n    var resultComputed = key(result);\n    for (var i = 1, length_2 = array.length; i < length_2; i++) {\n        var value = array[i];\n        var computed = key(value);\n        if (computed < resultComputed) {\n            result = value;\n            resultComputed = computed;\n        }\n    }\n    return result;\n}\nexports.minBy = minBy;\nfunction max(array) {\n    var value;\n    var result = -Infinity;\n    for (var i = 0, length_3 = array.length; i < length_3; i++) {\n        value = array[i];\n        if (value > result) {\n            result = value;\n        }\n    }\n    return result;\n}\nexports.max = max;\nfunction maxBy(array, key) {\n    if (array.length == 0)\n        throw new Error(\"maxBy() called with an empty array\");\n    var result = array[0];\n    var resultComputed = key(result);\n    for (var i = 1, length_4 = array.length; i < length_4; i++) {\n        var value = array[i];\n        var computed = key(value);\n        if (computed > resultComputed) {\n            result = value;\n            resultComputed = computed;\n        }\n    }\n    return result;\n}\nexports.maxBy = maxBy;\nfunction argmin(array) {\n    return minBy(range(array.length), function (i) { return array[i]; });\n}\nexports.argmin = argmin;\nfunction argmax(array) {\n    return maxBy(range(array.length), function (i) { return array[i]; });\n}\nexports.argmax = argmax;\nfunction all(array, predicate) {\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n        var item = array_1[_i];\n        if (!predicate(item))\n            return false;\n    }\n    return true;\n}\nexports.all = all;\nfunction any(array, predicate) {\n    for (var _i = 0, array_2 = array; _i < array_2.length; _i++) {\n        var item = array_2[_i];\n        if (predicate(item))\n            return true;\n    }\n    return false;\n}\nexports.any = any;\nfunction findIndexFactory(dir) {\n    return function (array, predicate) {\n        var length = array.length;\n        var index = dir > 0 ? 0 : length - 1;\n        for (; index >= 0 && index < length; index += dir) {\n            if (predicate(array[index]))\n                return index;\n        }\n        return -1;\n    };\n}\nexports.findIndex = findIndexFactory(1);\nexports.findLastIndex = findIndexFactory(-1);\nfunction find(array, predicate) {\n    var index = exports.findIndex(array, predicate);\n    return index == -1 ? undefined : array[index];\n}\nexports.find = find;\nfunction findLast(array, predicate) {\n    var index = exports.findLastIndex(array, predicate);\n    return index == -1 ? undefined : array[index];\n}\nexports.findLast = findLast;\nfunction sortedIndex(array, value) {\n    var low = 0;\n    var high = array.length;\n    while (low < high) {\n        var mid = Math.floor((low + high) / 2);\n        if (array[mid] < value)\n            low = mid + 1;\n        else\n            high = mid;\n    }\n    return low;\n}\nexports.sortedIndex = sortedIndex;\nfunction sortBy(array, key) {\n    var tmp = array.map(function (value, index) {\n        return { value: value, index: index, key: key(value) };\n    });\n    tmp.sort(function (left, right) {\n        var a = left.key;\n        var b = right.key;\n        if (a !== b) {\n            if (a > b || a === undefined)\n                return 1;\n            if (a < b || b === undefined)\n                return -1;\n        }\n        return left.index - right.index;\n    });\n    return tmp.map(function (item) { return item.value; });\n}\nexports.sortBy = sortBy;\nfunction uniq(array) {\n    var result = [];\n    for (var _i = 0, array_3 = array; _i < array_3.length; _i++) {\n        var value = array_3[_i];\n        if (!contains(result, value)) {\n            result.push(value);\n        }\n    }\n    return result;\n}\nexports.uniq = uniq;\nfunction uniqBy(array, key) {\n    var result = [];\n    var seen = [];\n    for (var _i = 0, array_4 = array; _i < array_4.length; _i++) {\n        var value = array_4[_i];\n        var computed = key(value);\n        if (!contains(seen, computed)) {\n            seen.push(computed);\n            result.push(value);\n        }\n    }\n    return result;\n}\nexports.uniqBy = uniqBy;\nfunction union() {\n    var arrays = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        arrays[_i] = arguments[_i];\n    }\n    return uniq(concat(arrays));\n}\nexports.union = union;\nfunction intersection(array) {\n    var arrays = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        arrays[_i - 1] = arguments[_i];\n    }\n    var result = [];\n    top: for (var _a = 0, array_5 = array; _a < array_5.length; _a++) {\n        var item = array_5[_a];\n        if (contains(result, item))\n            continue;\n        for (var _b = 0, arrays_1 = arrays; _b < arrays_1.length; _b++) {\n            var other = arrays_1[_b];\n            if (!contains(other, item))\n                continue top;\n        }\n        result.push(item);\n    }\n    return result;\n}\nexports.intersection = intersection;\nfunction difference(array) {\n    var arrays = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        arrays[_i - 1] = arguments[_i];\n    }\n    var rest = concat(arrays);\n    return array.filter(function (value) { return !contains(rest, value); });\n}\nexports.difference = difference;\nfunction removeBy(array, key) {\n    for (var i = 0; i < array.length;) {\n        if (key(array[i]))\n            array.splice(i, 1);\n        else\n            i++;\n    }\n}\nexports.removeBy = removeBy;\n// Shuffle a collection, using the modern version of the\n// [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).\nfunction shuffle(array) {\n    var length = array.length;\n    var shuffled = new Array(length);\n    for (var i = 0; i < length; i++) {\n        var rand = math_1.randomIn(0, i);\n        if (rand !== i)\n            shuffled[i] = shuffled[rand];\n        shuffled[rand] = array[i];\n    }\n    return shuffled;\n}\nexports.shuffle = shuffle;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction empty() {\n    return {\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity,\n    };\n}\nexports.empty = empty;\nfunction positive_x() {\n    return {\n        minX: Number.MIN_VALUE,\n        minY: -Infinity,\n        maxX: Infinity,\n        maxY: Infinity,\n    };\n}\nexports.positive_x = positive_x;\nfunction positive_y() {\n    return {\n        minX: -Infinity,\n        minY: Number.MIN_VALUE,\n        maxX: Infinity,\n        maxY: Infinity,\n    };\n}\nexports.positive_y = positive_y;\nfunction union(a, b) {\n    return {\n        minX: Math.min(a.minX, b.minX),\n        maxX: Math.max(a.maxX, b.maxX),\n        minY: Math.min(a.minY, b.minY),\n        maxY: Math.max(a.maxY, b.maxY),\n    };\n}\nexports.union = union;\nvar BBox = (function () {\n    function BBox(bbox) {\n        if (bbox == null) {\n            this.x0 = Infinity;\n            this.y0 = -Infinity;\n            this.x1 = Infinity;\n            this.y1 = -Infinity;\n        }\n        else {\n            this.x0 = bbox.x0;\n            this.y0 = bbox.y0;\n            this.x1 = bbox.x1;\n            this.y1 = bbox.y1;\n        }\n    }\n    Object.defineProperty(BBox.prototype, \"minX\", {\n        get: function () { return this.x0; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"minY\", {\n        get: function () { return this.y0; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"maxX\", {\n        get: function () { return this.x1; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"maxY\", {\n        get: function () { return this.y1; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"pt0\", {\n        get: function () { return [this.x0, this.y0]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"pt1\", {\n        get: function () { return [this.x1, this.y1]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"x\", {\n        get: function () { return this.x0; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"y\", {\n        get: function () { return this.x1; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"width\", {\n        get: function () { return this.x1 - this.x0; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"height\", {\n        get: function () { return this.y1 - this.y0; },\n        enumerable: true,\n        configurable: true\n    });\n    BBox.prototype.contains = function (x, y) {\n        return x >= this.x0 && x <= this.x1 && y >= this.y0 && y <= this.y1;\n    };\n    BBox.prototype.union = function (that) {\n        return new BBox({\n            x0: Math.min(this.x0, that.x0),\n            y0: Math.min(this.y0, that.y0),\n            x1: Math.max(this.x1, that.x1),\n            y1: Math.max(this.y1, that.y1),\n        });\n    };\n    return BBox;\n}());\nexports.BBox = BBox;\n","\"use strict\";\n//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction delay(func, wait) {\n    return setTimeout(func, wait);\n}\nexports.delay = delay;\nvar _defer = typeof requestAnimationFrame === \"function\" ? requestAnimationFrame : setImmediate;\nfunction defer(func) {\n    return _defer(func);\n}\nexports.defer = defer;\nfunction throttle(func, wait, options) {\n    if (options === void 0) { options = {}; }\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    var later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout)\n            context = args = null;\n    };\n    return function () {\n        var now = Date.now();\n        if (!previous && options.leading === false)\n            previous = now;\n        var remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            result = func.apply(context, args);\n            if (!timeout)\n                context = args = null;\n        }\n        else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(later, remaining);\n        }\n        return result;\n    };\n}\nexports.throttle = throttle;\nfunction once(func) {\n    var done = false;\n    var memo;\n    return function () {\n        if (!done) {\n            done = true;\n            memo = func();\n        }\n        return memo;\n    };\n}\nexports.once = once;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fixup_ellipse, fixup_image_smoothing, fixup_line_dash, fixup_line_dash_offset, fixup_measure_text;\nfixup_line_dash = function (ctx) {\n    if (!ctx.setLineDash) {\n        ctx.setLineDash = function (dash) {\n            ctx.mozDash = dash;\n            return ctx.webkitLineDash = dash;\n        };\n    }\n    if (!ctx.getLineDash) {\n        return ctx.getLineDash = function () {\n            return ctx.mozDash;\n        };\n    }\n};\nfixup_line_dash_offset = function (ctx) {\n    ctx.setLineDashOffset = function (dash_offset) {\n        ctx.lineDashOffset = dash_offset;\n        ctx.mozDashOffset = dash_offset;\n        return ctx.webkitLineDashOffset = dash_offset;\n    };\n    return ctx.getLineDashOffset = function () {\n        return ctx.mozDashOffset;\n    };\n};\nfixup_image_smoothing = function (ctx) {\n    ctx.setImageSmoothingEnabled = function (value) {\n        ctx.imageSmoothingEnabled = value;\n        ctx.mozImageSmoothingEnabled = value;\n        ctx.oImageSmoothingEnabled = value;\n        return ctx.webkitImageSmoothingEnabled = value;\n    };\n    return ctx.getImageSmoothingEnabled = function () {\n        var ref;\n        return (ref = ctx.imageSmoothingEnabled) != null ? ref : true;\n    };\n};\nfixup_measure_text = function (ctx) {\n    if (ctx.measureText && (ctx.html5MeasureText == null)) {\n        ctx.html5MeasureText = ctx.measureText;\n        return ctx.measureText = function (text) {\n            var textMetrics;\n            textMetrics = ctx.html5MeasureText(text);\n            textMetrics.ascent = ctx.html5MeasureText(\"m\").width * 1.6;\n            return textMetrics;\n        };\n    }\n};\nfixup_ellipse = function (ctx) {\n    var ellipse_bezier;\n    ellipse_bezier = function (x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {\n        var c, rx, ry;\n        if (anticlockwise == null) {\n            anticlockwise = false;\n        }\n        c = 0.551784;\n        ctx.translate(x, y);\n        ctx.rotate(rotation);\n        rx = radiusX;\n        ry = radiusY;\n        if (anticlockwise) {\n            rx = -radiusX;\n            ry = -radiusY;\n        }\n        ctx.moveTo(-rx, 0);\n        ctx.bezierCurveTo(-rx, ry * c, -rx * c, ry, 0, ry);\n        ctx.bezierCurveTo(rx * c, ry, rx, ry * c, rx, 0);\n        ctx.bezierCurveTo(rx, -ry * c, rx * c, -ry, 0, -ry);\n        ctx.bezierCurveTo(-rx * c, -ry, -rx, -ry * c, -rx, 0);\n        ctx.rotate(-rotation);\n        ctx.translate(-x, -y);\n    };\n    if (!ctx.ellipse) {\n        return ctx.ellipse = ellipse_bezier;\n    }\n};\nexports.fixup_ctx = function (ctx) {\n    fixup_line_dash(ctx);\n    fixup_line_dash_offset(ctx);\n    fixup_image_smoothing(ctx);\n    fixup_measure_text(ctx);\n    return fixup_ellipse(ctx);\n};\nexports.get_scale_ratio = function (ctx, hidpi, backend) {\n    var backingStoreRatio, devicePixelRatio;\n    if (backend === \"svg\") {\n        return 1;\n    }\n    else if (hidpi) {\n        devicePixelRatio = window.devicePixelRatio || 1;\n        backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n        return devicePixelRatio / backingStoreRatio;\n    }\n    else {\n        return 1;\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _component2hex, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar svg_colors = require(\"./svg_colors\");\n_component2hex = function (v) {\n    var h;\n    h = Number(v).toString(16);\n    return h = h.length === 1 ? '0' + h : h;\n};\nexports.color2hex = function (color) {\n    var hex, rgb, v;\n    color = color + '';\n    if (color.indexOf('#') === 0) {\n        return color;\n    }\n    else if (svg_colors[color] != null) {\n        return svg_colors[color];\n    }\n    else if (color.indexOf('rgb') === 0) {\n        rgb = color.match(/\\d+/g);\n        hex = ((function () {\n            var j, len, results;\n            results = [];\n            for (j = 0, len = rgb.length; j < len; j++) {\n                v = rgb[j];\n                results.push(_component2hex(v));\n            }\n            return results;\n        })()).join('');\n        return '#' + hex.slice(0, 8);\n    }\n    else {\n        return color;\n    }\n};\nexports.color2rgba = function (color, alpha) {\n    var hex, i, rgba;\n    if (alpha == null) {\n        alpha = 1;\n    }\n    if (!color) {\n        return [0, 0, 0, 0];\n    }\n    hex = exports.color2hex(color);\n    hex = hex.replace(/ |#/g, '');\n    if (hex.length <= 4) {\n        hex = hex.replace(/(.)/g, '$1$1');\n    }\n    hex = hex.match(/../g);\n    rgba = (function () {\n        var j, len, results;\n        results = [];\n        for (j = 0, len = hex.length; j < len; j++) {\n            i = hex[j];\n            results.push(parseInt(i, 16) / 255);\n        }\n        return results;\n    })();\n    while (rgba.length < 3) {\n        rgba.push(0);\n    }\n    if (rgba.length < 4) {\n        rgba.push(alpha);\n    }\n    return rgba.slice(0, 4);\n};\nexports.valid_rgb = function (value) {\n    var contents, params, ref, rgb;\n    switch (value.substring(0, 4)) {\n        case \"rgba\":\n            params = {\n                start: \"rgba(\",\n                len: 4,\n                alpha: true\n            };\n            break;\n        case \"rgb(\":\n            params = {\n                start: \"rgb(\",\n                len: 3,\n                alpha: false\n            };\n            break;\n        default:\n            return false;\n    }\n    if (new RegExp(\".*?(\\\\.).*(,)\").test(value)) {\n        throw new Error(\"color expects integers for rgb in rgb/rgba tuple, received \" + value);\n    }\n    contents = value.replace(params.start, \"\").replace(\")\", \"\").split(',').map(parseFloat);\n    if (contents.length !== params.len) {\n        throw new Error(\"color expects rgba \" + expect_len + \"-tuple, received \" + value);\n    }\n    if (params.alpha && !((0 <= (ref = contents[3]) && ref <= 1))) {\n        throw new Error(\"color expects rgba 4-tuple to have alpha value between 0 and 1\");\n    }\n    if (indexOf.call((function () {\n        var j, len, ref1, results;\n        ref1 = contents.slice(0, 3);\n        results = [];\n        for (j = 0, len = ref1.length; j < len; j++) {\n            rgb = ref1[j];\n            results.push((0 <= rgb && rgb <= 255));\n        }\n        return results;\n    })(), false) >= 0) {\n        throw new Error(\"color expects rgb to have value between 0 and 255\");\n    }\n    return true;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar array_1 = require(\"./array\");\nvar eq_1 = require(\"./eq\");\nvar types_1 = require(\"./types\");\nexports.MultiDict = (function () {\n    function MultiDict() {\n        this._dict = {};\n    }\n    MultiDict.prototype._existing = function (key) {\n        if (key in this._dict) {\n            return this._dict[key];\n        }\n        else {\n            return null;\n        }\n    };\n    MultiDict.prototype.add_value = function (key, value) {\n        var existing;\n        if (value === null) {\n            throw new Error(\"Can't put null in this dict\");\n        }\n        if (types_1.isArray(value)) {\n            throw new Error(\"Can't put arrays in this dict\");\n        }\n        existing = this._existing(key);\n        if (existing === null) {\n            return this._dict[key] = value;\n        }\n        else if (types_1.isArray(existing)) {\n            return existing.push(value);\n        }\n        else {\n            return this._dict[key] = [existing, value];\n        }\n    };\n    MultiDict.prototype.remove_value = function (key, value) {\n        var existing, new_array;\n        existing = this._existing(key);\n        if (types_1.isArray(existing)) {\n            new_array = array_1.difference(existing, [value]);\n            if (new_array.length > 0) {\n                return this._dict[key] = new_array;\n            }\n            else {\n                return delete this._dict[key];\n            }\n        }\n        else if (eq_1.isEqual(existing, value)) {\n            return delete this._dict[key];\n        }\n    };\n    MultiDict.prototype.get_one = function (key, duplicate_error) {\n        var existing;\n        existing = this._existing(key);\n        if (types_1.isArray(existing)) {\n            if (existing.length === 1) {\n                return existing[0];\n            }\n            else {\n                throw new Error(duplicate_error);\n            }\n        }\n        else {\n            return existing;\n        }\n    };\n    return MultiDict;\n})();\nexports.Set = (function () {\n    function Set(array) {\n        if (!array) {\n            this.values = [];\n        }\n        else {\n            if (array.constructor === Set) {\n                return new Set(array.values);\n            }\n            if (array.constructor === Array) {\n                this.values = Set.compact(array);\n            }\n            else {\n                this.values = [array];\n            }\n        }\n    }\n    Set.compact = function (array) {\n        var item, j, len, newArray;\n        newArray = [];\n        for (j = 0, len = array.length; j < len; j++) {\n            item = array[j];\n            if (newArray.indexOf(item) === -1) {\n                newArray.push(item);\n            }\n        }\n        return newArray;\n    };\n    Set.prototype.push = function (item) {\n        if (this.missing(item)) {\n            return this.values.push(item);\n        }\n    };\n    Set.prototype.remove = function (item) {\n        var i;\n        i = this.values.indexOf(item);\n        return this.values = this.values.slice(0, i).concat(this.values.slice(i + 1));\n    };\n    Set.prototype.length = function () {\n        return this.values.length;\n    };\n    Set.prototype.includes = function (item) {\n        return this.values.indexOf(item) !== -1;\n    };\n    Set.prototype.missing = function (item) {\n        return !this.includes(item);\n    };\n    Set.prototype.slice = function (from, to) {\n        return this.values.slice(from, to);\n    };\n    Set.prototype.join = function (str) {\n        return this.values.join(str);\n    };\n    Set.prototype.toString = function () {\n        return this.join(', ');\n    };\n    Set.prototype.includes = function (item) {\n        return this.values.indexOf(item) !== -1;\n    };\n    Set.prototype.union = function (set) {\n        set = new Set(set);\n        return new Set(this.values.concat(set.values));\n    };\n    Set.prototype.intersect = function (set) {\n        var item, j, len, newSet, ref;\n        set = new Set(set);\n        newSet = new Set;\n        ref = set.values;\n        for (j = 0, len = ref.length; j < len; j++) {\n            item = ref[j];\n            if (this.includes(item) && set.includes(item)) {\n                newSet.push(item);\n            }\n        }\n        return newSet;\n    };\n    Set.prototype.diff = function (set) {\n        var item, j, len, newSet, ref;\n        set = new Set(set);\n        newSet = new Set;\n        ref = this.values;\n        for (j = 0, len = ref.length; j < len; j++) {\n            item = ref[j];\n            if (set.missing(item)) {\n                newSet.push(item);\n            }\n        }\n        return newSet;\n    };\n    return Set;\n})();\n","\"use strict\";\n//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar types_1 = require(\"./types\");\nvar toString = Object.prototype.toString;\n// Internal recursive comparison function for `isEqual`.\nfunction eq(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b)\n        return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null)\n        return a === b;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b))\n        return false;\n    switch (className) {\n        // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n        case '[object RegExp]':\n        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n        case '[object String]':\n            // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n            // equivalent to `new String(\"5\")`.\n            return '' + a === '' + b;\n        case '[object Number]':\n            // `NaN`s are equivalent, but non-reflexive.\n            // Object(NaN) is equivalent to NaN\n            if (+a !== +a)\n                return +b !== +b;\n            // An `egal` comparison is performed for other numeric values.\n            return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n        case '[object Date]':\n        case '[object Boolean]':\n            // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n            // millisecond representations. Note that invalid dates with millisecond representations\n            // of `NaN` are not equivalent.\n            return +a === +b;\n    }\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n        if (typeof a != 'object' || typeof b != 'object')\n            return false;\n        // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n        // from different frames are.\n        var aCtor = a.constructor, bCtor = b.constructor;\n        if (aCtor !== bCtor && !(types_1.isFunction(aCtor) && aCtor instanceof aCtor &&\n            types_1.isFunction(bCtor) && bCtor instanceof bCtor)\n            && ('constructor' in a && 'constructor' in b)) {\n            return false;\n        }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n        // Linear search. Performance is inversely proportional to the number of\n        // unique nested structures.\n        if (aStack[length] === a)\n            return bStack[length] === b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n        // Compare array lengths to determine if a deep comparison is necessary.\n        length = a.length;\n        if (length !== b.length)\n            return false;\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (length--) {\n            if (!eq(a[length], b[length], aStack, bStack))\n                return false;\n        }\n    }\n    else {\n        // Deep compare objects.\n        var keys = Object.keys(a);\n        var key = void 0;\n        length = keys.length;\n        // Ensure that both objects contain the same number of properties before comparing deep equality.\n        if (Object.keys(b).length !== length)\n            return false;\n        while (length--) {\n            // Deep compare each member\n            key = keys[length];\n            if (!(b.hasOwnProperty(key) && eq(a[key], b[key], aStack, bStack)))\n                return false;\n        }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n}\n// Perform a deep comparison to check if two objects are equal.\nfunction isEqual(a, b) {\n    return eq(a, b);\n}\nexports.isEqual = isEqual;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction angle_norm(angle) {\n    while (angle < 0) {\n        angle += 2 * Math.PI;\n    }\n    while (angle > 2 * Math.PI) {\n        angle -= 2 * Math.PI;\n    }\n    return angle;\n}\nexports.angle_norm = angle_norm;\nfunction angle_dist(lhs, rhs) {\n    return Math.abs(angle_norm(lhs - rhs));\n}\nexports.angle_dist = angle_dist;\nfunction angle_between(mid, lhs, rhs, direction) {\n    var norm_mid = angle_norm(mid);\n    var d = angle_dist(lhs, rhs);\n    var cond = angle_dist(lhs, norm_mid) <= d && angle_dist(norm_mid, rhs) <= d;\n    if (direction == \"anticlock\")\n        return cond;\n    else\n        return !cond;\n}\nexports.angle_between = angle_between;\nfunction random() {\n    return Math.random();\n}\nexports.random = random;\nfunction randomIn(min, max) {\n    if (max == null) {\n        max = min;\n        min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n}\nexports.randomIn = randomIn;\nfunction atan2(start, end) {\n    /*\n     * Calculate the angle between a line containing start and end points (composed\n     * of [x, y] arrays) and the positive x-axis.\n     */\n    return Math.atan2(end[1] - start[1], end[0] - start[0]);\n}\nexports.atan2 = atan2;\n// http://www2.econ.osaka-u.ac.jp/~tanizaki/class/2013/econome3/13.pdf (Page 432)\nfunction rnorm(mu, sigma) {\n    // Generate a random normal with a mean of 0 and a sigma of 1\n    var r1;\n    var r2;\n    while (true) {\n        r1 = random();\n        r2 = random();\n        r2 = (2 * r2 - 1) * Math.sqrt(2 * (1 / Math.E));\n        if (-4 * r1 * r1 * Math.log(r1) >= r2 * r2)\n            break;\n    }\n    var rn = r2 / r1;\n    // Transform the standard normal to meet the characteristics that we want (mu, sigma)\n    rn = mu + sigma * rn;\n    return rn;\n}\nexports.rnorm = rnorm;\nfunction clamp(val, min, max) {\n    if (val > max)\n        return max;\n    if (val < min)\n        return min;\n    return val;\n}\nexports.clamp = clamp;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar array_1 = require(\"./array\");\nexports.keys = Object.keys;\nfunction values(object) {\n    var keys = Object.keys(object);\n    var length = keys.length;\n    var values = new Array(length);\n    for (var i = 0; i < length; i++) {\n        values[i] = object[keys[i]];\n    }\n    return values;\n}\nexports.values = values;\nfunction extend(dest) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {\n        var source = sources_1[_a];\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                dest[key] = source[key];\n            }\n        }\n    }\n    return dest;\n}\nexports.extend = extend;\nfunction clone(obj) {\n    return extend({}, obj);\n}\nexports.clone = clone;\nfunction merge(obj1, obj2) {\n    /*\n     * Returns an object with the array values for obj1 and obj2 unioned by key.\n     */\n    var result = Object.create(Object.prototype);\n    var keys = array_1.concat([Object.keys(obj1), Object.keys(obj2)]);\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n        var arr1 = obj1.hasOwnProperty(key) ? obj1[key] : [];\n        var arr2 = obj2.hasOwnProperty(key) ? obj2[key] : [];\n        result[key] = array_1.union(arr1, arr2);\n    }\n    return result;\n}\nexports.merge = merge;\nfunction size(obj) {\n    return Object.keys(obj).length;\n}\nexports.size = size;\nfunction isEmpty(obj) {\n    return size(obj) === 0;\n}\nexports.isEmpty = isEmpty;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar proj4 = require(\"proj4/lib/core\");\nexports.proj4 = proj4;\nvar Proj = require(\"proj4/lib/Proj\");\nvar toPoint = require(\"proj4/lib/common/toPoint\");\nvar defs = require(\"proj4/lib/defs\");\nvar transform = require(\"proj4/lib/transform\");\nproj4.defaultDatum = 'WGS84';\nproj4.WGS84 = new Proj('WGS84');\nproj4.Proj = Proj;\nproj4.toPoint = toPoint;\nproj4.defs = defs;\nproj4.transform = transform;\nexports.mercator = defs('GOOGLE');\nexports.wgs84 = defs('WGS84');\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar proj4_1 = require(\"./proj4\");\nexports.project_xy = function (x, y) {\n    var i, j, merc_x, merc_x_s, merc_y, merc_y_s, ref, ref1;\n    merc_x_s = [];\n    merc_y_s = [];\n    for (i = j = 0, ref = x.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n        ref1 = proj4_1.proj4(proj4_1.mercator, [x[i], y[i]]), merc_x = ref1[0], merc_y = ref1[1];\n        merc_x_s[i] = merc_x;\n        merc_y_s[i] = merc_y;\n    }\n    return [merc_x_s, merc_y_s];\n};\nexports.project_xsys = function (xs, ys) {\n    var i, j, merc_x_s, merc_xs_s, merc_y_s, merc_ys_s, ref, ref1;\n    merc_xs_s = [];\n    merc_ys_s = [];\n    for (i = j = 0, ref = xs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n        ref1 = exports.project_xy(xs[i], ys[i]), merc_x_s = ref1[0], merc_y_s = ref1[1];\n        merc_xs_s[i] = merc_x_s;\n        merc_ys_s[i] = merc_y_s;\n    }\n    return [merc_xs_s, merc_ys_s];\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar has_props_1 = require(\"../has_props\");\nvar types_1 = require(\"./types\");\nexports.create_ref = function (obj) {\n    var ref;\n    if (!(obj instanceof has_props_1.HasProps)) {\n        throw new Error(\"can only create refs for HasProps subclasses\");\n    }\n    ref = {\n        'type': obj.type,\n        'id': obj.id\n    };\n    if (obj._subtype != null) {\n        ref['subtype'] = obj._subtype;\n    }\n    return ref;\n};\nexports.is_ref = function (arg) {\n    var keys;\n    if (types_1.isObject(arg)) {\n        keys = Object.keys(arg).sort();\n        if (keys.length === 2) {\n            return keys[0] === 'id' && keys[1] === 'type';\n        }\n        if (keys.length === 3) {\n            return keys[0] === 'id' && keys[1] === 'subtype' && keys[2] === 'type';\n        }\n    }\n    return false;\n};\nexports.convert_to_ref = function (value) {\n    if (types_1.isArray(value)) {\n        return value.map(exports.convert_to_ref);\n    }\n    else {\n        if (value instanceof has_props_1.HasProps) {\n            return value.ref();\n        }\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.get_indices = function (data_source) {\n    var selected;\n    selected = data_source.selected;\n    if (selected['0d'].glyph) {\n        return selected['0d'].indices;\n    }\n    else if (selected['1d'].indices.length > 0) {\n        return selected['1d'].indices;\n    }\n    else if (selected['2d'].indices.length > 0) {\n        return selected['2d'].indices;\n    }\n    else {\n        return [];\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ARRAY_TYPES, DTYPES, _arrayBufferToBase64, _base64ToArrayBuffer, k, v;\nvar types_1 = require(\"./types\");\nARRAY_TYPES = {\n    float32: Float32Array,\n    float64: Float64Array,\n    uint8: Uint8Array,\n    int8: Int8Array,\n    uint16: Uint16Array,\n    int16: Int16Array,\n    uint32: Uint32Array,\n    int32: Int32Array\n};\nDTYPES = {};\nfor (k in ARRAY_TYPES) {\n    v = ARRAY_TYPES[k];\n    DTYPES[v.name] = k;\n}\n_arrayBufferToBase64 = function (buffer) {\n    var b, binary, bytes;\n    bytes = new Uint8Array(buffer);\n    binary = (function () {\n        var j, len1, results;\n        results = [];\n        for (j = 0, len1 = bytes.length; j < len1; j++) {\n            b = bytes[j];\n            results.push(String.fromCharCode(b));\n        }\n        return results;\n    })();\n    return btoa(binary.join(\"\"));\n};\n_base64ToArrayBuffer = function (base64) {\n    var binary_string, bytes, i, j, len, ref;\n    binary_string = atob(base64);\n    len = binary_string.length;\n    bytes = new Uint8Array(len);\n    for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n        bytes[i] = binary_string.charCodeAt(i);\n    }\n    return bytes.buffer;\n};\nexports.decode_base64 = function (input) {\n    var array, bytes, dtype, shape;\n    bytes = _base64ToArrayBuffer(input['__ndarray__']);\n    dtype = input['dtype'];\n    if (dtype in ARRAY_TYPES) {\n        array = new ARRAY_TYPES[dtype](bytes);\n    }\n    shape = input['shape'];\n    return [array, shape];\n};\nexports.encode_base64 = function (array, shape) {\n    var b64, data, dtype;\n    b64 = _arrayBufferToBase64(array.buffer);\n    dtype = DTYPES[array.constructor.name];\n    data = {\n        __ndarray__: b64,\n        shape: shape,\n        dtype: dtype\n    };\n    return data;\n};\nexports.decode_column_data = function (data) {\n    var arr, arrays, data_shapes, j, len1, new_data, ref, ref1, shape, shapes;\n    new_data = {};\n    data_shapes = {};\n    for (k in data) {\n        v = data[k];\n        if (types_1.isArray(v)) {\n            arrays = [];\n            shapes = [];\n            for (j = 0, len1 = v.length; j < len1; j++) {\n                arr = v[j];\n                if (types_1.isObject(arr) && '__ndarray__' in arr) {\n                    ref = exports.decode_base64(arr), arr = ref[0], shape = ref[1];\n                    shapes.push(shape);\n                    arrays.push(arr);\n                }\n                else if (types_1.isArray(arr)) {\n                    shapes.push([]);\n                    arrays.push(arr);\n                }\n            }\n            if (shapes.length > 0) {\n                new_data[k] = arrays;\n                data_shapes[k] = shapes;\n            }\n            else {\n                new_data[k] = v;\n            }\n        }\n        else if (types_1.isObject(v) && '__ndarray__' in v) {\n            ref1 = exports.decode_base64(v), arr = ref1[0], shape = ref1[1];\n            new_data[k] = arr;\n            data_shapes[k] = shape;\n        }\n        else {\n            new_data[k] = v;\n            data_shapes[k] = [];\n        }\n    }\n    return [new_data, data_shapes];\n};\nexports.encode_column_data = function (data, shapes) {\n    var i, j, new_array, new_data, ref, ref1, ref2;\n    new_data = {};\n    for (k in data) {\n        v = data[k];\n        if ((v != null ? v.buffer : void 0) instanceof ArrayBuffer) {\n            v = exports.encode_base64(v, shapes != null ? shapes[k] : void 0);\n        }\n        else if (types_1.isArray(v)) {\n            new_array = [];\n            for (i = j = 0, ref = v.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                if (((ref1 = v[i]) != null ? ref1.buffer : void 0) instanceof ArrayBuffer) {\n                    new_array.push(exports.encode_base64(v[i], shapes != null ? (ref2 = shapes[k]) != null ? ref2[i] : void 0 : void 0));\n                }\n                else {\n                    new_array.push(v[i]);\n                }\n            }\n            v = new_array;\n        }\n        new_data[k] = v;\n    }\n    return new_data;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\n/// <reference types=\"@types/rbush\" />\nvar rbush = require(\"rbush\");\nvar SpatialIndex = (function () {\n    function SpatialIndex() {\n    }\n    return SpatialIndex;\n}());\nexports.SpatialIndex = SpatialIndex;\nvar RBush = (function (_super) {\n    tslib_1.__extends(RBush, _super);\n    function RBush(points) {\n        var _this = _super.call(this) || this;\n        _this.index = rbush();\n        _this.index.load(points);\n        return _this;\n    }\n    Object.defineProperty(RBush.prototype, \"bbox\", {\n        get: function () {\n            var _a = this.index.toJSON(), minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;\n            return { minX: minX, minY: minY, maxX: maxX, maxY: maxY };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    RBush.prototype.search = function (rect) {\n        return this.index.search(rect);\n    };\n    RBush.prototype.indices = function (rect) {\n        var points = this.search(rect);\n        var n = points.length;\n        var indices = new Array(n);\n        for (var j = 0; j < n; j++) {\n            indices[j] = points[j].i;\n        }\n        return indices;\n    };\n    return RBush;\n}(SpatialIndex));\nexports.RBush = RBush;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar settings_1 = require(\"../settings\");\nfunction startsWith(str, searchString, position) {\n    if (position === void 0) { position = 0; }\n    return str.substr(position, searchString.length) == searchString;\n}\nexports.startsWith = startsWith;\nfunction uuid4() {\n    // from ipython project\n    // http://www.ietf.org/rfc/rfc4122.txt\n    var s = new Array(32);\n    var hexDigits = \"0123456789ABCDEF\";\n    for (var i = 0; i < 32; i++) {\n        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\n    }\n    s[12] = \"4\"; // bits 12-15 of the time_hi_and_version field to 0010\n    s[16] = hexDigits.substr((s[16].charCodeAt(0) & 0x3) | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01\n    return s.join(\"\");\n}\nexports.uuid4 = uuid4;\nvar counter = 1000;\nfunction uniqueId(prefix) {\n    var id = settings_1.settings.dev ? \"j\" + counter++ : uuid4();\n    if (prefix != null)\n        return prefix + \"-\" + id;\n    else\n        return id;\n}\nexports.uniqueId = uniqueId;\nfunction escape(s) {\n    return s.replace(/(?:[&<>\"'`])/g, function (ch) {\n        switch (ch) {\n            case '&': return '&amp;';\n            case '<': return '&lt;';\n            case '>': return '&gt;';\n            case '\"': return '&quot;';\n            case \"'\": return '&#x27;';\n            case '`': return '&#x60;';\n            default: return ch;\n        }\n    });\n}\nexports.escape = escape;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.indianred = \"#CD5C5C\";\nexports.lightcoral = \"#F08080\";\nexports.salmon = \"#FA8072\";\nexports.darksalmon = \"#E9967A\";\nexports.lightsalmon = \"#FFA07A\";\nexports.crimson = \"#DC143C\";\nexports.red = \"#FF0000\";\nexports.firebrick = \"#B22222\";\nexports.darkred = \"#8B0000\";\nexports.pink = \"#FFC0CB\";\nexports.lightpink = \"#FFB6C1\";\nexports.hotpink = \"#FF69B4\";\nexports.deeppink = \"#FF1493\";\nexports.mediumvioletred = \"#C71585\";\nexports.palevioletred = \"#DB7093\";\nexports.coral = \"#FF7F50\";\nexports.tomato = \"#FF6347\";\nexports.orangered = \"#FF4500\";\nexports.darkorange = \"#FF8C00\";\nexports.orange = \"#FFA500\";\nexports.gold = \"#FFD700\";\nexports.yellow = \"#FFFF00\";\nexports.lightyellow = \"#FFFFE0\";\nexports.lemonchiffon = \"#FFFACD\";\nexports.lightgoldenrodyellow = \"#FAFAD2\";\nexports.papayawhip = \"#FFEFD5\";\nexports.moccasin = \"#FFE4B5\";\nexports.peachpuff = \"#FFDAB9\";\nexports.palegoldenrod = \"#EEE8AA\";\nexports.khaki = \"#F0E68C\";\nexports.darkkhaki = \"#BDB76B\";\nexports.lavender = \"#E6E6FA\";\nexports.thistle = \"#D8BFD8\";\nexports.plum = \"#DDA0DD\";\nexports.violet = \"#EE82EE\";\nexports.orchid = \"#DA70D6\";\nexports.fuchsia = \"#FF00FF\";\nexports.magenta = \"#FF00FF\";\nexports.mediumorchid = \"#BA55D3\";\nexports.mediumpurple = \"#9370DB\";\nexports.blueviolet = \"#8A2BE2\";\nexports.darkviolet = \"#9400D3\";\nexports.darkorchid = \"#9932CC\";\nexports.darkmagenta = \"#8B008B\";\nexports.purple = \"#800080\";\nexports.indigo = \"#4B0082\";\nexports.slateblue = \"#6A5ACD\";\nexports.darkslateblue = \"#483D8B\";\nexports.mediumslateblue = \"#7B68EE\";\nexports.greenyellow = \"#ADFF2F\";\nexports.chartreuse = \"#7FFF00\";\nexports.lawngreen = \"#7CFC00\";\nexports.lime = \"#00FF00\";\nexports.limegreen = \"#32CD32\";\nexports.palegreen = \"#98FB98\";\nexports.lightgreen = \"#90EE90\";\nexports.mediumspringgreen = \"#00FA9A\";\nexports.springgreen = \"#00FF7F\";\nexports.mediumseagreen = \"#3CB371\";\nexports.seagreen = \"#2E8B57\";\nexports.forestgreen = \"#228B22\";\nexports.green = \"#008000\";\nexports.darkgreen = \"#006400\";\nexports.yellowgreen = \"#9ACD32\";\nexports.olivedrab = \"#6B8E23\";\nexports.olive = \"#808000\";\nexports.darkolivegreen = \"#556B2F\";\nexports.mediumaquamarine = \"#66CDAA\";\nexports.darkseagreen = \"#8FBC8F\";\nexports.lightseagreen = \"#20B2AA\";\nexports.darkcyan = \"#008B8B\";\nexports.teal = \"#008080\";\nexports.aqua = \"#00FFFF\";\nexports.cyan = \"#00FFFF\";\nexports.lightcyan = \"#E0FFFF\";\nexports.paleturquoise = \"#AFEEEE\";\nexports.aquamarine = \"#7FFFD4\";\nexports.turquoise = \"#40E0D0\";\nexports.mediumturquoise = \"#48D1CC\";\nexports.darkturquoise = \"#00CED1\";\nexports.cadetblue = \"#5F9EA0\";\nexports.steelblue = \"#4682B4\";\nexports.lightsteelblue = \"#B0C4DE\";\nexports.powderblue = \"#B0E0E6\";\nexports.lightblue = \"#ADD8E6\";\nexports.skyblue = \"#87CEEB\";\nexports.lightskyblue = \"#87CEFA\";\nexports.deepskyblue = \"#00BFFF\";\nexports.dodgerblue = \"#1E90FF\";\nexports.cornflowerblue = \"#6495ED\";\nexports.royalblue = \"#4169E1\";\nexports.blue = \"#0000FF\";\nexports.mediumblue = \"#0000CD\";\nexports.darkblue = \"#00008B\";\nexports.navy = \"#000080\";\nexports.midnightblue = \"#191970\";\nexports.cornsilk = \"#FFF8DC\";\nexports.blanchedalmond = \"#FFEBCD\";\nexports.bisque = \"#FFE4C4\";\nexports.navajowhite = \"#FFDEAD\";\nexports.wheat = \"#F5DEB3\";\nexports.burlywood = \"#DEB887\";\nexports.tan = \"#D2B48C\";\nexports.rosybrown = \"#BC8F8F\";\nexports.sandybrown = \"#F4A460\";\nexports.goldenrod = \"#DAA520\";\nexports.darkgoldenrod = \"#B8860B\";\nexports.peru = \"#CD853F\";\nexports.chocolate = \"#D2691E\";\nexports.saddlebrown = \"#8B4513\";\nexports.sienna = \"#A0522D\";\nexports.brown = \"#A52A2A\";\nexports.maroon = \"#800000\";\nexports.white = \"#FFFFFF\";\nexports.snow = \"#FFFAFA\";\nexports.honeydew = \"#F0FFF0\";\nexports.mintcream = \"#F5FFFA\";\nexports.azure = \"#F0FFFF\";\nexports.aliceblue = \"#F0F8FF\";\nexports.ghostwhite = \"#F8F8FF\";\nexports.whitesmoke = \"#F5F5F5\";\nexports.seashell = \"#FFF5EE\";\nexports.beige = \"#F5F5DC\";\nexports.oldlace = \"#FDF5E6\";\nexports.floralwhite = \"#FFFAF0\";\nexports.ivory = \"#FFFFF0\";\nexports.antiquewhite = \"#FAEBD7\";\nexports.linen = \"#FAF0E6\";\nexports.lavenderblush = \"#FFF0F5\";\nexports.mistyrose = \"#FFE4E1\";\nexports.gainsboro = \"#DCDCDC\";\nexports.lightgray = \"#D3D3D3\";\nexports.lightgrey = \"#D3D3D3\";\nexports.silver = \"#C0C0C0\";\nexports.darkgray = \"#A9A9A9\";\nexports.darkgrey = \"#A9A9A9\";\nexports.gray = \"#808080\";\nexports.grey = \"#808080\";\nexports.dimgray = \"#696969\";\nexports.dimgrey = \"#696969\";\nexports.lightslategray = \"#778899\";\nexports.lightslategrey = \"#778899\";\nexports.slategray = \"#708090\";\nexports.slategrey = \"#708090\";\nexports.darkslategray = \"#2F4F4F\";\nexports.darkslategrey = \"#2F4F4F\";\nexports.black = \"#000000\";\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _format_number;\nvar SPrintf = require(\"sprintf\");\nvar Numbro = require(\"numbro\");\nvar tz = require(\"timezone\");\nvar string_1 = require(\"./string\");\nvar types_1 = require(\"./types\");\n_format_number = function (number) {\n    var format;\n    if (types_1.isNumber(number)) {\n        format = (function () {\n            switch (false) {\n                case Math.floor(number) !== number:\n                    return \"%d\";\n                case !(Math.abs(number) > 0.1 && Math.abs(number) < 1000):\n                    return \"%0.3f\";\n                default:\n                    return \"%0.3e\";\n            }\n        })();\n        return SPrintf.sprintf(format, number);\n    }\n    else {\n        return \"\" + number;\n    }\n};\nexports.replace_placeholders = function (string, data_source, i, formatters, special_vars) {\n    if (special_vars == null) {\n        special_vars = {};\n    }\n    string = string.replace(/(^|[^\\$])\\$(\\w+)/g, (function (_this) {\n        return function (match, prefix, name) {\n            return prefix + \"@$\" + name;\n        };\n    })(this));\n    string = string.replace(/(^|[^@])@(?:(\\$?\\w+)|{([^{}]+)})(?:{([^{}]+)})?/g, (function (_this) {\n        return function (match, prefix, name, long_name, format) {\n            var ref, replacement, value;\n            name = long_name != null ? long_name : name;\n            value = name[0] === \"$\" ? special_vars[name.substring(1)] : (ref = data_source.get_column(name)) != null ? ref[i] : void 0;\n            replacement = null;\n            if (value == null) {\n                replacement = \"???\";\n            }\n            else {\n                if (format === 'safe') {\n                    return \"\" + prefix + value;\n                }\n                else if (format != null) {\n                    if ((formatters != null) && name in formatters) {\n                        if (formatters[name] === \"numeral\") {\n                            replacement = Numbro.format(value, format);\n                        }\n                        else if (formatters[name] === \"datetime\") {\n                            replacement = tz(value, format);\n                        }\n                        else if (formatters[name] === \"printf\") {\n                            replacement = SPrintf(format, value);\n                        }\n                        else {\n                            throw new Error(\"Unknown tooltip field formatter type '\" + formatters[name] + \"'\");\n                        }\n                    }\n                    else {\n                        replacement = Numbro.format(value, format);\n                    }\n                }\n                else {\n                    replacement = _format_number(value);\n                }\n            }\n            return replacement = \"\" + prefix + (string_1.escape(replacement));\n        };\n    })(this));\n    return string;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar cache;\nvar dom_1 = require(\"../dom\");\ncache = {};\nexports.get_text_height = function (font) {\n    var block, elem, result, text;\n    if (cache[font] != null) {\n        return cache[font];\n    }\n    text = dom_1.span({\n        style: {\n            font: font\n        }\n    }, \"Hg\");\n    block = dom_1.div({\n        style: {\n            display: \"inline-block\",\n            width: \"1px\",\n            height: \"0px\"\n        }\n    });\n    elem = dom_1.div({}, text, block);\n    document.body.appendChild(elem);\n    try {\n        result = {};\n        block.style.verticalAlign = \"baseline\";\n        result.ascent = dom_1.offset(block).top - dom_1.offset(text).top;\n        block.style.verticalAlign = \"bottom\";\n        result.height = dom_1.offset(block).top - dom_1.offset(text).top;\n        result.descent = result.height - result.ascent;\n    }\n    finally {\n        document.body.removeChild(elem);\n    }\n    cache[font] = result;\n    return result;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _delay_animation, delay_animation;\n_delay_animation = function (f) {\n    return f();\n};\ndelay_animation = (typeof window !== \"undefined\" && window !== null ? window.requestAnimationFrame : void 0) || (typeof window !== \"undefined\" && window !== null ? window.mozRequestAnimationFrame : void 0) || (typeof window !== \"undefined\" && window !== null ? window.webkitRequestAnimationFrame : void 0) || (typeof window !== \"undefined\" && window !== null ? window.msRequestAnimationFrame : void 0) || _delay_animation;\nexports.throttle = function (func, wait) {\n    var args, context, later, pending, previous, ref, result, timeout;\n    ref = [null, null, null, null], context = ref[0], args = ref[1], timeout = ref[2], result = ref[3];\n    previous = 0;\n    pending = false;\n    later = function () {\n        previous = new Date;\n        timeout = null;\n        pending = false;\n        return result = func.apply(context, args);\n    };\n    return function () {\n        var now, remaining;\n        now = new Date;\n        remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 && !pending) {\n            clearTimeout(timeout);\n            pending = true;\n            delay_animation(later);\n        }\n        else if (!timeout && !pending) {\n            timeout = setTimeout((function () {\n                return delay_animation(later);\n            }), remaining);\n        }\n        return result;\n    };\n};\n","\"use strict\";\n//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar toString = Object.prototype.toString;\nfunction isBoolean(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n}\nexports.isBoolean = isBoolean;\nfunction isNumber(obj) {\n    return toString.call(obj) === \"[object Number]\";\n}\nexports.isNumber = isNumber;\nfunction isString(obj) {\n    return toString.call(obj) === \"[object String]\";\n}\nexports.isString = isString;\nfunction isStrictNaN(obj) {\n    return isNumber(obj) && obj !== +obj;\n}\nexports.isStrictNaN = isStrictNaN;\nfunction isFunction(obj) {\n    return toString.call(obj) === \"[object Function]\";\n}\nexports.isFunction = isFunction;\nfunction isArray(obj) {\n    return Array.isArray(obj);\n}\nexports.isArray = isArray;\nfunction isObject(obj) {\n    var tp = typeof obj;\n    return tp === 'function' || tp === 'object' && !!obj;\n}\nexports.isObject = isObject;\n","\"use strict\";\n/*!\n * jQuery Mousewheel 3.1.13\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction fontSize(element) {\n    var value = getComputedStyle(element).fontSize;\n    if (value != null)\n        return parseInt(value, 10);\n    return null;\n}\nfunction lineHeight(element) {\n    var parent = element.offsetParent || document.body;\n    return fontSize(parent) || fontSize(element) || 16;\n}\nfunction pageHeight(element) {\n    return element.clientHeight; // XXX: should be content height?\n}\nfunction getDeltaY(event) {\n    var deltaY = -event.deltaY;\n    if (event.target instanceof HTMLElement) {\n        switch (event.deltaMode) {\n            case event.DOM_DELTA_LINE:\n                deltaY *= lineHeight(event.target);\n                break;\n            case event.DOM_DELTA_PAGE:\n                deltaY *= pageHeight(event.target);\n                break;\n        }\n    }\n    return deltaY;\n}\nexports.getDeltaY = getDeltaY;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar math_1 = require(\"./math\");\nexports.scale_highlow = function (range, factor, center) {\n    var high, low, ref, x, x0, x1;\n    if (center == null) {\n        center = null;\n    }\n    ref = [range.start, range.end], low = ref[0], high = ref[1];\n    x = center != null ? center : (high + low) / 2.0;\n    x0 = low - (low - x) * factor;\n    x1 = high - (high - x) * factor;\n    return [x0, x1];\n};\nexports.get_info = function (scales, arg) {\n    var end, info, name, ref, scale, start, x0, x1;\n    x0 = arg[0], x1 = arg[1];\n    info = {};\n    for (name in scales) {\n        scale = scales[name];\n        ref = scale.v_invert([x0, x1], true), start = ref[0], end = ref[1];\n        info[name] = {\n            start: start,\n            end: end\n        };\n    }\n    return info;\n};\nexports.scale_range = function (frame, factor, h_axis, v_axis, center) {\n    var hfactor, ref, ref1, vfactor, vx0, vx1, vy0, vy1, xrs, yrs;\n    if (h_axis == null) {\n        h_axis = true;\n    }\n    if (v_axis == null) {\n        v_axis = true;\n    }\n    if (center == null) {\n        center = null;\n    }\n    \"Utility function for zoom tools to calculate/create the zoom_info object\\nof the form required by ``PlotCanvasView.update_range``\\n\\nParameters:\\n  frame : CartesianFrame\\n  factor : Number\\n  h_axis : Boolean, optional\\n    whether to zoom the horizontal axis (default = true)\\n  v_axis : Boolean, optional\\n    whether to zoom the horizontal axis (default = true)\\n  center : object, optional\\n    of form {'x': Number, 'y', Number}\\n\\nReturns:\\n  object:\";\n    factor = math_1.clamp(factor, -0.9, 0.9);\n    hfactor = h_axis ? factor : 0;\n    ref = exports.scale_highlow(frame.h_range, hfactor, center != null ? center.x : void 0), vx0 = ref[0], vx1 = ref[1];\n    xrs = exports.get_info(frame.xscales, [vx0, vx1]);\n    vfactor = v_axis ? factor : 0;\n    ref1 = exports.scale_highlow(frame.v_range, vfactor, center != null ? center.y : void 0), vy0 = ref1[0], vy1 = ref1[1];\n    yrs = exports.get_info(frame.yscales, [vy0, vy1]);\n    return {\n        xrs: xrs,\n        yrs: yrs,\n        factor: factor\n    };\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar signaling_1 = require(\"./signaling\");\nvar string_1 = require(\"./util/string\");\nexports.View = (function () {\n    extend(View.prototype, signaling_1.Signalable);\n    View.getters = function (specs) {\n        var fn, name, results;\n        results = [];\n        for (name in specs) {\n            fn = specs[name];\n            results.push(Object.defineProperty(this.prototype, name, {\n                get: fn\n            }));\n        }\n        return results;\n    };\n    function View(options) {\n        var ref;\n        if (options == null) {\n            options = {};\n        }\n        this.removed = new signaling_1.Signal(this, \"removed\");\n        if (options.model != null) {\n            this.model = options.model;\n        }\n        else {\n            throw new Error(\"model of a view wasn't configured\");\n        }\n        this._parent = options.parent;\n        this.id = (ref = options.id) != null ? ref : string_1.uniqueId();\n        this.initialize(options);\n    }\n    View.prototype.initialize = function (options) { };\n    View.prototype.remove = function () {\n        this._parent = void 0;\n        this.disconnect_signals();\n        return this.removed.emit();\n    };\n    View.prototype.toString = function () {\n        return this.model.type + \"View(\" + this.id + \")\";\n    };\n    View.getters({\n        parent: function () {\n            if (this._parent !== void 0) {\n                return this._parent;\n            }\n            else {\n                throw new Error(\"parent of a view wasn't configured\");\n            }\n        },\n        is_root: function () {\n            return this.parent === null;\n        },\n        root: function () {\n            if (this.is_root) {\n                return this;\n            }\n            else {\n                return this.parent.root;\n            }\n        }\n    });\n    View.prototype.connect_signals = function () { };\n    View.prototype.disconnect_signals = function () {\n        return signaling_1.Signal.disconnectReceiver(this);\n    };\n    return View;\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ContextProperties, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar mixins = require(\"./property_mixins\");\nvar color_1 = require(\"./util/color\");\nContextProperties = (function () {\n    function ContextProperties(obj, prefix) {\n        var attr, do_spec, j, len, ref;\n        if (prefix == null) {\n            prefix = \"\";\n        }\n        this.obj = obj;\n        this.prefix = prefix;\n        this.cache = {};\n        do_spec = obj.properties[prefix + this.do_attr].spec;\n        this.doit = do_spec.value !== null;\n        ref = this.attrs;\n        for (j = 0, len = ref.length; j < len; j++) {\n            attr = ref[j];\n            this[attr] = obj.properties[prefix + attr];\n        }\n    }\n    ContextProperties.prototype.warm_cache = function (source) {\n        var attr, j, len, prop, ref, results;\n        ref = this.attrs;\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n            attr = ref[j];\n            prop = this.obj.properties[this.prefix + attr];\n            if (prop.spec.value !== void 0) {\n                results.push(this.cache[attr] = prop.spec.value);\n            }\n            else {\n                results.push(this.cache[attr + \"_array\"] = prop.array(source));\n            }\n        }\n        return results;\n    };\n    ContextProperties.prototype.cache_select = function (attr, i) {\n        var prop;\n        prop = this.obj.properties[this.prefix + attr];\n        if (prop.spec.value !== void 0) {\n            return this.cache[attr] = prop.spec.value;\n        }\n        else {\n            return this.cache[attr] = this.cache[attr + \"_array\"][i];\n        }\n    };\n    return ContextProperties;\n})();\nexports.Line = (function (superClass) {\n    extend(Line, superClass);\n    function Line() {\n        return Line.__super__.constructor.apply(this, arguments);\n    }\n    Line.prototype.attrs = Object.keys(mixins.line());\n    Line.prototype.do_attr = \"line_color\";\n    Line.prototype.set_value = function (ctx) {\n        ctx.strokeStyle = this.line_color.value();\n        ctx.globalAlpha = this.line_alpha.value();\n        ctx.lineWidth = this.line_width.value();\n        ctx.lineJoin = this.line_join.value();\n        ctx.lineCap = this.line_cap.value();\n        ctx.setLineDash(this.line_dash.value());\n        return ctx.setLineDashOffset(this.line_dash_offset.value());\n    };\n    Line.prototype.set_vectorize = function (ctx, i) {\n        this.cache_select(\"line_color\", i);\n        if (ctx.strokeStyle !== this.cache.line_color) {\n            ctx.strokeStyle = this.cache.line_color;\n        }\n        this.cache_select(\"line_alpha\", i);\n        if (ctx.globalAlpha !== this.cache.line_alpha) {\n            ctx.globalAlpha = this.cache.line_alpha;\n        }\n        this.cache_select(\"line_width\", i);\n        if (ctx.lineWidth !== this.cache.line_width) {\n            ctx.lineWidth = this.cache.line_width;\n        }\n        this.cache_select(\"line_join\", i);\n        if (ctx.lineJoin !== this.cache.line_join) {\n            ctx.lineJoin = this.cache.line_join;\n        }\n        this.cache_select(\"line_cap\", i);\n        if (ctx.lineCap !== this.cache.line_cap) {\n            ctx.lineCap = this.cache.line_cap;\n        }\n        this.cache_select(\"line_dash\", i);\n        if (ctx.getLineDash() !== this.cache.line_dash) {\n            ctx.setLineDash(this.cache.line_dash);\n        }\n        this.cache_select(\"line_dash_offset\", i);\n        if (ctx.getLineDashOffset() !== this.cache.line_dash_offset) {\n            return ctx.setLineDashOffset(this.cache.line_dash_offset);\n        }\n    };\n    Line.prototype.color_value = function () {\n        var color;\n        color = color_1.color2rgba(this.line_color.value(), this.line_alpha.value());\n        return \"rgba(\" + (color[0] * 255) + \",\" + (color[1] * 255) + \",\" + (color[2] * 255) + \",\" + color[3] + \")\";\n    };\n    return Line;\n})(ContextProperties);\nexports.Fill = (function (superClass) {\n    extend(Fill, superClass);\n    function Fill() {\n        return Fill.__super__.constructor.apply(this, arguments);\n    }\n    Fill.prototype.attrs = Object.keys(mixins.fill());\n    Fill.prototype.do_attr = \"fill_color\";\n    Fill.prototype.set_value = function (ctx) {\n        ctx.fillStyle = this.fill_color.value();\n        return ctx.globalAlpha = this.fill_alpha.value();\n    };\n    Fill.prototype.set_vectorize = function (ctx, i) {\n        this.cache_select(\"fill_color\", i);\n        if (ctx.fillStyle !== this.cache.fill_color) {\n            ctx.fillStyle = this.cache.fill_color;\n        }\n        this.cache_select(\"fill_alpha\", i);\n        if (ctx.globalAlpha !== this.cache.fill_alpha) {\n            return ctx.globalAlpha = this.cache.fill_alpha;\n        }\n    };\n    Fill.prototype.color_value = function () {\n        var color;\n        color = color_1.color2rgba(this.fill_color.value(), this.fill_alpha.value());\n        return \"rgba(\" + (color[0] * 255) + \",\" + (color[1] * 255) + \",\" + (color[2] * 255) + \",\" + color[3] + \")\";\n    };\n    return Fill;\n})(ContextProperties);\nexports.Text = (function (superClass) {\n    extend(Text, superClass);\n    function Text() {\n        return Text.__super__.constructor.apply(this, arguments);\n    }\n    Text.prototype.attrs = Object.keys(mixins.text());\n    Text.prototype.do_attr = \"text_color\";\n    Text.prototype.cache_select = function (name, i) {\n        var val;\n        if (name === \"font\") {\n            val = Text.__super__.cache_select.call(this, \"text_font_style\", i) + \" \" + Text.__super__.cache_select.call(this, \"text_font_size\", i) + \" \" + Text.__super__.cache_select.call(this, \"text_font\", i);\n            return this.cache.font = val;\n        }\n        else {\n            return Text.__super__.cache_select.call(this, name, i);\n        }\n    };\n    Text.prototype.font_value = function () {\n        var font, font_size, font_style;\n        font = this.text_font.value();\n        font_size = this.text_font_size.value();\n        font_style = this.text_font_style.value();\n        return font_style + \" \" + font_size + \" \" + font;\n    };\n    Text.prototype.color_value = function () {\n        var color;\n        color = color_1.color2rgba(this.text_color.value(), this.text_alpha.value());\n        return \"rgba(\" + (color[0] * 255) + \",\" + (color[1] * 255) + \",\" + (color[2] * 255) + \",\" + color[3] + \")\";\n    };\n    Text.prototype.set_value = function (ctx) {\n        ctx.font = this.font_value();\n        ctx.fillStyle = this.text_color.value();\n        ctx.globalAlpha = this.text_alpha.value();\n        ctx.textAlign = this.text_align.value();\n        return ctx.textBaseline = this.text_baseline.value();\n    };\n    Text.prototype.set_vectorize = function (ctx, i) {\n        this.cache_select(\"font\", i);\n        if (ctx.font !== this.cache.font) {\n            ctx.font = this.cache.font;\n        }\n        this.cache_select(\"text_color\", i);\n        if (ctx.fillStyle !== this.cache.text_color) {\n            ctx.fillStyle = this.cache.text_color;\n        }\n        this.cache_select(\"text_alpha\", i);\n        if (ctx.globalAlpha !== this.cache.text_alpha) {\n            ctx.globalAlpha = this.cache.text_alpha;\n        }\n        this.cache_select(\"text_align\", i);\n        if (ctx.textAlign !== this.cache.text_align) {\n            ctx.textAlign = this.cache.text_align;\n        }\n        this.cache_select(\"text_baseline\", i);\n        if (ctx.textBaseline !== this.cache.text_baseline) {\n            return ctx.textBaseline = this.cache.text_baseline;\n        }\n    };\n    return Text;\n})(ContextProperties);\nexports.Visuals = (function () {\n    function Visuals(model) {\n        var cls, j, len, name, prefix, ref, ref1, ref2, spec;\n        ref = model.mixins;\n        for (j = 0, len = ref.length; j < len; j++) {\n            spec = ref[j];\n            ref1 = spec.split(\":\"), name = ref1[0], prefix = (ref2 = ref1[1]) != null ? ref2 : \"\";\n            cls = (function () {\n                switch (name) {\n                    case \"line\":\n                        return exports.Line;\n                    case \"fill\":\n                        return exports.Fill;\n                    case \"text\":\n                        return exports.Text;\n                }\n            })();\n            this[prefix + name] = new cls(model, prefix);\n        }\n    }\n    Visuals.prototype.warm_cache = function (source) {\n        var name, prop, ref, results;\n        ref = this;\n        results = [];\n        for (name in ref) {\n            if (!hasProp.call(ref, name))\n                continue;\n            prop = ref[name];\n            if (prop instanceof ContextProperties) {\n                results.push(prop.warm_cache(source));\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    return Visuals;\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EventManager, extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar base_1 = require(\"./base\");\nvar version_1 = require(\"./version\");\nvar logging_1 = require(\"./core/logging\");\nvar has_props_1 = require(\"./core/has_props\");\nvar signaling_1 = require(\"./core/signaling\");\nvar refs_1 = require(\"./core/util/refs\");\nvar serialization_1 = require(\"./core/util/serialization\");\nvar data_structures_1 = require(\"./core/util/data_structures\");\nvar array_1 = require(\"./core/util/array\");\nvar object_1 = require(\"./core/util/object\");\nvar eq_1 = require(\"./core/util/eq\");\nvar types_1 = require(\"./core/util/types\");\nvar layout_dom_1 = require(\"./models/layouts/layout_dom\");\nvar column_data_source_1 = require(\"./models/sources/column_data_source\");\nEventManager = (function () {\n    function EventManager(document) {\n        this.document = document;\n        this.session = null;\n        this.subscribed_models = new data_structures_1.Set();\n    }\n    EventManager.prototype.send_event = function (event) {\n        var ref1;\n        return (ref1 = this.session) != null ? ref1.send_event(event) : void 0;\n    };\n    EventManager.prototype.trigger = function (event) {\n        var j, len, model, model_id, ref1, results;\n        ref1 = this.subscribed_models.values;\n        results = [];\n        for (j = 0, len = ref1.length; j < len; j++) {\n            model_id = ref1[j];\n            if (event.model_id !== null && event.model_id !== model_id) {\n                continue;\n            }\n            model = this.document._all_models[model_id];\n            results.push(model != null ? model._process_event(event) : void 0);\n        }\n        return results;\n    };\n    return EventManager;\n})();\nexports.DocumentChangedEvent = (function () {\n    function DocumentChangedEvent(document) {\n        this.document = document;\n    }\n    return DocumentChangedEvent;\n})();\nexports.ModelChangedEvent = (function (superClass) {\n    extend1(ModelChangedEvent, superClass);\n    function ModelChangedEvent(document, model1, attr1, old1, new_1, setter_id1) {\n        this.document = document;\n        this.model = model1;\n        this.attr = attr1;\n        this.old = old1;\n        this.new_ = new_1;\n        this.setter_id = setter_id1;\n        ModelChangedEvent.__super__.constructor.call(this, this.document);\n    }\n    ModelChangedEvent.prototype.json = function (references) {\n        var id, value, value_json, value_refs;\n        if (this.attr === 'id') {\n            logging_1.logger.warn(\"'id' field is immutable and should never be in a ModelChangedEvent \", this);\n            throw new Error(\"'id' field should never change, whatever code just set it is wrong\");\n        }\n        value = this.new_;\n        value_json = this.model.constructor._value_to_json(this.attr, value, this.model);\n        value_refs = {};\n        has_props_1.HasProps._value_record_references(value, value_refs, true);\n        if (this.model.id in value_refs && this.model !== value) {\n            delete value_refs[this.model.id];\n        }\n        for (id in value_refs) {\n            references[id] = value_refs[id];\n        }\n        return {\n            'kind': 'ModelChanged',\n            'model': this.model.ref(),\n            'attr': this.attr,\n            'new': value_json\n        };\n    };\n    return ModelChangedEvent;\n})(exports.DocumentChangedEvent);\nexports.TitleChangedEvent = (function (superClass) {\n    extend1(TitleChangedEvent, superClass);\n    function TitleChangedEvent(document, title1, setter_id1) {\n        this.document = document;\n        this.title = title1;\n        this.setter_id = setter_id1;\n        TitleChangedEvent.__super__.constructor.call(this, this.document);\n    }\n    TitleChangedEvent.prototype.json = function (references) {\n        return {\n            'kind': 'TitleChanged',\n            'title': this.title\n        };\n    };\n    return TitleChangedEvent;\n})(exports.DocumentChangedEvent);\nexports.RootAddedEvent = (function (superClass) {\n    extend1(RootAddedEvent, superClass);\n    function RootAddedEvent(document, model1, setter_id1) {\n        this.document = document;\n        this.model = model1;\n        this.setter_id = setter_id1;\n        RootAddedEvent.__super__.constructor.call(this, this.document);\n    }\n    RootAddedEvent.prototype.json = function (references) {\n        has_props_1.HasProps._value_record_references(this.model, references, true);\n        return {\n            'kind': 'RootAdded',\n            'model': this.model.ref()\n        };\n    };\n    return RootAddedEvent;\n})(exports.DocumentChangedEvent);\nexports.RootRemovedEvent = (function (superClass) {\n    extend1(RootRemovedEvent, superClass);\n    function RootRemovedEvent(document, model1, setter_id1) {\n        this.document = document;\n        this.model = model1;\n        this.setter_id = setter_id1;\n        RootRemovedEvent.__super__.constructor.call(this, this.document);\n    }\n    RootRemovedEvent.prototype.json = function (references) {\n        return {\n            'kind': 'RootRemoved',\n            'model': this.model.ref()\n        };\n    };\n    return RootRemovedEvent;\n})(exports.DocumentChangedEvent);\nexports.documents = [];\nexports.DEFAULT_TITLE = \"Bokeh Application\";\nexports.Document = (function () {\n    function Document() {\n        exports.documents.push(this);\n        this._title = exports.DEFAULT_TITLE;\n        this._roots = [];\n        this._all_models = {};\n        this._all_models_by_name = new data_structures_1.MultiDict();\n        this._all_models_freeze_count = 0;\n        this._callbacks = [];\n        this.event_manager = new EventManager(this);\n        this.idle = new signaling_1.Signal(this, \"idle\");\n        this._idle_roots = new WeakMap();\n    }\n    Object.defineProperty(Document.prototype, \"layoutables\", {\n        get: function () {\n            var j, len, ref1, results, root;\n            ref1 = this._roots;\n            results = [];\n            for (j = 0, len = ref1.length; j < len; j++) {\n                root = ref1[j];\n                if (root instanceof layout_dom_1.LayoutDOM) {\n                    results.push(root);\n                }\n            }\n            return results;\n        }\n    });\n    Object.defineProperty(Document.prototype, \"is_idle\", {\n        get: function () {\n            var j, len, ref1, root;\n            ref1 = this.layoutables;\n            for (j = 0, len = ref1.length; j < len; j++) {\n                root = ref1[j];\n                if (!this._idle_roots.has(root)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    });\n    Document.prototype.notify_idle = function (model) {\n        this._idle_roots.set(model, true);\n        if (this.is_idle) {\n            return this.idle.emit();\n        }\n    };\n    Document.prototype.clear = function () {\n        var results;\n        this._push_all_models_freeze();\n        try {\n            results = [];\n            while (this._roots.length > 0) {\n                results.push(this.remove_root(this._roots[0]));\n            }\n            return results;\n        }\n        finally {\n            this._pop_all_models_freeze();\n        }\n    };\n    Document.prototype.destructively_move = function (dest_doc) {\n        var j, l, len, len1, len2, n, r, ref1, roots;\n        if (dest_doc === this) {\n            throw new Error(\"Attempted to overwrite a document with itself\");\n        }\n        dest_doc.clear();\n        roots = [];\n        ref1 = this._roots;\n        for (j = 0, len = ref1.length; j < len; j++) {\n            r = ref1[j];\n            roots.push(r);\n        }\n        this.clear();\n        for (l = 0, len1 = roots.length; l < len1; l++) {\n            r = roots[l];\n            if (r.document !== null) {\n                throw new Error(\"Somehow we didn't detach \" + r);\n            }\n        }\n        if (Object.keys(this._all_models).length !== 0) {\n            throw new Error(\"@_all_models still had stuff in it: \" + this._all_models);\n        }\n        for (n = 0, len2 = roots.length; n < len2; n++) {\n            r = roots[n];\n            dest_doc.add_root(r);\n        }\n        return dest_doc.set_title(this._title);\n    };\n    Document.prototype._push_all_models_freeze = function () {\n        return this._all_models_freeze_count += 1;\n    };\n    Document.prototype._pop_all_models_freeze = function () {\n        this._all_models_freeze_count -= 1;\n        if (this._all_models_freeze_count === 0) {\n            return this._recompute_all_models();\n        }\n    };\n    Document.prototype._invalidate_all_models = function () {\n        logging_1.logger.debug(\"invalidating document models\");\n        if (this._all_models_freeze_count === 0) {\n            return this._recompute_all_models();\n        }\n    };\n    Document.prototype._recompute_all_models = function () {\n        var a, d, j, l, len, len1, len2, len3, m, n, name, new_all_models_set, o, old_all_models_set, r, recomputed, ref1, ref2, ref3, ref4, to_attach, to_detach;\n        new_all_models_set = new data_structures_1.Set();\n        ref1 = this._roots;\n        for (j = 0, len = ref1.length; j < len; j++) {\n            r = ref1[j];\n            new_all_models_set = new_all_models_set.union(r.references());\n        }\n        old_all_models_set = new data_structures_1.Set(object_1.values(this._all_models));\n        to_detach = old_all_models_set.diff(new_all_models_set);\n        to_attach = new_all_models_set.diff(old_all_models_set);\n        recomputed = {};\n        ref2 = new_all_models_set.values;\n        for (l = 0, len1 = ref2.length; l < len1; l++) {\n            m = ref2[l];\n            recomputed[m.id] = m;\n        }\n        ref3 = to_detach.values;\n        for (n = 0, len2 = ref3.length; n < len2; n++) {\n            d = ref3[n];\n            d.detach_document();\n            name = d.name;\n            if (name !== null) {\n                this._all_models_by_name.remove_value(name, d);\n            }\n        }\n        ref4 = to_attach.values;\n        for (o = 0, len3 = ref4.length; o < len3; o++) {\n            a = ref4[o];\n            a.attach_document(this);\n            name = a.name;\n            if (name !== null) {\n                this._all_models_by_name.add_value(name, a);\n            }\n        }\n        return this._all_models = recomputed;\n    };\n    Document.prototype.roots = function () {\n        return this._roots;\n    };\n    Document.prototype.add_root = function (model, setter_id) {\n        logging_1.logger.debug(\"Adding root: \" + model);\n        if (indexOf.call(this._roots, model) >= 0) {\n            return;\n        }\n        this._push_all_models_freeze();\n        try {\n            this._roots.push(model);\n        }\n        finally {\n            this._pop_all_models_freeze();\n        }\n        return this._trigger_on_change(new exports.RootAddedEvent(this, model, setter_id));\n    };\n    Document.prototype.remove_root = function (model, setter_id) {\n        var i;\n        i = this._roots.indexOf(model);\n        if (i < 0) {\n            return;\n        }\n        this._push_all_models_freeze();\n        try {\n            this._roots.splice(i, 1);\n        }\n        finally {\n            this._pop_all_models_freeze();\n        }\n        return this._trigger_on_change(new exports.RootRemovedEvent(this, model, setter_id));\n    };\n    Document.prototype.title = function () {\n        return this._title;\n    };\n    Document.prototype.set_title = function (title, setter_id) {\n        if (title !== this._title) {\n            this._title = title;\n            return this._trigger_on_change(new exports.TitleChangedEvent(this, title, setter_id));\n        }\n    };\n    Document.prototype.get_model_by_id = function (model_id) {\n        if (model_id in this._all_models) {\n            return this._all_models[model_id];\n        }\n        else {\n            return null;\n        }\n    };\n    Document.prototype.get_model_by_name = function (name) {\n        return this._all_models_by_name.get_one(name, \"Multiple models are named '\" + name + \"'\");\n    };\n    Document.prototype.on_change = function (callback) {\n        if (indexOf.call(this._callbacks, callback) >= 0) {\n            return;\n        }\n        return this._callbacks.push(callback);\n    };\n    Document.prototype.remove_on_change = function (callback) {\n        var i;\n        i = this._callbacks.indexOf(callback);\n        if (i >= 0) {\n            return this._callbacks.splice(i, 1);\n        }\n    };\n    Document.prototype._trigger_on_change = function (event) {\n        var cb, j, len, ref1, results;\n        ref1 = this._callbacks;\n        results = [];\n        for (j = 0, len = ref1.length; j < len; j++) {\n            cb = ref1[j];\n            results.push(cb(event));\n        }\n        return results;\n    };\n    Document.prototype._notify_change = function (model, attr, old, new_, options) {\n        if (attr === 'name') {\n            this._all_models_by_name.remove_value(old, model);\n            if (new_ !== null) {\n                this._all_models_by_name.add_value(new_, model);\n            }\n        }\n        return this._trigger_on_change(new exports.ModelChangedEvent(this, model, attr, old, new_, options != null ? options.setter_id : void 0));\n    };\n    Document._references_json = function (references, include_defaults) {\n        var j, len, r, ref, references_json;\n        if (include_defaults == null) {\n            include_defaults = true;\n        }\n        references_json = [];\n        for (j = 0, len = references.length; j < len; j++) {\n            r = references[j];\n            ref = r.ref();\n            ref['attributes'] = r.attributes_as_json(include_defaults);\n            delete ref['attributes']['id'];\n            references_json.push(ref);\n        }\n        return references_json;\n    };\n    Document._instantiate_object = function (obj_id, obj_type, obj_attrs) {\n        var full_attrs, model;\n        full_attrs = object_1.extend({}, obj_attrs, {\n            id: obj_id\n        });\n        model = base_1.Models(obj_type);\n        return new model(full_attrs, {\n            silent: true,\n            defer_initialization: true\n        });\n    };\n    Document._instantiate_references_json = function (references_json, existing_models) {\n        var instance, j, len, obj, obj_attrs, obj_id, obj_type, references;\n        references = {};\n        for (j = 0, len = references_json.length; j < len; j++) {\n            obj = references_json[j];\n            obj_id = obj['id'];\n            obj_type = obj['type'];\n            obj_attrs = obj['attributes'];\n            if (obj_id in existing_models) {\n                instance = existing_models[obj_id];\n            }\n            else {\n                instance = Document._instantiate_object(obj_id, obj_type, obj_attrs);\n                if ('subtype' in obj) {\n                    instance.set_subtype(obj['subtype']);\n                }\n            }\n            references[instance.id] = instance;\n        }\n        return references;\n    };\n    Document._resolve_refs = function (value, old_references, new_references) {\n        var resolve_array, resolve_dict, resolve_ref;\n        resolve_ref = function (v) {\n            if (refs_1.is_ref(v)) {\n                if (v['id'] in old_references) {\n                    return old_references[v['id']];\n                }\n                else if (v['id'] in new_references) {\n                    return new_references[v['id']];\n                }\n                else {\n                    throw new Error(\"reference \" + (JSON.stringify(v)) + \" isn't known (not in Document?)\");\n                }\n            }\n            else if (types_1.isArray(v)) {\n                return resolve_array(v);\n            }\n            else if (types_1.isObject(v)) {\n                return resolve_dict(v);\n            }\n            else {\n                return v;\n            }\n        };\n        resolve_dict = function (dict) {\n            var k, resolved, v;\n            resolved = {};\n            for (k in dict) {\n                v = dict[k];\n                resolved[k] = resolve_ref(v);\n            }\n            return resolved;\n        };\n        resolve_array = function (array) {\n            var j, len, results, v;\n            results = [];\n            for (j = 0, len = array.length; j < len; j++) {\n                v = array[j];\n                results.push(resolve_ref(v));\n            }\n            return results;\n        };\n        return resolve_ref(value);\n    };\n    Document._initialize_references_json = function (references_json, old_references, new_references) {\n        var foreach_depth_first, instance, j, len, obj, obj_attrs, obj_id, to_update, was_new;\n        to_update = {};\n        for (j = 0, len = references_json.length; j < len; j++) {\n            obj = references_json[j];\n            obj_id = obj['id'];\n            obj_attrs = obj['attributes'];\n            was_new = false;\n            instance = obj_id in old_references ? old_references[obj_id] : (was_new = true, new_references[obj_id]);\n            obj_attrs = Document._resolve_refs(obj_attrs, old_references, new_references);\n            to_update[instance.id] = [instance, obj_attrs, was_new];\n        }\n        foreach_depth_first = function (items, f) {\n            var already_started, foreach_value, k, results, v;\n            already_started = {};\n            foreach_value = function (v, f) {\n                var a, attrs, e, k, l, len1, ref1, results, results1, same_as_v;\n                if (v instanceof has_props_1.HasProps) {\n                    if (!(v.id in already_started) && v.id in items) {\n                        already_started[v.id] = true;\n                        ref1 = items[v.id], same_as_v = ref1[0], attrs = ref1[1], was_new = ref1[2];\n                        for (a in attrs) {\n                            e = attrs[a];\n                            foreach_value(e, f);\n                        }\n                        return f(v, attrs, was_new);\n                    }\n                }\n                else if (types_1.isArray(v)) {\n                    results = [];\n                    for (l = 0, len1 = v.length; l < len1; l++) {\n                        e = v[l];\n                        results.push(foreach_value(e, f));\n                    }\n                    return results;\n                }\n                else if (types_1.isObject(v)) {\n                    results1 = [];\n                    for (k in v) {\n                        e = v[k];\n                        results1.push(foreach_value(e, f));\n                    }\n                    return results1;\n                }\n            };\n            results = [];\n            for (k in items) {\n                v = items[k];\n                results.push(foreach_value(v[0], f));\n            }\n            return results;\n        };\n        foreach_depth_first(to_update, function (instance, attrs, was_new) {\n            if (was_new) {\n                return instance.setv(attrs, {\n                    silent: true\n                });\n            }\n        });\n        return foreach_depth_first(to_update, function (instance, attrs, was_new) {\n            if (was_new) {\n                return instance.finalize(attrs);\n            }\n        });\n    };\n    Document._event_for_attribute_change = function (changed_obj, key, new_value, doc, value_refs) {\n        var changed_model, event;\n        changed_model = doc.get_model_by_id(changed_obj.id);\n        if (!changed_model.attribute_is_serializable(key)) {\n            return null;\n        }\n        event = {\n            'kind': 'ModelChanged',\n            'model': {\n                id: changed_obj.id,\n                type: changed_obj.type\n            },\n            'attr': key,\n            'new': new_value\n        };\n        has_props_1.HasProps._json_record_references(doc, new_value, value_refs, true);\n        return event;\n    };\n    Document._events_to_sync_objects = function (from_obj, to_obj, to_doc, value_refs) {\n        var added, events, from_keys, j, key, l, len, len1, len2, n, new_value, old_value, removed, shared, to_keys;\n        from_keys = Object.keys(from_obj.attributes);\n        to_keys = Object.keys(to_obj.attributes);\n        removed = array_1.difference(from_keys, to_keys);\n        added = array_1.difference(to_keys, from_keys);\n        shared = array_1.intersection(from_keys, to_keys);\n        events = [];\n        for (j = 0, len = removed.length; j < len; j++) {\n            key = removed[j];\n            logging_1.logger.warn(\"Server sent key \" + key + \" but we don't seem to have it in our JSON\");\n        }\n        for (l = 0, len1 = added.length; l < len1; l++) {\n            key = added[l];\n            new_value = to_obj.attributes[key];\n            events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\n        }\n        for (n = 0, len2 = shared.length; n < len2; n++) {\n            key = shared[n];\n            old_value = from_obj.attributes[key];\n            new_value = to_obj.attributes[key];\n            if (old_value === null && new_value === null) {\n            }\n            else if (old_value === null || new_value === null) {\n                events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\n            }\n            else {\n                if (!eq_1.isEqual(old_value, new_value)) {\n                    events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\n                }\n            }\n        }\n        return events.filter(function (e) {\n            return e !== null;\n        });\n    };\n    Document._compute_patch_since_json = function (from_json, to_doc) {\n        var events, from_references, from_root_ids, from_roots, id, include_defaults, j, l, len, len1, model, r, ref1, ref2, ref3, refs, to_json, to_references, to_root_ids, to_roots, update_model_events, value_refs;\n        to_json = to_doc.to_json(include_defaults = false);\n        refs = function (json) {\n            var j, len, obj, ref1, result;\n            result = {};\n            ref1 = json['roots']['references'];\n            for (j = 0, len = ref1.length; j < len; j++) {\n                obj = ref1[j];\n                result[obj.id] = obj;\n            }\n            return result;\n        };\n        from_references = refs(from_json);\n        from_roots = {};\n        from_root_ids = [];\n        ref1 = from_json['roots']['root_ids'];\n        for (j = 0, len = ref1.length; j < len; j++) {\n            r = ref1[j];\n            from_roots[r] = from_references[r];\n            from_root_ids.push(r);\n        }\n        to_references = refs(to_json);\n        to_roots = {};\n        to_root_ids = [];\n        ref2 = to_json['roots']['root_ids'];\n        for (l = 0, len1 = ref2.length; l < len1; l++) {\n            r = ref2[l];\n            to_roots[r] = to_references[r];\n            to_root_ids.push(r);\n        }\n        from_root_ids.sort();\n        to_root_ids.sort();\n        if (array_1.difference(from_root_ids, to_root_ids).length > 0 || array_1.difference(to_root_ids, from_root_ids).length > 0) {\n            throw new Error(\"Not implemented: computing add/remove of document roots\");\n        }\n        value_refs = {};\n        events = [];\n        ref3 = to_doc._all_models;\n        for (id in ref3) {\n            model = ref3[id];\n            if (id in from_references) {\n                update_model_events = Document._events_to_sync_objects(from_references[id], to_references[id], to_doc, value_refs);\n                events = events.concat(update_model_events);\n            }\n        }\n        return {\n            'events': events,\n            'references': Document._references_json(object_1.values(value_refs), include_defaults = false)\n        };\n    };\n    Document.prototype.to_json_string = function (include_defaults) {\n        if (include_defaults == null) {\n            include_defaults = true;\n        }\n        return JSON.stringify(this.to_json(include_defaults));\n    };\n    Document.prototype.to_json = function (include_defaults) {\n        var j, len, r, ref1, root_ids, root_references;\n        if (include_defaults == null) {\n            include_defaults = true;\n        }\n        root_ids = [];\n        ref1 = this._roots;\n        for (j = 0, len = ref1.length; j < len; j++) {\n            r = ref1[j];\n            root_ids.push(r.id);\n        }\n        root_references = object_1.values(this._all_models);\n        return {\n            'title': this._title,\n            'roots': {\n                'root_ids': root_ids,\n                'references': Document._references_json(root_references, include_defaults)\n            }\n        };\n    };\n    Document.from_json_string = function (s) {\n        var json;\n        if (s === null || (s == null)) {\n            throw new Error(\"JSON string is \" + (typeof s));\n        }\n        json = JSON.parse(s);\n        return Document.from_json(json);\n    };\n    Document.from_json = function (json) {\n        var doc, is_dev, j, len, py_version, r, references, references_json, root_ids, roots_json, versions_string;\n        logging_1.logger.debug(\"Creating Document from JSON\");\n        if (typeof json !== 'object') {\n            throw new Error(\"JSON object has wrong type \" + (typeof json));\n        }\n        py_version = json['version'];\n        is_dev = py_version.indexOf('+') !== -1 || py_version.indexOf('-') !== -1;\n        versions_string = \"Library versions: JS (\" + version_1.version + \")  /  Python (\" + py_version + \")\";\n        if (!is_dev && version_1.version !== py_version) {\n            logging_1.logger.warn(\"JS/Python version mismatch\");\n            logging_1.logger.warn(versions_string);\n        }\n        else {\n            logging_1.logger.debug(versions_string);\n        }\n        roots_json = json['roots'];\n        root_ids = roots_json['root_ids'];\n        references_json = roots_json['references'];\n        references = Document._instantiate_references_json(references_json, {});\n        Document._initialize_references_json(references_json, {}, references);\n        doc = new Document();\n        for (j = 0, len = root_ids.length; j < len; j++) {\n            r = root_ids[j];\n            doc.add_root(references[r]);\n        }\n        doc.set_title(json['title']);\n        return doc;\n    };\n    Document.prototype.replace_with_json = function (json) {\n        var replacement;\n        replacement = Document.from_json(json);\n        return replacement.destructively_move(this);\n    };\n    Document.prototype.create_json_patch_string = function (events) {\n        return JSON.stringify(this.create_json_patch(events));\n    };\n    Document.prototype.create_json_patch = function (events) {\n        var event, j, json_events, len, references, result;\n        references = {};\n        json_events = [];\n        for (j = 0, len = events.length; j < len; j++) {\n            event = events[j];\n            if (event.document !== this) {\n                logging_1.logger.warn(\"Cannot create a patch using events from a different document, event had \", event.document, \" we are \", this);\n                throw new Error(\"Cannot create a patch using events from a different document\");\n            }\n            json_events.push(event.json(references));\n        }\n        return result = {\n            events: json_events,\n            references: Document._references_json(object_1.values(references))\n        };\n    };\n    Document.prototype.apply_json_patch_string = function (patch) {\n        return this.apply_json_patch(JSON.parse(patch));\n    };\n    Document.prototype.apply_json_patch = function (patch, setter_id) {\n        var attr, column_source, column_source_id, data, event_json, events_json, id, j, l, len, len1, model_id, model_type, new_references, obj1, old_references, patched_id, patched_obj, patches, ref1, references, references_json, results, rollover, root_id, root_obj, shapes, value;\n        references_json = patch['references'];\n        events_json = patch['events'];\n        references = Document._instantiate_references_json(references_json, this._all_models);\n        for (j = 0, len = events_json.length; j < len; j++) {\n            event_json = events_json[j];\n            if ('model' in event_json) {\n                model_id = event_json['model']['id'];\n                if (model_id in this._all_models) {\n                    references[model_id] = this._all_models[model_id];\n                }\n                else {\n                    if (!(model_id in references)) {\n                        logging_1.logger.warn(\"Got an event for unknown model \", event_json['model']);\n                        throw new Error(\"event model wasn't known\");\n                    }\n                }\n            }\n        }\n        old_references = {};\n        new_references = {};\n        for (id in references) {\n            value = references[id];\n            if (id in this._all_models) {\n                old_references[id] = value;\n            }\n            else {\n                new_references[id] = value;\n            }\n        }\n        Document._initialize_references_json(references_json, old_references, new_references);\n        results = [];\n        for (l = 0, len1 = events_json.length; l < len1; l++) {\n            event_json = events_json[l];\n            switch (event_json.kind) {\n                case 'ModelChanged':\n                    patched_id = event_json['model']['id'];\n                    if (!(patched_id in this._all_models)) {\n                        throw new Error(\"Cannot apply patch to \" + patched_id + \" which is not in the document\");\n                    }\n                    patched_obj = this._all_models[patched_id];\n                    attr = event_json['attr'];\n                    model_type = event_json['model']['type'];\n                    if (attr === 'data' && model_type === 'ColumnDataSource') {\n                        ref1 = serialization_1.decode_column_data(event_json['new']), data = ref1[0], shapes = ref1[1];\n                        results.push(patched_obj.setv({\n                            _shapes: shapes,\n                            data: data\n                        }, {\n                            setter_id: setter_id\n                        }));\n                    }\n                    else {\n                        value = Document._resolve_refs(event_json['new'], old_references, new_references);\n                        results.push(patched_obj.setv((obj1 = {},\n                            obj1[\"\" + attr] = value,\n                            obj1), {\n                            setter_id: setter_id\n                        }));\n                    }\n                    break;\n                case 'ColumnsStreamed':\n                    column_source_id = event_json['column_source']['id'];\n                    if (!(column_source_id in this._all_models)) {\n                        throw new Error(\"Cannot stream to \" + column_source_id + \" which is not in the document\");\n                    }\n                    column_source = this._all_models[column_source_id];\n                    if (!(column_source instanceof column_data_source_1.ColumnDataSource)) {\n                        throw new Error(\"Cannot stream to non-ColumnDataSource\");\n                    }\n                    data = event_json['data'];\n                    rollover = event_json['rollover'];\n                    results.push(column_source.stream(data, rollover));\n                    break;\n                case 'ColumnsPatched':\n                    column_source_id = event_json['column_source']['id'];\n                    if (!(column_source_id in this._all_models)) {\n                        throw new Error(\"Cannot patch \" + column_source_id + \" which is not in the document\");\n                    }\n                    column_source = this._all_models[column_source_id];\n                    if (!(column_source instanceof column_data_source_1.ColumnDataSource)) {\n                        throw new Error(\"Cannot patch non-ColumnDataSource\");\n                    }\n                    patches = event_json['patches'];\n                    results.push(column_source.patch(patches));\n                    break;\n                case 'RootAdded':\n                    root_id = event_json['model']['id'];\n                    root_obj = references[root_id];\n                    results.push(this.add_root(root_obj, setter_id));\n                    break;\n                case 'RootRemoved':\n                    root_id = event_json['model']['id'];\n                    root_obj = references[root_id];\n                    results.push(this.remove_root(root_obj, setter_id));\n                    break;\n                case 'TitleChanged':\n                    results.push(this.set_title(event_json['title'], setter_id));\n                    break;\n                default:\n                    throw new Error(\"Unknown patch event \" + JSON.stringify(event_json));\n            }\n        }\n        return results;\n    };\n    return Document;\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _create_view, _get_session, _handle_notebook_comms, _init_comms, _render_document_to_element, _sessions, _update_comms_callback, add_document_from_session, add_model_from_session, add_model_static, fill_render_item_from_script_tag;\nvar base = require(\"./base\");\nvar client_1 = require(\"./client\");\nvar logging_1 = require(\"./core/logging\");\nvar document_1 = require(\"./document\");\nvar dom_1 = require(\"./core/dom\");\nexports.BOKEH_ROOT = \"bk-root\";\n_handle_notebook_comms = function (msg) {\n    var data;\n    logging_1.logger.debug(\"handling notebook comms\");\n    data = JSON.parse(msg.content.data);\n    if ('events' in data && 'references' in data) {\n        return this.apply_json_patch(data);\n    }\n    else if ('doc' in data) {\n        return this.replace_with_json(data['doc']);\n    }\n    else {\n        throw new Error(\"handling notebook comms message: \", msg);\n    }\n};\n_update_comms_callback = function (target, doc, comm) {\n    if (target === comm.target_name) {\n        return comm.on_msg(_handle_notebook_comms.bind(doc));\n    }\n};\n_init_comms = function (target, doc) {\n    var comm_manager, e, id, promise, ref, update_comms;\n    if ((typeof Jupyter !== \"undefined\" && Jupyter !== null) && (Jupyter.notebook.kernel != null)) {\n        logging_1.logger.info(\"Registering Jupyter comms for target \" + target);\n        comm_manager = Jupyter.notebook.kernel.comm_manager;\n        update_comms = function (comm) {\n            return _update_comms_callback(target, doc, comm);\n        };\n        ref = comm_manager.comms;\n        for (id in ref) {\n            promise = ref[id];\n            promise.then(update_comms);\n        }\n        try {\n            return comm_manager.register_target(target, function (comm, msg) {\n                logging_1.logger.info(\"Registering Jupyter comms for target \" + target);\n                return comm.on_msg(_handle_notebook_comms.bind(doc));\n            });\n        }\n        catch (error1) {\n            e = error1;\n            return logging_1.logger.warn(\"Jupyter comms failed to register. push_notebook() will not function. (exception reported: \" + e + \")\");\n        }\n    }\n    else {\n        return console.warn('Jupyter notebooks comms not available. push_notebook() will not function');\n    }\n};\n_create_view = function (model) {\n    var view;\n    view = new model.default_view({\n        model: model,\n        parent: null\n    });\n    base.index[model.id] = view;\n    return view;\n};\n_render_document_to_element = function (element, document, use_for_title) {\n    var i, len, model, ref, render_model, unrender_model, views;\n    views = {};\n    render_model = function (model) {\n        var view;\n        view = _create_view(model);\n        view.renderTo(element);\n        return views[model.id] = view;\n    };\n    unrender_model = function (model) {\n        var view;\n        if (model.id in views) {\n            view = views[model.id];\n            element.removeChild(view.el);\n            delete views[model.id];\n            return delete base.index[model.id];\n        }\n    };\n    ref = document.roots();\n    for (i = 0, len = ref.length; i < len; i++) {\n        model = ref[i];\n        render_model(model);\n    }\n    if (use_for_title) {\n        window.document.title = document.title();\n    }\n    document.on_change(function (event) {\n        if (event instanceof document_1.RootAddedEvent) {\n            return render_model(event.model);\n        }\n        else if (event instanceof document_1.RootRemovedEvent) {\n            return unrender_model(event.model);\n        }\n        else if (use_for_title && event instanceof document_1.TitleChangedEvent) {\n            return window.document.title = event.title;\n        }\n    });\n    return views;\n};\nadd_model_static = function (element, model_id, doc) {\n    var model, view;\n    model = doc.get_model_by_id(model_id);\n    if (model == null) {\n        throw new Error(\"Model \" + model_id + \" was not in document \" + doc);\n    }\n    view = _create_view(model);\n    return view.renderTo(element, true);\n};\nexports.add_document_static = function (element, doc, use_for_title) {\n    return _render_document_to_element(element, doc, use_for_title);\n};\nexports.add_document_standalone = function (document, element, use_for_title) {\n    if (use_for_title == null) {\n        use_for_title = false;\n    }\n    return _render_document_to_element(element, document, use_for_title);\n};\n_sessions = {};\n_get_session = function (websocket_url, session_id, args_string) {\n    var subsessions;\n    if (websocket_url == null) {\n        throw new Error(\"Missing websocket_url\");\n    }\n    if (!(websocket_url in _sessions)) {\n        _sessions[websocket_url] = {};\n    }\n    subsessions = _sessions[websocket_url];\n    if (!(session_id in subsessions)) {\n        subsessions[session_id] = client_1.pull_session(websocket_url, session_id, args_string);\n    }\n    return subsessions[session_id];\n};\nadd_document_from_session = function (element, websocket_url, session_id, use_for_title) {\n    var args_string, promise;\n    args_string = window.location.search.substr(1);\n    promise = _get_session(websocket_url, session_id, args_string);\n    return promise.then(function (session) {\n        return _render_document_to_element(element, session.document, use_for_title);\n    }, function (error) {\n        logging_1.logger.error(\"Failed to load Bokeh session \" + session_id + \": \" + error);\n        throw error;\n    });\n};\nadd_model_from_session = function (element, websocket_url, model_id, session_id) {\n    var args_string, promise;\n    args_string = window.location.search.substr(1);\n    promise = _get_session(websocket_url, session_id, args_string);\n    return promise.then(function (session) {\n        var model, view;\n        model = session.document.get_model_by_id(model_id);\n        if (model == null) {\n            throw new Error(\"Did not find model \" + model_id + \" in session\");\n        }\n        view = _create_view(model);\n        return view.renderTo(element, true);\n    }, function (error) {\n        logging_1.logger.error(\"Failed to load Bokeh session \" + session_id + \": \" + error);\n        throw error;\n    });\n};\nexports.inject_css = function (url) {\n    var element;\n    element = dom_1.link({\n        href: url,\n        rel: \"stylesheet\",\n        type: \"text/css\"\n    });\n    return document.body.appendChild(element);\n};\nexports.inject_raw_css = function (css) {\n    var element;\n    element = dom_1.style({}, css);\n    return document.body.appendChild(element);\n};\nfill_render_item_from_script_tag = function (script, item) {\n    var info;\n    info = script.dataset;\n    if ((info.bokehLogLevel != null) && info.bokehLogLevel.length > 0) {\n        logging_1.set_log_level(info.bokehLogLevel);\n    }\n    if ((info.bokehDocId != null) && info.bokehDocId.length > 0) {\n        item['docid'] = info.bokehDocId;\n    }\n    if ((info.bokehModelId != null) && info.bokehModelId.length > 0) {\n        item['modelid'] = info.bokehModelId;\n    }\n    if ((info.bokehSessionId != null) && info.bokehSessionId.length > 0) {\n        item['sessionid'] = info.bokehSessionId;\n    }\n    return logging_1.logger.info(\"Will inject Bokeh script tag with params \" + (JSON.stringify(item)));\n};\nexports.embed_items = function (docs_json, render_items, app_path, absolute_url) {\n    var child, container, docid, docs, elem, element_id, i, item, len, loc, promise, protocol, results, use_for_title, websocket_url;\n    protocol = 'ws:';\n    if (window.location.protocol === 'https:') {\n        protocol = 'wss:';\n    }\n    if (absolute_url != null) {\n        loc = new URL(absolute_url);\n    }\n    else {\n        loc = window.location;\n    }\n    if (app_path != null) {\n        if (app_path === \"/\") {\n            app_path = \"\";\n        }\n    }\n    else {\n        app_path = loc.pathname.replace(/\\/+$/, '');\n    }\n    websocket_url = protocol + '//' + loc.host + app_path + '/ws';\n    logging_1.logger.debug(\"embed: computed ws url: \" + websocket_url);\n    docs = {};\n    for (docid in docs_json) {\n        docs[docid] = document_1.Document.from_json(docs_json[docid]);\n    }\n    results = [];\n    for (i = 0, len = render_items.length; i < len; i++) {\n        item = render_items[i];\n        if (item.notebook_comms_target != null) {\n            _init_comms(item.notebook_comms_target, docs[docid]);\n        }\n        element_id = item['elementid'];\n        elem = document.getElementById(element_id);\n        if (elem == null) {\n            throw new Error(\"Error rendering Bokeh model: could not find tag with id: \" + element_id);\n        }\n        if (!document.body.contains(elem)) {\n            throw new Error(\"Error rendering Bokeh model: element with id '\" + element_id + \"' must be under <body>\");\n        }\n        if (elem.tagName === \"SCRIPT\") {\n            fill_render_item_from_script_tag(elem, item);\n            container = dom_1.div({\n                \"class\": exports.BOKEH_ROOT\n            });\n            dom_1.replaceWith(elem, container);\n            child = dom_1.div();\n            container.appendChild(child);\n            elem = child;\n        }\n        use_for_title = (item.use_for_title != null) && item.use_for_title;\n        promise = null;\n        if (item.modelid != null) {\n            if (item.docid != null) {\n                add_model_static(elem, item.modelid, docs[item.docid]);\n            }\n            else if (item.sessionid != null) {\n                promise = add_model_from_session(elem, websocket_url, item.modelid, item.sessionid);\n            }\n            else {\n                throw new Error(\"Error rendering Bokeh model \" + item['modelid'] + \" to element \" + element_id + \": no document ID or session ID specified\");\n            }\n        }\n        else {\n            if (item.docid != null) {\n                exports.add_document_static(elem, docs[item.docid], use_for_title);\n            }\n            else if (item.sessionid != null) {\n                promise = add_document_from_session(elem, websocket_url, item.sessionid, use_for_title);\n            }\n            else {\n                throw new Error(\"Error rendering Bokeh document to element \" + element_id + \": no document ID or session ID specified\");\n            }\n        }\n        if (promise !== null) {\n            results.push(promise.then(function (value) {\n                return console.log(\"Bokeh items were rendered successfully\");\n            }, function (error) {\n                return console.log(\"Error rendering Bokeh items \", error);\n            }));\n        }\n        else {\n            results.push(void 0);\n        }\n    }\n    return results;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"./polyfill\");\nvar version_1 = require(\"./version\");\nexports.version = version_1.version;\nvar embed = require(\"./embed\");\nexports.embed = embed;\nvar logging_1 = require(\"./core/logging\");\nexports.logger = logging_1.logger;\nexports.set_log_level = logging_1.set_log_level;\nvar settings_1 = require(\"./core/settings\");\nexports.settings = settings_1.settings;\nvar base_1 = require(\"./base\");\nexports.Models = base_1.Models;\nexports.index = base_1.index;\nvar document_1 = require(\"./document\");\nexports.documents = document_1.documents;\nvar safely_1 = require(\"./safely\");\nexports.safely = safely_1.safely;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar has_props_1 = require(\"./core/has_props\");\nvar p = require(\"./core/properties\");\nvar types_1 = require(\"./core/util/types\");\nvar object_1 = require(\"./core/util/object\");\nvar logging_1 = require(\"./core/logging\");\nexports.Model = (function (superClass) {\n    extend(Model, superClass);\n    function Model() {\n        return Model.__super__.constructor.apply(this, arguments);\n    }\n    Model.prototype.type = \"Model\";\n    Model.define({\n        tags: [p.Array, []],\n        name: [p.String],\n        js_property_callbacks: [p.Any, {}],\n        js_event_callbacks: [p.Any, {}],\n        subscribed_events: [p.Array, []]\n    });\n    Model.prototype.connect_signals = function () {\n        var attr, callbacks, cb, evt, i, len, ref1, ref2, ref3;\n        Model.__super__.connect_signals.call(this);\n        ref1 = this.js_property_callbacks;\n        for (evt in ref1) {\n            callbacks = ref1[evt];\n            ref2 = evt.split(':'), evt = ref2[0], attr = (ref3 = ref2[1]) != null ? ref3 : null;\n            for (i = 0, len = callbacks.length; i < len; i++) {\n                cb = callbacks[i];\n                if (attr !== null) {\n                    this.connect(this.properties[attr][evt], function () {\n                        return cb.execute(this);\n                    });\n                }\n                else {\n                    this.connect(this[evt], function () {\n                        return cb.execute(this);\n                    });\n                }\n            }\n        }\n        this.connect(this.properties.js_event_callbacks.change, function () {\n            return this._update_event_callbacks;\n        });\n        return this.connect(this.properties.subscribed_events.change, function () {\n            return this._update_event_callbacks;\n        });\n    };\n    Model.prototype._process_event = function (event) {\n        var callback, i, len, ref1, ref2;\n        if (event.is_applicable_to(this)) {\n            event = event._customize_event(this);\n            ref2 = (ref1 = this.js_event_callbacks[event.event_name]) != null ? ref1 : [];\n            for (i = 0, len = ref2.length; i < len; i++) {\n                callback = ref2[i];\n                callback.execute(event, {});\n            }\n            if (this.subscribed_events.some(function (m) {\n                return m === event.event_name;\n            })) {\n                return this.document.event_manager.send_event(event);\n            }\n        }\n    };\n    Model.prototype.trigger_event = function (event) {\n        var ref1;\n        return (ref1 = this.document) != null ? ref1.event_manager.trigger(event.set_model_id(this.id)) : void 0;\n    };\n    Model.prototype._update_event_callbacks = function () {\n        if (this.document == null) {\n            logging_1.logger.warn('WARNING: Document not defined for updating event callbacks');\n            return;\n        }\n        return this.document.event_manager.subscribed_models.push(this.id);\n    };\n    Model.prototype._doc_attached = function () {\n        if (!object_1.isEmpty(this.js_event_callbacks) || !object_1.isEmpty(this.subscribed_events)) {\n            return this._update_event_callbacks();\n        }\n    };\n    Model.prototype.select = function (selector) {\n        if (selector.prototype instanceof Model) {\n            return this.references().filter(function (ref) {\n                return ref instanceof selector;\n            });\n        }\n        else if (types_1.isString(selector)) {\n            return this.references().filter(function (ref) {\n                return ref.name === selector;\n            });\n        }\n        else {\n            throw new Error(\"invalid selector\");\n        }\n    };\n    Model.prototype.select_one = function (selector) {\n        var result;\n        result = this.select(selector);\n        switch (result.length) {\n            case 0:\n                return null;\n            case 1:\n                return result[0];\n            default:\n                throw new Error(\"found more than one object matching given selector\");\n        }\n    };\n    return Model;\n})(has_props_1.HasProps);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar side_panel_1 = require(\"core/layout/side_panel\");\nvar p = require(\"core/properties\");\nvar renderer_1 = require(\"../renderers/renderer\");\nexports.AnnotationView = (function (superClass) {\n    extend(AnnotationView, superClass);\n    function AnnotationView() {\n        return AnnotationView.__super__.constructor.apply(this, arguments);\n    }\n    AnnotationView.prototype._get_panel_offset = function () {\n        var x, y;\n        x = this.model.panel._left.value;\n        y = this.model.panel._bottom.value;\n        return {\n            x: x,\n            y: -y\n        };\n    };\n    AnnotationView.prototype._get_size = function () {\n        return -1;\n    };\n    return AnnotationView;\n})(renderer_1.RendererView);\nexports.Annotation = (function (superClass) {\n    extend(Annotation, superClass);\n    function Annotation() {\n        return Annotation.__super__.constructor.apply(this, arguments);\n    }\n    Annotation.prototype.type = 'Annotation';\n    Annotation.prototype.default_view = exports.AnnotationView;\n    Annotation.define({\n        plot: [p.Instance]\n    });\n    Annotation.override({\n        level: 'annotation'\n    });\n    Annotation.prototype.add_panel = function (side) {\n        this.panel = new side_panel_1.SidePanel({\n            side: side\n        });\n        this.panel.attach_document(this.document);\n        return this.level = 'overlay';\n    };\n    return Annotation;\n})(renderer_1.Renderer);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar arrow_head_1 = require(\"./arrow_head\");\nvar column_data_source_1 = require(\"../sources/column_data_source\");\nvar p = require(\"core/properties\");\nvar math_1 = require(\"core/util/math\");\nexports.ArrowView = (function (superClass) {\n    extend(ArrowView, superClass);\n    function ArrowView() {\n        return ArrowView.__super__.constructor.apply(this, arguments);\n    }\n    ArrowView.prototype.initialize = function (options) {\n        ArrowView.__super__.initialize.call(this, options);\n        if (this.model.source == null) {\n            this.model.source = new column_data_source_1.ColumnDataSource();\n        }\n        this.canvas = this.plot_model.canvas;\n        return this.set_data(this.model.source);\n    };\n    ArrowView.prototype.connect_signals = function () {\n        ArrowView.__super__.connect_signals.call(this);\n        this.connect(this.model.change, (function (_this) {\n            return function () {\n                return _this.plot_view.request_render();\n            };\n        })(this));\n        this.connect(this.model.source.streaming, function () {\n            return this.set_data(this.model.source);\n        });\n        this.connect(this.model.source.patching, function () {\n            return this.set_data(this.model.source);\n        });\n        return this.connect(this.model.source.change, function () {\n            return this.set_data(this.model.source);\n        });\n    };\n    ArrowView.prototype.set_data = function (source) {\n        ArrowView.__super__.set_data.call(this, source);\n        this.visuals.warm_cache(source);\n        return this.plot_view.request_render();\n    };\n    ArrowView.prototype._map_data = function () {\n        var end, start, x_name, y_name;\n        if (this.model.start_units === 'data') {\n            start = this.plot_view.map_to_screen(this._x_start, this._y_start, x_name = this.model.x_range_name, y_name = this.model.y_range_name);\n        }\n        else {\n            start = [this.canvas.v_vx_to_sx(this._x_start), this.canvas.v_vy_to_sy(this._y_start)];\n        }\n        if (this.model.end_units === 'data') {\n            end = this.plot_view.map_to_screen(this._x_end, this._y_end, x_name = this.model.x_range_name, y_name = this.model.y_range_name);\n        }\n        else {\n            end = [this.canvas.v_vx_to_sx(this._x_end), this.canvas.v_vy_to_sy(this._y_end)];\n        }\n        return [start, end];\n    };\n    ArrowView.prototype.render = function () {\n        var ctx, ref;\n        if (!this.model.visible) {\n            return;\n        }\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        ref = this._map_data(), this.start = ref[0], this.end = ref[1];\n        if (this.model.end != null) {\n            this._arrow_head(ctx, \"render\", this.model.end, this.start, this.end);\n        }\n        if (this.model.start != null) {\n            this._arrow_head(ctx, \"render\", this.model.start, this.end, this.start);\n        }\n        ctx.beginPath();\n        ctx.rect(0, 0, this.canvas._width.value, this.canvas._height.value);\n        if (this.model.end != null) {\n            this._arrow_head(ctx, \"clip\", this.model.end, this.start, this.end);\n        }\n        if (this.model.start != null) {\n            this._arrow_head(ctx, \"clip\", this.model.start, this.end, this.start);\n        }\n        ctx.closePath();\n        ctx.clip();\n        this._arrow_body(ctx);\n        return ctx.restore();\n    };\n    ArrowView.prototype._arrow_body = function (ctx) {\n        var i, j, ref, results;\n        if (!this.visuals.line.doit) {\n            return;\n        }\n        results = [];\n        for (i = j = 0, ref = this._x_start.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            this.visuals.line.set_vectorize(ctx, i);\n            ctx.beginPath();\n            ctx.moveTo(this.start[0][i], this.start[1][i]);\n            ctx.lineTo(this.end[0][i], this.end[1][i]);\n            results.push(ctx.stroke());\n        }\n        return results;\n    };\n    ArrowView.prototype._arrow_head = function (ctx, action, head, start, end) {\n        var angle, i, j, ref, results;\n        results = [];\n        for (i = j = 0, ref = this._x_start.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            angle = Math.PI / 2 + math_1.atan2([start[0][i], start[1][i]], [end[0][i], end[1][i]]);\n            ctx.save();\n            ctx.translate(end[0][i], end[1][i]);\n            ctx.rotate(angle);\n            if (action === \"render\") {\n                head.render(ctx);\n            }\n            else if (action === \"clip\") {\n                head.clip(ctx);\n            }\n            results.push(ctx.restore());\n        }\n        return results;\n    };\n    return ArrowView;\n})(annotation_1.AnnotationView);\nexports.Arrow = (function (superClass) {\n    extend(Arrow, superClass);\n    function Arrow() {\n        return Arrow.__super__.constructor.apply(this, arguments);\n    }\n    Arrow.prototype.default_view = exports.ArrowView;\n    Arrow.prototype.type = 'Arrow';\n    Arrow.mixins(['line']);\n    Arrow.define({\n        x_start: [p.NumberSpec],\n        y_start: [p.NumberSpec],\n        start_units: [p.String, 'data'],\n        start: [p.Instance, null],\n        x_end: [p.NumberSpec],\n        y_end: [p.NumberSpec],\n        end_units: [p.String, 'data'],\n        end: [p.Instance, new arrow_head_1.OpenHead({})],\n        source: [p.Instance],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default']\n    });\n    return Arrow;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar visuals_1 = require(\"core/visuals\");\nvar p = require(\"core/properties\");\nexports.ArrowHead = (function (superClass) {\n    extend(ArrowHead, superClass);\n    function ArrowHead() {\n        return ArrowHead.__super__.constructor.apply(this, arguments);\n    }\n    ArrowHead.prototype.type = 'ArrowHead';\n    ArrowHead.prototype.initialize = function (options) {\n        ArrowHead.__super__.initialize.call(this, options);\n        return this.visuals = new visuals_1.Visuals(this);\n    };\n    ArrowHead.prototype.render = function (ctx, i) {\n        return null;\n    };\n    ArrowHead.prototype.clip = function (ctx, i) {\n        return null;\n    };\n    return ArrowHead;\n})(annotation_1.Annotation);\nexports.OpenHead = (function (superClass) {\n    extend(OpenHead, superClass);\n    function OpenHead() {\n        return OpenHead.__super__.constructor.apply(this, arguments);\n    }\n    OpenHead.prototype.type = 'OpenHead';\n    OpenHead.prototype.clip = function (ctx, i) {\n        this.visuals.line.set_vectorize(ctx, i);\n        ctx.moveTo(0.5 * this.size, this.size);\n        ctx.lineTo(0.5 * this.size, -2);\n        ctx.lineTo(-0.5 * this.size, -2);\n        ctx.lineTo(-0.5 * this.size, this.size);\n        ctx.lineTo(0, 0);\n        return ctx.lineTo(0.5 * this.size, this.size);\n    };\n    OpenHead.prototype.render = function (ctx, i) {\n        if (this.visuals.line.doit) {\n            this.visuals.line.set_vectorize(ctx, i);\n            ctx.beginPath();\n            ctx.moveTo(0.5 * this.size, this.size);\n            ctx.lineTo(0, 0);\n            ctx.lineTo(-0.5 * this.size, this.size);\n            return ctx.stroke();\n        }\n    };\n    OpenHead.mixins(['line']);\n    OpenHead.define({\n        size: [p.Number, 25]\n    });\n    return OpenHead;\n})(exports.ArrowHead);\nexports.NormalHead = (function (superClass) {\n    extend(NormalHead, superClass);\n    function NormalHead() {\n        return NormalHead.__super__.constructor.apply(this, arguments);\n    }\n    NormalHead.prototype.type = 'NormalHead';\n    NormalHead.prototype.clip = function (ctx, i) {\n        this.visuals.line.set_vectorize(ctx, i);\n        ctx.moveTo(0.5 * this.size, this.size);\n        ctx.lineTo(0.5 * this.size, -2);\n        ctx.lineTo(-0.5 * this.size, -2);\n        ctx.lineTo(-0.5 * this.size, this.size);\n        return ctx.lineTo(0.5 * this.size, this.size);\n    };\n    NormalHead.prototype.render = function (ctx, i) {\n        if (this.visuals.fill.doit) {\n            this.visuals.fill.set_vectorize(ctx, i);\n            this._normal(ctx, i);\n            ctx.fill();\n        }\n        if (this.visuals.line.doit) {\n            this.visuals.line.set_vectorize(ctx, i);\n            this._normal(ctx, i);\n            return ctx.stroke();\n        }\n    };\n    NormalHead.prototype._normal = function (ctx, i) {\n        ctx.beginPath();\n        ctx.moveTo(0.5 * this.size, this.size);\n        ctx.lineTo(0, 0);\n        ctx.lineTo(-0.5 * this.size, this.size);\n        return ctx.closePath();\n    };\n    NormalHead.mixins(['line', 'fill']);\n    NormalHead.define({\n        size: [p.Number, 25]\n    });\n    NormalHead.override({\n        fill_color: 'black'\n    });\n    return NormalHead;\n})(exports.ArrowHead);\nexports.VeeHead = (function (superClass) {\n    extend(VeeHead, superClass);\n    function VeeHead() {\n        return VeeHead.__super__.constructor.apply(this, arguments);\n    }\n    VeeHead.prototype.type = 'VeeHead';\n    VeeHead.prototype.clip = function (ctx, i) {\n        this.visuals.line.set_vectorize(ctx, i);\n        ctx.moveTo(0.5 * this.size, this.size);\n        ctx.lineTo(0.5 * this.size, -2);\n        ctx.lineTo(-0.5 * this.size, -2);\n        ctx.lineTo(-0.5 * this.size, this.size);\n        ctx.lineTo(0, 0.5 * this.size);\n        return ctx.lineTo(0.5 * this.size, this.size);\n    };\n    VeeHead.prototype.render = function (ctx, i) {\n        if (this.visuals.fill.doit) {\n            this.visuals.fill.set_vectorize(ctx, i);\n            this._vee(ctx, i);\n            ctx.fill();\n        }\n        if (this.visuals.line.doit) {\n            this.visuals.line.set_vectorize(ctx, i);\n            this._vee(ctx, i);\n            return ctx.stroke();\n        }\n    };\n    VeeHead.prototype._vee = function (ctx, i) {\n        ctx.beginPath();\n        ctx.moveTo(0.5 * this.size, this.size);\n        ctx.lineTo(0, 0);\n        ctx.lineTo(-0.5 * this.size, this.size);\n        ctx.lineTo(0, 0.5 * this.size);\n        return ctx.closePath();\n    };\n    VeeHead.mixins(['line', 'fill']);\n    VeeHead.define({\n        size: [p.Number, 25]\n    });\n    VeeHead.override({\n        fill_color: 'black'\n    });\n    return VeeHead;\n})(exports.ArrowHead);\nexports.TeeHead = (function (superClass) {\n    extend(TeeHead, superClass);\n    function TeeHead() {\n        return TeeHead.__super__.constructor.apply(this, arguments);\n    }\n    TeeHead.prototype.type = 'TeeHead';\n    TeeHead.prototype.render = function (ctx, i) {\n        if (this.visuals.line.doit) {\n            this.visuals.line.set_vectorize(ctx, i);\n            ctx.beginPath();\n            ctx.moveTo(0.5 * this.size, 0);\n            ctx.lineTo(-0.5 * this.size, 0);\n            return ctx.stroke();\n        }\n    };\n    TeeHead.mixins(['line']);\n    TeeHead.define({\n        size: [p.Number, 25]\n    });\n    return TeeHead;\n})(exports.ArrowHead);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar column_data_source_1 = require(\"../sources/column_data_source\");\nvar p = require(\"core/properties\");\nexports.BandView = (function (superClass) {\n    extend(BandView, superClass);\n    function BandView() {\n        return BandView.__super__.constructor.apply(this, arguments);\n    }\n    BandView.prototype.initialize = function (options) {\n        BandView.__super__.initialize.call(this, options);\n        return this.set_data(this.model.source);\n    };\n    BandView.prototype.connect_signals = function () {\n        BandView.__super__.connect_signals.call(this);\n        this.connect(this.model.source.streaming, function () {\n            return this.set_data(this.model.source);\n        });\n        this.connect(this.model.source.patching, function () {\n            return this.set_data(this.model.source);\n        });\n        return this.connect(this.model.source.change, function () {\n            return this.set_data(this.model.source);\n        });\n    };\n    BandView.prototype.set_data = function (source) {\n        BandView.__super__.set_data.call(this, source);\n        this.visuals.warm_cache(source);\n        return this.plot_view.request_render();\n    };\n    BandView.prototype._map_data = function () {\n        var _base_vx, _lower, _lower_vx, _upper, _upper_vx, base_scale, i, j, limit_scale, ref, x_scale, y_scale;\n        x_scale = this.plot_view.frame.xscales[this.model.x_range_name];\n        y_scale = this.plot_view.frame.yscales[this.model.y_range_name];\n        limit_scale = this.model.dimension === \"height\" ? y_scale : x_scale;\n        base_scale = this.model.dimension === \"height\" ? x_scale : y_scale;\n        if (this.model.lower.units === \"data\") {\n            _lower_vx = limit_scale.v_compute(this._lower);\n        }\n        else {\n            _lower_vx = this._lower;\n        }\n        if (this.model.upper.units === \"data\") {\n            _upper_vx = limit_scale.v_compute(this._upper);\n        }\n        else {\n            _upper_vx = this._upper;\n        }\n        if (this.model.base.units === \"data\") {\n            _base_vx = base_scale.v_compute(this._base);\n        }\n        else {\n            _base_vx = this._base;\n        }\n        ref = this.model._normals(), i = ref[0], j = ref[1];\n        _lower = [_lower_vx, _base_vx];\n        _upper = [_upper_vx, _base_vx];\n        this._lower_sx = this.plot_model.canvas.v_vx_to_sx(_lower[i]);\n        this._lower_sy = this.plot_model.canvas.v_vy_to_sy(_lower[j]);\n        this._upper_sx = this.plot_model.canvas.v_vx_to_sx(_upper[i]);\n        return this._upper_sy = this.plot_model.canvas.v_vy_to_sy(_upper[j]);\n    };\n    BandView.prototype.render = function () {\n        var ctx, i, k, l, m, n, ref, ref1, ref2, ref3;\n        if (!this.model.visible) {\n            return;\n        }\n        this._map_data();\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.beginPath();\n        ctx.moveTo(this._lower_sx[0], this._lower_sy[0]);\n        for (i = k = 0, ref = this._lower_sx.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            ctx.lineTo(this._lower_sx[i], this._lower_sy[i]);\n        }\n        for (i = l = ref1 = this._upper_sx.length - 1; ref1 <= 0 ? l <= 0 : l >= 0; i = ref1 <= 0 ? ++l : --l) {\n            ctx.lineTo(this._upper_sx[i], this._upper_sy[i]);\n        }\n        ctx.closePath();\n        if (this.visuals.fill.doit) {\n            this.visuals.fill.set_value(ctx);\n            ctx.fill();\n        }\n        ctx.beginPath();\n        ctx.moveTo(this._lower_sx[0], this._lower_sy[0]);\n        for (i = m = 0, ref2 = this._lower_sx.length; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {\n            ctx.lineTo(this._lower_sx[i], this._lower_sy[i]);\n        }\n        if (this.visuals.line.doit) {\n            this.visuals.line.set_value(ctx);\n            ctx.stroke();\n        }\n        ctx.beginPath();\n        ctx.moveTo(this._upper_sx[0], this._upper_sy[0]);\n        for (i = n = 0, ref3 = this._upper_sx.length; 0 <= ref3 ? n < ref3 : n > ref3; i = 0 <= ref3 ? ++n : --n) {\n            ctx.lineTo(this._upper_sx[i], this._upper_sy[i]);\n        }\n        if (this.visuals.line.doit) {\n            this.visuals.line.set_value(ctx);\n            return ctx.stroke();\n        }\n    };\n    return BandView;\n})(annotation_1.AnnotationView);\nexports.Band = (function (superClass) {\n    extend(Band, superClass);\n    function Band() {\n        return Band.__super__.constructor.apply(this, arguments);\n    }\n    Band.prototype.default_view = exports.BandView;\n    Band.prototype.type = 'Band';\n    Band.mixins(['line', 'fill']);\n    Band.define({\n        lower: [p.DistanceSpec],\n        upper: [p.DistanceSpec],\n        base: [p.DistanceSpec],\n        dimension: [p.Dimension, 'height'],\n        source: [\n            p.Instance, function () {\n                return new column_data_source_1.ColumnDataSource();\n            }\n        ],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default']\n    });\n    Band.override({\n        fill_color: \"#fff9ba\",\n        fill_alpha: 0.4,\n        line_color: \"#cccccc\",\n        line_alpha: 0.3\n    });\n    Band.prototype._normals = function () {\n        var i, j, ref, ref1;\n        if (this.dimension === 'height') {\n            ref = [1, 0], i = ref[0], j = ref[1];\n        }\n        else {\n            ref1 = [0, 1], i = ref1[0], j = ref1[1];\n        }\n        return [i, j];\n    };\n    return Band;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar signaling_1 = require(\"core/signaling\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.BoxAnnotationView = (function (superClass) {\n    extend(BoxAnnotationView, superClass);\n    function BoxAnnotationView() {\n        return BoxAnnotationView.__super__.constructor.apply(this, arguments);\n    }\n    BoxAnnotationView.prototype.initialize = function (options) {\n        BoxAnnotationView.__super__.initialize.call(this, options);\n        this.plot_view.canvas_overlays.appendChild(this.el);\n        this.el.classList.add(\"bk-shading\");\n        return dom_1.hide(this.el);\n    };\n    BoxAnnotationView.prototype.connect_signals = function () {\n        BoxAnnotationView.__super__.connect_signals.call(this);\n        if (this.model.render_mode === 'css') {\n            this.connect(this.model.change, function () {\n                return this.render();\n            });\n            return this.connect(this.model.data_update, function () {\n                return this.render();\n            });\n        }\n        else {\n            this.connect(this.model.change, (function (_this) {\n                return function () {\n                    return _this.plot_view.request_render();\n                };\n            })(this));\n            return this.connect(this.model.data_update, (function (_this) {\n                return function () {\n                    return _this.plot_view.request_render();\n                };\n            })(this));\n        }\n    };\n    BoxAnnotationView.prototype.render = function () {\n        var canvas, frame, sbottom, sleft, sright, stop, xscale, yscale;\n        if (!this.model.visible && this.model.render_mode === 'css') {\n            dom_1.hide(this.el);\n        }\n        if (!this.model.visible) {\n            return;\n        }\n        if ((this.model.left == null) && (this.model.right == null) && (this.model.top == null) && (this.model.bottom == null)) {\n            dom_1.hide(this.el);\n            return null;\n        }\n        frame = this.plot_model.frame;\n        canvas = this.plot_model.canvas;\n        xscale = this.plot_view.frame.xscales[this.model.x_range_name];\n        yscale = this.plot_view.frame.yscales[this.model.y_range_name];\n        sleft = canvas.vx_to_sx(this._calc_dim(this.model.left, this.model.left_units, xscale, frame.h_range.start));\n        sright = canvas.vx_to_sx(this._calc_dim(this.model.right, this.model.right_units, xscale, frame.h_range.end));\n        sbottom = canvas.vy_to_sy(this._calc_dim(this.model.bottom, this.model.bottom_units, yscale, frame.v_range.start));\n        stop = canvas.vy_to_sy(this._calc_dim(this.model.top, this.model.top_units, yscale, frame.v_range.end));\n        if (this.model.render_mode === 'css') {\n            return this._css_box(sleft, sright, sbottom, stop);\n        }\n        else {\n            return this._canvas_box(sleft, sright, sbottom, stop);\n        }\n    };\n    BoxAnnotationView.prototype._css_box = function (sleft, sright, sbottom, stop) {\n        var ld, sh, sw;\n        sw = Math.abs(sright - sleft);\n        sh = Math.abs(sbottom - stop);\n        this.el.style.left = sleft + \"px\";\n        this.el.style.width = sw + \"px\";\n        this.el.style.top = stop + \"px\";\n        this.el.style.height = sh + \"px\";\n        this.el.style.borderWidth = this.model.line_width.value + \"px\";\n        this.el.style.borderColor = this.model.line_color.value;\n        this.el.style.backgroundColor = this.model.fill_color.value;\n        this.el.style.opacity = this.model.fill_alpha.value;\n        ld = this.model.line_dash;\n        if (types_1.isArray(ld)) {\n            ld = ld.length < 2 ? \"solid\" : \"dashed\";\n        }\n        if (types_1.isString(ld)) {\n            this.el.style.borderStyle = ld;\n        }\n        return dom_1.show(this.el);\n    };\n    BoxAnnotationView.prototype._canvas_box = function (sleft, sright, sbottom, stop) {\n        var ctx;\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(sleft, stop, sright - sleft, sbottom - stop);\n        this.visuals.fill.set_value(ctx);\n        ctx.fill();\n        this.visuals.line.set_value(ctx);\n        ctx.stroke();\n        return ctx.restore();\n    };\n    BoxAnnotationView.prototype._calc_dim = function (dim, dim_units, scale, frame_extrema) {\n        var vdim;\n        if (dim != null) {\n            if (dim_units === 'data') {\n                vdim = scale.compute(dim);\n            }\n            else {\n                vdim = dim;\n            }\n        }\n        else {\n            vdim = frame_extrema;\n        }\n        return vdim;\n    };\n    return BoxAnnotationView;\n})(annotation_1.AnnotationView);\nexports.BoxAnnotation = (function (superClass) {\n    extend(BoxAnnotation, superClass);\n    function BoxAnnotation() {\n        return BoxAnnotation.__super__.constructor.apply(this, arguments);\n    }\n    BoxAnnotation.prototype.default_view = exports.BoxAnnotationView;\n    BoxAnnotation.prototype.type = 'BoxAnnotation';\n    BoxAnnotation.mixins(['line', 'fill']);\n    BoxAnnotation.define({\n        render_mode: [p.RenderMode, 'canvas'],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default'],\n        top: [p.Number, null],\n        top_units: [p.SpatialUnits, 'data'],\n        bottom: [p.Number, null],\n        bottom_units: [p.SpatialUnits, 'data'],\n        left: [p.Number, null],\n        left_units: [p.SpatialUnits, 'data'],\n        right: [p.Number, null],\n        right_units: [p.SpatialUnits, 'data']\n    });\n    BoxAnnotation.override({\n        fill_color: '#fff9ba',\n        fill_alpha: 0.4,\n        line_color: '#cccccc',\n        line_alpha: 0.3\n    });\n    BoxAnnotation.prototype.initialize = function (attrs, options) {\n        BoxAnnotation.__super__.initialize.call(this, attrs, options);\n        return this.data_update = new signaling_1.Signal(this, \"data_update\");\n    };\n    BoxAnnotation.prototype.update = function (arg) {\n        var bottom, left, right, top;\n        left = arg.left, right = arg.right, top = arg.top, bottom = arg.bottom;\n        this.setv({\n            left: left,\n            right: right,\n            top: top,\n            bottom: bottom\n        }, {\n            silent: true\n        });\n        return this.data_update.emit();\n    };\n    return BoxAnnotation;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar LONG_DIM_MAX_SCALAR, LONG_DIM_MIN_SCALAR, SHORT_DIM, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar basic_ticker_1 = require(\"../tickers/basic_ticker\");\nvar basic_tick_formatter_1 = require(\"../formatters/basic_tick_formatter\");\nvar linear_color_mapper_1 = require(\"../mappers/linear_color_mapper\");\nvar linear_scale_1 = require(\"../scales/linear_scale\");\nvar log_scale_1 = require(\"../scales/log_scale\");\nvar range1d_1 = require(\"../ranges/range1d\");\nvar p = require(\"core/properties\");\nvar text_util = require(\"core/util/text\");\nvar array_1 = require(\"core/util/array\");\nvar object_1 = require(\"core/util/object\");\nvar types_1 = require(\"core/util/types\");\nSHORT_DIM = 25;\nLONG_DIM_MIN_SCALAR = 0.3;\nLONG_DIM_MAX_SCALAR = 0.8;\nexports.ColorBarView = (function (superClass) {\n    extend(ColorBarView, superClass);\n    function ColorBarView() {\n        return ColorBarView.__super__.constructor.apply(this, arguments);\n    }\n    ColorBarView.prototype.initialize = function (options) {\n        ColorBarView.__super__.initialize.call(this, options);\n        return this._set_canvas_image();\n    };\n    ColorBarView.prototype.connect_signals = function () {\n        ColorBarView.__super__.connect_signals.call(this);\n        this.connect(this.model.properties.visible.change, (function (_this) {\n            return function () {\n                return _this.plot_view.request_render();\n            };\n        })(this));\n        this.connect(this.model.ticker.change, (function (_this) {\n            return function () {\n                return _this.plot_view.request_render();\n            };\n        })(this));\n        this.connect(this.model.formatter.change, (function (_this) {\n            return function () {\n                return _this.plot_view.request_render();\n            };\n        })(this));\n        if (this.model.color_mapper != null) {\n            return this.connect(this.model.color_mapper.change, function () {\n                this._set_canvas_image();\n                return this.plot_view.request_render();\n            });\n        }\n    };\n    ColorBarView.prototype._get_panel_offset = function () {\n        var x, y;\n        x = this.model.panel._left.value;\n        y = this.model.panel._top.value;\n        return {\n            x: x,\n            y: -y\n        };\n    };\n    ColorBarView.prototype._get_size = function () {\n        var bbox, side;\n        if (this.model.color_mapper == null) {\n            return;\n        }\n        bbox = this.compute_legend_dimensions();\n        side = this.model.panel.side;\n        if (side === 'above' || side === 'below') {\n            return bbox.height;\n        }\n        if (side === 'left' || side === 'right') {\n            return bbox.width;\n        }\n    };\n    ColorBarView.prototype._set_canvas_image = function () {\n        var buf, buf8, canvas, cmap, h, image_ctx, image_data, k, palette, ref, ref1, ref2, ref3, results, w;\n        if (this.model.color_mapper == null) {\n            return;\n        }\n        palette = this.model.color_mapper.palette;\n        if (this.model.orientation === 'vertical') {\n            palette = palette.slice(0).reverse();\n        }\n        switch (this.model.orientation) {\n            case \"vertical\":\n                ref = [1, palette.length], w = ref[0], h = ref[1];\n                break;\n            case \"horizontal\":\n                ref1 = [palette.length, 1], w = ref1[0], h = ref1[1];\n        }\n        canvas = document.createElement('canvas');\n        ref2 = [w, h], canvas.width = ref2[0], canvas.height = ref2[1];\n        image_ctx = canvas.getContext('2d');\n        image_data = image_ctx.getImageData(0, 0, w, h);\n        cmap = new linear_color_mapper_1.LinearColorMapper({\n            palette: palette\n        });\n        buf = cmap.v_map_screen((function () {\n            results = [];\n            for (var k = 0, ref3 = palette.length; 0 <= ref3 ? k < ref3 : k > ref3; 0 <= ref3 ? k++ : k--) {\n                results.push(k);\n            }\n            return results;\n        }).apply(this));\n        buf8 = new Uint8Array(buf);\n        image_data.data.set(buf8);\n        image_ctx.putImageData(image_data, 0, 0);\n        return this.image = canvas;\n    };\n    ColorBarView.prototype.compute_legend_dimensions = function () {\n        var image_dimensions, image_height, image_width, label_extent, legend_height, legend_width, padding, ref, tick_extent, title_extent;\n        image_dimensions = this.model._computed_image_dimensions();\n        ref = [image_dimensions.height, image_dimensions.width], image_height = ref[0], image_width = ref[1];\n        label_extent = this._get_label_extent();\n        title_extent = this.model._title_extent();\n        tick_extent = this.model._tick_extent();\n        padding = this.model.padding;\n        switch (this.model.orientation) {\n            case \"vertical\":\n                legend_height = image_height + title_extent + padding * 2;\n                legend_width = image_width + tick_extent + label_extent + padding * 2;\n                break;\n            case \"horizontal\":\n                legend_height = image_height + title_extent + tick_extent + label_extent + padding * 2;\n                legend_width = image_width + padding * 2;\n        }\n        return {\n            height: legend_height,\n            width: legend_width\n        };\n    };\n    ColorBarView.prototype.compute_legend_location = function () {\n        var h_range, legend_dimensions, legend_height, legend_margin, legend_width, location, ref, sx, sy, v_range, x, y;\n        legend_dimensions = this.compute_legend_dimensions();\n        ref = [legend_dimensions.height, legend_dimensions.width], legend_height = ref[0], legend_width = ref[1];\n        legend_margin = this.model.margin;\n        location = this.model.location;\n        h_range = this.plot_view.frame.h_range;\n        v_range = this.plot_view.frame.v_range;\n        if (types_1.isString(location)) {\n            switch (location) {\n                case 'top_left':\n                    x = h_range.start + legend_margin;\n                    y = v_range.end - legend_margin;\n                    break;\n                case 'top_center':\n                    x = (h_range.end + h_range.start) / 2 - legend_width / 2;\n                    y = v_range.end - legend_margin;\n                    break;\n                case 'top_right':\n                    x = h_range.end - legend_margin - legend_width;\n                    y = v_range.end - legend_margin;\n                    break;\n                case 'center_right':\n                    x = h_range.end - legend_margin - legend_width;\n                    y = (v_range.end + v_range.start) / 2 + legend_height / 2;\n                    break;\n                case 'bottom_right':\n                    x = h_range.end - legend_margin - legend_width;\n                    y = v_range.start + legend_margin + legend_height;\n                    break;\n                case 'bottom_center':\n                    x = (h_range.end + h_range.start) / 2 - legend_width / 2;\n                    y = v_range.start + legend_margin + legend_height;\n                    break;\n                case 'bottom_left':\n                    x = h_range.start + legend_margin;\n                    y = v_range.start + legend_margin + legend_height;\n                    break;\n                case 'center_left':\n                    x = h_range.start + legend_margin;\n                    y = (v_range.end + v_range.start) / 2 + legend_height / 2;\n                    break;\n                case 'center':\n                    x = (h_range.end + h_range.start) / 2 - legend_width / 2;\n                    y = (v_range.end + v_range.start) / 2 + legend_height / 2;\n            }\n        }\n        else if (types_1.isArray(location) && location.length === 2) {\n            x = location[0], y = location[1];\n        }\n        sx = this.plot_view.canvas.vx_to_sx(x);\n        sy = this.plot_view.canvas.vy_to_sy(y);\n        return {\n            sx: sx,\n            sy: sy\n        };\n    };\n    ColorBarView.prototype.render = function () {\n        var ctx, frame_offset, image_offset, location, panel_offset;\n        if (!this.model.visible || (this.model.color_mapper == null)) {\n            return;\n        }\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        if (this.model.panel != null) {\n            panel_offset = this._get_panel_offset();\n            ctx.translate(panel_offset.x, panel_offset.y);\n            frame_offset = this._get_frame_offset();\n            ctx.translate(frame_offset.x, frame_offset.y);\n        }\n        location = this.compute_legend_location();\n        ctx.translate(location.sx, location.sy);\n        this._draw_bbox(ctx);\n        image_offset = this._get_image_offset();\n        ctx.translate(image_offset.x, image_offset.y);\n        this._draw_image(ctx);\n        if ((this.model.color_mapper.low != null) && (this.model.color_mapper.high != null)) {\n            this._draw_major_ticks(ctx);\n            this._draw_minor_ticks(ctx);\n            this._draw_major_labels(ctx);\n        }\n        if (this.model.title) {\n            this._draw_title(ctx);\n        }\n        return ctx.restore();\n    };\n    ColorBarView.prototype._draw_bbox = function (ctx) {\n        var bbox;\n        bbox = this.compute_legend_dimensions();\n        ctx.save();\n        if (this.visuals.background_fill.doit) {\n            this.visuals.background_fill.set_value(ctx);\n            ctx.fillRect(0, 0, bbox.width, bbox.height);\n        }\n        if (this.visuals.border_line.doit) {\n            this.visuals.border_line.set_value(ctx);\n            ctx.strokeRect(0, 0, bbox.width, bbox.height);\n        }\n        return ctx.restore();\n    };\n    ColorBarView.prototype._draw_image = function (ctx) {\n        var image;\n        image = this.model._computed_image_dimensions();\n        ctx.save();\n        ctx.setImageSmoothingEnabled(false);\n        ctx.globalAlpha = this.model.scale_alpha;\n        ctx.drawImage(this.image, 0, 0, image.width, image.height);\n        if (this.visuals.bar_line.doit) {\n            this.visuals.bar_line.set_value(ctx);\n            ctx.strokeRect(0, 0, image.width, image.height);\n        }\n        return ctx.restore();\n    };\n    ColorBarView.prototype._draw_major_ticks = function (ctx) {\n        var i, image, k, nx, ny, ref, ref1, ref2, ref3, sx, sy, tin, tout, x_offset, y_offset;\n        if (!this.visuals.major_tick_line.doit) {\n            return;\n        }\n        ref = this.model._normals(), nx = ref[0], ny = ref[1];\n        image = this.model._computed_image_dimensions();\n        ref1 = [image.width * nx, image.height * ny], x_offset = ref1[0], y_offset = ref1[1];\n        ref2 = this.model._tick_coordinates().major, sx = ref2[0], sy = ref2[1];\n        tin = this.model.major_tick_in;\n        tout = this.model.major_tick_out;\n        ctx.save();\n        ctx.translate(x_offset, y_offset);\n        this.visuals.major_tick_line.set_value(ctx);\n        for (i = k = 0, ref3 = sx.length; 0 <= ref3 ? k < ref3 : k > ref3; i = 0 <= ref3 ? ++k : --k) {\n            ctx.beginPath();\n            ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));\n            ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));\n            ctx.stroke();\n        }\n        return ctx.restore();\n    };\n    ColorBarView.prototype._draw_minor_ticks = function (ctx) {\n        var i, image, k, nx, ny, ref, ref1, ref2, ref3, sx, sy, tin, tout, x_offset, y_offset;\n        if (!this.visuals.minor_tick_line.doit) {\n            return;\n        }\n        ref = this.model._normals(), nx = ref[0], ny = ref[1];\n        image = this.model._computed_image_dimensions();\n        ref1 = [image.width * nx, image.height * ny], x_offset = ref1[0], y_offset = ref1[1];\n        ref2 = this.model._tick_coordinates().minor, sx = ref2[0], sy = ref2[1];\n        tin = this.model.minor_tick_in;\n        tout = this.model.minor_tick_out;\n        ctx.save();\n        ctx.translate(x_offset, y_offset);\n        this.visuals.minor_tick_line.set_value(ctx);\n        for (i = k = 0, ref3 = sx.length; 0 <= ref3 ? k < ref3 : k > ref3; i = 0 <= ref3 ? ++k : --k) {\n            ctx.beginPath();\n            ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));\n            ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));\n            ctx.stroke();\n        }\n        return ctx.restore();\n    };\n    ColorBarView.prototype._draw_major_labels = function (ctx) {\n        var formatted_labels, i, image, k, labels, nx, ny, ref, ref1, ref2, ref3, ref4, standoff, sx, sy, x_offset, x_standoff, y_offset, y_standoff;\n        if (!this.visuals.major_label_text.doit) {\n            return;\n        }\n        ref = this.model._normals(), nx = ref[0], ny = ref[1];\n        image = this.model._computed_image_dimensions();\n        ref1 = [image.width * nx, image.height * ny], x_offset = ref1[0], y_offset = ref1[1];\n        standoff = this.model.label_standoff + this.model._tick_extent();\n        ref2 = [standoff * nx, standoff * ny], x_standoff = ref2[0], y_standoff = ref2[1];\n        ref3 = this.model._tick_coordinates().major, sx = ref3[0], sy = ref3[1];\n        labels = this.model._tick_coordinates().major_labels;\n        formatted_labels = this.model.formatter.doFormat(labels, null);\n        this.visuals.major_label_text.set_value(ctx);\n        ctx.save();\n        ctx.translate(x_offset + x_standoff, y_offset + y_standoff);\n        for (i = k = 0, ref4 = sx.length; 0 <= ref4 ? k < ref4 : k > ref4; i = 0 <= ref4 ? ++k : --k) {\n            ctx.fillText(formatted_labels[i], Math.round(sx[i] + nx * this.model.label_standoff), Math.round(sy[i] + ny * this.model.label_standoff));\n        }\n        return ctx.restore();\n    };\n    ColorBarView.prototype._draw_title = function (ctx) {\n        if (!this.visuals.title_text.doit) {\n            return;\n        }\n        ctx.save();\n        this.visuals.title_text.set_value(ctx);\n        ctx.fillText(this.model.title, 0, -this.model.title_standoff);\n        return ctx.restore();\n    };\n    ColorBarView.prototype._get_label_extent = function () {\n        var ctx, formatted_labels, label, label_extent, major_labels;\n        major_labels = this.model._tick_coordinates().major_labels;\n        if ((this.model.color_mapper.low != null) && (this.model.color_mapper.high != null) && !object_1.isEmpty(major_labels)) {\n            ctx = this.plot_view.canvas_view.ctx;\n            ctx.save();\n            this.visuals.major_label_text.set_value(ctx);\n            switch (this.model.orientation) {\n                case \"vertical\":\n                    formatted_labels = this.model.formatter.doFormat(major_labels);\n                    label_extent = array_1.max((function () {\n                        var k, len, results;\n                        results = [];\n                        for (k = 0, len = formatted_labels.length; k < len; k++) {\n                            label = formatted_labels[k];\n                            results.push(ctx.measureText(label.toString()).width);\n                        }\n                        return results;\n                    })());\n                    break;\n                case \"horizontal\":\n                    label_extent = text_util.get_text_height(this.visuals.major_label_text.font_value()).height;\n            }\n            label_extent += this.model.label_standoff;\n            ctx.restore();\n        }\n        else {\n            label_extent = 0;\n        }\n        return label_extent;\n    };\n    ColorBarView.prototype._get_frame_offset = function () {\n        var frame, panel, ref, xoff, yoff;\n        ref = [0, 0], xoff = ref[0], yoff = ref[1];\n        panel = this.model.panel;\n        frame = this.plot_view.frame;\n        switch (panel.side) {\n            case \"left\":\n            case \"right\":\n                yoff = Math.abs(panel._top.value - frame._top.value);\n                break;\n            case \"above\":\n            case \"below\":\n                xoff = Math.abs(frame._left.value);\n        }\n        return {\n            x: xoff,\n            y: yoff\n        };\n    };\n    ColorBarView.prototype._get_image_offset = function () {\n        var x, y;\n        x = this.model.padding;\n        y = this.model.padding + this.model._title_extent();\n        return {\n            x: x,\n            y: y\n        };\n    };\n    return ColorBarView;\n})(annotation_1.AnnotationView);\nexports.ColorBar = (function (superClass) {\n    extend(ColorBar, superClass);\n    function ColorBar() {\n        return ColorBar.__super__.constructor.apply(this, arguments);\n    }\n    ColorBar.prototype.default_view = exports.ColorBarView;\n    ColorBar.prototype.type = 'ColorBar';\n    ColorBar.mixins(['text:major_label_', 'text:title_', 'line:major_tick_', 'line:minor_tick_', 'line:border_', 'line:bar_', 'fill:background_']);\n    ColorBar.define({\n        location: [p.Any, 'top_right'],\n        orientation: [p.Orientation, 'vertical'],\n        title: [p.String],\n        title_standoff: [p.Number, 2],\n        height: [p.Any, 'auto'],\n        width: [p.Any, 'auto'],\n        scale_alpha: [p.Number, 1.0],\n        ticker: [\n            p.Instance, function () {\n                return new basic_ticker_1.BasicTicker();\n            }\n        ],\n        formatter: [\n            p.Instance, function () {\n                return new basic_tick_formatter_1.BasicTickFormatter();\n            }\n        ],\n        color_mapper: [p.Instance],\n        label_standoff: [p.Number, 5],\n        margin: [p.Number, 30],\n        padding: [p.Number, 10],\n        major_tick_in: [p.Number, 5],\n        major_tick_out: [p.Number, 0],\n        minor_tick_in: [p.Number, 0],\n        minor_tick_out: [p.Number, 0]\n    });\n    ColorBar.override({\n        background_fill_color: \"#ffffff\",\n        background_fill_alpha: 0.95,\n        bar_line_color: null,\n        border_line_color: null,\n        major_label_text_align: \"center\",\n        major_label_text_baseline: \"middle\",\n        major_label_text_font_size: \"8pt\",\n        major_tick_line_color: \"#ffffff\",\n        minor_tick_line_color: null,\n        title_text_font_size: \"10pt\",\n        title_text_font_style: \"italic\"\n    });\n    ColorBar.prototype.initialize = function (attrs, options) {\n        return ColorBar.__super__.initialize.call(this, attrs, options);\n    };\n    ColorBar.prototype._normals = function () {\n        var i, j, ref, ref1;\n        if (this.orientation === 'vertical') {\n            ref = [1, 0], i = ref[0], j = ref[1];\n        }\n        else {\n            ref1 = [0, 1], i = ref1[0], j = ref1[1];\n        }\n        return [i, j];\n    };\n    ColorBar.prototype._title_extent = function () {\n        var font_value, title_extent;\n        font_value = this.title_text_font + \" \" + this.title_text_font_size + \" \" + this.title_text_font_style;\n        title_extent = this.title ? text_util.get_text_height(font_value).height + this.title_standoff : 0;\n        return title_extent;\n    };\n    ColorBar.prototype._tick_extent = function () {\n        var tick_extent;\n        if ((this.color_mapper.low != null) && (this.color_mapper.high != null)) {\n            tick_extent = array_1.max([this.major_tick_out, this.minor_tick_out]);\n        }\n        else {\n            tick_extent = 0;\n        }\n        return tick_extent;\n    };\n    ColorBar.prototype._computed_image_dimensions = function () {\n        /*\n        Heuristics to determine ColorBar image dimensions if set to \"auto\"\n        \n        Note: Returns the height/width values for the ColorBar's scale image, not\n        the dimensions of the entire ColorBar.\n        \n        If the short dimension (the width of a vertical bar or height of a\n        horizontal bar) is set to \"auto\", the resulting dimension will be set to\n        25 px.\n        \n        For a ColorBar in a side panel with the long dimension (the height of a\n        vertical bar or width of a horizontal bar) set to \"auto\", the\n        resulting dimension will be as long as the adjacent frame edge, so that the\n        bar \"fits\" to the plot.\n        \n        For a ColorBar in the plot frame with the long dimension set to \"auto\", the\n        resulting dimension will be the greater of:\n          * The length of the color palette * 25px\n          * The parallel frame dimension * 0.30\n            (i.e the frame height for a vertical ColorBar)\n        But not greater than:\n          * The parallel frame dimension * 0.80\n         */\n        var frame_height, frame_width, height, title_extent, width;\n        frame_height = this.plot.plot_canvas.frame._height.value;\n        frame_width = this.plot.plot_canvas.frame._width.value;\n        title_extent = this._title_extent();\n        switch (this.orientation) {\n            case \"vertical\":\n                if (this.height === 'auto') {\n                    if (this.panel != null) {\n                        height = frame_height - 2 * this.padding - title_extent;\n                    }\n                    else {\n                        height = array_1.max([this.color_mapper.palette.length * SHORT_DIM, frame_height * LONG_DIM_MIN_SCALAR]);\n                        height = array_1.min([height, frame_height * LONG_DIM_MAX_SCALAR - 2 * this.padding - title_extent]);\n                    }\n                }\n                else {\n                    height = this.height;\n                }\n                width = this.width === 'auto' ? SHORT_DIM : this.width;\n                break;\n            case \"horizontal\":\n                height = this.height === 'auto' ? SHORT_DIM : this.height;\n                if (this.width === 'auto') {\n                    if (this.panel != null) {\n                        width = frame_width - 2 * this.padding;\n                    }\n                    else {\n                        width = array_1.max([this.color_mapper.palette.length * SHORT_DIM, frame_width * LONG_DIM_MIN_SCALAR]);\n                        width = array_1.min([width, frame_width * LONG_DIM_MAX_SCALAR - 2 * this.padding]);\n                    }\n                }\n                else {\n                    width = this.width;\n                }\n        }\n        return {\n            \"height\": height,\n            \"width\": width\n        };\n    };\n    ColorBar.prototype._tick_coordinate_scale = function (scale_length) {\n        /*\n        Creates and returns a scale instance that maps the `color_mapper` range\n        (low to high) to a screen space range equal to the length of the ColorBar's\n        scale image. The scale is used to calculate the tick coordinates in screen\n        coordinates for plotting purposes.\n        \n        Note: the type of color_mapper has to match the type of scale (i.e.\n        a LinearColorMapper will require a corresponding LinearScale instance).\n         */\n        var ranges, scale;\n        ranges = {\n            'source_range': new range1d_1.Range1d({\n                start: this.color_mapper.low,\n                end: this.color_mapper.high\n            }),\n            'target_range': new range1d_1.Range1d({\n                start: 0,\n                end: scale_length\n            })\n        };\n        switch (this.color_mapper.type) {\n            case \"LinearColorMapper\":\n                scale = new linear_scale_1.LinearScale(ranges);\n                break;\n            case \"LogColorMapper\":\n                scale = new log_scale_1.LogScale(ranges);\n        }\n        return scale;\n    };\n    ColorBar.prototype._tick_coordinates = function () {\n        var coord, end, i, ii, image_dimensions, j, k, l, major_coords, major_labels, majors, minor_coords, minors, ref, ref1, ref2, ref3, scale, scale_length, start, ticks;\n        image_dimensions = this._computed_image_dimensions();\n        switch (this.orientation) {\n            case \"vertical\":\n                scale_length = image_dimensions.height;\n                break;\n            case \"horizontal\":\n                scale_length = image_dimensions.width;\n        }\n        scale = this._tick_coordinate_scale(scale_length);\n        ref = this._normals(), i = ref[0], j = ref[1];\n        ref1 = [this.color_mapper.low, this.color_mapper.high], start = ref1[0], end = ref1[1];\n        ticks = this.ticker.get_ticks(start, end, null, null, this.ticker.desired_num_ticks);\n        majors = ticks.major;\n        minors = ticks.minor;\n        major_coords = [[], []];\n        minor_coords = [[], []];\n        for (ii = k = 0, ref2 = majors.length; 0 <= ref2 ? k < ref2 : k > ref2; ii = 0 <= ref2 ? ++k : --k) {\n            if (majors[ii] < start || majors[ii] > end) {\n                continue;\n            }\n            major_coords[i].push(majors[ii]);\n            major_coords[j].push(0);\n        }\n        for (ii = l = 0, ref3 = minors.length; 0 <= ref3 ? l < ref3 : l > ref3; ii = 0 <= ref3 ? ++l : --l) {\n            if (minors[ii] < start || minors[ii] > end) {\n                continue;\n            }\n            minor_coords[i].push(minors[ii]);\n            minor_coords[j].push(0);\n        }\n        major_labels = major_coords[i].slice(0);\n        major_coords[i] = scale.v_compute(major_coords[i]);\n        minor_coords[i] = scale.v_compute(minor_coords[i]);\n        if (this.orientation === 'vertical') {\n            major_coords[i] = new Float64Array((function () {\n                var len, m, ref4, results;\n                ref4 = major_coords[i];\n                results = [];\n                for (m = 0, len = ref4.length; m < len; m++) {\n                    coord = ref4[m];\n                    results.push(scale_length - coord);\n                }\n                return results;\n            })());\n            minor_coords[i] = new Float64Array((function () {\n                var len, m, ref4, results;\n                ref4 = minor_coords[i];\n                results = [];\n                for (m = 0, len = ref4.length; m < len; m++) {\n                    coord = ref4[m];\n                    results.push(scale_length - coord);\n                }\n                return results;\n            })());\n        }\n        return {\n            \"major\": major_coords,\n            \"minor\": minor_coords,\n            \"major_labels\": major_labels\n        };\n    };\n    return ColorBar;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar annotation_1 = require(\"./annotation\");\nexports.Annotation = annotation_1.Annotation;\nvar arrow_1 = require(\"./arrow\");\nexports.Arrow = arrow_1.Arrow;\nvar arrow_head_1 = require(\"./arrow_head\");\nexports.ArrowHead = arrow_head_1.ArrowHead;\nvar arrow_head_2 = require(\"./arrow_head\");\nexports.OpenHead = arrow_head_2.OpenHead;\nvar arrow_head_3 = require(\"./arrow_head\");\nexports.NormalHead = arrow_head_3.NormalHead;\nvar arrow_head_4 = require(\"./arrow_head\");\nexports.TeeHead = arrow_head_4.TeeHead;\nvar arrow_head_5 = require(\"./arrow_head\");\nexports.VeeHead = arrow_head_5.VeeHead;\nvar band_1 = require(\"./band\");\nexports.Band = band_1.Band;\nvar box_annotation_1 = require(\"./box_annotation\");\nexports.BoxAnnotation = box_annotation_1.BoxAnnotation;\nvar color_bar_1 = require(\"./color_bar\");\nexports.ColorBar = color_bar_1.ColorBar;\nvar label_1 = require(\"./label\");\nexports.Label = label_1.Label;\nvar label_set_1 = require(\"./label_set\");\nexports.LabelSet = label_set_1.LabelSet;\nvar legend_1 = require(\"./legend\");\nexports.Legend = legend_1.Legend;\nvar legend_item_1 = require(\"./legend_item\");\nexports.LegendItem = legend_item_1.LegendItem;\nvar poly_annotation_1 = require(\"./poly_annotation\");\nexports.PolyAnnotation = poly_annotation_1.PolyAnnotation;\nvar span_1 = require(\"./span\");\nexports.Span = span_1.Span;\nvar text_annotation_1 = require(\"./text_annotation\");\nexports.TextAnnotation = text_annotation_1.TextAnnotation;\nvar title_1 = require(\"./title\");\nexports.Title = title_1.Title;\nvar tooltip_1 = require(\"./tooltip\");\nexports.Tooltip = tooltip_1.Tooltip;\nvar whisker_1 = require(\"./whisker\");\nexports.Whisker = whisker_1.Whisker;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar text_annotation_1 = require(\"./text_annotation\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nexports.LabelView = (function (superClass) {\n    extend(LabelView, superClass);\n    function LabelView() {\n        return LabelView.__super__.constructor.apply(this, arguments);\n    }\n    LabelView.prototype.initialize = function (options) {\n        LabelView.__super__.initialize.call(this, options);\n        this.canvas = this.plot_model.canvas;\n        return this.visuals.warm_cache(null);\n    };\n    LabelView.prototype._get_size = function () {\n        var ctx, height, side, width;\n        ctx = this.plot_view.canvas_view.ctx;\n        this.visuals.text.set_value(ctx);\n        side = this.model.panel.side;\n        if (side === \"above\" || side === \"below\") {\n            height = ctx.measureText(this.model.text).ascent;\n            return height;\n        }\n        if (side === 'left' || side === 'right') {\n            width = ctx.measureText(this.model.text).width;\n            return width;\n        }\n    };\n    LabelView.prototype.render = function () {\n        var angle, ctx, panel_offset, sx, sy, vx, vy, xscale, yscale;\n        if (!this.model.visible && this.model.render_mode === 'css') {\n            dom_1.hide(this.el);\n        }\n        if (!this.model.visible) {\n            return;\n        }\n        xscale = this.plot_view.frame.xscales[this.model.x_range_name];\n        yscale = this.plot_view.frame.yscales[this.model.y_range_name];\n        ctx = this.plot_view.canvas_view.ctx;\n        switch (this.model.angle_units) {\n            case \"rad\":\n                angle = -1 * this.model.angle;\n                break;\n            case \"deg\":\n                angle = -1 * this.model.angle * Math.PI / 180.0;\n        }\n        if (this.model.x_units === \"data\") {\n            vx = xscale.compute(this.model.x);\n        }\n        else {\n            vx = this.model.x;\n        }\n        sx = this.canvas.vx_to_sx(vx);\n        if (this.model.y_units === \"data\") {\n            vy = yscale.compute(this.model.y);\n        }\n        else {\n            vy = this.model.y;\n        }\n        sy = this.canvas.vy_to_sy(vy);\n        if (this.model.panel != null) {\n            panel_offset = this._get_panel_offset();\n            sx += panel_offset.x;\n            sy += panel_offset.y;\n        }\n        if (this.model.render_mode === 'canvas') {\n            return this._canvas_text(ctx, this.model.text, sx + this.model.x_offset, sy - this.model.y_offset, angle);\n        }\n        else {\n            return this._css_text(ctx, this.model.text, sx + this.model.x_offset, sy - this.model.y_offset, angle);\n        }\n    };\n    return LabelView;\n})(text_annotation_1.TextAnnotationView);\nexports.Label = (function (superClass) {\n    extend(Label, superClass);\n    function Label() {\n        return Label.__super__.constructor.apply(this, arguments);\n    }\n    Label.prototype.default_view = exports.LabelView;\n    Label.prototype.type = 'Label';\n    Label.mixins(['text', 'line:border_', 'fill:background_']);\n    Label.define({\n        x: [p.Number],\n        x_units: [p.SpatialUnits, 'data'],\n        y: [p.Number],\n        y_units: [p.SpatialUnits, 'data'],\n        text: [p.String],\n        angle: [p.Angle, 0],\n        angle_units: [p.AngleUnits, 'rad'],\n        x_offset: [p.Number, 0],\n        y_offset: [p.Number, 0],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default'],\n        render_mode: [p.RenderMode, 'canvas']\n    });\n    Label.override({\n        background_fill_color: null,\n        border_line_color: null\n    });\n    return Label;\n})(text_annotation_1.TextAnnotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar text_annotation_1 = require(\"./text_annotation\");\nvar column_data_source_1 = require(\"../sources/column_data_source\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.LabelSetView = (function (superClass) {\n    extend(LabelSetView, superClass);\n    function LabelSetView() {\n        return LabelSetView.__super__.constructor.apply(this, arguments);\n    }\n    LabelSetView.prototype.initialize = function (options) {\n        var i, j, ref, results;\n        LabelSetView.__super__.initialize.call(this, options);\n        this.set_data(this.model.source);\n        if (this.model.render_mode === 'css') {\n            results = [];\n            for (i = j = 0, ref = this._text.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                this.title_div = dom_1.div({\n                    \"class\": 'bk-annotation-child',\n                    style: {\n                        display: \"none\"\n                    }\n                });\n                results.push(this.el.appendChild(this.title_div));\n            }\n            return results;\n        }\n    };\n    LabelSetView.prototype.connect_signals = function () {\n        LabelSetView.__super__.connect_signals.call(this);\n        if (this.model.render_mode === 'css') {\n            this.connect(this.model.change, function () {\n                this.set_data(this.model.source);\n                return this.render();\n            });\n            this.connect(this.model.source.streaming, function () {\n                this.set_data(this.model.source);\n                return this.render();\n            });\n            this.connect(this.model.source.patching, function () {\n                this.set_data(this.model.source);\n                return this.render();\n            });\n            return this.connect(this.model.source.change, function () {\n                this.set_data(this.model.source);\n                return this.render();\n            });\n        }\n        else {\n            this.connect(this.model.change, function () {\n                this.set_data(this.model.source);\n                return this.plot_view.request_render();\n            });\n            this.connect(this.model.source.streaming, function () {\n                this.set_data(this.model.source);\n                return this.plot_view.request_render();\n            });\n            this.connect(this.model.source.patching, function () {\n                this.set_data(this.model.source);\n                return this.plot_view.request_render();\n            });\n            return this.connect(this.model.source.change, function () {\n                this.set_data(this.model.source);\n                return this.plot_view.request_render();\n            });\n        }\n    };\n    LabelSetView.prototype.set_data = function (source) {\n        LabelSetView.__super__.set_data.call(this, source);\n        return this.visuals.warm_cache(source);\n    };\n    LabelSetView.prototype._map_data = function () {\n        var sx, sy, vx, vy, xscale, yscale;\n        xscale = this.plot_view.frame.xscales[this.model.x_range_name];\n        yscale = this.plot_view.frame.yscales[this.model.y_range_name];\n        if (this.model.x_units === \"data\") {\n            vx = xscale.v_compute(this._x);\n        }\n        else {\n            vx = this._x.slice(0);\n        }\n        sx = this.canvas.v_vx_to_sx(vx);\n        if (this.model.y_units === \"data\") {\n            vy = yscale.v_compute(this._y);\n        }\n        else {\n            vy = this._y.slice(0);\n        }\n        sy = this.canvas.v_vy_to_sy(vy);\n        return [sx, sy];\n    };\n    LabelSetView.prototype.render = function () {\n        var ctx, i, j, k, ref, ref1, ref2, results, results1, sx, sy;\n        if (!this.model.visible && this.model.render_mode === 'css') {\n            dom_1.hide(this.el);\n        }\n        if (!this.model.visible) {\n            return;\n        }\n        ctx = this.plot_view.canvas_view.ctx;\n        ref = this._map_data(), sx = ref[0], sy = ref[1];\n        if (this.model.render_mode === 'canvas') {\n            results = [];\n            for (i = j = 0, ref1 = this._text.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n                results.push(this._v_canvas_text(ctx, i, this._text[i], sx[i] + this._x_offset[i], sy[i] - this._y_offset[i], this._angle[i]));\n            }\n            return results;\n        }\n        else {\n            results1 = [];\n            for (i = k = 0, ref2 = this._text.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {\n                results1.push(this._v_css_text(ctx, i, this._text[i], sx[i] + this._x_offset[i], sy[i] - this._y_offset[i], this._angle[i]));\n            }\n            return results1;\n        }\n    };\n    LabelSetView.prototype._get_size = function () {\n        var ctx, height, side, width;\n        ctx = this.plot_view.canvas_view.ctx;\n        this.visuals.text.set_value(ctx);\n        side = this.model.panel.side;\n        if (side === \"above\" || side === \"below\") {\n            height = ctx.measureText(this._text[0]).ascent;\n            return height;\n        }\n        if (side === 'left' || side === 'right') {\n            width = ctx.measureText(this._text[0]).width;\n            return width;\n        }\n    };\n    LabelSetView.prototype._v_canvas_text = function (ctx, i, text, sx, sy, angle) {\n        var bbox_dims;\n        this.visuals.text.set_vectorize(ctx, i);\n        bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\n        ctx.save();\n        ctx.beginPath();\n        ctx.translate(sx, sy);\n        ctx.rotate(angle);\n        ctx.rect(bbox_dims[0], bbox_dims[1], bbox_dims[2], bbox_dims[3]);\n        if (this.visuals.background_fill.doit) {\n            this.visuals.background_fill.set_vectorize(ctx, i);\n            ctx.fill();\n        }\n        if (this.visuals.border_line.doit) {\n            this.visuals.border_line.set_vectorize(ctx, i);\n            ctx.stroke();\n        }\n        if (this.visuals.text.doit) {\n            this.visuals.text.set_vectorize(ctx, i);\n            ctx.fillText(text, 0, 0);\n        }\n        return ctx.restore();\n    };\n    LabelSetView.prototype._v_css_text = function (ctx, i, text, sx, sy, angle) {\n        var bbox_dims, el, ld, line_dash;\n        el = this.el.childNodes[i];\n        el.textContent = text;\n        this.visuals.text.set_vectorize(ctx, i);\n        bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\n        ld = this.visuals.border_line.line_dash.value();\n        if (types_1.isArray(ld)) {\n            line_dash = ld.length < 2 ? \"solid\" : \"dashed\";\n        }\n        if (types_1.isString(ld)) {\n            line_dash = ld;\n        }\n        this.visuals.border_line.set_vectorize(ctx, i);\n        this.visuals.background_fill.set_vectorize(ctx, i);\n        el.style.position = 'absolute';\n        el.style.left = (sx + bbox_dims[0]) + \"px\";\n        el.style.top = (sy + bbox_dims[1]) + \"px\";\n        el.style.color = \"\" + (this.visuals.text.text_color.value());\n        el.style.opacity = \"\" + (this.visuals.text.text_alpha.value());\n        el.style.font = \"\" + (this.visuals.text.font_value());\n        el.style.lineHeight = \"normal\";\n        if (angle) {\n            el.style.transform = \"rotate(\" + angle + \"rad)\";\n        }\n        if (this.visuals.background_fill.doit) {\n            el.style.backgroundColor = \"\" + (this.visuals.background_fill.color_value());\n        }\n        if (this.visuals.border_line.doit) {\n            el.style.borderStyle = \"\" + line_dash;\n            el.style.borderWidth = (this.visuals.border_line.line_width.value()) + \"px\";\n            el.style.borderColor = \"\" + (this.visuals.border_line.color_value());\n        }\n        return dom_1.show(el);\n    };\n    return LabelSetView;\n})(text_annotation_1.TextAnnotationView);\nexports.LabelSet = (function (superClass) {\n    extend(LabelSet, superClass);\n    function LabelSet() {\n        return LabelSet.__super__.constructor.apply(this, arguments);\n    }\n    LabelSet.prototype.default_view = exports.LabelSetView;\n    LabelSet.prototype.type = 'Label';\n    LabelSet.mixins(['text', 'line:border_', 'fill:background_']);\n    LabelSet.define({\n        x: [p.NumberSpec],\n        y: [p.NumberSpec],\n        x_units: [p.SpatialUnits, 'data'],\n        y_units: [p.SpatialUnits, 'data'],\n        text: [\n            p.StringSpec, {\n                field: \"text\"\n            }\n        ],\n        angle: [p.AngleSpec, 0],\n        x_offset: [\n            p.NumberSpec, {\n                value: 0\n            }\n        ],\n        y_offset: [\n            p.NumberSpec, {\n                value: 0\n            }\n        ],\n        source: [\n            p.Instance, function () {\n                return new column_data_source_1.ColumnDataSource();\n            }\n        ],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default'],\n        render_mode: [p.RenderMode, 'canvas']\n    });\n    LabelSet.override({\n        background_fill_color: null,\n        border_line_color: null\n    });\n    return LabelSet;\n})(text_annotation_1.TextAnnotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar p = require(\"core/properties\");\nvar text_1 = require(\"core/util/text\");\nvar bbox_1 = require(\"core/util/bbox\");\nvar array_1 = require(\"core/util/array\");\nvar object_1 = require(\"core/util/object\");\nvar types_1 = require(\"core/util/types\");\nexports.LegendView = (function (superClass) {\n    extend(LegendView, superClass);\n    function LegendView() {\n        return LegendView.__super__.constructor.apply(this, arguments);\n    }\n    LegendView.prototype.initialize = function (options) {\n        return LegendView.__super__.initialize.call(this, options);\n    };\n    LegendView.prototype.connect_signals = function () {\n        LegendView.__super__.connect_signals.call(this);\n        return this.connect(this.model.properties.visible.change, (function (_this) {\n            return function () {\n                return _this.plot_view.request_render();\n            };\n        })(this));\n    };\n    LegendView.prototype.compute_legend_bbox = function () {\n        var ctx, glyph_height, glyph_width, h_range, i, label_height, label_standoff, label_width, legend_height, legend_margin, legend_names, legend_padding, legend_spacing, legend_width, len, location, max_label_width, name, panel, ref, ref1, ref2, v_range, width, x, y;\n        legend_names = this.model.get_legend_names();\n        glyph_height = this.model.glyph_height;\n        glyph_width = this.model.glyph_width;\n        label_height = this.model.label_height;\n        label_width = this.model.label_width;\n        this.max_label_height = array_1.max([text_1.get_text_height(this.visuals.label_text.font_value()).height, label_height, glyph_height]);\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        this.visuals.label_text.set_value(ctx);\n        this.text_widths = {};\n        for (i = 0, len = legend_names.length; i < len; i++) {\n            name = legend_names[i];\n            this.text_widths[name] = array_1.max([ctx.measureText(name).width, label_width]);\n        }\n        ctx.restore();\n        max_label_width = array_1.max(object_1.values(this.text_widths));\n        legend_margin = this.model.margin;\n        legend_padding = this.model.padding;\n        legend_spacing = this.model.spacing;\n        label_standoff = this.model.label_standoff;\n        if (this.model.orientation === \"vertical\") {\n            legend_height = legend_names.length * this.max_label_height + (legend_names.length - 1) * legend_spacing + 2 * legend_padding;\n            legend_width = max_label_width + glyph_width + label_standoff + 2 * legend_padding;\n        }\n        else {\n            legend_width = 2 * legend_padding + (legend_names.length - 1) * legend_spacing;\n            ref = this.text_widths;\n            for (name in ref) {\n                width = ref[name];\n                legend_width += array_1.max([width, label_width]) + glyph_width + label_standoff;\n            }\n            legend_height = this.max_label_height + 2 * legend_padding;\n        }\n        panel = (ref1 = this.model.panel) != null ? ref1 : this.plot_view.frame;\n        h_range = {\n            start: panel._left.value,\n            end: panel._right.value\n        };\n        v_range = {\n            start: panel._bottom.value,\n            end: panel._top.value\n        };\n        location = this.model.location;\n        if (types_1.isString(location)) {\n            switch (location) {\n                case 'top_left':\n                    x = h_range.start + legend_margin;\n                    y = v_range.end - legend_margin;\n                    break;\n                case 'top_center':\n                    x = (h_range.end + h_range.start) / 2 - legend_width / 2;\n                    y = v_range.end - legend_margin;\n                    break;\n                case 'top_right':\n                    x = h_range.end - legend_margin - legend_width;\n                    y = v_range.end - legend_margin;\n                    break;\n                case 'center_right':\n                    x = h_range.end - legend_margin - legend_width;\n                    y = (v_range.end + v_range.start) / 2 + legend_height / 2;\n                    break;\n                case 'bottom_right':\n                    x = h_range.end - legend_margin - legend_width;\n                    y = v_range.start + legend_margin + legend_height;\n                    break;\n                case 'bottom_center':\n                    x = (h_range.end + h_range.start) / 2 - legend_width / 2;\n                    y = v_range.start + legend_margin + legend_height;\n                    break;\n                case 'bottom_left':\n                    x = h_range.start + legend_margin;\n                    y = v_range.start + legend_margin + legend_height;\n                    break;\n                case 'center_left':\n                    x = h_range.start + legend_margin;\n                    y = (v_range.end + v_range.start) / 2 + legend_height / 2;\n                    break;\n                case 'center':\n                    x = (h_range.end + h_range.start) / 2 - legend_width / 2;\n                    y = (v_range.end + v_range.start) / 2 + legend_height / 2;\n            }\n        }\n        else if (types_1.isArray(location) && location.length === 2) {\n            x = location[0], y = location[1];\n            if ((ref2 = panel.side) === \"left\" || ref2 === \"right\" || ref2 === \"above\" || ref2 === \"below\") {\n                x += h_range.start;\n                y += v_range.end;\n            }\n            else {\n                x += h_range.start;\n                y += v_range.start;\n            }\n        }\n        x = this.plot_view.canvas.vx_to_sx(x);\n        y = this.plot_view.canvas.vy_to_sy(y);\n        return {\n            x: x,\n            y: y,\n            width: legend_width,\n            height: legend_height\n        };\n    };\n    LegendView.prototype.bbox = function () {\n        var height, ref, width, x, y;\n        ref = this.compute_legend_bbox(), x = ref.x, y = ref.y, width = ref.width, height = ref.height;\n        return new bbox_1.BBox({\n            x0: x,\n            y0: y,\n            x1: x + width,\n            y1: y + height\n        });\n    };\n    LegendView.prototype.on_hit = function (sx, sy) {\n        var bbox, field, glyph_height, glyph_width, h, i, item, j, k, l, label, label_standoff, labels, legend_bbox, legend_spacing, len, len1, len2, len3, r, ref, ref1, ref2, ref3, ref4, vertical, w, x1, x2, xoffset, y1, y2, yoffset;\n        glyph_height = this.model.glyph_height;\n        glyph_width = this.model.glyph_width;\n        legend_spacing = this.model.spacing;\n        label_standoff = this.model.label_standoff;\n        xoffset = yoffset = this.model.padding;\n        legend_bbox = this.compute_legend_bbox();\n        vertical = this.model.orientation === \"vertical\";\n        ref = this.model.items;\n        for (i = 0, len = ref.length; i < len; i++) {\n            item = ref[i];\n            labels = item.get_labels_list_from_label_prop();\n            field = item.get_field_from_label_prop();\n            for (j = 0, len1 = labels.length; j < len1; j++) {\n                label = labels[j];\n                x1 = legend_bbox.x + xoffset;\n                y1 = legend_bbox.y + yoffset;\n                x2 = x1 + glyph_width;\n                y2 = y1 + glyph_height;\n                if (vertical) {\n                    ref1 = [legend_bbox.width - 2 * this.model.padding, this.max_label_height], w = ref1[0], h = ref1[1];\n                }\n                else {\n                    ref2 = [this.text_widths[label] + glyph_width + label_standoff, this.max_label_height], w = ref2[0], h = ref2[1];\n                }\n                bbox = new bbox_1.BBox({\n                    x0: x1,\n                    y0: y1,\n                    x1: x1 + w,\n                    y1: y1 + h\n                });\n                if (bbox.contains(sx, sy)) {\n                    switch (this.model.click_policy) {\n                        case \"hide\":\n                            ref3 = item.renderers;\n                            for (k = 0, len2 = ref3.length; k < len2; k++) {\n                                r = ref3[k];\n                                r.visible = !r.visible;\n                            }\n                            break;\n                        case \"mute\":\n                            ref4 = item.renderers;\n                            for (l = 0, len3 = ref4.length; l < len3; l++) {\n                                r = ref4[l];\n                                r.muted = !r.muted;\n                            }\n                    }\n                    return true;\n                }\n                if (vertical) {\n                    yoffset += this.max_label_height + legend_spacing;\n                }\n                else {\n                    xoffset += this.text_widths[label] + glyph_width + label_standoff + legend_spacing;\n                }\n            }\n        }\n        return false;\n    };\n    LegendView.prototype.render = function () {\n        var bbox, ctx;\n        if (!this.model.visible) {\n            return;\n        }\n        if (this.model.items.length === 0) {\n            return;\n        }\n        ctx = this.plot_view.canvas_view.ctx;\n        bbox = this.compute_legend_bbox();\n        ctx.save();\n        this._draw_legend_box(ctx, bbox);\n        this._draw_legend_items(ctx, bbox);\n        return ctx.restore();\n    };\n    LegendView.prototype._draw_legend_box = function (ctx, bbox) {\n        ctx.beginPath();\n        ctx.rect(bbox.x, bbox.y, bbox.width, bbox.height);\n        this.visuals.background_fill.set_value(ctx);\n        ctx.fill();\n        if (this.visuals.border_line.doit) {\n            this.visuals.border_line.set_value(ctx);\n            return ctx.stroke();\n        }\n    };\n    LegendView.prototype._draw_legend_items = function (ctx, bbox) {\n        var active, field, glyph_height, glyph_width, h, i, item, j, k, label, label_standoff, labels, legend_spacing, len, len1, len2, r, ref, ref1, ref2, ref3, vertical, view, w, x1, x2, xoffset, y1, y2, yoffset;\n        glyph_height = this.model.glyph_height;\n        glyph_width = this.model.glyph_width;\n        legend_spacing = this.model.spacing;\n        label_standoff = this.model.label_standoff;\n        xoffset = yoffset = this.model.padding;\n        vertical = this.model.orientation === \"vertical\";\n        ref = this.model.items;\n        for (i = 0, len = ref.length; i < len; i++) {\n            item = ref[i];\n            labels = item.get_labels_list_from_label_prop();\n            field = item.get_field_from_label_prop();\n            if (labels.length === 0) {\n                continue;\n            }\n            active = (function () {\n                switch (this.model.click_policy) {\n                    case \"none\":\n                        return true;\n                    case \"hide\":\n                        return array_1.all(item.renderers, function (r) {\n                            return r.visible;\n                        });\n                    case \"mute\":\n                        return array_1.all(item.renderers, function (r) {\n                            return !r.muted;\n                        });\n                }\n            }).call(this);\n            for (j = 0, len1 = labels.length; j < len1; j++) {\n                label = labels[j];\n                x1 = bbox.x + xoffset;\n                y1 = bbox.y + yoffset;\n                x2 = x1 + glyph_width;\n                y2 = y1 + glyph_height;\n                if (vertical) {\n                    yoffset += this.max_label_height + legend_spacing;\n                }\n                else {\n                    xoffset += this.text_widths[label] + glyph_width + label_standoff + legend_spacing;\n                }\n                this.visuals.label_text.set_value(ctx);\n                ctx.fillText(label, x2 + label_standoff, y1 + this.max_label_height / 2.0);\n                ref1 = item.renderers;\n                for (k = 0, len2 = ref1.length; k < len2; k++) {\n                    r = ref1[k];\n                    view = this.plot_view.renderer_views[r.id];\n                    view.draw_legend(ctx, x1, x2, y1, y2, field, label);\n                }\n                if (!active) {\n                    if (vertical) {\n                        ref2 = [bbox.width - 2 * this.model.padding, this.max_label_height], w = ref2[0], h = ref2[1];\n                    }\n                    else {\n                        ref3 = [this.text_widths[label] + glyph_width + label_standoff, this.max_label_height], w = ref3[0], h = ref3[1];\n                    }\n                    ctx.beginPath();\n                    ctx.rect(x1, y1, w, h);\n                    this.visuals.inactive_fill.set_value(ctx);\n                    ctx.fill();\n                }\n            }\n        }\n        return null;\n    };\n    LegendView.prototype._get_size = function () {\n        var bbox, side;\n        bbox = this.compute_legend_bbox();\n        side = this.model.panel.side;\n        if (side === 'above' || side === 'below') {\n            return bbox.height;\n        }\n        if (side === 'left' || side === 'right') {\n            return bbox.width;\n        }\n    };\n    return LegendView;\n})(annotation_1.AnnotationView);\nexports.Legend = (function (superClass) {\n    extend(Legend, superClass);\n    function Legend() {\n        return Legend.__super__.constructor.apply(this, arguments);\n    }\n    Legend.prototype.default_view = exports.LegendView;\n    Legend.prototype.type = 'Legend';\n    Legend.prototype.cursor = function () {\n        if (this.click_policy === \"none\") {\n            return null;\n        }\n        else {\n            return \"pointer\";\n        }\n    };\n    Legend.prototype.get_legend_names = function () {\n        var i, item, labels, legend_names, len, ref;\n        legend_names = [];\n        ref = this.items;\n        for (i = 0, len = ref.length; i < len; i++) {\n            item = ref[i];\n            labels = item.get_labels_list_from_label_prop();\n            legend_names = legend_names.concat(labels);\n        }\n        return legend_names;\n    };\n    Legend.mixins(['text:label_', 'fill:inactive_', 'line:border_', 'fill:background_']);\n    Legend.define({\n        orientation: [p.Orientation, 'vertical'],\n        location: [p.Any, 'top_right'],\n        label_standoff: [p.Number, 5],\n        glyph_height: [p.Number, 20],\n        glyph_width: [p.Number, 20],\n        label_height: [p.Number, 20],\n        label_width: [p.Number, 20],\n        margin: [p.Number, 10],\n        padding: [p.Number, 10],\n        spacing: [p.Number, 3],\n        items: [p.Array, []],\n        click_policy: [p.Any, \"none\"]\n    });\n    Legend.override({\n        border_line_color: \"#e5e5e5\",\n        border_line_alpha: 0.5,\n        border_line_width: 1,\n        background_fill_color: \"#ffffff\",\n        background_fill_alpha: 0.95,\n        inactive_fill_color: \"white\",\n        inactive_fill_alpha: 0.9,\n        label_text_font_size: \"10pt\",\n        label_text_baseline: \"middle\"\n    });\n    return Legend;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar model_1 = require(\"../../model\");\nvar p = require(\"core/properties\");\nvar logging_1 = require(\"core/logging\");\nvar array_1 = require(\"core/util/array\");\nvar column_data_source_1 = require(\"../../models/sources/column_data_source\");\nexports.LegendItem = (function (superClass) {\n    extend(LegendItem, superClass);\n    function LegendItem() {\n        this.get_labels_list_from_label_prop = bind(this.get_labels_list_from_label_prop, this);\n        this.get_field_from_label_prop = bind(this.get_field_from_label_prop, this);\n        return LegendItem.__super__.constructor.apply(this, arguments);\n    }\n    LegendItem.prototype.type = \"LegendItem\";\n    LegendItem.prototype._check_data_sources_on_renderers = function () {\n        var field, i, len, r, ref, source;\n        field = this.get_field_from_label_prop();\n        if (field != null) {\n            if (this.renderers.length < 1) {\n                return false;\n            }\n            source = this.renderers[0].data_source;\n            if (source != null) {\n                ref = this.renderers;\n                for (i = 0, len = ref.length; i < len; i++) {\n                    r = ref[i];\n                    if (r.data_source !== source) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    };\n    LegendItem.prototype._check_field_label_on_data_source = function () {\n        var field, source;\n        field = this.get_field_from_label_prop();\n        if (field != null) {\n            if (this.renderers.length < 1) {\n                return false;\n            }\n            source = this.renderers[0].data_source;\n            if ((source != null) && indexOf.call(source.columns(), field) < 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n    LegendItem.prototype.initialize = function (attrs, options) {\n        var data_source_validation, field_validation;\n        LegendItem.__super__.initialize.call(this, attrs, options);\n        data_source_validation = this._check_data_sources_on_renderers();\n        if (!data_source_validation) {\n            logging_1.logger.error(\"Non matching data sources on legend item renderers\");\n        }\n        field_validation = this._check_field_label_on_data_source();\n        if (!field_validation) {\n            return logging_1.logger.error(\"Bad column name on label: \" + this.label);\n        }\n    };\n    LegendItem.define({\n        label: [p.StringSpec, null],\n        renderers: [p.Array, []]\n    });\n    LegendItem.prototype.get_field_from_label_prop = function () {\n        if ((this.label != null) && (this.label.field != null)) {\n            return this.label.field;\n        }\n    };\n    LegendItem.prototype.get_labels_list_from_label_prop = function () {\n        var data, field, source;\n        if ((this.label != null) && (this.label.value != null)) {\n            return [this.label.value];\n        }\n        field = this.get_field_from_label_prop();\n        if (field != null) {\n            if (this.renderers[0] && (this.renderers[0].data_source != null)) {\n                source = this.renderers[0].data_source;\n            }\n            else {\n                return [\"No source found\"];\n            }\n            if (source instanceof column_data_source_1.ColumnDataSource) {\n                data = source.get_column(field);\n                if (data != null) {\n                    return array_1.uniq(data);\n                }\n                else {\n                    return [\"Invalid field\"];\n                }\n            }\n        }\n        return [];\n    };\n    return LegendItem;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar signaling_1 = require(\"core/signaling\");\nvar p = require(\"core/properties\");\nexports.PolyAnnotationView = (function (superClass) {\n    extend(PolyAnnotationView, superClass);\n    function PolyAnnotationView() {\n        return PolyAnnotationView.__super__.constructor.apply(this, arguments);\n    }\n    PolyAnnotationView.prototype.connect_signals = function () {\n        PolyAnnotationView.__super__.connect_signals.call(this);\n        this.connect(this.model.change, (function (_this) {\n            return function () {\n                return _this.plot_view.request_render();\n            };\n        })(this));\n        return this.connect(this.model.data_update, (function (_this) {\n            return function () {\n                return _this.plot_view.request_render();\n            };\n        })(this));\n    };\n    PolyAnnotationView.prototype.render = function (ctx) {\n        var canvas, i, j, ref, sx, sy, vx, vy, xs, ys;\n        if (!this.model.visible) {\n            return;\n        }\n        xs = this.model.xs;\n        ys = this.model.ys;\n        if (xs.length !== ys.length) {\n            return null;\n        }\n        if (xs.length < 3 || ys.length < 3) {\n            return null;\n        }\n        canvas = this.plot_view.canvas;\n        ctx = this.plot_view.canvas_view.ctx;\n        for (i = j = 0, ref = xs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            if (this.model.xs_units === 'screen') {\n                vx = xs[i];\n            }\n            if (this.model.ys_units === 'screen') {\n                vy = ys[i];\n            }\n            sx = canvas.vx_to_sx(vx);\n            sy = canvas.vy_to_sy(vy);\n            if (i === 0) {\n                ctx.beginPath();\n                ctx.moveTo(sx, sy);\n            }\n            else {\n                ctx.lineTo(sx, sy);\n            }\n        }\n        ctx.closePath();\n        if (this.visuals.line.doit) {\n            this.visuals.line.set_value(ctx);\n            ctx.stroke();\n        }\n        if (this.visuals.fill.doit) {\n            this.visuals.fill.set_value(ctx);\n            return ctx.fill();\n        }\n    };\n    return PolyAnnotationView;\n})(annotation_1.AnnotationView);\nexports.PolyAnnotation = (function (superClass) {\n    extend(PolyAnnotation, superClass);\n    function PolyAnnotation() {\n        return PolyAnnotation.__super__.constructor.apply(this, arguments);\n    }\n    PolyAnnotation.prototype.default_view = exports.PolyAnnotationView;\n    PolyAnnotation.prototype.type = \"PolyAnnotation\";\n    PolyAnnotation.mixins(['line', 'fill']);\n    PolyAnnotation.define({\n        xs: [p.Array, []],\n        xs_units: [p.SpatialUnits, 'data'],\n        ys: [p.Array, []],\n        ys_units: [p.SpatialUnits, 'data'],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default']\n    });\n    PolyAnnotation.override({\n        fill_color: \"#fff9ba\",\n        fill_alpha: 0.4,\n        line_color: \"#cccccc\",\n        line_alpha: 0.3\n    });\n    PolyAnnotation.prototype.initialize = function (attrs, options) {\n        PolyAnnotation.__super__.initialize.call(this, attrs, options);\n        return this.data_update = new signaling_1.Signal(this, \"data_update\");\n    };\n    PolyAnnotation.prototype.update = function (arg) {\n        var xs, ys;\n        xs = arg.xs, ys = arg.ys;\n        this.setv({\n            xs: xs,\n            ys: ys\n        }, {\n            silent: true\n        });\n        return this.data_update.emit();\n    };\n    return PolyAnnotation;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nexports.SpanView = (function (superClass) {\n    extend(SpanView, superClass);\n    function SpanView() {\n        return SpanView.__super__.constructor.apply(this, arguments);\n    }\n    SpanView.prototype.initialize = function (options) {\n        SpanView.__super__.initialize.call(this, options);\n        this.plot_view.canvas_overlays.appendChild(this.el);\n        this.el.style.position = \"absolute\";\n        return dom_1.hide(this.el);\n    };\n    SpanView.prototype.connect_signals = function () {\n        SpanView.__super__.connect_signals.call(this);\n        if (this.model.for_hover) {\n            return this.connect(this.model.properties.computed_location.change, function () {\n                return this._draw_span();\n            });\n        }\n        else {\n            if (this.model.render_mode === 'canvas') {\n                this.connect(this.model.change, (function (_this) {\n                    return function () {\n                        return _this.plot_view.request_render();\n                    };\n                })(this));\n                return this.connect(this.model.properties.location.change, (function (_this) {\n                    return function () {\n                        return _this.plot_view.request_render();\n                    };\n                })(this));\n            }\n            else {\n                this.connect(this.model.change, function () {\n                    return this.render();\n                });\n                return this.connect(this.model.properties.location.change, function () {\n                    return this._draw_span();\n                });\n            }\n        }\n    };\n    SpanView.prototype.render = function () {\n        if (!this.model.visible && this.model.render_mode === 'css') {\n            dom_1.hide(this.el);\n        }\n        if (!this.model.visible) {\n            return;\n        }\n        return this._draw_span();\n    };\n    SpanView.prototype._draw_span = function () {\n        var canvas, ctx, frame, height, loc, sleft, stop, width, xscale, yscale;\n        if (this.model.for_hover) {\n            loc = this.model.computed_location;\n        }\n        else {\n            loc = this.model.location;\n        }\n        if (loc == null) {\n            dom_1.hide(this.el);\n            return;\n        }\n        frame = this.plot_model.frame;\n        canvas = this.plot_model.canvas;\n        xscale = this.plot_view.frame.xscales[this.model.x_range_name];\n        yscale = this.plot_view.frame.yscales[this.model.y_range_name];\n        if (this.model.dimension === 'width') {\n            stop = canvas.vy_to_sy(this._calc_dim(loc, yscale));\n            sleft = canvas.vx_to_sx(frame._left.value);\n            width = frame._width.value;\n            height = this.model.properties.line_width.value();\n        }\n        else {\n            stop = canvas.vy_to_sy(frame._top.value);\n            sleft = canvas.vx_to_sx(this._calc_dim(loc, xscale));\n            width = this.model.properties.line_width.value();\n            height = frame._height.value;\n        }\n        if (this.model.render_mode === \"css\") {\n            this.el.style.top = stop + \"px\";\n            this.el.style.left = sleft + \"px\";\n            this.el.style.width = width + \"px\";\n            this.el.style.height = height + \"px\";\n            this.el.style.zIndex = 1000;\n            this.el.style.backgroundColor = this.model.properties.line_color.value();\n            this.el.style.opacity = this.model.properties.line_alpha.value();\n            return dom_1.show(this.el);\n        }\n        else if (this.model.render_mode === \"canvas\") {\n            ctx = this.plot_view.canvas_view.ctx;\n            ctx.save();\n            ctx.beginPath();\n            this.visuals.line.set_value(ctx);\n            ctx.moveTo(sleft, stop);\n            if (this.model.dimension === \"width\") {\n                ctx.lineTo(sleft + width, stop);\n            }\n            else {\n                ctx.lineTo(sleft, stop + height);\n            }\n            ctx.stroke();\n            return ctx.restore();\n        }\n    };\n    SpanView.prototype._calc_dim = function (location, scale) {\n        var vdim;\n        if (this.model.location_units === 'data') {\n            vdim = scale.compute(location);\n        }\n        else {\n            vdim = location;\n        }\n        return vdim;\n    };\n    return SpanView;\n})(annotation_1.AnnotationView);\nexports.Span = (function (superClass) {\n    extend(Span, superClass);\n    function Span() {\n        return Span.__super__.constructor.apply(this, arguments);\n    }\n    Span.prototype.default_view = exports.SpanView;\n    Span.prototype.type = 'Span';\n    Span.mixins(['line']);\n    Span.define({\n        render_mode: [p.RenderMode, 'canvas'],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default'],\n        location: [p.Number, null],\n        location_units: [p.SpatialUnits, 'data'],\n        dimension: [p.Dimension, 'width']\n    });\n    Span.override({\n        line_color: 'black'\n    });\n    Span.internal({\n        for_hover: [p.Boolean, false],\n        computed_location: [p.Number, null]\n    });\n    return Span;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar dom_1 = require(\"core/dom\");\nvar types_1 = require(\"core/util/types\");\nvar text_1 = require(\"core/util/text\");\nexports.TextAnnotationView = (function (superClass) {\n    extend(TextAnnotationView, superClass);\n    function TextAnnotationView() {\n        return TextAnnotationView.__super__.constructor.apply(this, arguments);\n    }\n    TextAnnotationView.prototype.initialize = function (options) {\n        TextAnnotationView.__super__.initialize.call(this, options);\n        this.canvas = this.plot_model.canvas;\n        this.frame = this.plot_model.frame;\n        if (this.model.render_mode === 'css') {\n            this.el.classList.add('bk-annotation');\n            return this.plot_view.canvas_overlays.appendChild(this.el);\n        }\n    };\n    TextAnnotationView.prototype.connect_signals = function () {\n        TextAnnotationView.__super__.connect_signals.call(this);\n        if (this.model.render_mode === 'css') {\n            return this.connect(this.model.change, function () {\n                return this.render();\n            });\n        }\n        else {\n            return this.connect(this.model.change, (function (_this) {\n                return function () {\n                    return _this.plot_view.request_render();\n                };\n            })(this));\n        }\n    };\n    TextAnnotationView.prototype._calculate_text_dimensions = function (ctx, text) {\n        var height, width;\n        width = ctx.measureText(text).width;\n        height = text_1.get_text_height(this.visuals.text.font_value()).height;\n        return [width, height];\n    };\n    TextAnnotationView.prototype._calculate_bounding_box_dimensions = function (ctx, text) {\n        var height, ref, width, x_offset, y_offset;\n        ref = this._calculate_text_dimensions(ctx, text), width = ref[0], height = ref[1];\n        switch (ctx.textAlign) {\n            case 'left':\n                x_offset = 0;\n                break;\n            case 'center':\n                x_offset = -width / 2;\n                break;\n            case 'right':\n                x_offset = -width;\n        }\n        switch (ctx.textBaseline) {\n            case 'top':\n                y_offset = 0.0;\n                break;\n            case 'middle':\n                y_offset = -0.5 * height;\n                break;\n            case 'bottom':\n                y_offset = -1.0 * height;\n                break;\n            case 'alphabetic':\n                y_offset = -0.8 * height;\n                break;\n            case 'hanging':\n                y_offset = -0.17 * height;\n                break;\n            case 'ideographic':\n                y_offset = -0.83 * height;\n        }\n        return [x_offset, y_offset, width, height];\n    };\n    TextAnnotationView.prototype._get_size = function () {\n        var ctx;\n        ctx = this.plot_view.canvas_view.ctx;\n        this.visuals.text.set_value(ctx);\n        return ctx.measureText(this.model.text).ascent;\n    };\n    TextAnnotationView.prototype.render = function () {\n        return null;\n    };\n    TextAnnotationView.prototype._canvas_text = function (ctx, text, sx, sy, angle) {\n        var bbox_dims;\n        this.visuals.text.set_value(ctx);\n        bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\n        ctx.save();\n        ctx.beginPath();\n        ctx.translate(sx, sy);\n        if (angle) {\n            ctx.rotate(angle);\n        }\n        ctx.rect(bbox_dims[0], bbox_dims[1], bbox_dims[2], bbox_dims[3]);\n        if (this.visuals.background_fill.doit) {\n            this.visuals.background_fill.set_value(ctx);\n            ctx.fill();\n        }\n        if (this.visuals.border_line.doit) {\n            this.visuals.border_line.set_value(ctx);\n            ctx.stroke();\n        }\n        if (this.visuals.text.doit) {\n            this.visuals.text.set_value(ctx);\n            ctx.fillText(text, 0, 0);\n        }\n        return ctx.restore();\n    };\n    TextAnnotationView.prototype._css_text = function (ctx, text, sx, sy, angle) {\n        var bbox_dims, ld, line_dash;\n        dom_1.hide(this.el);\n        this.visuals.text.set_value(ctx);\n        bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\n        ld = this.visuals.border_line.line_dash.value();\n        if (types_1.isArray(ld)) {\n            if (ld.length < 2) {\n                line_dash = \"solid\";\n            }\n            else {\n                line_dash = \"dashed\";\n            }\n        }\n        if (types_1.isString(ld)) {\n            line_dash = ld;\n        }\n        this.visuals.border_line.set_value(ctx);\n        this.visuals.background_fill.set_value(ctx);\n        this.el.style.position = 'absolute';\n        this.el.style.left = (sx + bbox_dims[0]) + \"px\";\n        this.el.style.top = (sy + bbox_dims[1]) + \"px\";\n        this.el.style.color = \"\" + (this.visuals.text.text_color.value());\n        this.el.style.opacity = \"\" + (this.visuals.text.text_alpha.value());\n        this.el.style.font = \"\" + (this.visuals.text.font_value());\n        this.el.style.lineHeight = \"normal\";\n        if (angle) {\n            this.el.style.transform = \"rotate(\" + angle + \"rad)\";\n        }\n        if (this.visuals.background_fill.doit) {\n            this.el.style.backgroundColor = \"\" + (this.visuals.background_fill.color_value());\n        }\n        if (this.visuals.border_line.doit) {\n            this.el.style.borderStyle = \"\" + line_dash;\n            this.el.style.borderWidth = (this.visuals.border_line.line_width.value()) + \"px\";\n            this.el.style.borderColor = \"\" + (this.visuals.border_line.color_value());\n        }\n        this.el.textContent = text;\n        return dom_1.show(this.el);\n    };\n    return TextAnnotationView;\n})(annotation_1.AnnotationView);\nexports.TextAnnotation = (function (superClass) {\n    extend(TextAnnotation, superClass);\n    function TextAnnotation() {\n        return TextAnnotation.__super__.constructor.apply(this, arguments);\n    }\n    TextAnnotation.prototype.type = 'TextAnnotation';\n    TextAnnotation.prototype.default_view = exports.TextAnnotationView;\n    return TextAnnotation;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar text_annotation_1 = require(\"./text_annotation\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nvar Visuals = require(\"core/visuals\");\nexports.TitleView = (function (superClass) {\n    extend(TitleView, superClass);\n    function TitleView() {\n        return TitleView.__super__.constructor.apply(this, arguments);\n    }\n    TitleView.prototype.initialize = function (options) {\n        var ctx;\n        TitleView.__super__.initialize.call(this, options);\n        this.visuals.text = new Visuals.Text(this.model);\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        this.model.panel.apply_label_text_heuristics(ctx, 'justified');\n        this.model.text_baseline = ctx.textBaseline;\n        this.model.text_align = this.model.align;\n        return ctx.restore();\n    };\n    TitleView.prototype._get_computed_location = function () {\n        var height, ref, sx, sy, vx, vy, width;\n        ref = this._calculate_text_dimensions(this.plot_view.canvas_view.ctx, this.text), width = ref[0], height = ref[1];\n        switch (this.model.panel.side) {\n            case 'left':\n                vx = 0;\n                vy = this._get_text_location(this.model.align, this.frame.v_range) + this.model.offset;\n                break;\n            case 'right':\n                vx = this.canvas._right.value - 1;\n                vy = this.canvas._height.value - this._get_text_location(this.model.align, this.frame.v_range) - this.model.offset;\n                break;\n            case 'above':\n                vx = this._get_text_location(this.model.align, this.frame.h_range) + this.model.offset;\n                vy = this.canvas._top.value - 10;\n                break;\n            case 'below':\n                vx = this._get_text_location(this.model.align, this.frame.h_range) + this.model.offset;\n                vy = 0;\n        }\n        sx = this.canvas.vx_to_sx(vx);\n        sy = this.canvas.vy_to_sy(vy);\n        return [sx, sy];\n    };\n    TitleView.prototype._get_text_location = function (alignment, range) {\n        var text_location;\n        switch (alignment) {\n            case 'left':\n                text_location = range.start;\n                break;\n            case 'center':\n                text_location = (range.end + range.start) / 2;\n                break;\n            case 'right':\n                text_location = range.end;\n        }\n        return text_location;\n    };\n    TitleView.prototype.render = function () {\n        var angle, ctx, ref, sx, sy;\n        if (!this.model.visible && this.model.render_mode === 'css') {\n            dom_1.hide(this.el);\n        }\n        if (!this.model.visible) {\n            return;\n        }\n        angle = this.model.panel.get_label_angle_heuristic('parallel');\n        ref = this._get_computed_location(), sx = ref[0], sy = ref[1];\n        ctx = this.plot_view.canvas_view.ctx;\n        if (this.model.text === \"\" || this.model.text === null) {\n            return;\n        }\n        if (this.model.render_mode === 'canvas') {\n            return this._canvas_text(ctx, this.model.text, sx, sy, angle);\n        }\n        else {\n            return this._css_text(ctx, this.model.text, sx, sy, angle);\n        }\n    };\n    TitleView.prototype._get_size = function () {\n        var ctx, text;\n        text = this.model.text;\n        if (text === \"\" || text === null) {\n            return 0;\n        }\n        else {\n            ctx = this.plot_view.canvas_view.ctx;\n            this.visuals.text.set_value(ctx);\n            return ctx.measureText(text).ascent + 10;\n        }\n    };\n    return TitleView;\n})(text_annotation_1.TextAnnotationView);\nexports.Title = (function (superClass) {\n    extend(Title, superClass);\n    function Title() {\n        return Title.__super__.constructor.apply(this, arguments);\n    }\n    Title.prototype.default_view = exports.TitleView;\n    Title.prototype.type = 'Title';\n    Title.mixins(['line:border_', 'fill:background_']);\n    Title.define({\n        text: [p.String],\n        text_font: [p.Font, 'helvetica'],\n        text_font_size: [p.FontSizeSpec, '10pt'],\n        text_font_style: [p.FontStyle, 'bold'],\n        text_color: [p.ColorSpec, '#444444'],\n        text_alpha: [p.NumberSpec, 1.0],\n        align: [p.TextAlign, 'left'],\n        offset: [p.Number, 0],\n        render_mode: [p.RenderMode, 'canvas']\n    });\n    Title.override({\n        background_fill_color: null,\n        border_line_color: null\n    });\n    Title.internal({\n        text_align: [p.TextAlign, 'left'],\n        text_baseline: [p.TextBaseline, 'bottom']\n    });\n    return Title;\n})(text_annotation_1.TextAnnotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nexports.TooltipView = (function (superClass) {\n    extend(TooltipView, superClass);\n    function TooltipView() {\n        return TooltipView.__super__.constructor.apply(this, arguments);\n    }\n    TooltipView.prototype.className = \"bk-tooltip\";\n    TooltipView.prototype.initialize = function (options) {\n        TooltipView.__super__.initialize.call(this, options);\n        this.plot_view.canvas_overlays.appendChild(this.el);\n        this.el.style.zIndex = 1010;\n        return dom_1.hide(this.el);\n    };\n    TooltipView.prototype.connect_signals = function () {\n        TooltipView.__super__.connect_signals.call(this);\n        return this.connect(this.model.properties.data.change, function () {\n            return this._draw_tips();\n        });\n    };\n    TooltipView.prototype.render = function () {\n        if (!this.model.visible) {\n            return;\n        }\n        return this._draw_tips();\n    };\n    TooltipView.prototype._draw_tips = function () {\n        var arrow_size, attachment, bottom, content, data, height, i, left, len, side, sx, sy, tip, top, val, vx, vy, width;\n        data = this.model.data;\n        dom_1.empty(this.el);\n        dom_1.hide(this.el);\n        if (this.model.custom) {\n            this.el.classList.add(\"bk-tooltip-custom\");\n        }\n        else {\n            this.el.classList.remove(\"bk-tooltip-custom\");\n        }\n        if (data.length === 0) {\n            return;\n        }\n        for (i = 0, len = data.length; i < len; i++) {\n            val = data[i];\n            vx = val[0], vy = val[1], content = val[2];\n            if (this.model.inner_only && !this.plot_view.frame.contains(vx, vy)) {\n                continue;\n            }\n            tip = dom_1.div({}, content);\n            this.el.appendChild(tip);\n        }\n        sx = this.plot_view.model.canvas.vx_to_sx(vx);\n        sy = this.plot_view.model.canvas.vy_to_sy(vy);\n        attachment = this.model.attachment;\n        switch (attachment) {\n            case \"horizontal\":\n                width = this.plot_view.frame._width.value;\n                left = this.plot_view.frame._left.value;\n                if (vx - left < width / 2) {\n                    side = 'right';\n                }\n                else {\n                    side = 'left';\n                }\n                break;\n            case \"vertical\":\n                height = this.plot_view.frame._height.value;\n                bottom = this.plot_view.frame._bottom.value;\n                if (vy - bottom < height / 2) {\n                    side = 'below';\n                }\n                else {\n                    side = 'above';\n                }\n                break;\n            default:\n                side = attachment;\n        }\n        this.el.classList.remove(\"bk-right\");\n        this.el.classList.remove(\"bk-left\");\n        this.el.classList.remove(\"bk-above\");\n        this.el.classList.remove(\"bk-below\");\n        arrow_size = 10;\n        dom_1.show(this.el);\n        switch (side) {\n            case \"right\":\n                this.el.classList.add(\"bk-left\");\n                left = sx + (this.el.offsetWidth - this.el.clientWidth) + arrow_size;\n                top = sy - this.el.offsetHeight / 2;\n                break;\n            case \"left\":\n                this.el.classList.add(\"bk-right\");\n                left = sx - this.el.offsetWidth - arrow_size;\n                top = sy - this.el.offsetHeight / 2;\n                break;\n            case \"above\":\n                this.el.classList.add(\"bk-above\");\n                top = sy + (this.el.offsetHeight - this.el.clientHeight) + arrow_size;\n                left = Math.round(sx - this.el.offsetWidth / 2);\n                break;\n            case \"below\":\n                this.el.classList.add(\"bk-below\");\n                top = sy - this.el.offsetHeight - arrow_size;\n                left = Math.round(sx - this.el.offsetWidth / 2);\n        }\n        if (this.model.show_arrow) {\n            this.el.classList.add(\"bk-tooltip-arrow\");\n        }\n        if (this.el.childNodes.length > 0) {\n            this.el.style.top = top + \"px\";\n            return this.el.style.left = left + \"px\";\n        }\n        else {\n            return dom_1.hide(this.el);\n        }\n    };\n    return TooltipView;\n})(annotation_1.AnnotationView);\nexports.Tooltip = (function (superClass) {\n    extend(Tooltip, superClass);\n    function Tooltip() {\n        return Tooltip.__super__.constructor.apply(this, arguments);\n    }\n    Tooltip.prototype.default_view = exports.TooltipView;\n    Tooltip.prototype.type = 'Tooltip';\n    Tooltip.define({\n        attachment: [p.String, 'horizontal'],\n        inner_only: [p.Bool, true],\n        show_arrow: [p.Bool, true]\n    });\n    Tooltip.override({\n        level: 'overlay'\n    });\n    Tooltip.internal({\n        data: [p.Any, []],\n        custom: [p.Any]\n    });\n    Tooltip.prototype.clear = function () {\n        return this.data = [];\n    };\n    Tooltip.prototype.add = function (vx, vy, content) {\n        var data;\n        data = this.data;\n        data.push([vx, vy, content]);\n        this.data = data;\n        return this.properties.data.change.emit();\n    };\n    return Tooltip;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar column_data_source_1 = require(\"../sources/column_data_source\");\nvar arrow_head_1 = require(\"./arrow_head\");\nvar p = require(\"core/properties\");\nexports.WhiskerView = (function (superClass) {\n    extend(WhiskerView, superClass);\n    function WhiskerView() {\n        return WhiskerView.__super__.constructor.apply(this, arguments);\n    }\n    WhiskerView.prototype.initialize = function (options) {\n        WhiskerView.__super__.initialize.call(this, options);\n        return this.set_data(this.model.source);\n    };\n    WhiskerView.prototype.connect_signals = function () {\n        WhiskerView.__super__.connect_signals.call(this);\n        this.connect(this.model.source.streaming, function () {\n            return this.set_data(this.model.source);\n        });\n        this.connect(this.model.source.patching, function () {\n            return this.set_data(this.model.source);\n        });\n        return this.connect(this.model.source.change, function () {\n            return this.set_data(this.model.source);\n        });\n    };\n    WhiskerView.prototype.set_data = function (source) {\n        WhiskerView.__super__.set_data.call(this, source);\n        this.visuals.warm_cache(source);\n        return this.plot_view.request_render();\n    };\n    WhiskerView.prototype._map_data = function () {\n        var _base_vx, _lower, _lower_vx, _upper, _upper_vx, base_scale, i, j, limit_scale, ref, x_scale, y_scale;\n        x_scale = this.plot_view.frame.xscales[this.model.x_range_name];\n        y_scale = this.plot_view.frame.yscales[this.model.y_range_name];\n        limit_scale = this.model.dimension === \"height\" ? y_scale : x_scale;\n        base_scale = this.model.dimension === \"height\" ? x_scale : y_scale;\n        if (this.model.lower.units === \"data\") {\n            _lower_vx = limit_scale.v_compute(this._lower);\n        }\n        else {\n            _lower_vx = this._lower;\n        }\n        if (this.model.upper.units === \"data\") {\n            _upper_vx = limit_scale.v_compute(this._upper);\n        }\n        else {\n            _upper_vx = this._upper;\n        }\n        if (this.model.base.units === \"data\") {\n            _base_vx = base_scale.v_compute(this._base);\n        }\n        else {\n            _base_vx = this._base;\n        }\n        ref = this.model._normals(), i = ref[0], j = ref[1];\n        _lower = [_lower_vx, _base_vx];\n        _upper = [_upper_vx, _base_vx];\n        this._lower_sx = this.plot_model.canvas.v_vx_to_sx(_lower[i]);\n        this._lower_sy = this.plot_model.canvas.v_vy_to_sy(_lower[j]);\n        this._upper_sx = this.plot_model.canvas.v_vx_to_sx(_upper[i]);\n        return this._upper_sy = this.plot_model.canvas.v_vy_to_sy(_upper[j]);\n    };\n    WhiskerView.prototype.render = function () {\n        var angle, ctx, i, k, l, m, ref, ref1, ref2, results;\n        if (!this.model.visible) {\n            return;\n        }\n        this._map_data();\n        ctx = this.plot_view.canvas_view.ctx;\n        if (this.visuals.line.doit) {\n            for (i = k = 0, ref = this._lower_sx.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.beginPath();\n                ctx.moveTo(this._lower_sx[i], this._lower_sy[i]);\n                ctx.lineTo(this._upper_sx[i], this._upper_sy[i]);\n                ctx.stroke();\n            }\n        }\n        angle = this.model.dimension === \"height\" ? 0 : Math.PI / 2;\n        if (this.model.lower_head != null) {\n            for (i = l = 0, ref1 = this._lower_sx.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {\n                ctx.save();\n                ctx.translate(this._lower_sx[i], this._lower_sy[i]);\n                ctx.rotate(angle + Math.PI);\n                this.model.lower_head.render(ctx, i);\n                ctx.restore();\n            }\n        }\n        if (this.model.upper_head != null) {\n            results = [];\n            for (i = m = 0, ref2 = this._upper_sx.length; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {\n                ctx.save();\n                ctx.translate(this._upper_sx[i], this._upper_sy[i]);\n                ctx.rotate(angle);\n                this.model.upper_head.render(ctx, i);\n                results.push(ctx.restore());\n            }\n            return results;\n        }\n    };\n    return WhiskerView;\n})(annotation_1.AnnotationView);\nexports.Whisker = (function (superClass) {\n    extend(Whisker, superClass);\n    function Whisker() {\n        return Whisker.__super__.constructor.apply(this, arguments);\n    }\n    Whisker.prototype.default_view = exports.WhiskerView;\n    Whisker.prototype.type = 'Whisker';\n    Whisker.mixins(['line']);\n    Whisker.define({\n        lower: [p.DistanceSpec],\n        lower_head: [\n            p.Instance, function () {\n                return new arrow_head_1.TeeHead({\n                    level: \"underlay\",\n                    size: 10\n                });\n            }\n        ],\n        upper: [p.DistanceSpec],\n        upper_head: [\n            p.Instance, function () {\n                return new arrow_head_1.TeeHead({\n                    level: \"underlay\",\n                    size: 10\n                });\n            }\n        ],\n        base: [p.DistanceSpec],\n        dimension: [p.Dimension, 'height'],\n        source: [\n            p.Instance, function () {\n                return new column_data_source_1.ColumnDataSource();\n            }\n        ],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default']\n    });\n    Whisker.override({\n        level: 'underlay'\n    });\n    Whisker.prototype._normals = function () {\n        var i, j, ref, ref1;\n        if (this.dimension === 'height') {\n            ref = [1, 0], i = ref[0], j = ref[1];\n        }\n        else {\n            ref1 = [0, 1], i = ref1[0], j = ref1[1];\n        }\n        return [i, j];\n    };\n    return Whisker;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar side_panel_1 = require(\"core/layout/side_panel\");\nvar guide_renderer_1 = require(\"../renderers/guide_renderer\");\nvar renderer_1 = require(\"../renderers/renderer\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.AxisView = (function (superClass) {\n    extend(AxisView, superClass);\n    function AxisView() {\n        return AxisView.__super__.constructor.apply(this, arguments);\n    }\n    AxisView.prototype.initialize = function (options) {\n        AxisView.__super__.initialize.call(this, options);\n        this._x_range_name = this.model.x_range_name;\n        return this._y_range_name = this.model.y_range_name;\n    };\n    AxisView.prototype.render = function () {\n        var ctx;\n        if (this.model.visible === false) {\n            return;\n        }\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        this._draw_rule(ctx);\n        this._draw_major_ticks(ctx);\n        this._draw_minor_ticks(ctx);\n        this._draw_major_labels(ctx);\n        this._draw_axis_label(ctx);\n        return ctx.restore();\n    };\n    AxisView.prototype.connect_signals = function () {\n        AxisView.__super__.connect_signals.call(this);\n        return this.connect(this.model.change, (function (_this) {\n            return function () {\n                return _this.plot_view.request_render();\n            };\n        })(this));\n    };\n    AxisView.prototype._get_size = function () {\n        return this._tick_extent() + this._tick_label_extent() + this._axis_label_extent();\n    };\n    AxisView.prototype._draw_rule = function (ctx) {\n        var coords, i, k, nx, ny, ref, ref1, ref2, ref3, ref4, sx, sy, x, xoff, y, yoff;\n        if (!this.visuals.axis_line.doit) {\n            return;\n        }\n        ref = coords = this.model.rule_coords, x = ref[0], y = ref[1];\n        ref1 = this.plot_view.map_to_screen(x, y, this._x_range_name, this._y_range_name), sx = ref1[0], sy = ref1[1];\n        ref2 = this.model.normals, nx = ref2[0], ny = ref2[1];\n        ref3 = this.model.offsets, xoff = ref3[0], yoff = ref3[1];\n        this.visuals.axis_line.set_value(ctx);\n        ctx.beginPath();\n        ctx.moveTo(Math.round(sx[0] + nx * xoff), Math.round(sy[0] + ny * yoff));\n        for (i = k = 1, ref4 = sx.length; 1 <= ref4 ? k < ref4 : k > ref4; i = 1 <= ref4 ? ++k : --k) {\n            ctx.lineTo(Math.round(sx[i] + nx * xoff), Math.round(sy[i] + ny * yoff));\n        }\n        return ctx.stroke();\n    };\n    AxisView.prototype._draw_major_ticks = function (ctx) {\n        var coords, i, k, nx, ny, ref, ref1, ref2, ref3, ref4, results, sx, sy, tin, tout, x, xoff, y, yoff;\n        if (!this.visuals.major_tick_line.doit) {\n            return;\n        }\n        coords = this.model.tick_coords;\n        ref = coords.major, x = ref[0], y = ref[1];\n        ref1 = this.plot_view.map_to_screen(x, y, this._x_range_name, this._y_range_name), sx = ref1[0], sy = ref1[1];\n        ref2 = this.model.normals, nx = ref2[0], ny = ref2[1];\n        ref3 = this.model.offsets, xoff = ref3[0], yoff = ref3[1];\n        tin = this.model.major_tick_in;\n        tout = this.model.major_tick_out;\n        this.visuals.major_tick_line.set_value(ctx);\n        results = [];\n        for (i = k = 0, ref4 = sx.length; 0 <= ref4 ? k < ref4 : k > ref4; i = 0 <= ref4 ? ++k : --k) {\n            ctx.beginPath();\n            ctx.moveTo(Math.round(sx[i] + nx * tout + nx * xoff), Math.round(sy[i] + ny * tout + ny * yoff));\n            ctx.lineTo(Math.round(sx[i] - nx * tin + nx * xoff), Math.round(sy[i] - ny * tin + ny * yoff));\n            results.push(ctx.stroke());\n        }\n        return results;\n    };\n    AxisView.prototype._draw_minor_ticks = function (ctx) {\n        var coords, i, k, nx, ny, ref, ref1, ref2, ref3, ref4, results, sx, sy, tin, tout, x, xoff, y, yoff;\n        if (!this.visuals.minor_tick_line.doit) {\n            return;\n        }\n        coords = this.model.tick_coords;\n        ref = coords.minor, x = ref[0], y = ref[1];\n        ref1 = this.plot_view.map_to_screen(x, y, this._x_range_name, this._y_range_name), sx = ref1[0], sy = ref1[1];\n        ref2 = this.model.normals, nx = ref2[0], ny = ref2[1];\n        ref3 = this.model.offsets, xoff = ref3[0], yoff = ref3[1];\n        tin = this.model.minor_tick_in;\n        tout = this.model.minor_tick_out;\n        this.visuals.minor_tick_line.set_value(ctx);\n        results = [];\n        for (i = k = 0, ref4 = sx.length; 0 <= ref4 ? k < ref4 : k > ref4; i = 0 <= ref4 ? ++k : --k) {\n            ctx.beginPath();\n            ctx.moveTo(Math.round(sx[i] + nx * tout + nx * xoff), Math.round(sy[i] + ny * tout + ny * yoff));\n            ctx.lineTo(Math.round(sx[i] - nx * tin + nx * xoff), Math.round(sy[i] - ny * tin + ny * yoff));\n            results.push(ctx.stroke());\n        }\n        return results;\n    };\n    AxisView.prototype._draw_major_labels = function (ctx) {\n        var angle, coords, dim, i, k, labels, nx, ny, orient, ref, ref1, ref2, ref3, ref4, results, side, standoff, sx, sy, x, xoff, y, yoff;\n        coords = this.model.tick_coords;\n        ref = coords.major, x = ref[0], y = ref[1];\n        ref1 = this.plot_view.map_to_screen(x, y, this._x_range_name, this._y_range_name), sx = ref1[0], sy = ref1[1];\n        ref2 = this.model.normals, nx = ref2[0], ny = ref2[1];\n        ref3 = this.model.offsets, xoff = ref3[0], yoff = ref3[1];\n        dim = this.model.dimension;\n        side = this.model.panel_side;\n        orient = this.model.major_label_orientation;\n        if (types_1.isString(orient)) {\n            angle = this.model.panel.get_label_angle_heuristic(orient);\n        }\n        else {\n            angle = -orient;\n        }\n        standoff = this._tick_extent() + this.model.major_label_standoff;\n        labels = this.model.compute_labels(coords.major[dim]);\n        this.visuals.major_label_text.set_value(ctx);\n        this.model.panel.apply_label_text_heuristics(ctx, orient);\n        results = [];\n        for (i = k = 0, ref4 = sx.length; 0 <= ref4 ? k < ref4 : k > ref4; i = 0 <= ref4 ? ++k : --k) {\n            if (angle) {\n                ctx.translate(sx[i] + nx * standoff + nx * xoff, sy[i] + ny * standoff + ny * yoff);\n                ctx.rotate(angle);\n                ctx.fillText(labels[i], 0, 0);\n                ctx.rotate(-angle);\n                results.push(ctx.translate(-sx[i] - nx * standoff + nx * xoff, -sy[i] - ny * standoff + ny * yoff));\n            }\n            else {\n                results.push(ctx.fillText(labels[i], Math.round(sx[i] + nx * standoff + nx * xoff), Math.round(sy[i] + ny * standoff + ny * yoff)));\n            }\n        }\n        return results;\n    };\n    AxisView.prototype._draw_axis_label = function (ctx) {\n        var angle, label, nx, ny, orient, ref, ref1, ref2, ref3, side, standoff, sx, sy, x, xoff, y, yoff;\n        label = this.model.axis_label;\n        if (label == null) {\n            return;\n        }\n        ref = this.model.rule_coords, x = ref[0], y = ref[1];\n        ref1 = this.plot_view.map_to_screen(x, y, this._x_range_name, this._y_range_name), sx = ref1[0], sy = ref1[1];\n        ref2 = this.model.normals, nx = ref2[0], ny = ref2[1];\n        ref3 = this.model.offsets, xoff = ref3[0], yoff = ref3[1];\n        side = this.model.panel_side;\n        orient = 'parallel';\n        angle = this.model.panel.get_label_angle_heuristic(orient);\n        standoff = this._tick_extent() + this._tick_label_extent() + this.model.axis_label_standoff;\n        sx = (sx[0] + sx[sx.length - 1]) / 2;\n        sy = (sy[0] + sy[sy.length - 1]) / 2;\n        this.visuals.axis_label_text.set_value(ctx);\n        this.model.panel.apply_label_text_heuristics(ctx, orient);\n        x = sx + nx * standoff + nx * xoff;\n        y = sy + ny * standoff + ny * yoff;\n        if (isNaN(x) || isNaN(y)) {\n            return;\n        }\n        if (angle) {\n            ctx.translate(x, y);\n            ctx.rotate(angle);\n            ctx.fillText(label, 0, 0);\n            ctx.rotate(-angle);\n            return ctx.translate(-x, -y);\n        }\n        else {\n            return ctx.fillText(label, x, y);\n        }\n    };\n    AxisView.prototype._tick_extent = function () {\n        return this.model.major_tick_out;\n    };\n    AxisView.prototype._tick_label_extent = function () {\n        var angle, c, coords, ctx, dim, extent, h, hfactor, hscale, i, k, labels, orient, ref, s, side, val, w, wfactor;\n        extent = 0;\n        ctx = this.plot_view.canvas_view.ctx;\n        dim = this.model.dimension;\n        coords = this.model.tick_coords.major;\n        side = this.model.panel_side;\n        orient = this.model.major_label_orientation;\n        labels = this.model.compute_labels(coords[dim]);\n        this.visuals.major_label_text.set_value(ctx);\n        if (types_1.isString(orient)) {\n            hscale = 1;\n            angle = this.model.panel.get_label_angle_heuristic(orient);\n        }\n        else {\n            hscale = 2;\n            angle = -orient;\n        }\n        angle = Math.abs(angle);\n        c = Math.cos(angle);\n        s = Math.sin(angle);\n        if (side === \"above\" || side === \"below\") {\n            wfactor = s;\n            hfactor = c;\n        }\n        else {\n            wfactor = c;\n            hfactor = s;\n        }\n        for (i = k = 0, ref = labels.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            if (labels[i] == null) {\n                continue;\n            }\n            w = ctx.measureText(labels[i]).width * 1.1;\n            h = ctx.measureText(labels[i]).ascent * 0.9;\n            val = w * wfactor + (h / hscale) * hfactor;\n            if (val > extent) {\n                extent = val;\n            }\n        }\n        if (extent > 0) {\n            extent += this.model.major_label_standoff;\n        }\n        return extent;\n    };\n    AxisView.prototype._axis_label_extent = function () {\n        var angle, axis_label, c, ctx, extent, h, orient, s, side, w;\n        extent = 0;\n        side = this.model.panel_side;\n        axis_label = this.model.axis_label;\n        orient = 'parallel';\n        ctx = this.plot_view.canvas_view.ctx;\n        this.visuals.axis_label_text.set_value(ctx);\n        angle = Math.abs(this.model.panel.get_label_angle_heuristic(orient));\n        c = Math.cos(angle);\n        s = Math.sin(angle);\n        if (axis_label) {\n            extent += this.model.axis_label_standoff;\n            this.visuals.axis_label_text.set_value(ctx);\n            w = ctx.measureText(axis_label).width * 1.1;\n            h = ctx.measureText(axis_label).ascent * 0.9;\n            if (side === \"above\" || side === \"below\") {\n                extent += w * s + h * c;\n            }\n            else {\n                extent += w * c + h * s;\n            }\n        }\n        return extent;\n    };\n    return AxisView;\n})(renderer_1.RendererView);\nexports.Axis = (function (superClass) {\n    extend(Axis, superClass);\n    function Axis() {\n        return Axis.__super__.constructor.apply(this, arguments);\n    }\n    Axis.prototype.default_view = exports.AxisView;\n    Axis.prototype.type = 'Axis';\n    Axis.mixins(['line:axis_', 'line:major_tick_', 'line:minor_tick_', 'text:major_label_', 'text:axis_label_']);\n    Axis.define({\n        bounds: [p.Any, 'auto'],\n        ticker: [p.Instance, null],\n        formatter: [p.Instance, null],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default'],\n        axis_label: [p.String, ''],\n        axis_label_standoff: [p.Int, 5],\n        major_label_standoff: [p.Int, 5],\n        major_label_orientation: [p.Any, \"horizontal\"],\n        major_label_overrides: [p.Any, {}],\n        major_tick_in: [p.Number, 2],\n        major_tick_out: [p.Number, 6],\n        minor_tick_in: [p.Number, 0],\n        minor_tick_out: [p.Number, 4]\n    });\n    Axis.override({\n        axis_line_color: 'black',\n        major_tick_line_color: 'black',\n        minor_tick_line_color: 'black',\n        major_label_text_font_size: \"8pt\",\n        major_label_text_align: \"center\",\n        major_label_text_baseline: \"alphabetic\",\n        axis_label_text_font_size: \"10pt\",\n        axis_label_text_font_style: \"italic\"\n    });\n    Axis.internal({\n        panel_side: [p.Any]\n    });\n    Axis.prototype.compute_labels = function (ticks) {\n        var i, k, labels, ref;\n        labels = this.formatter.doFormat(ticks, this);\n        for (i = k = 0, ref = ticks.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            if (ticks[i] in this.major_label_overrides) {\n                labels[i] = this.major_label_overrides[ticks[i]];\n            }\n        }\n        return labels;\n    };\n    Axis.getters({\n        computed_bounds: function () {\n            return this._computed_bounds();\n        },\n        rule_coords: function () {\n            return this._rule_coords();\n        },\n        tick_coords: function () {\n            return this._tick_coords();\n        },\n        ranges: function () {\n            return this._ranges();\n        },\n        normals: function () {\n            return this.panel._normals;\n        },\n        dimension: function () {\n            return this.panel._dim;\n        },\n        offsets: function () {\n            return this._offsets();\n        },\n        loc: function () {\n            return this._get_loc();\n        }\n    });\n    Axis.prototype.add_panel = function (side) {\n        this.panel = new side_panel_1.SidePanel({\n            side: side\n        });\n        this.panel.attach_document(this.document);\n        return this.panel_side = side;\n    };\n    Axis.prototype._offsets = function () {\n        var frame, ref, side, xoff, yoff;\n        side = this.panel_side;\n        ref = [0, 0], xoff = ref[0], yoff = ref[1];\n        frame = this.plot.plot_canvas.frame;\n        switch (side) {\n            case \"below\":\n                yoff = Math.abs(this.panel._top.value - frame._bottom.value);\n                break;\n            case \"above\":\n                yoff = Math.abs(this.panel._bottom.value - frame._top.value);\n                break;\n            case \"right\":\n                xoff = Math.abs(this.panel._left.value - frame._right.value);\n                break;\n            case \"left\":\n                xoff = Math.abs(this.panel._right.value - frame._left.value);\n        }\n        return [xoff, yoff];\n    };\n    Axis.prototype._ranges = function () {\n        var frame, i, j, ranges;\n        i = this.dimension;\n        j = (i + 1) % 2;\n        frame = this.plot.plot_canvas.frame;\n        ranges = [frame.x_ranges[this.x_range_name], frame.y_ranges[this.y_range_name]];\n        return [ranges[i], ranges[j]];\n    };\n    Axis.prototype._computed_bounds = function () {\n        var cross_range, end, range, range_bounds, ref, ref1, start, user_bounds;\n        ref = this.ranges, range = ref[0], cross_range = ref[1];\n        user_bounds = (ref1 = this.bounds) != null ? ref1 : 'auto';\n        range_bounds = [range.min, range.max];\n        if (user_bounds === 'auto') {\n            return range_bounds;\n        }\n        if (types_1.isArray(user_bounds)) {\n            if (Math.abs(user_bounds[0] - user_bounds[1]) > Math.abs(range_bounds[0] - range_bounds[1])) {\n                start = Math.max(Math.min(user_bounds[0], user_bounds[1]), range_bounds[0]);\n                end = Math.min(Math.max(user_bounds[0], user_bounds[1]), range_bounds[1]);\n            }\n            else {\n                start = Math.min(user_bounds[0], user_bounds[1]);\n                end = Math.max(user_bounds[0], user_bounds[1]);\n            }\n            return [start, end];\n        }\n        logging_1.logger.error(\"user bounds '\" + user_bounds + \"' not understood\");\n        return null;\n    };\n    Axis.prototype._rule_coords = function () {\n        var coords, cross_range, end, i, j, range, ref, ref1, start, xs, ys;\n        i = this.dimension;\n        j = (i + 1) % 2;\n        ref = this.ranges, range = ref[0], cross_range = ref[1];\n        ref1 = this.computed_bounds, start = ref1[0], end = ref1[1];\n        xs = new Array(2);\n        ys = new Array(2);\n        coords = [xs, ys];\n        coords[i][0] = Math.max(start, range.min);\n        coords[i][1] = Math.min(end, range.max);\n        if (coords[i][0] > coords[i][1]) {\n            coords[i][0] = coords[i][1] = 0 / 0;\n        }\n        coords[j][0] = this.loc;\n        coords[j][1] = this.loc;\n        return coords;\n    };\n    Axis.prototype._tick_coords = function () {\n        var coords, cross_range, end, i, ii, j, k, l, m, majors, minor_coords, minor_xs, minor_ys, minors, range, range_max, range_min, ref, ref1, ref2, ref3, ref4, ref5, start, ticks, xs, ys;\n        i = this.dimension;\n        j = (i + 1) % 2;\n        ref = this.ranges, range = ref[0], cross_range = ref[1];\n        ref1 = this.computed_bounds, start = ref1[0], end = ref1[1];\n        ticks = this.ticker.get_ticks(start, end, range, this.loc, {});\n        majors = ticks.major;\n        minors = ticks.minor;\n        xs = [];\n        ys = [];\n        coords = [xs, ys];\n        minor_xs = [];\n        minor_ys = [];\n        minor_coords = [minor_xs, minor_ys];\n        if (range.type === \"FactorRange\") {\n            for (ii = k = 0, ref2 = majors.length; 0 <= ref2 ? k < ref2 : k > ref2; ii = 0 <= ref2 ? ++k : --k) {\n                coords[i].push(majors[ii]);\n                coords[j].push(this.loc);\n            }\n        }\n        else {\n            ref3 = [range.min, range.max], range_min = ref3[0], range_max = ref3[1];\n            for (ii = l = 0, ref4 = majors.length; 0 <= ref4 ? l < ref4 : l > ref4; ii = 0 <= ref4 ? ++l : --l) {\n                if (majors[ii] < range_min || majors[ii] > range_max) {\n                    continue;\n                }\n                coords[i].push(majors[ii]);\n                coords[j].push(this.loc);\n            }\n            for (ii = m = 0, ref5 = minors.length; 0 <= ref5 ? m < ref5 : m > ref5; ii = 0 <= ref5 ? ++m : --m) {\n                if (minors[ii] < range_min || minors[ii] > range_max) {\n                    continue;\n                }\n                minor_coords[i].push(minors[ii]);\n                minor_coords[j].push(this.loc);\n            }\n        }\n        return {\n            \"major\": coords,\n            \"minor\": minor_coords\n        };\n    };\n    Axis.prototype._get_loc = function () {\n        var cend, cross_range, cstart, range, ref, side;\n        ref = this.ranges, range = ref[0], cross_range = ref[1];\n        cstart = cross_range.start;\n        cend = cross_range.end;\n        side = this.panel_side;\n        switch (side) {\n            case 'left':\n            case 'below':\n                return cross_range.start;\n            case 'right':\n            case 'above':\n                return cross_range.end;\n        }\n    };\n    return Axis;\n})(guide_renderer_1.GuideRenderer);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar axis_1 = require(\"./axis\");\nvar categorical_tick_formatter_1 = require(\"../formatters/categorical_tick_formatter\");\nvar categorical_ticker_1 = require(\"../tickers/categorical_ticker\");\nvar logging_1 = require(\"core/logging\");\nexports.CategoricalAxisView = (function (superClass) {\n    extend(CategoricalAxisView, superClass);\n    function CategoricalAxisView() {\n        return CategoricalAxisView.__super__.constructor.apply(this, arguments);\n    }\n    return CategoricalAxisView;\n})(axis_1.AxisView);\nexports.CategoricalAxis = (function (superClass) {\n    extend(CategoricalAxis, superClass);\n    function CategoricalAxis() {\n        return CategoricalAxis.__super__.constructor.apply(this, arguments);\n    }\n    CategoricalAxis.prototype.default_view = exports.CategoricalAxisView;\n    CategoricalAxis.prototype.type = 'CategoricalAxis';\n    CategoricalAxis.override({\n        ticker: function () {\n            return new categorical_ticker_1.CategoricalTicker();\n        },\n        formatter: function () {\n            return new categorical_tick_formatter_1.CategoricalTickFormatter();\n        }\n    });\n    CategoricalAxis.prototype._computed_bounds = function () {\n        var cross_range, range, range_bounds, ref, ref1, user_bounds;\n        ref = this.ranges, range = ref[0], cross_range = ref[1];\n        user_bounds = (ref1 = this.bounds) != null ? ref1 : 'auto';\n        range_bounds = [range.min, range.max];\n        if (user_bounds !== 'auto') {\n            logging_1.logger.warn(\"Categorical Axes only support user_bounds='auto', ignoring\");\n        }\n        return range_bounds;\n    };\n    return CategoricalAxis;\n})(axis_1.Axis);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar axis_1 = require(\"./axis\");\nexports.ContinuousAxis = (function (superClass) {\n    extend(ContinuousAxis, superClass);\n    function ContinuousAxis() {\n        return ContinuousAxis.__super__.constructor.apply(this, arguments);\n    }\n    ContinuousAxis.prototype.type = 'ContinuousAxis';\n    return ContinuousAxis;\n})(axis_1.Axis);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar linear_axis_1 = require(\"./linear_axis\");\nvar datetime_tick_formatter_1 = require(\"../formatters/datetime_tick_formatter\");\nvar datetime_ticker_1 = require(\"../tickers/datetime_ticker\");\nexports.DatetimeAxisView = (function (superClass) {\n    extend(DatetimeAxisView, superClass);\n    function DatetimeAxisView() {\n        return DatetimeAxisView.__super__.constructor.apply(this, arguments);\n    }\n    return DatetimeAxisView;\n})(linear_axis_1.LinearAxisView);\nexports.DatetimeAxis = (function (superClass) {\n    extend(DatetimeAxis, superClass);\n    function DatetimeAxis() {\n        return DatetimeAxis.__super__.constructor.apply(this, arguments);\n    }\n    DatetimeAxis.prototype.default_view = exports.DatetimeAxisView;\n    DatetimeAxis.prototype.type = 'DatetimeAxis';\n    DatetimeAxis.override({\n        ticker: function () {\n            return new datetime_ticker_1.DatetimeTicker();\n        },\n        formatter: function () {\n            return new datetime_tick_formatter_1.DatetimeTickFormatter();\n        }\n    });\n    return DatetimeAxis;\n})(linear_axis_1.LinearAxis);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar axis_1 = require(\"./axis\");\nexports.Axis = axis_1.Axis;\nvar categorical_axis_1 = require(\"./categorical_axis\");\nexports.CategoricalAxis = categorical_axis_1.CategoricalAxis;\nvar continuous_axis_1 = require(\"./continuous_axis\");\nexports.ContinuousAxis = continuous_axis_1.ContinuousAxis;\nvar datetime_axis_1 = require(\"./datetime_axis\");\nexports.DatetimeAxis = datetime_axis_1.DatetimeAxis;\nvar linear_axis_1 = require(\"./linear_axis\");\nexports.LinearAxis = linear_axis_1.LinearAxis;\nvar log_axis_1 = require(\"./log_axis\");\nexports.LogAxis = log_axis_1.LogAxis;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar axis_1 = require(\"./axis\");\nvar continuous_axis_1 = require(\"./continuous_axis\");\nvar basic_tick_formatter_1 = require(\"../formatters/basic_tick_formatter\");\nvar basic_ticker_1 = require(\"../tickers/basic_ticker\");\nexports.LinearAxisView = (function (superClass) {\n    extend(LinearAxisView, superClass);\n    function LinearAxisView() {\n        return LinearAxisView.__super__.constructor.apply(this, arguments);\n    }\n    return LinearAxisView;\n})(axis_1.AxisView);\nexports.LinearAxis = (function (superClass) {\n    extend(LinearAxis, superClass);\n    function LinearAxis() {\n        return LinearAxis.__super__.constructor.apply(this, arguments);\n    }\n    LinearAxis.prototype.default_view = exports.LinearAxisView;\n    LinearAxis.prototype.type = 'LinearAxis';\n    LinearAxis.override({\n        ticker: function () {\n            return new basic_ticker_1.BasicTicker();\n        },\n        formatter: function () {\n            return new basic_tick_formatter_1.BasicTickFormatter();\n        }\n    });\n    return LinearAxis;\n})(continuous_axis_1.ContinuousAxis);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar axis_1 = require(\"./axis\");\nvar continuous_axis_1 = require(\"./continuous_axis\");\nvar log_tick_formatter_1 = require(\"../formatters/log_tick_formatter\");\nvar log_ticker_1 = require(\"../tickers/log_ticker\");\nexports.LogAxisView = (function (superClass) {\n    extend(LogAxisView, superClass);\n    function LogAxisView() {\n        return LogAxisView.__super__.constructor.apply(this, arguments);\n    }\n    return LogAxisView;\n})(axis_1.AxisView);\nexports.LogAxis = (function (superClass) {\n    extend(LogAxis, superClass);\n    function LogAxis() {\n        return LogAxis.__super__.constructor.apply(this, arguments);\n    }\n    LogAxis.prototype.default_view = exports.LogAxisView;\n    LogAxis.prototype.type = 'LogAxis';\n    LogAxis.override({\n        ticker: function () {\n            return new log_ticker_1.LogTicker();\n        },\n        formatter: function () {\n            return new log_tick_formatter_1.LogTickFormatter();\n        }\n    });\n    return LogAxis;\n})(continuous_axis_1.ContinuousAxis);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, slice = [].slice;\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nvar model_1 = require(\"../../model\");\nexports.CustomJS = (function (superClass) {\n    extend(CustomJS, superClass);\n    function CustomJS() {\n        return CustomJS.__super__.constructor.apply(this, arguments);\n    }\n    CustomJS.prototype.type = 'CustomJS';\n    CustomJS.define({\n        args: [p.Any, {}],\n        code: [p.String, '']\n    });\n    CustomJS.getters({\n        values: function () {\n            return this._make_values();\n        },\n        func: function () {\n            return this._make_func();\n        }\n    });\n    CustomJS.prototype.execute = function (cb_obj, cb_data) {\n        return this.func.apply(cb_obj, this.values.concat(cb_obj, cb_data, require, {}));\n    };\n    CustomJS.prototype._make_values = function () {\n        return object_1.values(this.args);\n    };\n    CustomJS.prototype._make_func = function () {\n        return (function (func, args, ctor) {\n            ctor.prototype = func.prototype;\n            var child = new ctor, result = func.apply(child, args);\n            return Object(result) === result ? result : child;\n        })(Function, slice.call(Object.keys(this.args)).concat([\"cb_obj\"], [\"cb_data\"], [\"require\"], [\"exports\"], [this.code]), function () { });\n    };\n    return CustomJS;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar customjs_1 = require(\"./customjs\");\nexports.CustomJS = customjs_1.CustomJS;\nvar open_url_1 = require(\"./open_url\");\nexports.OpenURL = open_url_1.OpenURL;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nvar p = require(\"core/properties\");\nvar selection_1 = require(\"core/util/selection\");\nvar templating_1 = require(\"core/util/templating\");\nexports.OpenURL = (function (superClass) {\n    extend(OpenURL, superClass);\n    function OpenURL() {\n        return OpenURL.__super__.constructor.apply(this, arguments);\n    }\n    OpenURL.prototype.type = 'OpenURL';\n    OpenURL.define({\n        url: [p.String, 'http://']\n    });\n    OpenURL.prototype.execute = function (data_source) {\n        var i, j, len, ref, url;\n        ref = selection_1.get_indices(data_source);\n        for (j = 0, len = ref.length; j < len; j++) {\n            i = ref[j];\n            url = templating_1.replace_placeholders(this.url, data_source, i);\n            window.open(url);\n        }\n        return null;\n    };\n    return OpenURL;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar layout_canvas_1 = require(\"core/layout/layout_canvas\");\nvar dom_view_1 = require(\"core/dom_view\");\nvar solver_1 = require(\"core/layout/solver\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar dom_1 = require(\"core/dom\");\nvar canvas_1 = require(\"core/util/canvas\");\nvar canvas2svg = require(\"canvas2svg\");\nif (window.CanvasPixelArray != null) {\n    CanvasPixelArray.prototype.set = function (arr) {\n        var i, j, ref, results;\n        results = [];\n        for (i = j = 0, ref = this.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            results.push(this[i] = arr[i]);\n        }\n        return results;\n    };\n}\nexports.CanvasView = (function (superClass) {\n    extend(CanvasView, superClass);\n    function CanvasView() {\n        return CanvasView.__super__.constructor.apply(this, arguments);\n    }\n    CanvasView.prototype.className = \"bk-canvas-wrapper\";\n    CanvasView.prototype.initialize = function (options) {\n        CanvasView.__super__.initialize.call(this, options);\n        this.map_el = this.model.map ? this.el.appendChild(dom_1.div({\n            \"class\": \"bk-canvas-map\"\n        })) : null;\n        this.events_el = this.el.appendChild(dom_1.div({\n            \"class\": \"bk-canvas-events\"\n        }));\n        this.overlays_el = this.el.appendChild(dom_1.div({\n            \"class\": \"bk-canvas-overlays\"\n        }));\n        switch (this.model.output_backend) {\n            case \"canvas\":\n            case \"webgl\":\n                this.canvas_el = this.el.appendChild(dom_1.canvas({\n                    \"class\": \"bk-canvas\"\n                }));\n                this._ctx = this.canvas_el.getContext('2d');\n                break;\n            case \"svg\":\n                this._ctx = new canvas2svg();\n                this.canvas_el = this.el.appendChild(this._ctx.getSvg());\n        }\n        this.ctx = this.get_ctx();\n        canvas_1.fixup_ctx(this.ctx);\n        return logging_1.logger.debug(\"CanvasView initialized\");\n    };\n    CanvasView.prototype.get_ctx = function () {\n        return this._ctx;\n    };\n    CanvasView.prototype.get_canvas_element = function () {\n        return this.canvas_el;\n    };\n    CanvasView.prototype.prepare_canvas = function () {\n        var height, pixel_ratio, width;\n        width = this.model._width.value;\n        height = this.model._height.value;\n        this.el.style.width = width + \"px\";\n        this.el.style.height = height + \"px\";\n        pixel_ratio = canvas_1.get_scale_ratio(this.ctx, this.model.use_hidpi, this.model.output_backend);\n        this.model.pixel_ratio = pixel_ratio;\n        this.canvas_el.style.width = width + \"px\";\n        this.canvas_el.style.height = height + \"px\";\n        this.canvas_el.setAttribute('width', width * pixel_ratio);\n        this.canvas_el.setAttribute('height', height * pixel_ratio);\n        return logging_1.logger.debug(\"Rendering CanvasView with width: \" + width + \", height: \" + height + \", pixel ratio: \" + pixel_ratio);\n    };\n    CanvasView.prototype.set_dims = function (arg) {\n        var height, width;\n        width = arg[0], height = arg[1];\n        if (width === 0 || height === 0) {\n            return;\n        }\n        if ((this._width_constraint != null) && this.solver.has_constraint(this._width_constraint)) {\n            this.solver.remove_constraint(this._width_constraint);\n        }\n        if ((this._height_constraint != null) && this.solver.has_constraint(this._height_constraint)) {\n            this.solver.remove_constraint(this._height_constraint);\n        }\n        this._width_constraint = solver_1.EQ(this.model._width, -width);\n        this.solver.add_constraint(this._width_constraint);\n        this._height_constraint = solver_1.EQ(this.model._height, -height);\n        this.solver.add_constraint(this._height_constraint);\n        return this.solver.update_variables();\n    };\n    return CanvasView;\n})(dom_view_1.DOMView);\nexports.Canvas = (function (superClass) {\n    extend(Canvas, superClass);\n    function Canvas() {\n        return Canvas.__super__.constructor.apply(this, arguments);\n    }\n    Canvas.prototype.type = 'Canvas';\n    Canvas.prototype.default_view = exports.CanvasView;\n    Canvas.internal({\n        map: [p.Boolean, false],\n        initial_width: [p.Number],\n        initial_height: [p.Number],\n        use_hidpi: [p.Boolean, true],\n        pixel_ratio: [p.Number, 1],\n        output_backend: [p.OutputBackend, \"canvas\"]\n    });\n    Canvas.prototype.initialize = function (attrs, options) {\n        Canvas.__super__.initialize.call(this, attrs, options);\n        return this.panel = this;\n    };\n    Canvas.prototype.vx_to_sx = function (x) {\n        return x;\n    };\n    Canvas.prototype.vy_to_sy = function (y) {\n        return this._height.value - (y + 1);\n    };\n    Canvas.prototype.v_vx_to_sx = function (xx) {\n        return new Float64Array(xx);\n    };\n    Canvas.prototype.v_vy_to_sy = function (yy) {\n        var _yy, height, idx, j, len, y;\n        _yy = new Float64Array(yy.length);\n        height = this._height.value;\n        for (idx = j = 0, len = yy.length; j < len; idx = ++j) {\n            y = yy[idx];\n            _yy[idx] = height - (y + 1);\n        }\n        return _yy;\n    };\n    Canvas.prototype.sx_to_vx = function (x) {\n        return x;\n    };\n    Canvas.prototype.sy_to_vy = function (y) {\n        return this._height.value - (y + 1);\n    };\n    Canvas.prototype.v_sx_to_vx = function (xx) {\n        return new Float64Array(xx);\n    };\n    Canvas.prototype.v_sy_to_vy = function (yy) {\n        var _yy, height, idx, j, len, y;\n        _yy = new Float64Array(yy.length);\n        height = this._height.value;\n        for (idx = j = 0, len = yy.length; j < len; idx = ++j) {\n            y = yy[idx];\n            _yy[idx] = height - (y + 1);\n        }\n        return _yy;\n    };\n    Canvas.prototype.get_constraints = function () {\n        return Canvas.__super__.get_constraints.call(this).concat([solver_1.GE(this._top), solver_1.GE(this._bottom), solver_1.GE(this._left), solver_1.GE(this._right), solver_1.GE(this._width), solver_1.GE(this._height), solver_1.EQ(this._width, [-1, this._right]), solver_1.EQ(this._height, [-1, this._top])]);\n    };\n    return Canvas;\n})(layout_canvas_1.LayoutCanvas);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar categorical_scale_1 = require(\"../scales/categorical_scale\");\nvar linear_scale_1 = require(\"../scales/linear_scale\");\nvar log_scale_1 = require(\"../scales/log_scale\");\nvar range1d_1 = require(\"../ranges/range1d\");\nvar data_range1d_1 = require(\"../ranges/data_range1d\");\nvar factor_range_1 = require(\"../ranges/factor_range\");\nvar solver_1 = require(\"core/layout/solver\");\nvar layout_canvas_1 = require(\"core/layout/layout_canvas\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nexports.CartesianFrame = (function (superClass) {\n    extend(CartesianFrame, superClass);\n    function CartesianFrame() {\n        return CartesianFrame.__super__.constructor.apply(this, arguments);\n    }\n    CartesianFrame.prototype.type = 'CartesianFrame';\n    CartesianFrame.prototype.initialize = function (attrs, options) {\n        CartesianFrame.__super__.initialize.call(this, attrs, options);\n        this.panel = this;\n        this._configure_scales();\n        this.connect(this.change, (function (_this) {\n            return function () {\n                return _this._configure_scales();\n            };\n        })(this));\n        return null;\n    };\n    CartesianFrame.prototype.contains = function (vx, vy) {\n        return vx >= this._left.value && vx <= this._right.value && vy >= this._bottom.value && vy <= this._top.value;\n    };\n    CartesianFrame.prototype.map_to_screen = function (x, y, canvas, x_name, y_name) {\n        var sx, sy, vx, vy;\n        if (x_name == null) {\n            x_name = 'default';\n        }\n        if (y_name == null) {\n            y_name = 'default';\n        }\n        vx = this.xscales[x_name].v_compute(x);\n        sx = canvas.v_vx_to_sx(vx);\n        vy = this.yscales[y_name].v_compute(y);\n        sy = canvas.v_vy_to_sy(vy);\n        return [sx, sy];\n    };\n    CartesianFrame.prototype._get_ranges = function (range, extra_ranges) {\n        var extra_range, name, ranges;\n        ranges = {};\n        ranges['default'] = range;\n        if (extra_ranges != null) {\n            for (name in extra_ranges) {\n                extra_range = extra_ranges[name];\n                ranges[name] = extra_range;\n            }\n        }\n        return ranges;\n    };\n    CartesianFrame.prototype._get_scales = function (scale, ranges, frame_range) {\n        var name, range, s, scales;\n        scales = {};\n        for (name in ranges) {\n            range = ranges[name];\n            if (range instanceof data_range1d_1.DataRange1d || range instanceof range1d_1.Range1d) {\n                if (!(scale instanceof log_scale_1.LogScale) && !(scale instanceof linear_scale_1.LinearScale)) {\n                    throw new Error(\"Range \" + range.type + \" is incompatible is Scale \" + scale.type);\n                }\n                if (scale instanceof categorical_scale_1.CategoricalScale) {\n                    throw new Error(\"Range \" + range.type + \" is incompatible is Scale \" + scale.type);\n                }\n            }\n            if (range instanceof factor_range_1.FactorRange) {\n                if (!(scale instanceof categorical_scale_1.CategoricalScale)) {\n                    throw new Error(\"Range \" + range.type + \" is incompatible is Scale \" + scale.type);\n                }\n            }\n            if (scale instanceof log_scale_1.LogScale && range instanceof data_range1d_1.DataRange1d) {\n                range.scale_hint = \"log\";\n            }\n            s = scale.clone();\n            s.setv({\n                source_range: range,\n                target_range: frame_range\n            });\n            scales[name] = s;\n        }\n        return scales;\n    };\n    CartesianFrame.prototype._configure_frame_ranges = function () {\n        this._h_range = new range1d_1.Range1d({\n            start: this._left.value,\n            end: this._left.value + this._width.value\n        });\n        return this._v_range = new range1d_1.Range1d({\n            start: this._bottom.value,\n            end: this._bottom.value + this._height.value\n        });\n    };\n    CartesianFrame.prototype._configure_scales = function () {\n        this._configure_frame_ranges();\n        this._x_ranges = this._get_ranges(this.x_range, this.extra_x_ranges);\n        this._y_ranges = this._get_ranges(this.y_range, this.extra_y_ranges);\n        this._xscales = this._get_scales(this.x_scale, this._x_ranges, this._h_range);\n        return this._yscales = this._get_scales(this.y_scale, this._y_ranges, this._v_range);\n    };\n    CartesianFrame.prototype._update_scales = function () {\n        var name, ref, ref1, scale;\n        this._configure_frame_ranges();\n        ref = this._xscales;\n        for (name in ref) {\n            scale = ref[name];\n            scale.target_range = this._h_range;\n        }\n        ref1 = this._yscales;\n        for (name in ref1) {\n            scale = ref1[name];\n            scale.target_range = this._v_range;\n        }\n        return null;\n    };\n    CartesianFrame.getters({\n        h_range: function () {\n            return this._h_range;\n        },\n        v_range: function () {\n            return this._v_range;\n        },\n        x_ranges: function () {\n            return this._x_ranges;\n        },\n        y_ranges: function () {\n            return this._y_ranges;\n        },\n        xscales: function () {\n            return this._xscales;\n        },\n        yscales: function () {\n            return this._yscales;\n        },\n        x_mappers: function () {\n            logging_1.logger.warn(\"x_mappers attr is deprecated, use xscales\");\n            return this._xscales;\n        },\n        y_mappers: function () {\n            logging_1.logger.warn(\"y_mappers attr is deprecated, use yscales\");\n            return this._yscales;\n        }\n    });\n    CartesianFrame.internal({\n        extra_x_ranges: [p.Any, {}],\n        extra_y_ranges: [p.Any, {}],\n        x_range: [p.Instance],\n        y_range: [p.Instance],\n        x_scale: [p.Instance],\n        y_scale: [p.Instance]\n    });\n    CartesianFrame.prototype.get_constraints = function () {\n        return [solver_1.GE(this._top), solver_1.GE(this._bottom), solver_1.GE(this._left), solver_1.GE(this._right), solver_1.GE(this._width), solver_1.GE(this._height), solver_1.EQ(this._left, this._width, [-1, this._right]), solver_1.EQ(this._bottom, this._height, [-1, this._top])];\n    };\n    return CartesianFrame;\n})(layout_canvas_1.LayoutCanvas);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar canvas_1 = require(\"./canvas\");\nexports.Canvas = canvas_1.Canvas;\nvar cartesian_frame_1 = require(\"./cartesian_frame\");\nexports.CartesianFrame = cartesian_frame_1.CartesianFrame;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar tick_formatter_1 = require(\"./tick_formatter\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.BasicTickFormatter = (function (superClass) {\n    extend(BasicTickFormatter, superClass);\n    function BasicTickFormatter() {\n        return BasicTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    BasicTickFormatter.prototype.type = 'BasicTickFormatter';\n    BasicTickFormatter.define({\n        precision: [p.Any, 'auto'],\n        use_scientific: [p.Bool, true],\n        power_limit_high: [p.Number, 5],\n        power_limit_low: [p.Number, -3]\n    });\n    BasicTickFormatter.getters({\n        scientific_limit_low: function () {\n            return Math.pow(10.0, this.power_limit_low);\n        },\n        scientific_limit_high: function () {\n            return Math.pow(10.0, this.power_limit_high);\n        }\n    });\n    BasicTickFormatter.prototype.initialize = function (attrs, options) {\n        BasicTickFormatter.__super__.initialize.call(this, attrs, options);\n        return this.last_precision = 3;\n    };\n    BasicTickFormatter.prototype.doFormat = function (ticks, axis) {\n        var i, is_ok, j, k, l, labels, len, m, n, need_sci, o, precision, ref, ref1, ref2, ref3, ref4, tick, tick_abs, x, zero_eps;\n        if (ticks.length === 0) {\n            return [];\n        }\n        zero_eps = 0;\n        if (ticks.length >= 2) {\n            zero_eps = Math.abs(ticks[1] - ticks[0]) / 10000;\n        }\n        need_sci = false;\n        if (this.use_scientific) {\n            for (j = 0, len = ticks.length; j < len; j++) {\n                tick = ticks[j];\n                tick_abs = Math.abs(tick);\n                if (tick_abs > zero_eps && (tick_abs >= this.scientific_limit_high || tick_abs <= this.scientific_limit_low)) {\n                    need_sci = true;\n                    break;\n                }\n            }\n        }\n        precision = this.precision;\n        if ((precision == null) || types_1.isNumber(precision)) {\n            labels = new Array(ticks.length);\n            if (need_sci) {\n                for (i = k = 0, ref = ticks.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n                    labels[i] = ticks[i].toExponential(precision || void 0);\n                }\n            }\n            else {\n                for (i = l = 0, ref1 = ticks.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {\n                    labels[i] = ticks[i].toFixed(precision || void 0).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\");\n                }\n            }\n            return labels;\n        }\n        else if (precision === 'auto') {\n            labels = new Array(ticks.length);\n            for (x = m = ref2 = this.last_precision; ref2 <= 15 ? m <= 15 : m >= 15; x = ref2 <= 15 ? ++m : --m) {\n                is_ok = true;\n                if (need_sci) {\n                    for (i = n = 0, ref3 = ticks.length; 0 <= ref3 ? n < ref3 : n > ref3; i = 0 <= ref3 ? ++n : --n) {\n                        labels[i] = ticks[i].toExponential(x);\n                        if (i > 0) {\n                            if (labels[i] === labels[i - 1]) {\n                                is_ok = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (is_ok) {\n                        break;\n                    }\n                }\n                else {\n                    for (i = o = 0, ref4 = ticks.length; 0 <= ref4 ? o < ref4 : o > ref4; i = 0 <= ref4 ? ++o : --o) {\n                        labels[i] = ticks[i].toFixed(x).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\");\n                        if (i > 0) {\n                            if (labels[i] === labels[i - 1]) {\n                                is_ok = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (is_ok) {\n                        break;\n                    }\n                }\n                if (is_ok) {\n                    this.last_precision = x;\n                    return labels;\n                }\n            }\n        }\n        return labels;\n    };\n    return BasicTickFormatter;\n})(tick_formatter_1.TickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar tick_formatter_1 = require(\"./tick_formatter\");\nexports.CategoricalTickFormatter = (function (superClass) {\n    extend(CategoricalTickFormatter, superClass);\n    function CategoricalTickFormatter() {\n        return CategoricalTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    CategoricalTickFormatter.prototype.type = 'CategoricalTickFormatter';\n    CategoricalTickFormatter.prototype.doFormat = function (ticks, axis) {\n        return ticks;\n    };\n    return CategoricalTickFormatter;\n})(tick_formatter_1.TickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _array, _strftime, _us, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar SPrintf = require(\"sprintf\");\nvar tz = require(\"timezone\");\nvar tick_formatter_1 = require(\"./tick_formatter\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nvar types_1 = require(\"core/util/types\");\n_us = function (t) {\n    return Math.round(((t / 1000) % 1) * 1000000);\n};\n_array = function (t) {\n    return tz(t, \"%Y %m %d %H %M %S\").split(/\\s+/).map(function (e) {\n        return parseInt(e, 10);\n    });\n};\n_strftime = function (t, format) {\n    var microsecond_replacement_string;\n    if (types_1.isFunction(format)) {\n        return format(t);\n    }\n    else {\n        microsecond_replacement_string = SPrintf.sprintf(\"$1%06d\", _us(t));\n        format = format.replace(/((^|[^%])(%%)*)%f/, microsecond_replacement_string);\n        if (format.indexOf(\"%\") === -1) {\n            return format;\n        }\n        return tz(t, format);\n    }\n};\nexports.DatetimeTickFormatter = (function (superClass) {\n    extend(DatetimeTickFormatter, superClass);\n    function DatetimeTickFormatter() {\n        return DatetimeTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    DatetimeTickFormatter.prototype.type = 'DatetimeTickFormatter';\n    DatetimeTickFormatter.define({\n        microseconds: [p.Array, ['%fus']],\n        milliseconds: [p.Array, ['%3Nms', '%S.%3Ns']],\n        seconds: [p.Array, ['%Ss']],\n        minsec: [p.Array, [':%M:%S']],\n        minutes: [p.Array, [':%M', '%Mm']],\n        hourmin: [p.Array, ['%H:%M']],\n        hours: [p.Array, ['%Hh', '%H:%M']],\n        days: [p.Array, ['%m/%d', '%a%d']],\n        months: [p.Array, ['%m/%Y', '%b%y']],\n        years: [p.Array, ['%Y']]\n    });\n    DatetimeTickFormatter.prototype.format_order = ['microseconds', 'milliseconds', 'seconds', 'minsec', 'minutes', 'hourmin', 'hours', 'days', 'months', 'years'];\n    DatetimeTickFormatter.prototype.strip_leading_zeros = true;\n    DatetimeTickFormatter.prototype.initialize = function (attrs, options) {\n        DatetimeTickFormatter.__super__.initialize.call(this, attrs, options);\n        return this._update_width_formats();\n    };\n    DatetimeTickFormatter.prototype._update_width_formats = function () {\n        var _widths, now;\n        now = tz(new Date());\n        _widths = function (fmt_strings) {\n            var fmt_string, sizes, sorted;\n            sizes = (function () {\n                var j, len, results;\n                results = [];\n                for (j = 0, len = fmt_strings.length; j < len; j++) {\n                    fmt_string = fmt_strings[j];\n                    results.push(_strftime(now, fmt_string).length);\n                }\n                return results;\n            })();\n            sorted = array_1.sortBy(array_1.zip(sizes, fmt_strings), function (arg) {\n                var fmt, size;\n                size = arg[0], fmt = arg[1];\n                return size;\n            });\n            return array_1.unzip(sorted);\n        };\n        return this._width_formats = {\n            microseconds: _widths(this.microseconds),\n            milliseconds: _widths(this.milliseconds),\n            seconds: _widths(this.seconds),\n            minsec: _widths(this.minsec),\n            minutes: _widths(this.minutes),\n            hourmin: _widths(this.hourmin),\n            hours: _widths(this.hours),\n            days: _widths(this.days),\n            months: _widths(this.months),\n            years: _widths(this.years)\n        };\n    };\n    DatetimeTickFormatter.prototype._get_resolution_str = function (resolution_secs, span_secs) {\n        var adjusted_secs;\n        adjusted_secs = resolution_secs * 1.1;\n        switch (false) {\n            case !(adjusted_secs < 1e-3):\n                return \"microseconds\";\n            case !(adjusted_secs < 1.0):\n                return \"milliseconds\";\n            case !(adjusted_secs < 60):\n                if (span_secs >= 60) {\n                    return \"minsec\";\n                }\n                else {\n                    return \"seconds\";\n                }\n            case !(adjusted_secs < 3600):\n                if (span_secs >= 3600) {\n                    return \"hourmin\";\n                }\n                else {\n                    return \"minutes\";\n                }\n            case !(adjusted_secs < 24 * 3600):\n                return \"hours\";\n            case !(adjusted_secs < 31 * 24 * 3600):\n                return \"days\";\n            case !(adjusted_secs < 365 * 24 * 3600):\n                return \"months\";\n            default:\n                return \"years\";\n        }\n    };\n    DatetimeTickFormatter.prototype.doFormat = function (ticks, axis, num_labels, char_width, fill_ratio, ticker) {\n        var error, fmt, format, formats, good_formats, hybrid_handled, i, j, k, l, labels, len, len1, next_format, next_ndx, r, ref, ref1, ref2, resol, resol_ndx, s, span, ss, t, time_tuple_ndx_for_resol, tm, widths;\n        if (num_labels == null) {\n            num_labels = null;\n        }\n        if (char_width == null) {\n            char_width = null;\n        }\n        if (fill_ratio == null) {\n            fill_ratio = 0.3;\n        }\n        if (ticker == null) {\n            ticker = null;\n        }\n        if (ticks.length === 0) {\n            return [];\n        }\n        span = Math.abs(ticks[ticks.length - 1] - ticks[0]) / 1000.0;\n        if (ticker) {\n            r = ticker.resolution;\n        }\n        else {\n            r = span / (ticks.length - 1);\n        }\n        resol = this._get_resolution_str(r, span);\n        ref = this._width_formats[resol], widths = ref[0], formats = ref[1];\n        format = formats[0];\n        if (char_width) {\n            good_formats = [];\n            for (i = j = 0, ref1 = widths.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n                if (widths[i] * ticks.length < fill_ratio * char_width) {\n                    good_formats.push(this._width_formats[i]);\n                }\n            }\n            if (good_formats.length > 0) {\n                format = good_formats[good_formats.length - 1];\n            }\n        }\n        labels = [];\n        resol_ndx = this.format_order.indexOf(resol);\n        time_tuple_ndx_for_resol = {};\n        ref2 = this.format_order;\n        for (k = 0, len = ref2.length; k < len; k++) {\n            fmt = ref2[k];\n            time_tuple_ndx_for_resol[fmt] = 0;\n        }\n        time_tuple_ndx_for_resol[\"seconds\"] = 5;\n        time_tuple_ndx_for_resol[\"minsec\"] = 4;\n        time_tuple_ndx_for_resol[\"minutes\"] = 4;\n        time_tuple_ndx_for_resol[\"hourmin\"] = 3;\n        time_tuple_ndx_for_resol[\"hours\"] = 3;\n        for (l = 0, len1 = ticks.length; l < len1; l++) {\n            t = ticks[l];\n            try {\n                tm = _array(t);\n                s = _strftime(t, format);\n            }\n            catch (error1) {\n                error = error1;\n                logging_1.logger.warn(\"unable to format tick for timestamp value \" + t);\n                logging_1.logger.warn(\" - \" + error);\n                labels.push(\"ERR\");\n                continue;\n            }\n            hybrid_handled = false;\n            next_ndx = resol_ndx;\n            while (tm[time_tuple_ndx_for_resol[this.format_order[next_ndx]]] === 0) {\n                next_ndx += 1;\n                if (next_ndx === this.format_order.length) {\n                    break;\n                }\n                if ((resol === \"minsec\" || resol === \"hourmin\") && !hybrid_handled) {\n                    if ((resol === \"minsec\" && tm[4] === 0 && tm[5] !== 0) || (resol === \"hourmin\" && tm[3] === 0 && tm[4] !== 0)) {\n                        next_format = this._width_formats[this.format_order[resol_ndx - 1]][1][0];\n                        s = _strftime(t, next_format);\n                        break;\n                    }\n                    else {\n                        hybrid_handled = true;\n                    }\n                }\n                next_format = this._width_formats[this.format_order[next_ndx]][1][0];\n                s = _strftime(t, next_format);\n            }\n            if (this.strip_leading_zeros) {\n                ss = s.replace(/^0+/g, \"\");\n                if (ss !== s && isNaN(parseInt(ss))) {\n                    ss = '0' + ss;\n                }\n                labels.push(ss);\n            }\n            else {\n                labels.push(s);\n            }\n        }\n        return labels;\n    };\n    return DatetimeTickFormatter;\n})(tick_formatter_1.TickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, slice = [].slice;\nvar tick_formatter_1 = require(\"./tick_formatter\");\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nexports.FuncTickFormatter = (function (superClass) {\n    extend(FuncTickFormatter, superClass);\n    function FuncTickFormatter() {\n        return FuncTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    FuncTickFormatter.prototype.type = 'FuncTickFormatter';\n    FuncTickFormatter.define({\n        args: [p.Any, {}],\n        code: [p.String, '']\n    });\n    FuncTickFormatter.prototype._make_func = function () {\n        return (function (func, args, ctor) {\n            ctor.prototype = func.prototype;\n            var child = new ctor, result = func.apply(child, args);\n            return Object(result) === result ? result : child;\n        })(Function, [\"tick\"].concat(slice.call(Object.keys(this.args)), [\"require\"], [this.code]), function () { });\n    };\n    FuncTickFormatter.prototype.doFormat = function (ticks, axis) {\n        var func, tick;\n        func = this._make_func();\n        return (function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = ticks.length; i < len; i++) {\n                tick = ticks[i];\n                results.push(func.apply(null, [tick].concat(slice.call(object_1.values(this.args)), [require])));\n            }\n            return results;\n        }).call(this);\n    };\n    return FuncTickFormatter;\n})(tick_formatter_1.TickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar basic_tick_formatter_1 = require(\"./basic_tick_formatter\");\nexports.BasicTickFormatter = basic_tick_formatter_1.BasicTickFormatter;\nvar categorical_tick_formatter_1 = require(\"./categorical_tick_formatter\");\nexports.CategoricalTickFormatter = categorical_tick_formatter_1.CategoricalTickFormatter;\nvar datetime_tick_formatter_1 = require(\"./datetime_tick_formatter\");\nexports.DatetimeTickFormatter = datetime_tick_formatter_1.DatetimeTickFormatter;\nvar func_tick_formatter_1 = require(\"./func_tick_formatter\");\nexports.FuncTickFormatter = func_tick_formatter_1.FuncTickFormatter;\nvar log_tick_formatter_1 = require(\"./log_tick_formatter\");\nexports.LogTickFormatter = log_tick_formatter_1.LogTickFormatter;\nvar mercator_tick_formatter_1 = require(\"./mercator_tick_formatter\");\nexports.MercatorTickFormatter = mercator_tick_formatter_1.MercatorTickFormatter;\nvar numeral_tick_formatter_1 = require(\"./numeral_tick_formatter\");\nexports.NumeralTickFormatter = numeral_tick_formatter_1.NumeralTickFormatter;\nvar printf_tick_formatter_1 = require(\"./printf_tick_formatter\");\nexports.PrintfTickFormatter = printf_tick_formatter_1.PrintfTickFormatter;\nvar tick_formatter_1 = require(\"./tick_formatter\");\nexports.TickFormatter = tick_formatter_1.TickFormatter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar basic_tick_formatter_1 = require(\"./basic_tick_formatter\");\nvar tick_formatter_1 = require(\"./tick_formatter\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nexports.LogTickFormatter = (function (superClass) {\n    extend(LogTickFormatter, superClass);\n    function LogTickFormatter() {\n        return LogTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    LogTickFormatter.prototype.type = 'LogTickFormatter';\n    LogTickFormatter.define({\n        ticker: [p.Instance, null]\n    });\n    LogTickFormatter.prototype.initialize = function (attrs, options) {\n        LogTickFormatter.__super__.initialize.call(this, attrs, options);\n        this.basic_formatter = new basic_tick_formatter_1.BasicTickFormatter();\n        if (this.ticker == null) {\n            return logging_1.logger.warn(\"LogTickFormatter not configured with a ticker, using default base of 10 (labels will be incorrect if ticker base is not 10)\");\n        }\n    };\n    LogTickFormatter.prototype.doFormat = function (ticks, axis) {\n        var base, i, j, labels, ref, small_interval;\n        if (ticks.length === 0) {\n            return [];\n        }\n        if (this.ticker != null) {\n            base = this.ticker.base;\n        }\n        else {\n            base = 10;\n        }\n        small_interval = false;\n        labels = new Array(ticks.length);\n        for (i = j = 0, ref = ticks.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            labels[i] = base + \"^\" + (Math.round(Math.log(ticks[i]) / Math.log(base)));\n            if ((i > 0) && (labels[i] === labels[i - 1])) {\n                small_interval = true;\n                break;\n            }\n        }\n        if (small_interval) {\n            labels = this.basic_formatter.doFormat(ticks);\n        }\n        return labels;\n    };\n    return LogTickFormatter;\n})(tick_formatter_1.TickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar basic_tick_formatter_1 = require(\"./basic_tick_formatter\");\nvar p = require(\"core/properties\");\nvar proj4_1 = require(\"core/util/proj4\");\nexports.MercatorTickFormatter = (function (superClass) {\n    extend(MercatorTickFormatter, superClass);\n    function MercatorTickFormatter() {\n        return MercatorTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    MercatorTickFormatter.prototype.type = 'MercatorTickFormatter';\n    MercatorTickFormatter.define({\n        dimension: [p.LatLon]\n    });\n    MercatorTickFormatter.prototype.doFormat = function (ticks, axis) {\n        var i, j, k, lat, lon, proj_ticks, ref, ref1, ref2, ref3;\n        if (this.dimension == null) {\n            throw new Error(\"MercatorTickFormatter.dimension not configured\");\n        }\n        if (ticks.length === 0) {\n            return [];\n        }\n        proj_ticks = new Array(ticks.length);\n        if (this.dimension === \"lon\") {\n            for (i = j = 0, ref = ticks.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                ref1 = proj4_1.proj4(proj4_1.mercator).inverse([ticks[i], axis.loc]), lon = ref1[0], lat = ref1[1];\n                proj_ticks[i] = lon;\n            }\n        }\n        else {\n            for (i = k = 0, ref2 = ticks.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {\n                ref3 = proj4_1.proj4(proj4_1.mercator).inverse([axis.loc, ticks[i]]), lon = ref3[0], lat = ref3[1];\n                proj_ticks[i] = lat;\n            }\n        }\n        return MercatorTickFormatter.__super__.doFormat.call(this, proj_ticks, axis);\n    };\n    return MercatorTickFormatter;\n})(basic_tick_formatter_1.BasicTickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar Numbro = require(\"numbro\");\nvar tick_formatter_1 = require(\"./tick_formatter\");\nvar p = require(\"core/properties\");\nexports.NumeralTickFormatter = (function (superClass) {\n    extend(NumeralTickFormatter, superClass);\n    function NumeralTickFormatter() {\n        return NumeralTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    NumeralTickFormatter.prototype.type = 'NumeralTickFormatter';\n    NumeralTickFormatter.define({\n        format: [p.String, '0,0'],\n        language: [p.String, 'en'],\n        rounding: [p.String, 'round']\n    });\n    NumeralTickFormatter.prototype.doFormat = function (ticks, axis) {\n        var format, labels, language, rounding, tick;\n        format = this.format;\n        language = this.language;\n        rounding = (function () {\n            switch (this.rounding) {\n                case \"round\":\n                case \"nearest\":\n                    return Math.round;\n                case \"floor\":\n                case \"rounddown\":\n                    return Math.floor;\n                case \"ceil\":\n                case \"roundup\":\n                    return Math.ceil;\n            }\n        }).call(this);\n        labels = (function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = ticks.length; i < len; i++) {\n                tick = ticks[i];\n                results.push(Numbro.format(tick, format, language, rounding));\n            }\n            return results;\n        })();\n        return labels;\n    };\n    return NumeralTickFormatter;\n})(tick_formatter_1.TickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar SPrintf = require(\"sprintf\");\nvar tick_formatter_1 = require(\"./tick_formatter\");\nvar p = require(\"core/properties\");\nexports.PrintfTickFormatter = (function (superClass) {\n    extend(PrintfTickFormatter, superClass);\n    function PrintfTickFormatter() {\n        return PrintfTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    PrintfTickFormatter.prototype.type = 'PrintfTickFormatter';\n    PrintfTickFormatter.define({\n        format: [p.String, '%s']\n    });\n    PrintfTickFormatter.prototype.doFormat = function (ticks, axis) {\n        var format, labels, tick;\n        format = this.format;\n        labels = (function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = ticks.length; i < len; i++) {\n                tick = ticks[i];\n                results.push(SPrintf.sprintf(format, tick));\n            }\n            return results;\n        })();\n        return labels;\n    };\n    return PrintfTickFormatter;\n})(tick_formatter_1.TickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nexports.TickFormatter = (function (superClass) {\n    extend(TickFormatter, superClass);\n    function TickFormatter() {\n        return TickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    TickFormatter.prototype.type = 'TickFormatter';\n    TickFormatter.prototype.doFormat = function (ticks, axis) { };\n    return TickFormatter;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nvar math_1 = require(\"core/util/math\");\nexports.AnnularWedgeView = (function (superClass) {\n    extend(AnnularWedgeView, superClass);\n    function AnnularWedgeView() {\n        return AnnularWedgeView.__super__.constructor.apply(this, arguments);\n    }\n    AnnularWedgeView.prototype._map_data = function () {\n        var i, j, ref, results;\n        if (this.model.properties.inner_radius.units === \"data\") {\n            this.sinner_radius = this.sdist(this.renderer.xscale, this._x, this._inner_radius);\n        }\n        else {\n            this.sinner_radius = this._inner_radius;\n        }\n        if (this.model.properties.outer_radius.units === \"data\") {\n            this.souter_radius = this.sdist(this.renderer.xscale, this._x, this._outer_radius);\n        }\n        else {\n            this.souter_radius = this._outer_radius;\n        }\n        this._angle = new Float32Array(this._start_angle.length);\n        results = [];\n        for (i = j = 0, ref = this._start_angle.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            results.push(this._angle[i] = this._end_angle[i] - this._start_angle[i]);\n        }\n        return results;\n    };\n    AnnularWedgeView.prototype._render = function (ctx, indices, arg) {\n        var _angle, _start_angle, direction, i, j, len, results, sinner_radius, souter_radius, sx, sy;\n        sx = arg.sx, sy = arg.sy, _start_angle = arg._start_angle, _angle = arg._angle, sinner_radius = arg.sinner_radius, souter_radius = arg.souter_radius;\n        direction = this.model.properties.direction.value();\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + sinner_radius[i] + souter_radius[i] + _start_angle[i] + _angle[i])) {\n                continue;\n            }\n            ctx.translate(sx[i], sy[i]);\n            ctx.rotate(_start_angle[i]);\n            ctx.moveTo(souter_radius[i], 0);\n            ctx.beginPath();\n            ctx.arc(0, 0, souter_radius[i], 0, _angle[i], direction);\n            ctx.rotate(_angle[i]);\n            ctx.lineTo(sinner_radius[i], 0);\n            ctx.arc(0, 0, sinner_radius[i], 0, -_angle[i], !direction);\n            ctx.closePath();\n            ctx.rotate(-_angle[i] - _start_angle[i]);\n            ctx.translate(-sx[i], -sy[i]);\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    AnnularWedgeView.prototype._hit_point = function (geometry) {\n        var angle, bbox, candidates, direction, dist, hits, i, ir2, j, k, len, len1, or2, ref, ref1, ref2, ref3, ref4, sx, sx0, sx1, sy, sy0, sy1, vx, vx0, vx1, vy, vy0, vy1, x, x0, x1, y, y0, y1;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xscale.invert(vx, true);\n        y = this.renderer.yscale.invert(vy, true);\n        if (this.model.properties.outer_radius.units === \"data\") {\n            x0 = x - this.max_outer_radius;\n            x1 = x + this.max_outer_radius;\n            y0 = y - this.max_outer_radius;\n            y1 = y + this.max_outer_radius;\n        }\n        else {\n            vx0 = vx - this.max_outer_radius;\n            vx1 = vx + this.max_outer_radius;\n            ref1 = this.renderer.xscale.v_invert([vx0, vx1], true), x0 = ref1[0], x1 = ref1[1];\n            vy0 = vy - this.max_outer_radius;\n            vy1 = vy + this.max_outer_radius;\n            ref2 = this.renderer.yscale.v_invert([vy0, vy1], true), y0 = ref2[0], y1 = ref2[1];\n        }\n        candidates = [];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        ref3 = this.index.indices(bbox);\n        for (j = 0, len = ref3.length; j < len; j++) {\n            i = ref3[j];\n            or2 = Math.pow(this.souter_radius[i], 2);\n            ir2 = Math.pow(this.sinner_radius[i], 2);\n            sx0 = this.renderer.xscale.compute(x, true);\n            sx1 = this.renderer.xscale.compute(this._x[i], true);\n            sy0 = this.renderer.yscale.compute(y, true);\n            sy1 = this.renderer.yscale.compute(this._y[i], true);\n            dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);\n            if (dist <= or2 && dist >= ir2) {\n                candidates.push([i, dist]);\n            }\n        }\n        direction = this.model.properties.direction.value();\n        hits = [];\n        for (k = 0, len1 = candidates.length; k < len1; k++) {\n            ref4 = candidates[k], i = ref4[0], dist = ref4[1];\n            sx = this.renderer.plot_view.canvas.vx_to_sx(vx);\n            sy = this.renderer.plot_view.canvas.vy_to_sy(vy);\n            angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);\n            if (math_1.angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {\n                hits.push([i, dist]);\n            }\n        }\n        return hittest.create_1d_hit_test_result(hits);\n    };\n    AnnularWedgeView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    AnnularWedgeView.prototype._scxy = function (i) {\n        var a, r;\n        r = (this.sinner_radius[i] + this.souter_radius[i]) / 2;\n        a = (this._start_angle[i] + this._end_angle[i]) / 2;\n        return {\n            x: this.sx[i] + r * Math.cos(a),\n            y: this.sy[i] + r * Math.sin(a)\n        };\n    };\n    AnnularWedgeView.prototype.scx = function (i) {\n        return this._scxy(i).x;\n    };\n    AnnularWedgeView.prototype.scy = function (i) {\n        return this._scxy(i).y;\n    };\n    return AnnularWedgeView;\n})(xy_glyph_1.XYGlyphView);\nexports.AnnularWedge = (function (superClass) {\n    extend(AnnularWedge, superClass);\n    function AnnularWedge() {\n        return AnnularWedge.__super__.constructor.apply(this, arguments);\n    }\n    AnnularWedge.prototype.default_view = exports.AnnularWedgeView;\n    AnnularWedge.prototype.type = 'AnnularWedge';\n    AnnularWedge.mixins(['line', 'fill']);\n    AnnularWedge.define({\n        direction: [p.Direction, 'anticlock'],\n        inner_radius: [p.DistanceSpec],\n        outer_radius: [p.DistanceSpec],\n        start_angle: [p.AngleSpec],\n        end_angle: [p.AngleSpec]\n    });\n    return AnnularWedge;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nexports.AnnulusView = (function (superClass) {\n    extend(AnnulusView, superClass);\n    function AnnulusView() {\n        return AnnulusView.__super__.constructor.apply(this, arguments);\n    }\n    AnnulusView.prototype._map_data = function () {\n        if (this.model.properties.inner_radius.units === \"data\") {\n            this.sinner_radius = this.sdist(this.renderer.xscale, this._x, this._inner_radius);\n        }\n        else {\n            this.sinner_radius = this._inner_radius;\n        }\n        if (this.model.properties.outer_radius.units === \"data\") {\n            return this.souter_radius = this.sdist(this.renderer.xscale, this._x, this._outer_radius);\n        }\n        else {\n            return this.souter_radius = this._outer_radius;\n        }\n    };\n    AnnulusView.prototype._render = function (ctx, indices, arg) {\n        var clockwise, i, isie, j, k, len, len1, ref, results, sinner_radius, souter_radius, sx, sy;\n        sx = arg.sx, sy = arg.sy, sinner_radius = arg.sinner_radius, souter_radius = arg.souter_radius;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + sinner_radius[i] + souter_radius[i])) {\n                continue;\n            }\n            isie = navigator.userAgent.indexOf('MSIE') >= 0 || navigator.userAgent.indexOf('Trident') > 0 || navigator.userAgent.indexOf('Edge') > 0;\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.beginPath();\n                if (isie) {\n                    ref = [false, true];\n                    for (k = 0, len1 = ref.length; k < len1; k++) {\n                        clockwise = ref[k];\n                        ctx.arc(sx[i], sy[i], sinner_radius[i], 0, Math.PI, clockwise);\n                        ctx.arc(sx[i], sy[i], souter_radius[i], Math.PI, 0, !clockwise);\n                    }\n                }\n                else {\n                    ctx.arc(sx[i], sy[i], sinner_radius[i], 0, 2 * Math.PI, true);\n                    ctx.arc(sx[i], sy[i], souter_radius[i], 2 * Math.PI, 0, false);\n                }\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.beginPath();\n                ctx.arc(sx[i], sy[i], sinner_radius[i], 0, 2 * Math.PI);\n                ctx.moveTo(sx[i] + souter_radius[i], sy[i]);\n                ctx.arc(sx[i], sy[i], souter_radius[i], 0, 2 * Math.PI);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    AnnulusView.prototype._hit_point = function (geometry) {\n        var bbox, dist, hits, i, ir2, j, len, or2, ref, ref1, sx0, sx1, sy0, sy1, vx, vy, x, x0, x1, y, y0, y1;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xscale.invert(vx, true);\n        x0 = x - this.max_radius;\n        x1 = x + this.max_radius;\n        y = this.renderer.yscale.invert(vy, true);\n        y0 = y - this.max_radius;\n        y1 = y + this.max_radius;\n        hits = [];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        ref1 = this.index.indices(bbox);\n        for (j = 0, len = ref1.length; j < len; j++) {\n            i = ref1[j];\n            or2 = Math.pow(this.souter_radius[i], 2);\n            ir2 = Math.pow(this.sinner_radius[i], 2);\n            sx0 = this.renderer.xscale.compute(x);\n            sx1 = this.renderer.xscale.compute(this._x[i]);\n            sy0 = this.renderer.yscale.compute(y);\n            sy1 = this.renderer.yscale.compute(this._y[i]);\n            dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);\n            if (dist <= or2 && dist >= ir2) {\n                hits.push([i, dist]);\n            }\n        }\n        return hittest.create_1d_hit_test_result(hits);\n    };\n    AnnulusView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        var data, indices, r, sinner_radius, souter_radius, sx, sy;\n        indices = [index];\n        sx = {};\n        sx[index] = (x0 + x1) / 2;\n        sy = {};\n        sy[index] = (y0 + y1) / 2;\n        r = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.5;\n        sinner_radius = {};\n        sinner_radius[index] = r * 0.4;\n        souter_radius = {};\n        souter_radius[index] = r * 0.8;\n        data = {\n            sx: sx,\n            sy: sy,\n            sinner_radius: sinner_radius,\n            souter_radius: souter_radius\n        };\n        return this._render(ctx, indices, data);\n    };\n    return AnnulusView;\n})(xy_glyph_1.XYGlyphView);\nexports.Annulus = (function (superClass) {\n    extend(Annulus, superClass);\n    function Annulus() {\n        return Annulus.__super__.constructor.apply(this, arguments);\n    }\n    Annulus.prototype.default_view = exports.AnnulusView;\n    Annulus.prototype.type = 'Annulus';\n    Annulus.mixins(['line', 'fill']);\n    Annulus.define({\n        inner_radius: [p.DistanceSpec],\n        outer_radius: [p.DistanceSpec]\n    });\n    return Annulus;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar p = require(\"core/properties\");\nexports.ArcView = (function (superClass) {\n    extend(ArcView, superClass);\n    function ArcView() {\n        return ArcView.__super__.constructor.apply(this, arguments);\n    }\n    ArcView.prototype._map_data = function () {\n        if (this.model.properties.radius.units === \"data\") {\n            return this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);\n        }\n        else {\n            return this.sradius = this._radius;\n        }\n    };\n    ArcView.prototype._render = function (ctx, indices, arg) {\n        var _end_angle, _start_angle, direction, i, j, len, results, sradius, sx, sy;\n        sx = arg.sx, sy = arg.sy, sradius = arg.sradius, _start_angle = arg._start_angle, _end_angle = arg._end_angle;\n        if (this.visuals.line.doit) {\n            direction = this.model.properties.direction.value();\n            results = [];\n            for (j = 0, len = indices.length; j < len; j++) {\n                i = indices[j];\n                if (isNaN(sx[i] + sy[i] + sradius[i] + _start_angle[i] + _end_angle[i])) {\n                    continue;\n                }\n                ctx.beginPath();\n                ctx.arc(sx[i], sy[i], sradius[i], _start_angle[i], _end_angle[i], direction);\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            return results;\n        }\n    };\n    ArcView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return ArcView;\n})(xy_glyph_1.XYGlyphView);\nexports.Arc = (function (superClass) {\n    extend(Arc, superClass);\n    function Arc() {\n        return Arc.__super__.constructor.apply(this, arguments);\n    }\n    Arc.prototype.default_view = exports.ArcView;\n    Arc.prototype.type = 'Arc';\n    Arc.mixins(['line']);\n    Arc.define({\n        direction: [p.Direction, 'anticlock'],\n        radius: [p.DistanceSpec],\n        start_angle: [p.AngleSpec],\n        end_angle: [p.AngleSpec]\n    });\n    return Arc;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _cbb, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\n_cbb = function (x0, y0, x1, y1, x2, y2, x3, y3) {\n    var a, b, b2ac, bounds, c, i, j, jlen, k, mt, sqrtb2ac, t, t1, t2, tvalues, x, y;\n    tvalues = [];\n    bounds = [[], []];\n    for (i = k = 0; k <= 2; i = ++k) {\n        if (i === 0) {\n            b = 6 * x0 - 12 * x1 + 6 * x2;\n            a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n            c = 3 * x1 - 3 * x0;\n        }\n        else {\n            b = 6 * y0 - 12 * y1 + 6 * y2;\n            a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n            c = 3 * y1 - 3 * y0;\n        }\n        if (Math.abs(a) < 1e-12) {\n            if (Math.abs(b) < 1e-12) {\n                continue;\n            }\n            t = -c / b;\n            if (0 < t && t < 1) {\n                tvalues.push(t);\n            }\n            continue;\n        }\n        b2ac = b * b - 4 * c * a;\n        sqrtb2ac = Math.sqrt(b2ac);\n        if (b2ac < 0) {\n            continue;\n        }\n        t1 = (-b + sqrtb2ac) / (2 * a);\n        if (0 < t1 && t1 < 1) {\n            tvalues.push(t1);\n        }\n        t2 = (-b - sqrtb2ac) / (2 * a);\n        if (0 < t2 && t2 < 1) {\n            tvalues.push(t2);\n        }\n    }\n    j = tvalues.length;\n    jlen = j;\n    while (j--) {\n        t = tvalues[j];\n        mt = 1 - t;\n        x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n        bounds[0][j] = x;\n        y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n        bounds[1][j] = y;\n    }\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    return [Math.min.apply(null, bounds[0]), Math.max.apply(null, bounds[1]), Math.max.apply(null, bounds[0]), Math.min.apply(null, bounds[1])];\n};\nexports.BezierView = (function (superClass) {\n    extend(BezierView, superClass);\n    function BezierView() {\n        return BezierView.__super__.constructor.apply(this, arguments);\n    }\n    BezierView.prototype._index_data = function () {\n        var i, k, points, ref, ref1, x0, x1, y0, y1;\n        points = [];\n        for (i = k = 0, ref = this._x0.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            if (isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i] + this._cx0[i] + this._cy0[i] + this._cx1[i] + this._cy1[i])) {\n                continue;\n            }\n            ref1 = _cbb(this._x0[i], this._y0[i], this._x1[i], this._y1[i], this._cx0[i], this._cy0[i], this._cx1[i], this._cy1[i]), x0 = ref1[0], y0 = ref1[1], x1 = ref1[2], y1 = ref1[3];\n            points.push({\n                minX: x0,\n                minY: y0,\n                maxX: x1,\n                maxY: y1,\n                i: i\n            });\n        }\n        return new spatial_1.RBush(points);\n    };\n    BezierView.prototype._render = function (ctx, indices, arg) {\n        var i, k, len, results, scx, scx0, scx1, scy0, scy1, sx0, sx1, sy0, sy1;\n        sx0 = arg.sx0, sy0 = arg.sy0, sx1 = arg.sx1, sy1 = arg.sy1, scx = arg.scx, scx0 = arg.scx0, scy0 = arg.scy0, scx1 = arg.scx1, scy1 = arg.scy1;\n        if (this.visuals.line.doit) {\n            results = [];\n            for (k = 0, len = indices.length; k < len; k++) {\n                i = indices[k];\n                if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i] + scx0[i] + scy0[i] + scx1[i] + scy1[i])) {\n                    continue;\n                }\n                ctx.beginPath();\n                ctx.moveTo(sx0[i], sy0[i]);\n                ctx.bezierCurveTo(scx0[i], scy0[i], scx1[i], scy1[i], sx1[i], sy1[i]);\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            return results;\n        }\n    };\n    BezierView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return BezierView;\n})(glyph_1.GlyphView);\nexports.Bezier = (function (superClass) {\n    extend(Bezier, superClass);\n    function Bezier() {\n        return Bezier.__super__.constructor.apply(this, arguments);\n    }\n    Bezier.prototype.default_view = exports.BezierView;\n    Bezier.prototype.type = 'Bezier';\n    Bezier.coords([['x0', 'y0'], ['x1', 'y1'], ['cx0', 'cy0'], ['cx1', 'cy1']]);\n    Bezier.mixins(['line']);\n    return Bezier;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nexports.CircleView = (function (superClass) {\n    extend(CircleView, superClass);\n    function CircleView() {\n        return CircleView.__super__.constructor.apply(this, arguments);\n    }\n    CircleView.prototype._map_data = function () {\n        var rd, s;\n        if (this._radius != null) {\n            if (this.model.properties.radius.spec.units === \"data\") {\n                rd = this.model.properties.radius_dimension.spec.value;\n                return this.sradius = this.sdist(this.renderer[rd + \"scale\"], this[\"_\" + rd], this._radius);\n            }\n            else {\n                this.sradius = this._radius;\n                return this.max_size = 2 * this.max_radius;\n            }\n        }\n        else {\n            return this.sradius = (function () {\n                var j, len, ref, results;\n                ref = this._size;\n                results = [];\n                for (j = 0, len = ref.length; j < len; j++) {\n                    s = ref[j];\n                    results.push(s / 2);\n                }\n                return results;\n            }).call(this);\n        }\n    };\n    CircleView.prototype._mask_data = function (all_indices) {\n        var bbox, hr, ref, ref1, ref2, ref3, sx0, sx1, sy0, sy1, vr, x0, x1, y0, y1;\n        hr = this.renderer.plot_view.frame.h_range;\n        vr = this.renderer.plot_view.frame.v_range;\n        if ((this._radius != null) && this.model.properties.radius.units === \"data\") {\n            sx0 = hr.start;\n            sx1 = hr.end;\n            ref = this.renderer.xscale.v_invert([sx0, sx1], true), x0 = ref[0], x1 = ref[1];\n            x0 -= this.max_radius;\n            x1 += this.max_radius;\n            sy0 = vr.start;\n            sy1 = vr.end;\n            ref1 = this.renderer.yscale.v_invert([sy0, sy1], true), y0 = ref1[0], y1 = ref1[1];\n            y0 -= this.max_radius;\n            y1 += this.max_radius;\n        }\n        else {\n            sx0 = hr.start - this.max_size;\n            sx1 = hr.end + this.max_size;\n            ref2 = this.renderer.xscale.v_invert([sx0, sx1], true), x0 = ref2[0], x1 = ref2[1];\n            sy0 = vr.start - this.max_size;\n            sy1 = vr.end + this.max_size;\n            ref3 = this.renderer.yscale.v_invert([sy0, sy1], true), y0 = ref3[0], y1 = ref3[1];\n        }\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        return this.index.indices(bbox);\n    };\n    CircleView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, sradius, sx, sy;\n        sx = arg.sx, sy = arg.sy, sradius = arg.sradius;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + sradius[i])) {\n                continue;\n            }\n            ctx.beginPath();\n            ctx.arc(sx[i], sy[i], sradius[i], 0, 2 * Math.PI, false);\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    CircleView.prototype._hit_point = function (geometry) {\n        var bbox, candidates, dist, hits, i, j, k, len, len1, r2, ref, ref1, ref2, ref3, ref4, sx, sx0, sx1, sy, sy0, sy1, vx, vx0, vx1, vy, vy0, vy1, x, x0, x1, y, y0, y1;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xscale.invert(vx, true);\n        y = this.renderer.yscale.invert(vy, true);\n        if ((this._radius != null) && this.model.properties.radius.units === \"data\") {\n            x0 = x - this.max_radius;\n            x1 = x + this.max_radius;\n            y0 = y - this.max_radius;\n            y1 = y + this.max_radius;\n        }\n        else {\n            vx0 = vx - this.max_size;\n            vx1 = vx + this.max_size;\n            ref1 = this.renderer.xscale.v_invert([vx0, vx1], true), x0 = ref1[0], x1 = ref1[1];\n            ref2 = [Math.min(x0, x1), Math.max(x0, x1)], x0 = ref2[0], x1 = ref2[1];\n            vy0 = vy - this.max_size;\n            vy1 = vy + this.max_size;\n            ref3 = this.renderer.yscale.v_invert([vy0, vy1], true), y0 = ref3[0], y1 = ref3[1];\n            ref4 = [Math.min(y0, y1), Math.max(y0, y1)], y0 = ref4[0], y1 = ref4[1];\n        }\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        candidates = this.index.indices(bbox);\n        hits = [];\n        if ((this._radius != null) && this.model.properties.radius.units === \"data\") {\n            for (j = 0, len = candidates.length; j < len; j++) {\n                i = candidates[j];\n                r2 = Math.pow(this.sradius[i], 2);\n                sx0 = this.renderer.xscale.compute(x, true);\n                sx1 = this.renderer.xscale.compute(this._x[i], true);\n                sy0 = this.renderer.yscale.compute(y, true);\n                sy1 = this.renderer.yscale.compute(this._y[i], true);\n                dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);\n                if (dist <= r2) {\n                    hits.push([i, dist]);\n                }\n            }\n        }\n        else {\n            sx = this.renderer.plot_view.canvas.vx_to_sx(vx);\n            sy = this.renderer.plot_view.canvas.vy_to_sy(vy);\n            for (k = 0, len1 = candidates.length; k < len1; k++) {\n                i = candidates[k];\n                r2 = Math.pow(this.sradius[i], 2);\n                dist = Math.pow(this.sx[i] - sx, 2) + Math.pow(this.sy[i] - sy, 2);\n                if (dist <= r2) {\n                    hits.push([i, dist]);\n                }\n            }\n        }\n        return hittest.create_1d_hit_test_result(hits);\n    };\n    CircleView.prototype._hit_span = function (geometry) {\n        var bbox, hits, maxX, maxY, minX, minY, ms, ref, ref1, ref2, ref3, ref4, ref5, result, vx, vx0, vx1, vy, vy0, vy1, x0, x1, y0, y1;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        ref1 = this.bounds(), minX = ref1.minX, minY = ref1.minY, maxX = ref1.maxX, maxY = ref1.maxY;\n        result = hittest.create_hit_test_result();\n        if (geometry.direction === 'h') {\n            y0 = minY;\n            y1 = maxY;\n            if ((this._radius != null) && this.model.properties.radius.units === \"data\") {\n                vx0 = vx - this.max_radius;\n                vx1 = vx + this.max_radius;\n                ref2 = this.renderer.xscale.v_invert([vx0, vx1]), x0 = ref2[0], x1 = ref2[1];\n            }\n            else {\n                ms = this.max_size / 2;\n                vx0 = vx - ms;\n                vx1 = vx + ms;\n                ref3 = this.renderer.xscale.v_invert([vx0, vx1], true), x0 = ref3[0], x1 = ref3[1];\n            }\n        }\n        else {\n            x0 = minX;\n            x1 = maxX;\n            if ((this._radius != null) && this.model.properties.radius.units === \"data\") {\n                vy0 = vy - this.max_radius;\n                vy1 = vy + this.max_radius;\n                ref4 = this.renderer.yscale.v_invert([vy0, vy1]), y0 = ref4[0], y1 = ref4[1];\n            }\n            else {\n                ms = this.max_size / 2;\n                vy0 = vy - ms;\n                vy1 = vy + ms;\n                ref5 = this.renderer.yscale.v_invert([vy0, vy1], true), y0 = ref5[0], y1 = ref5[1];\n            }\n        }\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        hits = this.index.indices(bbox);\n        result['1d'].indices = hits;\n        return result;\n    };\n    CircleView.prototype._hit_rect = function (geometry) {\n        var bbox, ref, ref1, result, x0, x1, y0, y1;\n        ref = this.renderer.xscale.v_invert([geometry.vx0, geometry.vx1], true), x0 = ref[0], x1 = ref[1];\n        ref1 = this.renderer.yscale.v_invert([geometry.vy0, geometry.vy1], true), y0 = ref1[0], y1 = ref1[1];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = this.index.indices(bbox);\n        return result;\n    };\n    CircleView.prototype._hit_poly = function (geometry) {\n        var candidates, hits, i, idx, j, k, ref, ref1, ref2, result, results, sx, sy, vx, vy;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        sx = this.renderer.plot_view.canvas.v_vx_to_sx(vx);\n        sy = this.renderer.plot_view.canvas.v_vy_to_sy(vy);\n        candidates = (function () {\n            results = [];\n            for (var j = 0, ref1 = this.sx.length; 0 <= ref1 ? j < ref1 : j > ref1; 0 <= ref1 ? j++ : j--) {\n                results.push(j);\n            }\n            return results;\n        }).apply(this);\n        hits = [];\n        for (i = k = 0, ref2 = candidates.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {\n            idx = candidates[i];\n            if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy)) {\n                hits.push(idx);\n            }\n        }\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    CircleView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        var data, indices, sradius, sx, sy;\n        indices = [index];\n        sx = {};\n        sx[index] = (x0 + x1) / 2;\n        sy = {};\n        sy[index] = (y0 + y1) / 2;\n        sradius = {};\n        sradius[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.2;\n        data = {\n            sx: sx,\n            sy: sy,\n            sradius: sradius\n        };\n        return this._render(ctx, indices, data);\n    };\n    return CircleView;\n})(xy_glyph_1.XYGlyphView);\nexports.Circle = (function (superClass) {\n    extend(Circle, superClass);\n    function Circle() {\n        return Circle.__super__.constructor.apply(this, arguments);\n    }\n    Circle.prototype.default_view = exports.CircleView;\n    Circle.prototype.type = 'Circle';\n    Circle.mixins(['line', 'fill']);\n    Circle.define({\n        angle: [p.AngleSpec, 0],\n        size: [\n            p.DistanceSpec, {\n                units: \"screen\",\n                value: 4\n            }\n        ],\n        radius: [p.DistanceSpec, null],\n        radius_dimension: [p.String, 'x']\n    });\n    Circle.prototype.initialize = function (attrs, options) {\n        Circle.__super__.initialize.call(this, attrs, options);\n        return this.properties.radius.optional = true;\n    };\n    return Circle;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar p = require(\"core/properties\");\nexports.EllipseView = (function (superClass) {\n    extend(EllipseView, superClass);\n    function EllipseView() {\n        return EllipseView.__super__.constructor.apply(this, arguments);\n    }\n    EllipseView.prototype._set_data = function () {\n        this.max_w2 = 0;\n        if (this.model.properties.width.units === \"data\") {\n            this.max_w2 = this.max_width / 2;\n        }\n        this.max_h2 = 0;\n        if (this.model.properties.height.units === \"data\") {\n            return this.max_h2 = this.max_height / 2;\n        }\n    };\n    EllipseView.prototype._map_data = function () {\n        if (this.model.properties.width.units === \"data\") {\n            this.sw = this.sdist(this.renderer.xscale, this._x, this._width, 'center');\n        }\n        else {\n            this.sw = this._width;\n        }\n        if (this.model.properties.height.units === \"data\") {\n            return this.sh = this.sdist(this.renderer.yscale, this._y, this._height, 'center');\n        }\n        else {\n            return this.sh = this._height;\n        }\n    };\n    EllipseView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, sh, sw, sx, sy;\n        sx = arg.sx, sy = arg.sy, sw = arg.sw, sh = arg.sh;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + sw[i] + sh[i] + this._angle[i])) {\n                continue;\n            }\n            ctx.beginPath();\n            ctx.ellipse(sx[i], sy[i], sw[i] / 2.0, sh[i] / 2.0, this._angle[i], 0, 2 * Math.PI);\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    EllipseView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        var d, data, indices, scale, sh, sw, sx, sy;\n        indices = [index];\n        sx = {};\n        sx[index] = (x0 + x1) / 2;\n        sy = {};\n        sy[index] = (y0 + y1) / 2;\n        scale = this.sw[index] / this.sh[index];\n        d = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.8;\n        sw = {};\n        sh = {};\n        if (scale > 1) {\n            sw[index] = d;\n            sh[index] = d / scale;\n        }\n        else {\n            sw[index] = d * scale;\n            sh[index] = d;\n        }\n        data = {\n            sx: sx,\n            sy: sy,\n            sw: sw,\n            sh: sh\n        };\n        return this._render(ctx, indices, data);\n    };\n    EllipseView.prototype._bounds = function (bds) {\n        return this.max_wh2_bounds(bds);\n    };\n    return EllipseView;\n})(xy_glyph_1.XYGlyphView);\nexports.Ellipse = (function (superClass) {\n    extend(Ellipse, superClass);\n    function Ellipse() {\n        return Ellipse.__super__.constructor.apply(this, arguments);\n    }\n    Ellipse.prototype.default_view = exports.EllipseView;\n    Ellipse.prototype.type = 'Ellipse';\n    Ellipse.mixins(['line', 'fill']);\n    Ellipse.define({\n        angle: [p.AngleSpec, 0.0],\n        width: [p.DistanceSpec],\n        height: [p.DistanceSpec]\n    });\n    return Ellipse;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar bbox = require(\"core/util/bbox\");\nvar proj = require(\"core/util/projections\");\nvar view_1 = require(\"core/view\");\nvar model_1 = require(\"../../model\");\nvar visuals_1 = require(\"core/visuals\");\nvar logging_1 = require(\"core/logging\");\nvar object_1 = require(\"core/util/object\");\nvar types_1 = require(\"core/util/types\");\nexports.GlyphView = (function (superClass) {\n    extend1(GlyphView, superClass);\n    function GlyphView() {\n        return GlyphView.__super__.constructor.apply(this, arguments);\n    }\n    GlyphView.prototype.initialize = function (options) {\n        var Cls, ctx, e, glglyphs;\n        GlyphView.__super__.initialize.call(this, options);\n        this._nohit_warned = {};\n        this.renderer = options.renderer;\n        this.visuals = new visuals_1.Visuals(this.model);\n        ctx = this.renderer.plot_view.canvas_view.ctx;\n        if (ctx.glcanvas != null) {\n            try {\n                glglyphs = require(\"models/glyphs/webgl/index\");\n            }\n            catch (error) {\n                e = error;\n                if (e.code === 'MODULE_NOT_FOUND') {\n                    logging_1.logger.warn('WebGL was requested and is supported, but bokeh-gl(.min).js is not available, falling back to 2D rendering.');\n                    glglyphs = null;\n                }\n                else {\n                    throw e;\n                }\n            }\n            if (glglyphs != null) {\n                Cls = glglyphs[this.model.type + 'GLGlyph'];\n                if (Cls != null) {\n                    return this.glglyph = new Cls(ctx.glcanvas.gl, this);\n                }\n            }\n        }\n    };\n    GlyphView.prototype.set_visuals = function (source) {\n        this.visuals.warm_cache(source);\n        if (this.glglyph != null) {\n            return this.glglyph.set_visuals_changed();\n        }\n    };\n    GlyphView.prototype.render = function (ctx, indices, data) {\n        ctx.beginPath();\n        if (this.glglyph != null) {\n            if (this.glglyph.render(ctx, indices, data)) {\n                return;\n            }\n        }\n        return this._render(ctx, indices, data);\n    };\n    GlyphView.prototype.has_finished = function () {\n        return true;\n    };\n    GlyphView.prototype.notify_finished = function () {\n        return this.renderer.notify_finished();\n    };\n    GlyphView.prototype.bounds = function () {\n        if (this.index == null) {\n            return bbox.empty();\n        }\n        else {\n            return this._bounds(this.index.bbox);\n        }\n    };\n    GlyphView.prototype.log_bounds = function () {\n        var bb, j, k, len, len1, positive_x_bbs, positive_y_bbs, x, y;\n        if (this.index == null) {\n            return bbox.empty();\n        }\n        bb = bbox.empty();\n        positive_x_bbs = this.index.search(bbox.positive_x());\n        positive_y_bbs = this.index.search(bbox.positive_y());\n        for (j = 0, len = positive_x_bbs.length; j < len; j++) {\n            x = positive_x_bbs[j];\n            if (x.minX < bb.minX) {\n                bb.minX = x.minX;\n            }\n            if (x.maxX > bb.maxX) {\n                bb.maxX = x.maxX;\n            }\n        }\n        for (k = 0, len1 = positive_y_bbs.length; k < len1; k++) {\n            y = positive_y_bbs[k];\n            if (y.minY < bb.minY) {\n                bb.minY = y.minY;\n            }\n            if (y.maxY > bb.maxY) {\n                bb.maxY = y.maxY;\n            }\n        }\n        return this._bounds(bb);\n    };\n    GlyphView.prototype.max_wh2_bounds = function (bds) {\n        return {\n            minX: bds.minX - this.max_w2,\n            maxX: bds.maxX + this.max_w2,\n            minY: bds.minY - this.max_h2,\n            maxY: bds.maxY + this.max_h2\n        };\n    };\n    GlyphView.prototype.get_anchor_point = function (anchor, i, arg) {\n        var sx, sy;\n        sx = arg[0], sy = arg[1];\n        switch (anchor) {\n            case \"center\":\n                return {\n                    x: this.scx(i, sx, sy),\n                    y: this.scy(i, sx, sy)\n                };\n            default:\n                return null;\n        }\n    };\n    GlyphView.prototype.scx = function (i) {\n        return this.sx[i];\n    };\n    GlyphView.prototype.scy = function (i) {\n        return this.sy[i];\n    };\n    GlyphView.prototype.sdist = function (scale, pts, spans, pts_location, dilate) {\n        var d, halfspan, i, pt0, pt1, spt0, spt1;\n        if (pts_location == null) {\n            pts_location = \"edge\";\n        }\n        if (dilate == null) {\n            dilate = false;\n        }\n        if (types_1.isString(pts[0])) {\n            pts = scale.v_compute(pts);\n        }\n        if (pts_location === 'center') {\n            halfspan = (function () {\n                var j, len, results;\n                results = [];\n                for (j = 0, len = spans.length; j < len; j++) {\n                    d = spans[j];\n                    results.push(d / 2);\n                }\n                return results;\n            })();\n            pt0 = (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = pts.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(pts[i] - halfspan[i]);\n                }\n                return results;\n            })();\n            pt1 = (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = pts.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(pts[i] + halfspan[i]);\n                }\n                return results;\n            })();\n        }\n        else {\n            pt0 = pts;\n            pt1 = (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = pt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(pt0[i] + spans[i]);\n                }\n                return results;\n            })();\n        }\n        spt0 = scale.v_compute(pt0);\n        spt1 = scale.v_compute(pt1);\n        if (dilate) {\n            return (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = spt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(Math.ceil(Math.abs(spt1[i] - spt0[i])));\n                }\n                return results;\n            })();\n        }\n        else {\n            return (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = spt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(Math.abs(spt1[i] - spt0[i]));\n                }\n                return results;\n            })();\n        }\n    };\n    GlyphView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return null;\n    };\n    GlyphView.prototype._generic_line_legend = function (ctx, x0, x1, y0, y1, index) {\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(x0, (y0 + y1) / 2);\n        ctx.lineTo(x1, (y0 + y1) / 2);\n        if (this.visuals.line.doit) {\n            this.visuals.line.set_vectorize(ctx, index);\n            ctx.stroke();\n        }\n        return ctx.restore();\n    };\n    GlyphView.prototype._generic_area_legend = function (ctx, x0, x1, y0, y1, index) {\n        var dh, dw, h, indices, sx0, sx1, sy0, sy1, w;\n        indices = [index];\n        w = Math.abs(x1 - x0);\n        dw = w * 0.1;\n        h = Math.abs(y1 - y0);\n        dh = h * 0.1;\n        sx0 = x0 + dw;\n        sx1 = x1 - dw;\n        sy0 = y0 + dh;\n        sy1 = y1 - dh;\n        if (this.visuals.fill.doit) {\n            this.visuals.fill.set_vectorize(ctx, index);\n            ctx.fillRect(sx0, sy0, sx1 - sx0, sy1 - sy0);\n        }\n        if (this.visuals.line.doit) {\n            ctx.beginPath();\n            ctx.rect(sx0, sy0, sx1 - sx0, sy1 - sy0);\n            this.visuals.line.set_vectorize(ctx, index);\n            return ctx.stroke();\n        }\n    };\n    GlyphView.prototype.hit_test = function (geometry) {\n        var func, result;\n        result = null;\n        func = \"_hit_\" + geometry.type;\n        if (this[func] != null) {\n            result = this[func](geometry);\n        }\n        else if (this._nohit_warned[geometry.type] == null) {\n            logging_1.logger.debug(\"'\" + geometry.type + \"' selection not available for \" + this.model.type);\n            this._nohit_warned[geometry.type] = true;\n        }\n        return result;\n    };\n    GlyphView.prototype.set_data = function (source, indices) {\n        var data, ref, ref1;\n        data = this.model.materialize_dataspecs(source);\n        object_1.extend(this, data);\n        if (this.renderer.plot_view.model.use_map) {\n            if (this._x != null) {\n                ref = proj.project_xy(this._x, this._y), this._x = ref[0], this._y = ref[1];\n            }\n            if (this._xs != null) {\n                ref1 = proj.project_xsys(this._xs, this._ys), this._xs = ref1[0], this._ys = ref1[1];\n            }\n        }\n        if (this.glglyph != null) {\n            this.glglyph.set_data_changed(this._x.length);\n        }\n        this._set_data(source, indices);\n        return this.index = this._index_data();\n    };\n    GlyphView.prototype._set_data = function () { };\n    GlyphView.prototype._index_data = function () { };\n    GlyphView.prototype.mask_data = function (indices) {\n        if (this.glglyph != null) {\n            return indices;\n        }\n        else {\n            return this._mask_data(indices);\n        }\n    };\n    GlyphView.prototype._mask_data = function (indices) {\n        return indices;\n    };\n    GlyphView.prototype._bounds = function (bounds) {\n        return bounds;\n    };\n    GlyphView.prototype.map_data = function () {\n        var i, j, k, len, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, sx, sxname, sy, syname, xname, yname;\n        ref = this.model._coords;\n        for (j = 0, len = ref.length; j < len; j++) {\n            ref1 = ref[j], xname = ref1[0], yname = ref1[1];\n            sxname = \"s\" + xname;\n            syname = \"s\" + yname;\n            xname = \"_\" + xname;\n            yname = \"_\" + yname;\n            if (types_1.isArray((ref2 = this[xname]) != null ? ref2[0] : void 0) || ((ref3 = this[xname]) != null ? (ref4 = ref3[0]) != null ? ref4.buffer : void 0 : void 0) instanceof ArrayBuffer) {\n                ref5 = [[], []], this[sxname] = ref5[0], this[syname] = ref5[1];\n                for (i = k = 0, ref6 = this[xname].length; 0 <= ref6 ? k < ref6 : k > ref6; i = 0 <= ref6 ? ++k : --k) {\n                    ref7 = this.map_to_screen(this[xname][i], this[yname][i]), sx = ref7[0], sy = ref7[1];\n                    this[sxname].push(sx);\n                    this[syname].push(sy);\n                }\n            }\n            else {\n                ref8 = this.map_to_screen(this[xname], this[yname]), this[sxname] = ref8[0], this[syname] = ref8[1];\n            }\n        }\n        return this._map_data();\n    };\n    GlyphView.prototype._map_data = function () { };\n    GlyphView.prototype.map_to_screen = function (x, y) {\n        return this.renderer.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);\n    };\n    return GlyphView;\n})(view_1.View);\nexports.Glyph = (function (superClass) {\n    extend1(Glyph, superClass);\n    function Glyph() {\n        return Glyph.__super__.constructor.apply(this, arguments);\n    }\n    Glyph.prototype._coords = [];\n    Glyph.coords = function (coords) {\n        var _coords, j, len, ref, result, x, y;\n        _coords = this.prototype._coords.concat(coords);\n        this.prototype._coords = _coords;\n        result = {};\n        for (j = 0, len = coords.length; j < len; j++) {\n            ref = coords[j], x = ref[0], y = ref[1];\n            result[x] = [p.NumberSpec];\n            result[y] = [p.NumberSpec];\n        }\n        return this.define(result);\n    };\n    Glyph.internal({\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default']\n    });\n    return Glyph;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\nvar categorical_scale_1 = require(\"../scales/categorical_scale\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nexports.HBarView = (function (superClass) {\n    extend(HBarView, superClass);\n    function HBarView() {\n        return HBarView.__super__.constructor.apply(this, arguments);\n    }\n    HBarView.prototype._map_data = function () {\n        var i, j, ref, vleft, vright, vy;\n        vy = this.renderer.yscale.v_compute(this._y);\n        this.sy = this.renderer.plot_view.canvas.v_vy_to_sy(vy);\n        vright = this.renderer.xscale.v_compute(this._right);\n        vleft = this.renderer.xscale.v_compute(this._left);\n        this.sright = this.renderer.plot_view.canvas.v_vx_to_sx(vright);\n        this.sleft = this.renderer.plot_view.canvas.v_vx_to_sx(vleft);\n        this.stop = [];\n        this.sbottom = [];\n        this.sh = this.sdist(this.renderer.yscale, this._y, this._height, 'center');\n        for (i = j = 0, ref = this.sy.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            this.stop.push(this.sy[i] - this.sh[i] / 2);\n            this.sbottom.push(this.sy[i] + this.sh[i] / 2);\n        }\n        return null;\n    };\n    HBarView.prototype._index_data = function () {\n        var b, height, i, j, l, left, map_to_synthetic, points, r, ref, right, t, y;\n        map_to_synthetic = function (scale, array) {\n            if (scale instanceof categorical_scale_1.CategoricalScale) {\n                return scale.v_compute(array, true);\n            }\n            else {\n                return array;\n            }\n        };\n        left = map_to_synthetic(this.renderer.xscale, this._left);\n        right = map_to_synthetic(this.renderer.xscale, this._right);\n        y = map_to_synthetic(this.renderer.yscale, this._y);\n        height = map_to_synthetic(this.renderer.yscale, this._height);\n        points = [];\n        for (i = j = 0, ref = y.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            l = left[i];\n            r = right[i];\n            t = y[i] + 0.5 * height[i];\n            b = y[i] - 0.5 * height[i];\n            if (isNaN(l + r + t + b) || !isFinite(l + r + t + b)) {\n                continue;\n            }\n            points.push({\n                minX: l,\n                minY: b,\n                maxX: r,\n                maxY: t,\n                i: i\n            });\n        }\n        return new spatial_1.RBush(points);\n    };\n    HBarView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, sbottom, sleft, sright, stop;\n        sleft = arg.sleft, sright = arg.sright, stop = arg.stop, sbottom = arg.sbottom;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sleft[i] + stop[i] + sright[i] + sbottom[i])) {\n                continue;\n            }\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fillRect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n            }\n            if (this.visuals.line.doit) {\n                ctx.beginPath();\n                ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    HBarView.prototype._hit_point = function (geometry) {\n        var hits, ref, result, vx, vy, x, y;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xscale.invert(vx, true);\n        y = this.renderer.yscale.invert(vy, true);\n        hits = this.index.indices({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y\n        });\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    HBarView.prototype.scx = function (i) {\n        return (this.sleft[i] + this.sright[i]) / 2;\n    };\n    HBarView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return HBarView;\n})(glyph_1.GlyphView);\nexports.HBar = (function (superClass) {\n    extend(HBar, superClass);\n    function HBar() {\n        return HBar.__super__.constructor.apply(this, arguments);\n    }\n    HBar.prototype.default_view = exports.HBarView;\n    HBar.prototype.type = 'HBar';\n    HBar.mixins(['line', 'fill']);\n    HBar.define({\n        y: [p.NumberSpec],\n        height: [p.DistanceSpec],\n        left: [p.NumberSpec, 0],\n        right: [p.NumberSpec]\n    });\n    return HBar;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Greys9, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar linear_color_mapper_1 = require(\"../mappers/linear_color_mapper\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nexports.ImageView = (function (superClass) {\n    extend(ImageView, superClass);\n    function ImageView() {\n        return ImageView.__super__.constructor.apply(this, arguments);\n    }\n    ImageView.prototype.initialize = function (options) {\n        ImageView.__super__.initialize.call(this, options);\n        return this.connect(this.model.color_mapper.change, function () {\n            return this._update_image();\n        });\n    };\n    ImageView.prototype._update_image = function () {\n        if (this.image_data != null) {\n            this._set_data();\n            return this.renderer.plot_view.request_render();\n        }\n    };\n    ImageView.prototype._set_data = function () {\n        var buf, buf8, canvas, cmap, ctx, i, image_data, img, j, ref, results, shape;\n        if ((this.image_data == null) || this.image_data.length !== this._image.length) {\n            this.image_data = new Array(this._image.length);\n        }\n        if ((this._width == null) || this._width.length !== this._image.length) {\n            this._width = new Array(this._image.length);\n        }\n        if ((this._height == null) || this._height.length !== this._image.length) {\n            this._height = new Array(this._image.length);\n        }\n        results = [];\n        for (i = j = 0, ref = this._image.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            shape = [];\n            if (this._image_shape != null) {\n                shape = this._image_shape[i];\n            }\n            if (shape.length > 0) {\n                img = this._image[i];\n                this._height[i] = shape[0];\n                this._width[i] = shape[1];\n            }\n            else {\n                img = array_1.concat(this._image[i]);\n                this._height[i] = this._image[i].length;\n                this._width[i] = this._image[i][0].length;\n            }\n            if ((this.image_data[i] != null) && this.image_data[i].width === this._width[i] && this.image_data[i].height === this._height[i]) {\n                canvas = this.image_data[i];\n            }\n            else {\n                canvas = document.createElement('canvas');\n                canvas.width = this._width[i];\n                canvas.height = this._height[i];\n            }\n            ctx = canvas.getContext('2d');\n            image_data = ctx.getImageData(0, 0, this._width[i], this._height[i]);\n            cmap = this.model.color_mapper;\n            buf = cmap.v_map_screen(img, true);\n            buf8 = new Uint8Array(buf);\n            image_data.data.set(buf8);\n            ctx.putImageData(image_data, 0, 0);\n            this.image_data[i] = canvas;\n            this.max_dw = 0;\n            if (this._dw.units === \"data\") {\n                this.max_dw = array_1.max(this._dw);\n            }\n            this.max_dh = 0;\n            if (this._dh.units === \"data\") {\n                results.push(this.max_dh = array_1.max(this._dh));\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    ImageView.prototype._map_data = function () {\n        switch (this.model.properties.dw.units) {\n            case \"data\":\n                this.sw = this.sdist(this.renderer.xscale, this._x, this._dw, 'edge', this.model.dilate);\n                break;\n            case \"screen\":\n                this.sw = this._dw;\n        }\n        switch (this.model.properties.dh.units) {\n            case \"data\":\n                return this.sh = this.sdist(this.renderer.yscale, this._y, this._dh, 'edge', this.model.dilate);\n            case \"screen\":\n                return this.sh = this._dh;\n        }\n    };\n    ImageView.prototype._render = function (ctx, indices, arg) {\n        var i, image_data, j, len, old_smoothing, sh, sw, sx, sy, y_offset;\n        image_data = arg.image_data, sx = arg.sx, sy = arg.sy, sw = arg.sw, sh = arg.sh;\n        old_smoothing = ctx.getImageSmoothingEnabled();\n        ctx.setImageSmoothingEnabled(false);\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (image_data[i] == null) {\n                continue;\n            }\n            if (isNaN(sx[i] + sy[i] + sw[i] + sh[i])) {\n                continue;\n            }\n            y_offset = sy[i];\n            ctx.translate(0, y_offset);\n            ctx.scale(1, -1);\n            ctx.translate(0, -y_offset);\n            ctx.drawImage(image_data[i], sx[i] | 0, sy[i] | 0, sw[i], sh[i]);\n            ctx.translate(0, y_offset);\n            ctx.scale(1, -1);\n            ctx.translate(0, -y_offset);\n        }\n        return ctx.setImageSmoothingEnabled(old_smoothing);\n    };\n    ImageView.prototype.bounds = function () {\n        var bbox;\n        bbox = this.index.bbox;\n        bbox.maxX += this.max_dw;\n        bbox.maxY += this.max_dh;\n        return bbox;\n    };\n    return ImageView;\n})(xy_glyph_1.XYGlyphView);\nGreys9 = function () {\n    return [0x000000, 0x252525, 0x525252, 0x737373, 0x969696, 0xbdbdbd, 0xd9d9d9, 0xf0f0f0, 0xffffff];\n};\nexports.Image = (function (superClass) {\n    extend(Image, superClass);\n    function Image() {\n        return Image.__super__.constructor.apply(this, arguments);\n    }\n    Image.prototype.default_view = exports.ImageView;\n    Image.prototype.type = 'Image';\n    Image.define({\n        image: [p.NumberSpec],\n        dw: [p.DistanceSpec],\n        dh: [p.DistanceSpec],\n        dilate: [p.Bool, false],\n        color_mapper: [\n            p.Instance, function () {\n                return new linear_color_mapper_1.LinearColorMapper({\n                    palette: Greys9()\n                });\n            }\n        ]\n    });\n    return Image;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nexports.ImageRGBAView = (function (superClass) {\n    extend(ImageRGBAView, superClass);\n    function ImageRGBAView() {\n        return ImageRGBAView.__super__.constructor.apply(this, arguments);\n    }\n    ImageRGBAView.prototype._set_data = function (source, indices) {\n        var buf, buf8, canvas, color, ctx, flat, i, image_data, j, k, l, m, ref, ref1, ref2, results, shape;\n        if ((this.image_data == null) || this.image_data.length !== this._image.length) {\n            this.image_data = new Array(this._image.length);\n        }\n        if ((this._width == null) || this._width.length !== this._image.length) {\n            this._width = new Array(this._image.length);\n        }\n        if ((this._height == null) || this._height.length !== this._image.length) {\n            this._height = new Array(this._image.length);\n        }\n        results = [];\n        for (i = k = 0, ref = this._image.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            if ((indices != null) && indices.indexOf(i) < 0) {\n                continue;\n            }\n            shape = [];\n            if (this._image_shape != null) {\n                shape = this._image_shape[i];\n            }\n            if (this._rows != null) {\n                this._height[i] = this._rows[i];\n                this._width[i] = this._cols[i];\n                if (shape.length > 0) {\n                    buf = this._image[i].buffer;\n                }\n                else {\n                    flat = this._image[i];\n                    buf = new ArrayBuffer(flat.length * 4);\n                    color = new Uint32Array(buf);\n                    for (j = l = 0, ref1 = flat.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                        color[j] = flat[j];\n                    }\n                }\n            }\n            else if (shape.length > 0) {\n                buf = this._image[i].buffer;\n                this._height[i] = shape[0];\n                this._width[i] = shape[1];\n            }\n            else {\n                flat = array_1.concat(this._image[i]);\n                buf = new ArrayBuffer(flat.length * 4);\n                color = new Uint32Array(buf);\n                for (j = m = 0, ref2 = flat.length; 0 <= ref2 ? m < ref2 : m > ref2; j = 0 <= ref2 ? ++m : --m) {\n                    color[j] = flat[j];\n                }\n                this._height[i] = this._image[i].length;\n                this._width[i] = this._image[i][0].length;\n            }\n            if ((this.image_data[i] != null) && this.image_data[i].width === this._width[i] && this.image_data[i].height === this._height[i]) {\n                canvas = this.image_data[i];\n            }\n            else {\n                canvas = document.createElement('canvas');\n                canvas.width = this._width[i];\n                canvas.height = this._height[i];\n            }\n            ctx = canvas.getContext('2d');\n            image_data = ctx.getImageData(0, 0, this._width[i], this._height[i]);\n            buf8 = new Uint8Array(buf);\n            image_data.data.set(buf8);\n            ctx.putImageData(image_data, 0, 0);\n            this.image_data[i] = canvas;\n            this.max_dw = 0;\n            if (this._dw.units === \"data\") {\n                this.max_dw = array_1.max(this._dw);\n            }\n            this.max_dh = 0;\n            if (this._dh.units === \"data\") {\n                results.push(this.max_dh = array_1.max(this._dh));\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    ImageRGBAView.prototype._map_data = function () {\n        switch (this.model.properties.dw.units) {\n            case \"data\":\n                this.sw = this.sdist(this.renderer.xscale, this._x, this._dw, 'edge', this.model.dilate);\n                break;\n            case \"screen\":\n                this.sw = this._dw;\n        }\n        switch (this.model.properties.dh.units) {\n            case \"data\":\n                return this.sh = this.sdist(this.renderer.yscale, this._y, this._dh, 'edge', this.model.dilate);\n            case \"screen\":\n                return this.sh = this._dh;\n        }\n    };\n    ImageRGBAView.prototype._render = function (ctx, indices, arg) {\n        var i, image_data, k, len, old_smoothing, sh, sw, sx, sy, y_offset;\n        image_data = arg.image_data, sx = arg.sx, sy = arg.sy, sw = arg.sw, sh = arg.sh;\n        old_smoothing = ctx.getImageSmoothingEnabled();\n        ctx.setImageSmoothingEnabled(false);\n        for (k = 0, len = indices.length; k < len; k++) {\n            i = indices[k];\n            if (isNaN(sx[i] + sy[i] + sw[i] + sh[i])) {\n                continue;\n            }\n            y_offset = sy[i];\n            ctx.translate(0, y_offset);\n            ctx.scale(1, -1);\n            ctx.translate(0, -y_offset);\n            ctx.drawImage(image_data[i], sx[i] | 0, sy[i] | 0, sw[i], sh[i]);\n            ctx.translate(0, y_offset);\n            ctx.scale(1, -1);\n            ctx.translate(0, -y_offset);\n        }\n        return ctx.setImageSmoothingEnabled(old_smoothing);\n    };\n    ImageRGBAView.prototype.bounds = function () {\n        var bbox;\n        bbox = this.index.bbox;\n        bbox.maxX += this.max_dw;\n        bbox.maxY += this.max_dh;\n        return bbox;\n    };\n    return ImageRGBAView;\n})(xy_glyph_1.XYGlyphView);\nexports.ImageRGBA = (function (superClass) {\n    extend(ImageRGBA, superClass);\n    function ImageRGBA() {\n        return ImageRGBA.__super__.constructor.apply(this, arguments);\n    }\n    ImageRGBA.prototype.default_view = exports.ImageRGBAView;\n    ImageRGBA.prototype.type = 'ImageRGBA';\n    ImageRGBA.define({\n        image: [p.NumberSpec],\n        rows: [p.NumberSpec],\n        cols: [p.NumberSpec],\n        dw: [p.DistanceSpec],\n        dh: [p.DistanceSpec],\n        dilate: [p.Bool, false]\n    });\n    ImageRGBA.prototype.initialize = function (attrs, options) {\n        ImageRGBA.__super__.initialize.call(this, attrs, options);\n        this.properties.rows.optional = true;\n        return this.properties.cols.optional = true;\n    };\n    return ImageRGBA;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar glyph_1 = require(\"./glyph\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nexports.ImageURLView = (function (superClass) {\n    extend(ImageURLView, superClass);\n    function ImageURLView() {\n        return ImageURLView.__super__.constructor.apply(this, arguments);\n    }\n    ImageURLView.prototype.initialize = function (options) {\n        ImageURLView.__super__.initialize.call(this, options);\n        return this.connect(this.model.properties.global_alpha.change, (function (_this) {\n            return function () {\n                return _this.renderer.request_render();\n            };\n        })(this));\n    };\n    ImageURLView.prototype._index_data = function () { };\n    ImageURLView.prototype._set_data = function () {\n        var i, img, j, ref, results, retry_attempts, retry_timeout;\n        if ((this.image == null) || this.image.length !== this._url.length) {\n            this.image = (function () {\n                var j, len, ref, results;\n                ref = this._url;\n                results = [];\n                for (j = 0, len = ref.length; j < len; j++) {\n                    img = ref[j];\n                    results.push(null);\n                }\n                return results;\n            }).call(this);\n        }\n        retry_attempts = this.model.retry_attempts;\n        retry_timeout = this.model.retry_timeout;\n        this.retries = (function () {\n            var j, len, ref, results;\n            ref = this._url;\n            results = [];\n            for (j = 0, len = ref.length; j < len; j++) {\n                img = ref[j];\n                results.push(retry_attempts);\n            }\n            return results;\n        }).call(this);\n        results = [];\n        for (i = j = 0, ref = this._url.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            if (this._url[i] == null) {\n                continue;\n            }\n            img = new Image();\n            img.onerror = (function (_this) {\n                return function (i, img) {\n                    return function () {\n                        if (_this.retries[i] > 0) {\n                            logging_1.logger.trace(\"ImageURL failed to load \" + _this._url[i] + \" image, retrying in \" + retry_timeout + \" ms\");\n                            setTimeout((function () {\n                                return img.src = _this._url[i];\n                            }), retry_timeout);\n                        }\n                        else {\n                            logging_1.logger.warn(\"ImageURL unable to load \" + _this._url[i] + \" image after \" + retry_attempts + \" retries\");\n                        }\n                        return _this.retries[i] -= 1;\n                    };\n                };\n            })(this)(i, img);\n            img.onload = (function (_this) {\n                return function (img, i) {\n                    return function () {\n                        _this.image[i] = img;\n                        return _this.renderer.request_render();\n                    };\n                };\n            })(this)(img, i);\n            results.push(img.src = this._url[i]);\n        }\n        return results;\n    };\n    ImageURLView.prototype.has_finished = function () {\n        return ImageURLView.__super__.has_finished.call(this) && this._images_rendered === true;\n    };\n    ImageURLView.prototype._map_data = function () {\n        var hs, ws, x;\n        ws = ((function () {\n            var j, len, ref, results;\n            if (this.model.w != null) {\n                return this._w;\n            }\n            else {\n                ref = this._x;\n                results = [];\n                for (j = 0, len = ref.length; j < len; j++) {\n                    x = ref[j];\n                    results.push(0 / 0);\n                }\n                return results;\n            }\n        }).call(this));\n        hs = ((function () {\n            var j, len, ref, results;\n            if (this.model.h != null) {\n                return this._h;\n            }\n            else {\n                ref = this._x;\n                results = [];\n                for (j = 0, len = ref.length; j < len; j++) {\n                    x = ref[j];\n                    results.push(0 / 0);\n                }\n                return results;\n            }\n        }).call(this));\n        switch (this.model.properties.w.units) {\n            case \"data\":\n                this.sw = this.sdist(this.renderer.xscale, this._x, ws, 'edge', this.model.dilate);\n                break;\n            case \"screen\":\n                this.sw = ws;\n        }\n        switch (this.model.properties.h.units) {\n            case \"data\":\n                return this.sh = this.sdist(this.renderer.yscale, this._y, hs, 'edge', this.model.dilate);\n            case \"screen\":\n                return this.sh = hs;\n        }\n    };\n    ImageURLView.prototype._render = function (ctx, indices, arg) {\n        var _angle, _url, finished, frame, i, image, j, len, sh, sw, sx, sy;\n        _url = arg._url, image = arg.image, sx = arg.sx, sy = arg.sy, sw = arg.sw, sh = arg.sh, _angle = arg._angle;\n        frame = this.renderer.plot_view.frame;\n        ctx.rect(frame._left.value + 1, frame._bottom.value + 1, frame._width.value - 2, frame._height.value - 2);\n        ctx.clip();\n        finished = true;\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + _angle[i])) {\n                continue;\n            }\n            if (this.retries[i] === -1) {\n                continue;\n            }\n            if (image[i] == null) {\n                finished = false;\n                continue;\n            }\n            this._render_image(ctx, i, image[i], sx, sy, sw, sh, _angle);\n        }\n        if (finished && !this._images_rendered) {\n            this._images_rendered = true;\n            return this.notify_finished();\n        }\n    };\n    ImageURLView.prototype._final_sx_sy = function (anchor, sx, sy, sw, sh) {\n        switch (anchor) {\n            case 'top_left':\n                return [sx, sy];\n            case 'top_center':\n                return [sx - sw / 2, sy];\n            case 'top_right':\n                return [sx - sw, sy];\n            case 'center_right':\n                return [sx - sw, sy - sh / 2];\n            case 'bottom_right':\n                return [sx - sw, sy - sh];\n            case 'bottom_center':\n                return [sx - sw / 2, sy - sh];\n            case 'bottom_left':\n                return [sx, sy - sh];\n            case 'center_left':\n                return [sx, sy - sh / 2];\n            case 'center':\n                return [sx - sw / 2, sy - sh / 2];\n        }\n    };\n    ImageURLView.prototype._render_image = function (ctx, i, image, sx, sy, sw, sh, angle) {\n        var anchor, ref;\n        if (isNaN(sw[i])) {\n            sw[i] = image.width;\n        }\n        if (isNaN(sh[i])) {\n            sh[i] = image.height;\n        }\n        anchor = this.model.anchor;\n        ref = this._final_sx_sy(anchor, sx[i], sy[i], sw[i], sh[i]), sx = ref[0], sy = ref[1];\n        ctx.save();\n        ctx.globalAlpha = this.model.global_alpha;\n        if (angle[i]) {\n            ctx.translate(sx, sy);\n            ctx.rotate(angle[i]);\n            ctx.drawImage(image, 0, 0, sw[i], sh[i]);\n            ctx.rotate(-angle[i]);\n            ctx.translate(-sx, -sy);\n        }\n        else {\n            ctx.drawImage(image, sx, sy, sw[i], sh[i]);\n        }\n        return ctx.restore();\n    };\n    return ImageURLView;\n})(glyph_1.GlyphView);\nexports.ImageURL = (function (superClass) {\n    extend(ImageURL, superClass);\n    function ImageURL() {\n        return ImageURL.__super__.constructor.apply(this, arguments);\n    }\n    ImageURL.prototype.default_view = exports.ImageURLView;\n    ImageURL.prototype.type = 'ImageURL';\n    ImageURL.coords([['x', 'y']]);\n    ImageURL.mixins([]);\n    ImageURL.define({\n        url: [p.StringSpec],\n        anchor: [p.Anchor, 'top_left'],\n        global_alpha: [p.Number, 1.0],\n        angle: [p.AngleSpec, 0],\n        w: [p.DistanceSpec],\n        h: [p.DistanceSpec],\n        dilate: [p.Bool, false],\n        retry_attempts: [p.Number, 0],\n        retry_timeout: [p.Number, 0]\n    });\n    return ImageURL;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar annular_wedge_1 = require(\"./annular_wedge\");\nexports.AnnularWedge = annular_wedge_1.AnnularWedge;\nvar annulus_1 = require(\"./annulus\");\nexports.Annulus = annulus_1.Annulus;\nvar arc_1 = require(\"./arc\");\nexports.Arc = arc_1.Arc;\nvar bezier_1 = require(\"./bezier\");\nexports.Bezier = bezier_1.Bezier;\nvar circle_1 = require(\"./circle\");\nexports.Circle = circle_1.Circle;\nvar ellipse_1 = require(\"./ellipse\");\nexports.Ellipse = ellipse_1.Ellipse;\nvar glyph_1 = require(\"./glyph\");\nexports.Glyph = glyph_1.Glyph;\nvar hbar_1 = require(\"./hbar\");\nexports.HBar = hbar_1.HBar;\nvar image_1 = require(\"./image\");\nexports.Image = image_1.Image;\nvar image_rgba_1 = require(\"./image_rgba\");\nexports.ImageRGBA = image_rgba_1.ImageRGBA;\nvar image_url_1 = require(\"./image_url\");\nexports.ImageURL = image_url_1.ImageURL;\nvar line_1 = require(\"./line\");\nexports.Line = line_1.Line;\nvar multi_line_1 = require(\"./multi_line\");\nexports.MultiLine = multi_line_1.MultiLine;\nvar oval_1 = require(\"./oval\");\nexports.Oval = oval_1.Oval;\nvar patch_1 = require(\"./patch\");\nexports.Patch = patch_1.Patch;\nvar patches_1 = require(\"./patches\");\nexports.Patches = patches_1.Patches;\nvar quad_1 = require(\"./quad\");\nexports.Quad = quad_1.Quad;\nvar quadratic_1 = require(\"./quadratic\");\nexports.Quadratic = quadratic_1.Quadratic;\nvar ray_1 = require(\"./ray\");\nexports.Ray = ray_1.Ray;\nvar rect_1 = require(\"./rect\");\nexports.Rect = rect_1.Rect;\nvar segment_1 = require(\"./segment\");\nexports.Segment = segment_1.Segment;\nvar text_1 = require(\"./text\");\nexports.Text = text_1.Text;\nvar vbar_1 = require(\"./vbar\");\nexports.VBar = vbar_1.VBar;\nvar wedge_1 = require(\"./wedge\");\nexports.Wedge = wedge_1.Wedge;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nexports.XYGlyph = xy_glyph_1.XYGlyph;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar hittest = require(\"core/hittest\");\nexports.LineView = (function (superClass) {\n    extend(LineView, superClass);\n    function LineView() {\n        return LineView.__super__.constructor.apply(this, arguments);\n    }\n    LineView.prototype._render = function (ctx, indices, arg) {\n        var drawing, i, j, len, sx, sy;\n        sx = arg.sx, sy = arg.sy;\n        drawing = false;\n        this.visuals.line.set_value(ctx);\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (!isFinite(sx[i] + sy[i]) && drawing) {\n                ctx.stroke();\n                ctx.beginPath();\n                drawing = false;\n                continue;\n            }\n            if (drawing) {\n                ctx.lineTo(sx[i], sy[i]);\n            }\n            else {\n                ctx.beginPath();\n                ctx.moveTo(sx[i], sy[i]);\n                drawing = true;\n            }\n        }\n        if (drawing) {\n            return ctx.stroke();\n        }\n    };\n    LineView.prototype._hit_point = function (geometry) {\n        /* Check if the point geometry hits this line glyph and return an object\n        that describes the hit result:\n          Args:\n            * geometry (object): object with the following keys\n              * vx (float): view x coordinate of the point\n              * vy (float): view y coordinate of the point\n              * type (str): type of geometry (in this case it's a point)\n          Output:\n            Object with the following keys:\n              * 0d (bool): whether the point hits the glyph or not\n              * 1d (array(int)): array with the indices hit by the point\n         */\n        var dist, i, j, p0, p1, point, ref, ref1, result, shortest, threshold;\n        result = hittest.create_hit_test_result();\n        point = {\n            x: this.renderer.plot_view.canvas.vx_to_sx(geometry.vx),\n            y: this.renderer.plot_view.canvas.vy_to_sy(geometry.vy)\n        };\n        shortest = 9999;\n        threshold = Math.max(2, this.visuals.line.line_width.value() / 2);\n        for (i = j = 0, ref = this.sx.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            ref1 = [\n                {\n                    x: this.sx[i],\n                    y: this.sy[i]\n                }, {\n                    x: this.sx[i + 1],\n                    y: this.sy[i + 1]\n                }\n            ], p0 = ref1[0], p1 = ref1[1];\n            dist = hittest.dist_to_segment(point, p0, p1);\n            if (dist < threshold && dist < shortest) {\n                shortest = dist;\n                result['0d'].glyph = this.model;\n                result['0d'].get_view = (function () {\n                    return this;\n                }).bind(this);\n                result['0d'].flag = true;\n                result['0d'].indices = [i];\n            }\n        }\n        return result;\n    };\n    LineView.prototype._hit_span = function (geometry) {\n        var i, j, ref, ref1, result, val, values, vx, vy;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        result = hittest.create_hit_test_result();\n        if (geometry.direction === 'v') {\n            val = this.renderer.yscale.invert(vy);\n            values = this._y;\n        }\n        else {\n            val = this.renderer.xscale.invert(vx);\n            values = this._x;\n        }\n        for (i = j = 0, ref1 = values.length - 1; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n            if ((values[i] <= val && val <= values[i + 1]) || (values[i + 1] <= val && val <= values[i])) {\n                result['0d'].glyph = this.model;\n                result['0d'].get_view = (function () {\n                    return this;\n                }).bind(this);\n                result['0d'].flag = true;\n                result['0d'].indices.push(i);\n            }\n        }\n        return result;\n    };\n    LineView.prototype.get_interpolation_hit = function (i, geometry) {\n        var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, res, vx, vy, x0, x1, x2, x3, y0, y1, y2, y3;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        ref1 = [this._x[i], this._y[i], this._x[i + 1], this._y[i + 1]], x2 = ref1[0], y2 = ref1[1], x3 = ref1[2], y3 = ref1[3];\n        if (geometry.type === 'point') {\n            ref2 = this.renderer.yscale.v_invert([vy - 1, vy + 1]), y0 = ref2[0], y1 = ref2[1];\n            ref3 = this.renderer.xscale.v_invert([vx - 1, vx + 1]), x0 = ref3[0], x1 = ref3[1];\n        }\n        else {\n            if (geometry.direction === 'v') {\n                ref4 = this.renderer.yscale.v_invert([vy, vy]), y0 = ref4[0], y1 = ref4[1];\n                ref5 = [x2, x3], x0 = ref5[0], x1 = ref5[1];\n            }\n            else {\n                ref6 = this.renderer.xscale.v_invert([vx, vx]), x0 = ref6[0], x1 = ref6[1];\n                ref7 = [y2, y3], y0 = ref7[0], y1 = ref7[1];\n            }\n        }\n        res = hittest.check_2_segments_intersect(x0, y0, x1, y1, x2, y2, x3, y3);\n        return [res.x, res.y];\n    };\n    LineView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return LineView;\n})(xy_glyph_1.XYGlyphView);\nexports.Line = (function (superClass) {\n    extend(Line, superClass);\n    function Line() {\n        return Line.__super__.constructor.apply(this, arguments);\n    }\n    Line.prototype.default_view = exports.LineView;\n    Line.prototype.type = 'Line';\n    Line.mixins(['line']);\n    return Line;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar hittest = require(\"core/hittest\");\nvar array_1 = require(\"core/util/array\");\nvar types_1 = require(\"core/util/types\");\nvar glyph_1 = require(\"./glyph\");\nexports.MultiLineView = (function (superClass) {\n    extend(MultiLineView, superClass);\n    function MultiLineView() {\n        return MultiLineView.__super__.constructor.apply(this, arguments);\n    }\n    MultiLineView.prototype._index_data = function () {\n        var i, k, points, ref, x, xs, y, ys;\n        points = [];\n        for (i = k = 0, ref = this._xs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            xs = (function () {\n                var l, len, ref1, results;\n                ref1 = this._xs[i];\n                results = [];\n                for (l = 0, len = ref1.length; l < len; l++) {\n                    x = ref1[l];\n                    if (!types_1.isStrictNaN(x)) {\n                        results.push(x);\n                    }\n                }\n                return results;\n            }).call(this);\n            ys = (function () {\n                var l, len, ref1, results;\n                ref1 = this._ys[i];\n                results = [];\n                for (l = 0, len = ref1.length; l < len; l++) {\n                    y = ref1[l];\n                    if (!types_1.isStrictNaN(y)) {\n                        results.push(y);\n                    }\n                }\n                return results;\n            }).call(this);\n            if (xs.length === 0) {\n                continue;\n            }\n            points.push({\n                minX: array_1.min(xs),\n                minY: array_1.min(ys),\n                maxX: array_1.max(xs),\n                maxY: array_1.max(ys),\n                i: i\n            });\n        }\n        return new spatial_1.RBush(points);\n    };\n    MultiLineView.prototype._render = function (ctx, indices, arg) {\n        var i, j, k, l, len, ref, ref1, results, sx, sxs, sy, sys;\n        sxs = arg.sxs, sys = arg.sys;\n        results = [];\n        for (k = 0, len = indices.length; k < len; k++) {\n            i = indices[k];\n            ref = [sxs[i], sys[i]], sx = ref[0], sy = ref[1];\n            this.visuals.line.set_vectorize(ctx, i);\n            for (j = l = 0, ref1 = sx.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                if (j === 0) {\n                    ctx.beginPath();\n                    ctx.moveTo(sx[j], sy[j]);\n                    continue;\n                }\n                else if (isNaN(sx[j]) || isNaN(sy[j])) {\n                    ctx.stroke();\n                    ctx.beginPath();\n                    continue;\n                }\n                else {\n                    ctx.lineTo(sx[j], sy[j]);\n                }\n            }\n            results.push(ctx.stroke());\n        }\n        return results;\n    };\n    MultiLineView.prototype._hit_point = function (geometry) {\n        var dist, hits, i, j, k, l, p0, p1, point, points, ref, ref1, ref2, result, shortest, threshold;\n        result = hittest.create_hit_test_result();\n        point = {\n            x: this.renderer.plot_view.canvas.vx_to_sx(geometry.vx),\n            y: this.renderer.plot_view.canvas.vy_to_sy(geometry.vy)\n        };\n        shortest = 9999;\n        hits = {};\n        for (i = k = 0, ref = this.sxs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            threshold = Math.max(2, this.visuals.line.cache_select('line_width', i) / 2);\n            points = null;\n            for (j = l = 0, ref1 = this.sxs[i].length - 1; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                ref2 = [\n                    {\n                        x: this.sxs[i][j],\n                        y: this.sys[i][j]\n                    }, {\n                        x: this.sxs[i][j + 1],\n                        y: this.sys[i][j + 1]\n                    }\n                ], p0 = ref2[0], p1 = ref2[1];\n                dist = hittest.dist_to_segment(point, p0, p1);\n                if (dist < threshold && dist < shortest) {\n                    shortest = dist;\n                    points = [j];\n                }\n            }\n            if (points) {\n                hits[i] = points;\n            }\n        }\n        result['1d'].indices = Object.keys(hits);\n        result['2d'].indices = hits;\n        return result;\n    };\n    MultiLineView.prototype._hit_span = function (geometry) {\n        var hits, i, j, k, l, points, ref, ref1, ref2, result, val, values, vx, vy;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        result = hittest.create_hit_test_result();\n        if (geometry.direction === 'v') {\n            val = this.renderer.yscale.invert(vy);\n            values = this._ys;\n        }\n        else {\n            val = this.renderer.xscale.invert(vx);\n            values = this._xs;\n        }\n        hits = {};\n        for (i = k = 0, ref1 = values.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n            points = [];\n            for (j = l = 0, ref2 = values[i].length - 1; 0 <= ref2 ? l < ref2 : l > ref2; j = 0 <= ref2 ? ++l : --l) {\n                if ((values[i][j] <= val && val <= values[i][j + 1])) {\n                    points.push(j);\n                }\n            }\n            if (points.length > 0) {\n                hits[i] = points;\n            }\n        }\n        result['1d'].indices = Object.keys(hits);\n        result['2d'].indices = hits;\n        return result;\n    };\n    MultiLineView.prototype.get_interpolation_hit = function (i, point_i, geometry) {\n        var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, res, vx, vy, x0, x1, x2, x3, y0, y1, y2, y3;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        ref1 = [this._xs[i][point_i], this._ys[i][point_i], this._xs[i][point_i + 1], this._ys[i][point_i + 1]], x2 = ref1[0], y2 = ref1[1], x3 = ref1[2], y3 = ref1[3];\n        if (geometry.type === 'point') {\n            ref2 = this.renderer.yscale.v_invert([vy - 1, vy + 1]), y0 = ref2[0], y1 = ref2[1];\n            ref3 = this.renderer.xscale.v_invert([vx - 1, vx + 1]), x0 = ref3[0], x1 = ref3[1];\n        }\n        else {\n            if (geometry.direction === 'v') {\n                ref4 = this.renderer.yscale.v_invert([vy, vy]), y0 = ref4[0], y1 = ref4[1];\n                ref5 = [x2, x3], x0 = ref5[0], x1 = ref5[1];\n            }\n            else {\n                ref6 = this.renderer.xscale.v_invert([vx, vx]), x0 = ref6[0], x1 = ref6[1];\n                ref7 = [y2, y3], y0 = ref7[0], y1 = ref7[1];\n            }\n        }\n        res = hittest.check_2_segments_intersect(x0, y0, x1, y1, x2, y2, x3, y3);\n        return [res.x, res.y];\n    };\n    MultiLineView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return MultiLineView;\n})(glyph_1.GlyphView);\nexports.MultiLine = (function (superClass) {\n    extend(MultiLine, superClass);\n    function MultiLine() {\n        return MultiLine.__super__.constructor.apply(this, arguments);\n    }\n    MultiLine.prototype.default_view = exports.MultiLineView;\n    MultiLine.prototype.type = 'MultiLine';\n    MultiLine.coords([['xs', 'ys']]);\n    MultiLine.mixins(['line']);\n    return MultiLine;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar p = require(\"core/properties\");\nexports.OvalView = (function (superClass) {\n    extend(OvalView, superClass);\n    function OvalView() {\n        return OvalView.__super__.constructor.apply(this, arguments);\n    }\n    OvalView.prototype._set_data = function () {\n        this.max_w2 = 0;\n        if (this.model.properties.width.units === \"data\") {\n            this.max_w2 = this.max_width / 2;\n        }\n        this.max_h2 = 0;\n        if (this.model.properties.height.units === \"data\") {\n            return this.max_h2 = this.max_height / 2;\n        }\n    };\n    OvalView.prototype._map_data = function () {\n        if (this.model.properties.width.units === \"data\") {\n            this.sw = this.sdist(this.renderer.xscale, this._x, this._width, 'center');\n        }\n        else {\n            this.sw = this._width;\n        }\n        if (this.model.properties.height.units === \"data\") {\n            return this.sh = this.sdist(this.renderer.yscale, this._y, this._height, 'center');\n        }\n        else {\n            return this.sh = this._height;\n        }\n    };\n    OvalView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, sh, sw, sx, sy;\n        sx = arg.sx, sy = arg.sy, sw = arg.sw, sh = arg.sh;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + sw[i] + sh[i] + this._angle[i])) {\n                continue;\n            }\n            ctx.translate(sx[i], sy[i]);\n            ctx.rotate(this._angle[i]);\n            ctx.beginPath();\n            ctx.moveTo(0, -sh[i] / 2);\n            ctx.bezierCurveTo(sw[i] / 2, -sh[i] / 2, sw[i] / 2, sh[i] / 2, 0, sh[i] / 2);\n            ctx.bezierCurveTo(-sw[i] / 2, sh[i] / 2, -sw[i] / 2, -sh[i] / 2, 0, -sh[i] / 2);\n            ctx.closePath();\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.stroke();\n            }\n            ctx.rotate(-this._angle[i]);\n            results.push(ctx.translate(-sx[i], -sy[i]));\n        }\n        return results;\n    };\n    OvalView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        var d, data, indices, scale, sh, sw, sx, sy;\n        indices = [index];\n        sx = {};\n        sx[index] = (x0 + x1) / 2;\n        sy = {};\n        sy[index] = (y0 + y1) / 2;\n        scale = this.sw[index] / this.sh[index];\n        d = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.8;\n        sw = {};\n        sh = {};\n        if (scale > 1) {\n            sw[index] = d;\n            sh[index] = d / scale;\n        }\n        else {\n            sw[index] = d * scale;\n            sh[index] = d;\n        }\n        data = {\n            sx: sx,\n            sy: sy,\n            sw: sw,\n            sh: sh\n        };\n        return this._render(ctx, indices, data);\n    };\n    OvalView.prototype._bounds = function (bds) {\n        return this.max_wh2_bounds(bds);\n    };\n    return OvalView;\n})(xy_glyph_1.XYGlyphView);\nexports.Oval = (function (superClass) {\n    extend(Oval, superClass);\n    function Oval() {\n        return Oval.__super__.constructor.apply(this, arguments);\n    }\n    Oval.prototype.default_view = exports.OvalView;\n    Oval.prototype.type = 'Oval';\n    Oval.mixins(['line', 'fill']);\n    Oval.define({\n        angle: [p.AngleSpec, 0.0],\n        width: [p.DistanceSpec],\n        height: [p.DistanceSpec]\n    });\n    return Oval;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nexports.PatchView = (function (superClass) {\n    extend(PatchView, superClass);\n    function PatchView() {\n        return PatchView.__super__.constructor.apply(this, arguments);\n    }\n    PatchView.prototype._render = function (ctx, indices, arg) {\n        var i, j, k, len, len1, sx, sy;\n        sx = arg.sx, sy = arg.sy;\n        if (this.visuals.fill.doit) {\n            this.visuals.fill.set_value(ctx);\n            for (j = 0, len = indices.length; j < len; j++) {\n                i = indices[j];\n                if (i === 0) {\n                    ctx.beginPath();\n                    ctx.moveTo(sx[i], sy[i]);\n                    continue;\n                }\n                else if (isNaN(sx[i] + sy[i])) {\n                    ctx.closePath();\n                    ctx.fill();\n                    ctx.beginPath();\n                    continue;\n                }\n                else {\n                    ctx.lineTo(sx[i], sy[i]);\n                }\n            }\n            ctx.closePath();\n            ctx.fill();\n        }\n        if (this.visuals.line.doit) {\n            this.visuals.line.set_value(ctx);\n            for (k = 0, len1 = indices.length; k < len1; k++) {\n                i = indices[k];\n                if (i === 0) {\n                    ctx.beginPath();\n                    ctx.moveTo(sx[i], sy[i]);\n                    continue;\n                }\n                else if (isNaN(sx[i] + sy[i])) {\n                    ctx.closePath();\n                    ctx.stroke();\n                    ctx.beginPath();\n                    continue;\n                }\n                else {\n                    ctx.lineTo(sx[i], sy[i]);\n                }\n            }\n            ctx.closePath();\n            return ctx.stroke();\n        }\n    };\n    PatchView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return PatchView;\n})(xy_glyph_1.XYGlyphView);\nexports.Patch = (function (superClass) {\n    extend(Patch, superClass);\n    function Patch() {\n        return Patch.__super__.constructor.apply(this, arguments);\n    }\n    Patch.prototype.default_view = exports.PatchView;\n    Patch.prototype.type = 'Patch';\n    Patch.mixins(['line', 'fill']);\n    return Patch;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\nvar array_1 = require(\"core/util/array\");\nvar types_1 = require(\"core/util/types\");\nvar hittest = require(\"core/hittest\");\nexports.PatchesView = (function (superClass) {\n    extend(PatchesView, superClass);\n    function PatchesView() {\n        return PatchesView.__super__.constructor.apply(this, arguments);\n    }\n    PatchesView.prototype._build_discontinuous_object = function (nanned_qs) {\n        var denanned, ds, i, k, nan_index, q, qs, qs_part, ref;\n        ds = {};\n        for (i = k = 0, ref = nanned_qs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            ds[i] = [];\n            qs = array_1.copy(nanned_qs[i]);\n            while (qs.length > 0) {\n                nan_index = array_1.findLastIndex(qs, function (q) {\n                    return types_1.isStrictNaN(q);\n                });\n                if (nan_index >= 0) {\n                    qs_part = qs.splice(nan_index);\n                }\n                else {\n                    qs_part = qs;\n                    qs = [];\n                }\n                denanned = (function () {\n                    var l, len, results;\n                    results = [];\n                    for (l = 0, len = qs_part.length; l < len; l++) {\n                        q = qs_part[l];\n                        if (!types_1.isStrictNaN(q)) {\n                            results.push(q);\n                        }\n                    }\n                    return results;\n                })();\n                ds[i].push(denanned);\n            }\n        }\n        return ds;\n    };\n    PatchesView.prototype._index_data = function () {\n        var i, j, k, l, points, ref, ref1, xs, xss, ys, yss;\n        xss = this._build_discontinuous_object(this._xs);\n        yss = this._build_discontinuous_object(this._ys);\n        points = [];\n        for (i = k = 0, ref = this._xs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            for (j = l = 0, ref1 = xss[i].length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                xs = xss[i][j];\n                ys = yss[i][j];\n                if (xs.length === 0) {\n                    continue;\n                }\n                points.push({\n                    minX: array_1.min(xs),\n                    minY: array_1.min(ys),\n                    maxX: array_1.max(xs),\n                    maxY: array_1.max(ys),\n                    i: i\n                });\n            }\n        }\n        return new spatial_1.RBush(points);\n    };\n    PatchesView.prototype._mask_data = function (all_indices) {\n        var bbox, ref, ref1, x0, x1, xr, y0, y1, yr;\n        xr = this.renderer.plot_view.frame.x_ranges[\"default\"];\n        ref = [xr.min, xr.max], x0 = ref[0], x1 = ref[1];\n        yr = this.renderer.plot_view.frame.y_ranges[\"default\"];\n        ref1 = [yr.min, yr.max], y0 = ref1[0], y1 = ref1[1];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        return this.index.indices(bbox);\n    };\n    PatchesView.prototype._render = function (ctx, indices, arg) {\n        var i, j, k, l, len, m, ref, ref1, ref2, results, sx, sxs, sy, sys;\n        sxs = arg.sxs, sys = arg.sys;\n        this.renderer.sxss = this._build_discontinuous_object(sxs);\n        this.renderer.syss = this._build_discontinuous_object(sys);\n        results = [];\n        for (k = 0, len = indices.length; k < len; k++) {\n            i = indices[k];\n            ref = [sxs[i], sys[i]], sx = ref[0], sy = ref[1];\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                for (j = l = 0, ref1 = sx.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                    if (j === 0) {\n                        ctx.beginPath();\n                        ctx.moveTo(sx[j], sy[j]);\n                        continue;\n                    }\n                    else if (isNaN(sx[j] + sy[j])) {\n                        ctx.closePath();\n                        ctx.fill();\n                        ctx.beginPath();\n                        continue;\n                    }\n                    else {\n                        ctx.lineTo(sx[j], sy[j]);\n                    }\n                }\n                ctx.closePath();\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                for (j = m = 0, ref2 = sx.length; 0 <= ref2 ? m < ref2 : m > ref2; j = 0 <= ref2 ? ++m : --m) {\n                    if (j === 0) {\n                        ctx.beginPath();\n                        ctx.moveTo(sx[j], sy[j]);\n                        continue;\n                    }\n                    else if (isNaN(sx[j] + sy[j])) {\n                        ctx.closePath();\n                        ctx.stroke();\n                        ctx.beginPath();\n                        continue;\n                    }\n                    else {\n                        ctx.lineTo(sx[j], sy[j]);\n                    }\n                }\n                ctx.closePath();\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    PatchesView.prototype._hit_point = function (geometry) {\n        var candidates, hits, i, idx, j, k, l, ref, ref1, ref2, result, sx, sxs, sy, sys, vx, vy, x, y;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        sx = this.renderer.plot_view.canvas.vx_to_sx(vx);\n        sy = this.renderer.plot_view.canvas.vy_to_sy(vy);\n        x = this.renderer.xscale.invert(vx, true);\n        y = this.renderer.yscale.invert(vy, true);\n        candidates = this.index.indices({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y\n        });\n        hits = [];\n        for (i = k = 0, ref1 = candidates.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n            idx = candidates[i];\n            sxs = this.renderer.sxss[idx];\n            sys = this.renderer.syss[idx];\n            for (j = l = 0, ref2 = sxs.length; 0 <= ref2 ? l < ref2 : l > ref2; j = 0 <= ref2 ? ++l : --l) {\n                if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) {\n                    hits.push(idx);\n                }\n            }\n        }\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    PatchesView.prototype._get_snap_coord = function (array) {\n        var k, len, s, sum;\n        sum = 0;\n        for (k = 0, len = array.length; k < len; k++) {\n            s = array[k];\n            sum += s;\n        }\n        return sum / array.length;\n    };\n    PatchesView.prototype.scx = function (i, sx, sy) {\n        var j, k, ref, sxs, sys;\n        if (this.renderer.sxss[i].length === 1) {\n            return this._get_snap_coord(this.sxs[i]);\n        }\n        else {\n            sxs = this.renderer.sxss[i];\n            sys = this.renderer.syss[i];\n            for (j = k = 0, ref = sxs.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {\n                if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) {\n                    return this._get_snap_coord(sxs[j]);\n                }\n            }\n        }\n        return null;\n    };\n    PatchesView.prototype.scy = function (i, sx, sy) {\n        var j, k, ref, sxs, sys;\n        if (this.renderer.syss[i].length === 1) {\n            return this._get_snap_coord(this.sys[i]);\n        }\n        else {\n            sxs = this.renderer.sxss[i];\n            sys = this.renderer.syss[i];\n            for (j = k = 0, ref = sxs.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {\n                if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) {\n                    return this._get_snap_coord(sys[j]);\n                }\n            }\n        }\n    };\n    PatchesView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return PatchesView;\n})(glyph_1.GlyphView);\nexports.Patches = (function (superClass) {\n    extend(Patches, superClass);\n    function Patches() {\n        return Patches.__super__.constructor.apply(this, arguments);\n    }\n    Patches.prototype.default_view = exports.PatchesView;\n    Patches.prototype.type = 'Patches';\n    Patches.coords([['xs', 'ys']]);\n    Patches.mixins(['line', 'fill']);\n    return Patches;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\nvar categorical_scale_1 = require(\"../scales/categorical_scale\");\nvar hittest = require(\"core/hittest\");\nexports.QuadView = (function (superClass) {\n    extend(QuadView, superClass);\n    function QuadView() {\n        return QuadView.__super__.constructor.apply(this, arguments);\n    }\n    QuadView.prototype._index_data = function () {\n        var b, bottom, i, j, l, left, map_to_synthetic, points, r, ref, right, t, top;\n        map_to_synthetic = function (scale, array) {\n            if (scale instanceof categorical_scale_1.CategoricalScale) {\n                return scale.v_compute(array, true);\n            }\n            else {\n                return array;\n            }\n        };\n        left = map_to_synthetic(this.renderer.xscale, this._left);\n        right = map_to_synthetic(this.renderer.xscale, this._right);\n        top = map_to_synthetic(this.renderer.yscale, this._top);\n        bottom = map_to_synthetic(this.renderer.yscale, this._bottom);\n        points = [];\n        for (i = j = 0, ref = left.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            l = left[i];\n            r = right[i];\n            t = top[i];\n            b = bottom[i];\n            if (isNaN(l + r + t + b) || !isFinite(l + r + t + b)) {\n                continue;\n            }\n            points.push({\n                minX: l,\n                minY: b,\n                maxX: r,\n                maxY: t,\n                i: i\n            });\n        }\n        return new spatial_1.RBush(points);\n    };\n    QuadView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, sbottom, sleft, sright, stop;\n        sleft = arg.sleft, sright = arg.sright, stop = arg.stop, sbottom = arg.sbottom;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sleft[i] + stop[i] + sright[i] + sbottom[i])) {\n                continue;\n            }\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fillRect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n            }\n            if (this.visuals.line.doit) {\n                ctx.beginPath();\n                ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    QuadView.prototype._hit_point = function (geometry) {\n        var hits, ref, result, vx, vy, x, y;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xscale.invert(vx, true);\n        y = this.renderer.yscale.invert(vy, true);\n        hits = this.index.indices({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y\n        });\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    QuadView.prototype.get_anchor_point = function (anchor, i, spt) {\n        var bottom, left, right, top;\n        left = Math.min(this.sleft[i], this.sright[i]);\n        right = Math.max(this.sright[i], this.sleft[i]);\n        top = Math.min(this.stop[i], this.sbottom[i]);\n        bottom = Math.max(this.sbottom[i], this.stop[i]);\n        switch (anchor) {\n            case 'top_left':\n                return {\n                    x: left,\n                    y: top\n                };\n            case 'top_center':\n                return {\n                    x: (left + right) / 2,\n                    y: top\n                };\n            case 'top_right':\n                return {\n                    x: right,\n                    y: top\n                };\n            case 'center_right':\n                return {\n                    x: right,\n                    y: (top + bottom) / 2\n                };\n            case 'bottom_right':\n                return {\n                    x: right,\n                    y: bottom\n                };\n            case 'bottom_center':\n                return {\n                    x: (left + right) / 2,\n                    y: bottom\n                };\n            case 'bottom_left':\n                return {\n                    x: left,\n                    y: bottom\n                };\n            case 'center_left':\n                return {\n                    x: left,\n                    y: (top + bottom) / 2\n                };\n            case 'center':\n                return {\n                    x: (left + right) / 2,\n                    y: (top + bottom) / 2\n                };\n        }\n    };\n    QuadView.prototype.scx = function (i) {\n        return (this.sleft[i] + this.sright[i]) / 2;\n    };\n    QuadView.prototype.scy = function (i) {\n        return (this.stop[i] + this.sbottom[i]) / 2;\n    };\n    QuadView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return QuadView;\n})(glyph_1.GlyphView);\nexports.Quad = (function (superClass) {\n    extend(Quad, superClass);\n    function Quad() {\n        return Quad.__super__.constructor.apply(this, arguments);\n    }\n    Quad.prototype.default_view = exports.QuadView;\n    Quad.prototype.type = 'Quad';\n    Quad.coords([['right', 'bottom'], ['left', 'top']]);\n    Quad.mixins(['line', 'fill']);\n    return Quad;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _qbb, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\n_qbb = function (u, v, w) {\n    var bd, t;\n    if (v === (u + w) / 2) {\n        return [u, w];\n    }\n    else {\n        t = (u - v) / (u - 2 * v + w);\n        bd = u * Math.pow(1 - t, 2) + 2 * v * (1 - t) * t + w * Math.pow(t, 2);\n        return [Math.min(u, w, bd), Math.max(u, w, bd)];\n    }\n};\nexports.QuadraticView = (function (superClass) {\n    extend(QuadraticView, superClass);\n    function QuadraticView() {\n        return QuadraticView.__super__.constructor.apply(this, arguments);\n    }\n    QuadraticView.prototype._index_data = function () {\n        var i, j, points, ref, ref1, ref2, x0, x1, y0, y1;\n        points = [];\n        for (i = j = 0, ref = this._x0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            if (isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i] + this._cx[i] + this._cy[i])) {\n                continue;\n            }\n            ref1 = _qbb(this._x0[i], this._cx[i], this._x1[i]), x0 = ref1[0], x1 = ref1[1];\n            ref2 = _qbb(this._y0[i], this._cy[i], this._y1[i]), y0 = ref2[0], y1 = ref2[1];\n            points.push({\n                minX: x0,\n                minY: y0,\n                maxX: x1,\n                maxY: y1,\n                i: i\n            });\n        }\n        return new spatial_1.RBush(points);\n    };\n    QuadraticView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, scx, scy, sx0, sx1, sy0, sy1;\n        sx0 = arg.sx0, sy0 = arg.sy0, sx1 = arg.sx1, sy1 = arg.sy1, scx = arg.scx, scy = arg.scy;\n        if (this.visuals.line.doit) {\n            results = [];\n            for (j = 0, len = indices.length; j < len; j++) {\n                i = indices[j];\n                if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i] + scx[i] + scy[i])) {\n                    continue;\n                }\n                ctx.beginPath();\n                ctx.moveTo(sx0[i], sy0[i]);\n                ctx.quadraticCurveTo(scx[i], scy[i], sx1[i], sy1[i]);\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            return results;\n        }\n    };\n    QuadraticView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return QuadraticView;\n})(glyph_1.GlyphView);\nexports.Quadratic = (function (superClass) {\n    extend(Quadratic, superClass);\n    function Quadratic() {\n        return Quadratic.__super__.constructor.apply(this, arguments);\n    }\n    Quadratic.prototype.default_view = exports.QuadraticView;\n    Quadratic.prototype.type = 'Quadratic';\n    Quadratic.coords([['x0', 'y0'], ['x1', 'y1'], ['cx', 'cy']]);\n    Quadratic.mixins(['line']);\n    return Quadratic;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar p = require(\"core/properties\");\nexports.RayView = (function (superClass) {\n    extend(RayView, superClass);\n    function RayView() {\n        return RayView.__super__.constructor.apply(this, arguments);\n    }\n    RayView.prototype._map_data = function () {\n        return this.slength = this.sdist(this.renderer.xscale, this._x, this._length);\n    };\n    RayView.prototype._render = function (ctx, indices, arg) {\n        var _angle, height, i, inf_len, j, k, len, ref, results, slength, sx, sy, width;\n        sx = arg.sx, sy = arg.sy, slength = arg.slength, _angle = arg._angle;\n        if (this.visuals.line.doit) {\n            width = this.renderer.plot_view.frame._width.value;\n            height = this.renderer.plot_view.frame._height.value;\n            inf_len = 2 * (width + height);\n            for (i = j = 0, ref = slength.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                if (slength[i] === 0) {\n                    slength[i] = inf_len;\n                }\n            }\n            results = [];\n            for (k = 0, len = indices.length; k < len; k++) {\n                i = indices[k];\n                if (isNaN(sx[i] + sy[i] + _angle[i] + slength[i])) {\n                    continue;\n                }\n                ctx.translate(sx[i], sy[i]);\n                ctx.rotate(_angle[i]);\n                ctx.beginPath();\n                ctx.moveTo(0, 0);\n                ctx.lineTo(slength[i], 0);\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.stroke();\n                ctx.rotate(-_angle[i]);\n                results.push(ctx.translate(-sx[i], -sy[i]));\n            }\n            return results;\n        }\n    };\n    RayView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return RayView;\n})(xy_glyph_1.XYGlyphView);\nexports.Ray = (function (superClass) {\n    extend(Ray, superClass);\n    function Ray() {\n        return Ray.__super__.constructor.apply(this, arguments);\n    }\n    Ray.prototype.default_view = exports.RayView;\n    Ray.prototype.type = 'Ray';\n    Ray.mixins(['line']);\n    Ray.define({\n        length: [p.DistanceSpec],\n        angle: [p.AngleSpec]\n    });\n    return Ray;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nvar types_1 = require(\"core/util/types\");\nvar categorical_scale_1 = require(\"../scales/categorical_scale\");\nexports.RectView = (function (superClass) {\n    extend(RectView, superClass);\n    function RectView() {\n        return RectView.__super__.constructor.apply(this, arguments);\n    }\n    RectView.prototype._set_data = function () {\n        this.max_w2 = 0;\n        if (this.model.properties.width.units === \"data\") {\n            this.max_w2 = this.max_width / 2;\n        }\n        this.max_h2 = 0;\n        if (this.model.properties.height.units === \"data\") {\n            return this.max_h2 = this.max_height / 2;\n        }\n    };\n    RectView.prototype._map_data = function () {\n        var canvas, i, ref, ref1;\n        canvas = this.renderer.plot_view.canvas;\n        if (this.model.properties.width.units === \"data\") {\n            ref = this._map_dist_corner_for_data_side_length(this._x, this._width, this.renderer.xscale, canvas, 0), this.sw = ref[0], this.sx0 = ref[1];\n        }\n        else {\n            this.sw = this._width;\n            this.sx0 = (function () {\n                var j, ref1, results;\n                results = [];\n                for (i = j = 0, ref1 = this.sx.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n                    results.push(this.sx[i] - this.sw[i] / 2);\n                }\n                return results;\n            }).call(this);\n        }\n        if (this.model.properties.height.units === \"data\") {\n            ref1 = this._map_dist_corner_for_data_side_length(this._y, this._height, this.renderer.yscale, canvas, 1), this.sh = ref1[0], this.sy1 = ref1[1];\n        }\n        else {\n            this.sh = this._height;\n            this.sy1 = (function () {\n                var j, ref2, results;\n                results = [];\n                for (i = j = 0, ref2 = this.sy.length; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {\n                    results.push(this.sy[i] - this.sh[i] / 2);\n                }\n                return results;\n            }).call(this);\n        }\n        return this.ssemi_diag = (function () {\n            var j, ref2, results;\n            results = [];\n            for (i = j = 0, ref2 = this.sw.length; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {\n                results.push(Math.sqrt(this.sw[i] / 2 * this.sw[i] / 2 + this.sh[i] / 2 * this.sh[i] / 2));\n            }\n            return results;\n        }).call(this);\n    };\n    RectView.prototype._render = function (ctx, indices, arg) {\n        var _angle, i, j, k, len, len1, sh, sw, sx, sx0, sy, sy1;\n        sx = arg.sx, sy = arg.sy, sx0 = arg.sx0, sy1 = arg.sy1, sw = arg.sw, sh = arg.sh, _angle = arg._angle;\n        if (this.visuals.fill.doit) {\n            for (j = 0, len = indices.length; j < len; j++) {\n                i = indices[j];\n                if (isNaN(sx[i] + sy[i] + sx0[i] + sy1[i] + sw[i] + sh[i] + _angle[i])) {\n                    continue;\n                }\n                this.visuals.fill.set_vectorize(ctx, i);\n                if (_angle[i]) {\n                    ctx.translate(sx[i], sy[i]);\n                    ctx.rotate(_angle[i]);\n                    ctx.fillRect(-sw[i] / 2, -sh[i] / 2, sw[i], sh[i]);\n                    ctx.rotate(-_angle[i]);\n                    ctx.translate(-sx[i], -sy[i]);\n                }\n                else {\n                    ctx.fillRect(sx0[i], sy1[i], sw[i], sh[i]);\n                }\n            }\n        }\n        if (this.visuals.line.doit) {\n            ctx.beginPath();\n            for (k = 0, len1 = indices.length; k < len1; k++) {\n                i = indices[k];\n                if (isNaN(sx[i] + sy[i] + sx0[i] + sy1[i] + sw[i] + sh[i] + _angle[i])) {\n                    continue;\n                }\n                if (sw[i] === 0 || sh[i] === 0) {\n                    continue;\n                }\n                if (_angle[i]) {\n                    ctx.translate(sx[i], sy[i]);\n                    ctx.rotate(_angle[i]);\n                    ctx.rect(-sw[i] / 2, -sh[i] / 2, sw[i], sh[i]);\n                    ctx.rotate(-_angle[i]);\n                    ctx.translate(-sx[i], -sy[i]);\n                }\n                else {\n                    ctx.rect(sx0[i], sy1[i], sw[i], sh[i]);\n                }\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.stroke();\n                ctx.beginPath();\n            }\n            return ctx.stroke();\n        }\n    };\n    RectView.prototype._hit_rect = function (geometry) {\n        var bbox, ref, ref1, result, x0, x1, y0, y1;\n        ref = this.renderer.xscale.v_invert([geometry.vx0, geometry.vx1], true), x0 = ref[0], x1 = ref[1];\n        ref1 = this.renderer.yscale.v_invert([geometry.vy0, geometry.vy1], true), y0 = ref1[0], y1 = ref1[1];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = this.index.indices(bbox);\n        return result;\n    };\n    RectView.prototype._hit_point = function (geometry) {\n        var bbox, c, d, height_in, hits, i, j, len, max_x2_ddist, max_y2_ddist, px, py, ref, ref1, result, s, scenter_x, scenter_y, sx, sy, vx, vy, width_in, x, x0, x1, y, y0, y1;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xscale.invert(vx, true);\n        y = this.renderer.yscale.invert(vy, true);\n        scenter_x = (function () {\n            var j, ref1, results;\n            results = [];\n            for (i = j = 0, ref1 = this.sx0.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n                results.push(this.sx0[i] + this.sw[i] / 2);\n            }\n            return results;\n        }).call(this);\n        scenter_y = (function () {\n            var j, ref1, results;\n            results = [];\n            for (i = j = 0, ref1 = this.sy1.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n                results.push(this.sy1[i] + this.sh[i] / 2);\n            }\n            return results;\n        }).call(this);\n        max_x2_ddist = array_1.max(this._ddist(0, scenter_x, this.ssemi_diag));\n        max_y2_ddist = array_1.max(this._ddist(1, scenter_y, this.ssemi_diag));\n        x0 = x - max_x2_ddist;\n        x1 = x + max_x2_ddist;\n        y0 = y - max_y2_ddist;\n        y1 = y + max_y2_ddist;\n        hits = [];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        ref1 = this.index.indices(bbox);\n        for (j = 0, len = ref1.length; j < len; j++) {\n            i = ref1[j];\n            sx = this.renderer.plot_view.canvas.vx_to_sx(vx);\n            sy = this.renderer.plot_view.canvas.vy_to_sy(vy);\n            if (this._angle[i]) {\n                d = Math.sqrt(Math.pow(sx - this.sx[i], 2) + Math.pow(sy - this.sy[i], 2));\n                s = Math.sin(-this._angle[i]);\n                c = Math.cos(-this._angle[i]);\n                px = c * (sx - this.sx[i]) - s * (sy - this.sy[i]) + this.sx[i];\n                py = s * (sx - this.sx[i]) + c * (sy - this.sy[i]) + this.sy[i];\n                sx = px;\n                sy = py;\n                width_in = Math.abs(this.sx[i] - sx) <= this.sw[i] / 2;\n                height_in = Math.abs(this.sy[i] - sy) <= this.sh[i] / 2;\n            }\n            else {\n                width_in = sx - this.sx0[i] <= this.sw[i] && sx - this.sx0[i] >= 0;\n                height_in = sy - this.sy1[i] <= this.sh[i] && sy - this.sy1[i] >= 0;\n            }\n            if (height_in && width_in) {\n                hits.push(i);\n            }\n        }\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    RectView.prototype._map_dist_corner_for_data_side_length = function (coord, side_length, scale, canvas, dim) {\n        var i, pt0, pt1, return_synthetic, sside_length, synthetic_pt, synthetic_pt_corner, vpt0, vpt1, vpt_corner;\n        if (types_1.isString(coord[0]) && scale instanceof categorical_scale_1.CategoricalScale) {\n            return_synthetic = true;\n            synthetic_pt = scale.v_compute(coord, return_synthetic);\n            if (dim === 0) {\n                synthetic_pt_corner = (function () {\n                    var j, ref, results;\n                    results = [];\n                    for (i = j = 0, ref = coord.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                        results.push(synthetic_pt[i] - side_length[i] / 2);\n                    }\n                    return results;\n                })();\n            }\n            else if (dim === 1) {\n                synthetic_pt_corner = (function () {\n                    var j, ref, results;\n                    results = [];\n                    for (i = j = 0, ref = coord.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                        results.push(synthetic_pt[i] + side_length[i] / 2);\n                    }\n                    return results;\n                })();\n            }\n            vpt_corner = scale.v_compute(synthetic_pt_corner);\n            sside_length = this.sdist(scale, coord, side_length, 'center', this.model.dilate);\n        }\n        else {\n            pt0 = (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = coord.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(Number(coord[i]) - side_length[i] / 2);\n                }\n                return results;\n            })();\n            pt1 = (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = coord.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(Number(coord[i]) + side_length[i] / 2);\n                }\n                return results;\n            })();\n            vpt0 = scale.v_compute(pt0);\n            vpt1 = scale.v_compute(pt1);\n            sside_length = this.sdist(scale, pt0, side_length, 'edge', this.model.dilate);\n            if (dim === 0) {\n                vpt_corner = vpt0[0] < vpt1[0] ? vpt0 : vpt1;\n            }\n            else if (dim === 1) {\n                vpt_corner = vpt0[0] < vpt1[0] ? vpt1 : vpt0;\n            }\n        }\n        if (dim === 0) {\n            return [sside_length, canvas.v_vx_to_sx(vpt_corner)];\n        }\n        else if (dim === 1) {\n            return [sside_length, canvas.v_vy_to_sy(vpt_corner)];\n        }\n    };\n    RectView.prototype._ddist = function (dim, spts, spans) {\n        var i, pt0, pt1, scale, vpt0, vpt1, vpts;\n        if (dim === 0) {\n            vpts = this.renderer.plot_view.canvas.v_sx_to_vx(spts);\n            scale = this.renderer.xscale;\n        }\n        else {\n            vpts = this.renderer.plot_view.canvas.v_vy_to_sy(spts);\n            scale = this.renderer.yscale;\n        }\n        vpt0 = vpts;\n        vpt1 = (function () {\n            var j, ref, results;\n            results = [];\n            for (i = j = 0, ref = vpt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                results.push(vpt0[i] + spans[i]);\n            }\n            return results;\n        })();\n        pt0 = scale.v_invert(vpt0);\n        pt1 = scale.v_invert(vpt1);\n        return (function () {\n            var j, ref, results;\n            results = [];\n            for (i = j = 0, ref = pt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                results.push(Math.abs(pt1[i] - pt0[i]));\n            }\n            return results;\n        })();\n    };\n    RectView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    RectView.prototype._bounds = function (bds) {\n        return this.max_wh2_bounds(bds);\n    };\n    return RectView;\n})(xy_glyph_1.XYGlyphView);\nexports.Rect = (function (superClass) {\n    extend(Rect, superClass);\n    function Rect() {\n        return Rect.__super__.constructor.apply(this, arguments);\n    }\n    Rect.prototype.default_view = exports.RectView;\n    Rect.prototype.type = 'Rect';\n    Rect.mixins(['line', 'fill']);\n    Rect.define({\n        angle: [p.AngleSpec, 0],\n        width: [p.DistanceSpec],\n        height: [p.DistanceSpec],\n        dilate: [p.Bool, false]\n    });\n    return Rect;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar hittest = require(\"core/hittest\");\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\nexports.SegmentView = (function (superClass) {\n    extend(SegmentView, superClass);\n    function SegmentView() {\n        return SegmentView.__super__.constructor.apply(this, arguments);\n    }\n    SegmentView.prototype._index_data = function () {\n        var i, j, points, ref;\n        points = [];\n        for (i = j = 0, ref = this._x0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            if (!isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i])) {\n                points.push({\n                    minX: Math.min(this._x0[i], this._x1[i]),\n                    minY: Math.min(this._y0[i], this._y1[i]),\n                    maxX: Math.max(this._x0[i], this._x1[i]),\n                    maxY: Math.max(this._y0[i], this._y1[i]),\n                    i: i\n                });\n            }\n        }\n        return new spatial_1.RBush(points);\n    };\n    SegmentView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, sx0, sx1, sy0, sy1;\n        sx0 = arg.sx0, sy0 = arg.sy0, sx1 = arg.sx1, sy1 = arg.sy1;\n        if (this.visuals.line.doit) {\n            results = [];\n            for (j = 0, len = indices.length; j < len; j++) {\n                i = indices[j];\n                if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i])) {\n                    continue;\n                }\n                ctx.beginPath();\n                ctx.moveTo(sx0[i], sy0[i]);\n                ctx.lineTo(sx1[i], sy1[i]);\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            return results;\n        }\n    };\n    SegmentView.prototype._hit_point = function (geometry) {\n        var candidates, dist, hits, i, j, len, p0, p1, point, ref, ref1, result, threshold, vx, vy, x, y;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xscale.invert(vx, true);\n        y = this.renderer.yscale.invert(vy, true);\n        point = {\n            x: this.renderer.plot_view.canvas.vx_to_sx(vx),\n            y: this.renderer.plot_view.canvas.vy_to_sy(vy)\n        };\n        hits = [];\n        candidates = this.index.indices({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y\n        });\n        for (j = 0, len = candidates.length; j < len; j++) {\n            i = candidates[j];\n            threshold = Math.max(2, this.visuals.line.cache_select('line_width', i) / 2);\n            ref1 = [\n                {\n                    x: this.sx0[i],\n                    y: this.sy0[i]\n                }, {\n                    x: this.sx1[i],\n                    y: this.sy1[i]\n                }\n            ], p0 = ref1[0], p1 = ref1[1];\n            dist = hittest.dist_to_segment(point, p0, p1);\n            if (dist < threshold) {\n                hits.push(i);\n            }\n        }\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    SegmentView.prototype._hit_span = function (geometry) {\n        var candidates, hits, hr, i, j, len, ref, ref1, ref2, result, v0, v1, val, vr, vx, vy;\n        hr = this.renderer.plot_view.frame.h_range;\n        vr = this.renderer.plot_view.frame.v_range;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        if (geometry.direction === 'v') {\n            val = this.renderer.yscale.invert(vy);\n            ref1 = [this._y0, this._y1], v0 = ref1[0], v1 = ref1[1];\n        }\n        else {\n            val = this.renderer.xscale.invert(vx);\n            ref2 = [this._x0, this._x1], v0 = ref2[0], v1 = ref2[1];\n        }\n        hits = [];\n        candidates = this.index.indices({\n            minX: this.renderer.xscale.invert(hr.min),\n            minY: this.renderer.yscale.invert(vr.min),\n            maxX: this.renderer.xscale.invert(hr.max),\n            maxY: this.renderer.yscale.invert(vr.max)\n        });\n        for (j = 0, len = candidates.length; j < len; j++) {\n            i = candidates[j];\n            if ((v0[i] <= val && val <= v1[i]) || (v1[i] <= val && val <= v0[i])) {\n                hits.push(i);\n            }\n        }\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    SegmentView.prototype.scx = function (i) {\n        return (this.sx0[i] + this.sx1[i]) / 2;\n    };\n    SegmentView.prototype.scy = function (i) {\n        return (this.sy0[i] + this.sy1[i]) / 2;\n    };\n    SegmentView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return SegmentView;\n})(glyph_1.GlyphView);\nexports.Segment = (function (superClass) {\n    extend(Segment, superClass);\n    function Segment() {\n        return Segment.__super__.constructor.apply(this, arguments);\n    }\n    Segment.prototype.default_view = exports.SegmentView;\n    Segment.prototype.type = 'Segment';\n    Segment.coords([['x0', 'y0'], ['x1', 'y1']]);\n    Segment.mixins(['line']);\n    return Segment;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar p = require(\"core/properties\");\nexports.TextView = (function (superClass) {\n    extend(TextView, superClass);\n    function TextView() {\n        return TextView.__super__.constructor.apply(this, arguments);\n    }\n    TextView.prototype._render = function (ctx, indices, arg) {\n        var _angle, _text, _x_offset, _y_offset, i, j, len, results, sx, sy;\n        sx = arg.sx, sy = arg.sy, _x_offset = arg._x_offset, _y_offset = arg._y_offset, _angle = arg._angle, _text = arg._text;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + _x_offset[i] + _y_offset[i] + _angle[i]) || (_text[i] == null)) {\n                continue;\n            }\n            if (this.visuals.text.doit) {\n                ctx.save();\n                ctx.translate(sx[i] + _x_offset[i], sy[i] + _y_offset[i]);\n                ctx.rotate(_angle[i]);\n                this.visuals.text.set_vectorize(ctx, i);\n                ctx.fillText(_text[i], 0, 0);\n                results.push(ctx.restore());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    TextView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        ctx.save();\n        this.text_props.set_value(ctx);\n        ctx.font = this.text_props.font_value();\n        ctx.font = ctx.font.replace(/\\b[\\d\\.]+[\\w]+\\b/, '10pt');\n        ctx.textAlign = \"right\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(\"text\", x2, (y1 + y2) / 2);\n        return ctx.restore();\n    };\n    return TextView;\n})(xy_glyph_1.XYGlyphView);\nexports.Text = (function (superClass) {\n    extend(Text, superClass);\n    function Text() {\n        return Text.__super__.constructor.apply(this, arguments);\n    }\n    Text.prototype.default_view = exports.TextView;\n    Text.prototype.type = 'Text';\n    Text.mixins(['text']);\n    Text.define({\n        text: [\n            p.StringSpec, {\n                field: \"text\"\n            }\n        ],\n        angle: [p.AngleSpec, 0],\n        x_offset: [p.NumberSpec, 0],\n        y_offset: [p.NumberSpec, 0]\n    });\n    return Text;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\nvar categorical_scale_1 = require(\"../scales/categorical_scale\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nexports.VBarView = (function (superClass) {\n    extend(VBarView, superClass);\n    function VBarView() {\n        return VBarView.__super__.constructor.apply(this, arguments);\n    }\n    VBarView.prototype._map_data = function () {\n        var i, j, ref, vbottom, vtop;\n        this.sx = this.renderer.xscale.v_compute(this._x);\n        vtop = this.renderer.yscale.v_compute(this._top);\n        vbottom = this.renderer.yscale.v_compute(this._bottom);\n        this.stop = this.renderer.plot_view.canvas.v_vy_to_sy(vtop);\n        this.sbottom = this.renderer.plot_view.canvas.v_vy_to_sy(vbottom);\n        this.sleft = [];\n        this.sright = [];\n        this.sw = this.sdist(this.renderer.xscale, this._x, this._width, 'center');\n        for (i = j = 0, ref = this.sx.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            this.sleft.push(this.sx[i] - this.sw[i] / 2);\n            this.sright.push(this.sx[i] + this.sw[i] / 2);\n        }\n        return null;\n    };\n    VBarView.prototype._index_data = function () {\n        var b, bottom, i, j, l, map_to_synthetic, points, r, ref, t, top, width, x;\n        map_to_synthetic = function (scale, array) {\n            if (scale instanceof categorical_scale_1.CategoricalScale) {\n                return scale.v_compute(array, true);\n            }\n            else {\n                return array;\n            }\n        };\n        x = map_to_synthetic(this.renderer.xscale, this._x);\n        width = map_to_synthetic(this.renderer.xscale, this._width);\n        top = map_to_synthetic(this.renderer.yscale, this._top);\n        bottom = map_to_synthetic(this.renderer.yscale, this._bottom);\n        points = [];\n        for (i = j = 0, ref = x.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            l = x[i] - width[i] / 2;\n            r = x[i] + width[i] / 2;\n            t = top[i];\n            b = bottom[i];\n            if (isNaN(l + r + t + b) || !isFinite(l + r + t + b)) {\n                continue;\n            }\n            points.push({\n                minX: l,\n                minY: b,\n                maxX: r,\n                maxY: t,\n                i: i\n            });\n        }\n        return new spatial_1.RBush(points);\n    };\n    VBarView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, sbottom, sleft, sright, stop;\n        sleft = arg.sleft, sright = arg.sright, stop = arg.stop, sbottom = arg.sbottom;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sleft[i] + stop[i] + sright[i] + sbottom[i])) {\n                continue;\n            }\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fillRect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n            }\n            if (this.visuals.line.doit) {\n                ctx.beginPath();\n                ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    VBarView.prototype._hit_point = function (geometry) {\n        var hits, ref, result, vx, vy, x, y;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xscale.invert(vx, true);\n        y = this.renderer.yscale.invert(vy, true);\n        hits = this.index.indices({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y\n        });\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    VBarView.prototype.scy = function (i) {\n        return (this.stop[i] + this.sbottom[i]) / 2;\n    };\n    VBarView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return VBarView;\n})(glyph_1.GlyphView);\nexports.VBar = (function (superClass) {\n    extend(VBar, superClass);\n    function VBar() {\n        return VBar.__super__.constructor.apply(this, arguments);\n    }\n    VBar.prototype.default_view = exports.VBarView;\n    VBar.prototype.type = 'VBar';\n    VBar.mixins(['line', 'fill']);\n    VBar.define({\n        x: [p.NumberSpec],\n        width: [p.DistanceSpec],\n        top: [p.NumberSpec],\n        bottom: [p.NumberSpec, 0]\n    });\n    return VBar;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nvar math_1 = require(\"core/util/math\");\nexports.WedgeView = (function (superClass) {\n    extend(WedgeView, superClass);\n    function WedgeView() {\n        return WedgeView.__super__.constructor.apply(this, arguments);\n    }\n    WedgeView.prototype._map_data = function () {\n        if (this.model.properties.radius.units === \"data\") {\n            return this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);\n        }\n        else {\n            return this.sradius = this._radius;\n        }\n    };\n    WedgeView.prototype._render = function (ctx, indices, arg) {\n        var _end_angle, _start_angle, direction, i, j, len, results, sradius, sx, sy;\n        sx = arg.sx, sy = arg.sy, sradius = arg.sradius, _start_angle = arg._start_angle, _end_angle = arg._end_angle;\n        direction = this.model.properties.direction.value();\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + sradius[i] + _start_angle[i] + _end_angle[i])) {\n                continue;\n            }\n            ctx.beginPath();\n            ctx.arc(sx[i], sy[i], sradius[i], _start_angle[i], _end_angle[i], direction);\n            ctx.lineTo(sx[i], sy[i]);\n            ctx.closePath();\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    WedgeView.prototype._hit_point = function (geometry) {\n        var angle, bbox, candidates, direction, dist, hits, i, j, k, len, len1, r2, ref, ref1, ref2, ref3, ref4, sx, sx0, sx1, sy, sy0, sy1, vx, vx0, vx1, vy, vy0, vy1, x, x0, x1, y, y0, y1;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xscale.invert(vx, true);\n        y = this.renderer.yscale.invert(vy, true);\n        if (this.model.properties.radius.units === \"data\") {\n            x0 = x - this.max_radius;\n            x1 = x + this.max_radius;\n            y0 = y - this.max_radius;\n            y1 = y + this.max_radius;\n        }\n        else {\n            vx0 = vx - this.max_radius;\n            vx1 = vx + this.max_radius;\n            ref1 = this.renderer.xscale.v_invert([vx0, vx1], true), x0 = ref1[0], x1 = ref1[1];\n            vy0 = vy - this.max_radius;\n            vy1 = vy + this.max_radius;\n            ref2 = this.renderer.yscale.v_invert([vy0, vy1], true), y0 = ref2[0], y1 = ref2[1];\n        }\n        candidates = [];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        ref3 = this.index.indices(bbox);\n        for (j = 0, len = ref3.length; j < len; j++) {\n            i = ref3[j];\n            r2 = Math.pow(this.sradius[i], 2);\n            sx0 = this.renderer.xscale.compute(x, true);\n            sx1 = this.renderer.xscale.compute(this._x[i], true);\n            sy0 = this.renderer.yscale.compute(y, true);\n            sy1 = this.renderer.yscale.compute(this._y[i], true);\n            dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);\n            if (dist <= r2) {\n                candidates.push([i, dist]);\n            }\n        }\n        direction = this.model.properties.direction.value();\n        hits = [];\n        for (k = 0, len1 = candidates.length; k < len1; k++) {\n            ref4 = candidates[k], i = ref4[0], dist = ref4[1];\n            sx = this.renderer.plot_view.canvas.vx_to_sx(vx);\n            sy = this.renderer.plot_view.canvas.vy_to_sy(vy);\n            angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);\n            if (math_1.angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {\n                hits.push([i, dist]);\n            }\n        }\n        return hittest.create_1d_hit_test_result(hits);\n    };\n    WedgeView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return WedgeView;\n})(xy_glyph_1.XYGlyphView);\nexports.Wedge = (function (superClass) {\n    extend(Wedge, superClass);\n    function Wedge() {\n        return Wedge.__super__.constructor.apply(this, arguments);\n    }\n    Wedge.prototype.default_view = exports.WedgeView;\n    Wedge.prototype.type = 'Wedge';\n    Wedge.mixins(['line', 'fill']);\n    Wedge.define({\n        direction: [p.Direction, 'anticlock'],\n        radius: [p.DistanceSpec],\n        start_angle: [p.AngleSpec],\n        end_angle: [p.AngleSpec]\n    });\n    return Wedge;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\nvar categorical_scale_1 = require(\"../scales/categorical_scale\");\nexports.XYGlyphView = (function (superClass) {\n    extend(XYGlyphView, superClass);\n    function XYGlyphView() {\n        return XYGlyphView.__super__.constructor.apply(this, arguments);\n    }\n    XYGlyphView.prototype._index_data = function () {\n        var i, j, points, ref, x, xx, y, yy;\n        if (this.renderer.xscale instanceof categorical_scale_1.CategoricalScale) {\n            xx = this.renderer.xscale.v_compute(this._x, true);\n        }\n        else {\n            xx = this._x;\n        }\n        if (this.renderer.yscale instanceof categorical_scale_1.CategoricalScale) {\n            yy = this.renderer.yscale.v_compute(this._y, true);\n        }\n        else {\n            yy = this._y;\n        }\n        points = [];\n        for (i = j = 0, ref = xx.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            x = xx[i];\n            if (isNaN(x) || !isFinite(x)) {\n                continue;\n            }\n            y = yy[i];\n            if (isNaN(y) || !isFinite(y)) {\n                continue;\n            }\n            points.push({\n                minX: x,\n                minY: y,\n                maxX: x,\n                maxY: y,\n                i: i\n            });\n        }\n        return new spatial_1.RBush(points);\n    };\n    return XYGlyphView;\n})(glyph_1.GlyphView);\nexports.XYGlyph = (function (superClass) {\n    extend(XYGlyph, superClass);\n    function XYGlyph() {\n        return XYGlyph.__super__.constructor.apply(this, arguments);\n    }\n    XYGlyph.prototype.type = \"XYGlyph\";\n    XYGlyph.prototype.default_view = exports.XYGlyphView;\n    XYGlyph.coords([['x', 'y']]);\n    return XYGlyph;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar guide_renderer_1 = require(\"../renderers/guide_renderer\");\nvar renderer_1 = require(\"../renderers/renderer\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.GridView = (function (superClass) {\n    extend(GridView, superClass);\n    function GridView() {\n        return GridView.__super__.constructor.apply(this, arguments);\n    }\n    GridView.prototype.initialize = function (attrs, options) {\n        GridView.__super__.initialize.call(this, attrs, options);\n        this._x_range_name = this.model.x_range_name;\n        return this._y_range_name = this.model.y_range_name;\n    };\n    GridView.prototype.render = function () {\n        var ctx;\n        if (this.model.visible === false) {\n            return;\n        }\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        this._draw_regions(ctx);\n        this._draw_minor_grids(ctx);\n        this._draw_grids(ctx);\n        return ctx.restore();\n    };\n    GridView.prototype.connect_signals = function () {\n        GridView.__super__.connect_signals.call(this);\n        return this.connect(this.model.change, function () {\n            return this.request_render();\n        });\n    };\n    GridView.prototype._draw_regions = function (ctx) {\n        var i, k, ref, ref1, ref2, ref3, sx0, sx1, sy0, sy1, xs, ys;\n        if (!this.visuals.band_fill.doit) {\n            return;\n        }\n        ref = this.model.grid_coords('major', false), xs = ref[0], ys = ref[1];\n        this.visuals.band_fill.set_value(ctx);\n        for (i = k = 0, ref1 = xs.length - 1; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n            if (i % 2 === 1) {\n                ref2 = this.plot_view.map_to_screen(xs[i], ys[i], this._x_range_name, this._y_range_name), sx0 = ref2[0], sy0 = ref2[1];\n                ref3 = this.plot_view.map_to_screen(xs[i + 1], ys[i + 1], this._x_range_name, this._y_range_name), sx1 = ref3[0], sy1 = ref3[1];\n                ctx.fillRect(sx0[0], sy0[0], sx1[1] - sx0[0], sy1[1] - sy0[0]);\n                ctx.fill();\n            }\n        }\n    };\n    GridView.prototype._draw_grids = function (ctx) {\n        var ref, xs, ys;\n        if (!this.visuals.grid_line.doit) {\n            return;\n        }\n        ref = this.model.grid_coords('major'), xs = ref[0], ys = ref[1];\n        return this._draw_grid_helper(ctx, this.visuals.grid_line, xs, ys);\n    };\n    GridView.prototype._draw_minor_grids = function (ctx) {\n        var ref, xs, ys;\n        if (!this.visuals.minor_grid_line.doit) {\n            return;\n        }\n        ref = this.model.grid_coords('minor'), xs = ref[0], ys = ref[1];\n        return this._draw_grid_helper(ctx, this.visuals.minor_grid_line, xs, ys);\n    };\n    GridView.prototype._draw_grid_helper = function (ctx, props, xs, ys) {\n        var i, k, l, ref, ref1, ref2, sx, sy;\n        props.set_value(ctx);\n        for (i = k = 0, ref = xs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            ref1 = this.plot_view.map_to_screen(xs[i], ys[i], this._x_range_name, this._y_range_name), sx = ref1[0], sy = ref1[1];\n            ctx.beginPath();\n            ctx.moveTo(Math.round(sx[0]), Math.round(sy[0]));\n            for (i = l = 1, ref2 = sx.length; 1 <= ref2 ? l < ref2 : l > ref2; i = 1 <= ref2 ? ++l : --l) {\n                ctx.lineTo(Math.round(sx[i]), Math.round(sy[i]));\n            }\n            ctx.stroke();\n        }\n    };\n    return GridView;\n})(renderer_1.RendererView);\nexports.Grid = (function (superClass) {\n    extend(Grid, superClass);\n    function Grid() {\n        return Grid.__super__.constructor.apply(this, arguments);\n    }\n    Grid.prototype.default_view = exports.GridView;\n    Grid.prototype.type = 'Grid';\n    Grid.mixins(['line:grid_', 'line:minor_grid_', 'fill:band_']);\n    Grid.define({\n        bounds: [p.Any, 'auto'],\n        dimension: [p.Number, 0],\n        ticker: [p.Instance],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default']\n    });\n    Grid.override({\n        level: \"underlay\",\n        band_fill_color: null,\n        band_fill_alpha: 0,\n        grid_line_color: '#e5e5e5',\n        minor_grid_line_color: null\n    });\n    Grid.prototype.ranges = function () {\n        var frame, i, j, ranges;\n        i = this.dimension;\n        j = (i + 1) % 2;\n        frame = this.plot.plot_canvas.frame;\n        ranges = [frame.x_ranges[this.x_range_name], frame.y_ranges[this.y_range_name]];\n        return [ranges[i], ranges[j]];\n    };\n    Grid.prototype.computed_bounds = function () {\n        var cross_range, end, range, range_bounds, ref, start, user_bounds;\n        ref = this.ranges(), range = ref[0], cross_range = ref[1];\n        user_bounds = this.bounds;\n        range_bounds = [range.min, range.max];\n        if (types_1.isArray(user_bounds)) {\n            start = Math.min(user_bounds[0], user_bounds[1]);\n            end = Math.max(user_bounds[0], user_bounds[1]);\n            if (start < range_bounds[0]) {\n                start = range_bounds[0];\n            }\n            else if (start > range_bounds[1]) {\n                start = null;\n            }\n            if (end > range_bounds[1]) {\n                end = range_bounds[1];\n            }\n            else if (end < range_bounds[0]) {\n                end = null;\n            }\n        }\n        else {\n            start = range_bounds[0], end = range_bounds[1];\n        }\n        return [start, end];\n    };\n    Grid.prototype.grid_coords = function (location, exclude_ends) {\n        var N, cmax, cmin, coords, cross_range, dim_i, dim_j, end, i, ii, j, k, l, loc, max, min, n, range, ref, ref1, ref2, ref3, start, ticks, tmp;\n        if (exclude_ends == null) {\n            exclude_ends = true;\n        }\n        i = this.dimension;\n        j = (i + 1) % 2;\n        ref = this.ranges(), range = ref[0], cross_range = ref[1];\n        ref1 = this.computed_bounds(), start = ref1[0], end = ref1[1];\n        tmp = Math.min(start, end);\n        end = Math.max(start, end);\n        start = tmp;\n        ticks = this.ticker.get_ticks(start, end, range, cross_range.min, {})[location];\n        min = range.min;\n        max = range.max;\n        cmin = cross_range.min;\n        cmax = cross_range.max;\n        coords = [[], []];\n        for (ii = k = 0, ref2 = ticks.length; 0 <= ref2 ? k < ref2 : k > ref2; ii = 0 <= ref2 ? ++k : --k) {\n            if ((ticks[ii] === min || ticks[ii] === max) && exclude_ends) {\n                continue;\n            }\n            dim_i = [];\n            dim_j = [];\n            N = 2;\n            for (n = l = 0, ref3 = N; 0 <= ref3 ? l < ref3 : l > ref3; n = 0 <= ref3 ? ++l : --l) {\n                loc = cmin + (cmax - cmin) / (N - 1) * n;\n                dim_i.push(ticks[ii]);\n                dim_j.push(loc);\n            }\n            coords[i].push(dim_i);\n            coords[j].push(dim_j);\n        }\n        return coords;\n    };\n    return Grid;\n})(guide_renderer_1.GuideRenderer);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar grid_1 = require(\"./grid\");\nexports.Grid = grid_1.Grid;\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./annotations\"));\n__export(require(\"./axes\"));\n__export(require(\"./callbacks\"));\n__export(require(\"./canvas\"));\n__export(require(\"./formatters\"));\n__export(require(\"./glyphs\"));\n__export(require(\"./grids\"));\n__export(require(\"./layouts\"));\n__export(require(\"./mappers\"));\n__export(require(\"./transforms\"));\n__export(require(\"./markers\"));\n__export(require(\"./plots\"));\n__export(require(\"./ranges\"));\n__export(require(\"./renderers\"));\n__export(require(\"./scales\"));\n__export(require(\"./sources\"));\n__export(require(\"./tickers\"));\n__export(require(\"./tiles\"));\n__export(require(\"./tools\"));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar solver_1 = require(\"core/layout/solver\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nvar object_1 = require(\"core/util/object\");\nvar layout_dom_1 = require(\"./layout_dom\");\nexports.BoxView = (function (superClass) {\n    extend1(BoxView, superClass);\n    function BoxView() {\n        return BoxView.__super__.constructor.apply(this, arguments);\n    }\n    BoxView.prototype.className = \"bk-grid\";\n    BoxView.prototype.connect_signals = function () {\n        BoxView.__super__.connect_signals.call(this);\n        return this.connect(this.model.properties.children.change, (function (_this) {\n            return function () {\n                return _this.rebuild_child_views();\n            };\n        })(this));\n    };\n    BoxView.prototype.get_height = function () {\n        var child_heights, children, height;\n        children = this.model.get_layoutable_children();\n        child_heights = children.map(function (child) {\n            return child._height.value;\n        });\n        if (this.model._horizontal) {\n            height = array_1.max(child_heights);\n        }\n        else {\n            height = array_1.sum(child_heights);\n        }\n        return height;\n    };\n    BoxView.prototype.get_width = function () {\n        var child_widths, children, width;\n        children = this.model.get_layoutable_children();\n        child_widths = children.map(function (child) {\n            return child._width.value;\n        });\n        if (this.model._horizontal) {\n            width = array_1.sum(child_widths);\n        }\n        else {\n            width = array_1.max(child_widths);\n        }\n        return width;\n    };\n    return BoxView;\n})(layout_dom_1.LayoutDOMView);\nexports.Box = (function (superClass) {\n    extend1(Box, superClass);\n    Box.prototype.default_view = exports.BoxView;\n    function Box(attrs, options) {\n        Box.__super__.constructor.call(this, attrs, options);\n        this._child_equal_size_width = new solver_1.Variable();\n        this._child_equal_size_height = new solver_1.Variable();\n        this._box_equal_size_top = new solver_1.Variable();\n        this._box_equal_size_bottom = new solver_1.Variable();\n        this._box_equal_size_left = new solver_1.Variable();\n        this._box_equal_size_right = new solver_1.Variable();\n        this._box_cell_align_top = new solver_1.Variable();\n        this._box_cell_align_bottom = new solver_1.Variable();\n        this._box_cell_align_left = new solver_1.Variable();\n        this._box_cell_align_right = new solver_1.Variable();\n    }\n    Box.define({\n        children: [p.Array, []]\n    });\n    Box.internal({\n        spacing: [p.Number, 6]\n    });\n    Box.prototype.get_layoutable_children = function () {\n        return this.children;\n    };\n    Box.prototype.get_edit_variables = function () {\n        var child, edit_variables, j, len, ref;\n        edit_variables = Box.__super__.get_edit_variables.call(this);\n        ref = this.get_layoutable_children();\n        for (j = 0, len = ref.length; j < len; j++) {\n            child = ref[j];\n            edit_variables = edit_variables.concat(child.get_edit_variables());\n        }\n        return edit_variables;\n    };\n    Box.prototype.get_constrained_variables = function () {\n        return object_1.extend({}, Box.__super__.get_constrained_variables.call(this), {\n            box_equal_size_top: this._box_equal_size_top,\n            box_equal_size_bottom: this._box_equal_size_bottom,\n            box_equal_size_left: this._box_equal_size_left,\n            box_equal_size_right: this._box_equal_size_right,\n            box_cell_align_top: this._box_cell_align_top,\n            box_cell_align_bottom: this._box_cell_align_bottom,\n            box_cell_align_left: this._box_cell_align_left,\n            box_cell_align_right: this._box_cell_align_right\n        });\n    };\n    Box.prototype.get_constraints = function () {\n        var child, children, constraints, i, j, k, last, len, next, rect, ref, vars;\n        constraints = [];\n        children = this.get_layoutable_children();\n        if (children.length === 0) {\n            return constraints;\n        }\n        for (j = 0, len = children.length; j < len; j++) {\n            child = children[j];\n            vars = child.get_constrained_variables();\n            rect = this._child_rect(vars);\n            if (this._horizontal) {\n                if (vars.height != null) {\n                    constraints.push(solver_1.EQ(rect.height, [-1, this._height]));\n                }\n            }\n            else {\n                if (vars.width != null) {\n                    constraints.push(solver_1.EQ(rect.width, [-1, this._width]));\n                }\n            }\n            if (this._horizontal) {\n                if ((vars.box_equal_size_left != null) && (vars.box_equal_size_right != null) && (vars.width != null)) {\n                    constraints.push(solver_1.EQ([-1, vars.box_equal_size_left], [-1, vars.box_equal_size_right], vars.width, this._child_equal_size_width));\n                }\n            }\n            else {\n                if ((vars.box_equal_size_top != null) && (vars.box_equal_size_bottom != null) && (vars.height != null)) {\n                    constraints.push(solver_1.EQ([-1, vars.box_equal_size_top], [-1, vars.box_equal_size_bottom], vars.height, this._child_equal_size_height));\n                }\n            }\n            constraints = constraints.concat(child.get_constraints());\n        }\n        last = this._info(children[0].get_constrained_variables());\n        constraints.push(solver_1.EQ(last.span.start, 0));\n        for (i = k = 1, ref = children.length; 1 <= ref ? k < ref : k > ref; i = 1 <= ref ? ++k : --k) {\n            next = this._info(children[i].get_constrained_variables());\n            if (last.span.size) {\n                constraints.push(solver_1.EQ(last.span.start, last.span.size, [-1, next.span.start]));\n            }\n            constraints.push(solver_1.WEAK_EQ(last.whitespace.after, next.whitespace.before, 0 - this.spacing));\n            constraints.push(solver_1.GE(last.whitespace.after, next.whitespace.before, 0 - this.spacing));\n            last = next;\n        }\n        if (this._horizontal) {\n            if (vars.width != null) {\n                constraints.push(solver_1.EQ(last.span.start, last.span.size, [-1, this._width]));\n            }\n        }\n        else {\n            if (vars.height != null) {\n                constraints.push(solver_1.EQ(last.span.start, last.span.size, [-1, this._height]));\n            }\n        }\n        constraints = constraints.concat(this._align_outer_edges_constraints(true), this._align_outer_edges_constraints(false), this._align_inner_cell_edges_constraints(), this._box_equal_size_bounds(true), this._box_equal_size_bounds(false), this._box_cell_align_bounds(true), this._box_cell_align_bounds(false), this._box_whitespace(true), this._box_whitespace(false));\n        return constraints;\n    };\n    Box.prototype._child_rect = function (vars) {\n        return {\n            x: vars.origin_x,\n            y: vars.origin_y,\n            width: vars.width,\n            height: vars.height\n        };\n    };\n    Box.prototype._span = function (rect) {\n        if (this._horizontal) {\n            return {\n                start: rect.x,\n                size: rect.width\n            };\n        }\n        else {\n            return {\n                start: rect.y,\n                size: rect.height\n            };\n        }\n    };\n    Box.prototype._info = function (vars) {\n        var span, whitespace;\n        if (this._horizontal) {\n            whitespace = {\n                before: vars.whitespace_left,\n                after: vars.whitespace_right\n            };\n        }\n        else {\n            whitespace = {\n                before: vars.whitespace_top,\n                after: vars.whitespace_bottom\n            };\n        }\n        span = this._span(this._child_rect(vars));\n        return {\n            span: span,\n            whitespace: whitespace\n        };\n    };\n    Box.prototype._flatten_cell_edge_variables = function (horizontal) {\n        var add_path, all_vars, arity, cell, cell_vars, child, children, direction, flattened, j, k, key, kind, len, len1, name, new_key, parsed, path, relevant_edges, variables;\n        if (horizontal) {\n            relevant_edges = Box._top_bottom_inner_cell_edge_variables;\n        }\n        else {\n            relevant_edges = Box._left_right_inner_cell_edge_variables;\n        }\n        add_path = horizontal !== this._horizontal;\n        children = this.get_layoutable_children();\n        arity = children.length;\n        flattened = {};\n        cell = 0;\n        for (j = 0, len = children.length; j < len; j++) {\n            child = children[j];\n            if (child instanceof Box) {\n                cell_vars = child._flatten_cell_edge_variables(horizontal);\n            }\n            else {\n                cell_vars = {};\n            }\n            all_vars = child.get_constrained_variables();\n            for (k = 0, len1 = relevant_edges.length; k < len1; k++) {\n                name = relevant_edges[k];\n                if (name in all_vars) {\n                    cell_vars[name] = [all_vars[name]];\n                }\n            }\n            for (key in cell_vars) {\n                variables = cell_vars[key];\n                if (add_path) {\n                    parsed = key.split(\" \");\n                    kind = parsed[0];\n                    if (parsed.length > 1) {\n                        path = parsed[1];\n                    }\n                    else {\n                        path = \"\";\n                    }\n                    if (this._horizontal) {\n                        direction = \"row\";\n                    }\n                    else {\n                        direction = \"col\";\n                    }\n                    new_key = kind + \" \" + direction + \"-\" + arity + \"-\" + cell + \"-\" + path;\n                }\n                else {\n                    new_key = key;\n                }\n                if (new_key in flattened) {\n                    flattened[new_key] = flattened[new_key].concat(variables);\n                }\n                else {\n                    flattened[new_key] = variables;\n                }\n            }\n            cell = cell + 1;\n        }\n        return flattened;\n    };\n    Box.prototype._align_inner_cell_edges_constraints = function () {\n        var constraints, flattened, i, j, key, last, ref, variables;\n        constraints = [];\n        if ((this.document != null) && indexOf.call(this.document.roots(), this) >= 0) {\n            flattened = this._flatten_cell_edge_variables(this._horizontal);\n            for (key in flattened) {\n                variables = flattened[key];\n                if (variables.length > 1) {\n                    last = variables[0];\n                    for (i = j = 1, ref = variables.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {\n                        constraints.push(solver_1.EQ(variables[i], [-1, last]));\n                    }\n                }\n            }\n        }\n        return constraints;\n    };\n    Box.prototype._find_edge_leaves = function (horizontal) {\n        var child, child_leaves, children, end, j, leaves, len, start;\n        children = this.get_layoutable_children();\n        leaves = [[], []];\n        if (children.length > 0) {\n            if (this._horizontal === horizontal) {\n                start = children[0];\n                end = children[children.length - 1];\n                if (start instanceof Box) {\n                    leaves[0] = leaves[0].concat(start._find_edge_leaves(horizontal)[0]);\n                }\n                else {\n                    leaves[0].push(start);\n                }\n                if (end instanceof Box) {\n                    leaves[1] = leaves[1].concat(end._find_edge_leaves(horizontal)[1]);\n                }\n                else {\n                    leaves[1].push(end);\n                }\n            }\n            else {\n                for (j = 0, len = children.length; j < len; j++) {\n                    child = children[j];\n                    if (child instanceof Box) {\n                        child_leaves = child._find_edge_leaves(horizontal);\n                        leaves[0] = leaves[0].concat(child_leaves[0]);\n                        leaves[1] = leaves[1].concat(child_leaves[1]);\n                    }\n                    else {\n                        leaves[0].push(child);\n                        leaves[1].push(child);\n                    }\n                }\n            }\n        }\n        return leaves;\n    };\n    Box.prototype._align_outer_edges_constraints = function (horizontal) {\n        var add_all_equal, collect_vars, end_edges, end_leaves, end_variable, ref, result, start_edges, start_leaves, start_variable;\n        ref = this._find_edge_leaves(horizontal), start_leaves = ref[0], end_leaves = ref[1];\n        if (horizontal) {\n            start_variable = 'on_edge_align_left';\n            end_variable = 'on_edge_align_right';\n        }\n        else {\n            start_variable = 'on_edge_align_top';\n            end_variable = 'on_edge_align_bottom';\n        }\n        collect_vars = function (leaves, name) {\n            var edges, j, leaf, len, vars;\n            edges = [];\n            for (j = 0, len = leaves.length; j < len; j++) {\n                leaf = leaves[j];\n                vars = leaf.get_constrained_variables();\n                if (name in vars) {\n                    edges.push(vars[name]);\n                }\n            }\n            return edges;\n        };\n        start_edges = collect_vars(start_leaves, start_variable);\n        end_edges = collect_vars(end_leaves, end_variable);\n        result = [];\n        add_all_equal = function (edges) {\n            var edge, first, i, j, ref1;\n            if (edges.length > 1) {\n                first = edges[0];\n                for (i = j = 1, ref1 = edges.length; 1 <= ref1 ? j < ref1 : j > ref1; i = 1 <= ref1 ? ++j : --j) {\n                    edge = edges[i];\n                    result.push(solver_1.EQ([-1, first], edge));\n                }\n                return null;\n            }\n        };\n        add_all_equal(start_edges);\n        add_all_equal(end_edges);\n        return result;\n    };\n    Box.prototype._box_insets_from_child_insets = function (horizontal, child_variable_prefix, our_variable_prefix, minimum) {\n        var add_constraints, end_leaves, end_variable, our_end, our_start, ref, result, start_leaves, start_variable;\n        ref = this._find_edge_leaves(horizontal), start_leaves = ref[0], end_leaves = ref[1];\n        if (horizontal) {\n            start_variable = child_variable_prefix + \"_left\";\n            end_variable = child_variable_prefix + \"_right\";\n            our_start = this[our_variable_prefix + \"_left\"];\n            our_end = this[our_variable_prefix + \"_right\"];\n        }\n        else {\n            start_variable = child_variable_prefix + \"_top\";\n            end_variable = child_variable_prefix + \"_bottom\";\n            our_start = this[our_variable_prefix + \"_top\"];\n            our_end = this[our_variable_prefix + \"_bottom\"];\n        }\n        result = [];\n        add_constraints = function (ours, leaves, name) {\n            var edges, j, leaf, len, vars;\n            edges = [];\n            for (j = 0, len = leaves.length; j < len; j++) {\n                leaf = leaves[j];\n                vars = leaf.get_constrained_variables();\n                if (name in vars) {\n                    if (minimum) {\n                        result.push(solver_1.GE([-1, ours], vars[name]));\n                    }\n                    else {\n                        result.push(solver_1.EQ([-1, ours], vars[name]));\n                    }\n                }\n            }\n            return null;\n        };\n        add_constraints(our_start, start_leaves, start_variable);\n        add_constraints(our_end, end_leaves, end_variable);\n        return result;\n    };\n    Box.prototype._box_equal_size_bounds = function (horizontal) {\n        return this._box_insets_from_child_insets(horizontal, 'box_equal_size', '_box_equal_size', false);\n    };\n    Box.prototype._box_cell_align_bounds = function (horizontal) {\n        return this._box_insets_from_child_insets(horizontal, 'box_cell_align', '_box_cell_align', false);\n    };\n    Box.prototype._box_whitespace = function (horizontal) {\n        return this._box_insets_from_child_insets(horizontal, 'whitespace', '_whitespace', true);\n    };\n    Box._left_right_inner_cell_edge_variables = ['box_cell_align_left', 'box_cell_align_right'];\n    Box._top_bottom_inner_cell_edge_variables = ['box_cell_align_top', 'box_cell_align_bottom'];\n    return Box;\n})(layout_dom_1.LayoutDOM);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar box_1 = require(\"./box\");\nexports.ColumnView = (function (superClass) {\n    extend(ColumnView, superClass);\n    function ColumnView() {\n        return ColumnView.__super__.constructor.apply(this, arguments);\n    }\n    ColumnView.prototype.className = \"bk-grid-column\";\n    return ColumnView;\n})(box_1.BoxView);\nexports.Column = (function (superClass) {\n    extend(Column, superClass);\n    Column.prototype.type = 'Column';\n    Column.prototype.default_view = exports.ColumnView;\n    function Column(attrs, options) {\n        Column.__super__.constructor.call(this, attrs, options);\n        this._horizontal = false;\n    }\n    return Column;\n})(box_1.Box);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar box_1 = require(\"./box\");\nexports.Box = box_1.Box;\nvar column_1 = require(\"./column\");\nexports.Column = column_1.Column;\nvar layout_dom_1 = require(\"./layout_dom\");\nexports.LayoutDOM = layout_dom_1.LayoutDOM;\nvar row_1 = require(\"./row\");\nexports.Row = row_1.Row;\nvar spacer_1 = require(\"./spacer\");\nexports.Spacer = spacer_1.Spacer;\nvar widget_box_1 = require(\"./widget_box\");\nexports.WidgetBox = widget_box_1.WidgetBox;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nvar solver_1 = require(\"core/layout/solver\");\nvar build_views_1 = require(\"core/build_views\");\nvar dom_view_1 = require(\"core/dom_view\");\nvar logging_1 = require(\"core/logging\");\nexports.LayoutDOMView = (function (superClass) {\n    extend1(LayoutDOMView, superClass);\n    function LayoutDOMView() {\n        return LayoutDOMView.__super__.constructor.apply(this, arguments);\n    }\n    LayoutDOMView.prototype.initialize = function (options) {\n        LayoutDOMView.__super__.initialize.call(this, options);\n        if (this.is_root) {\n            this._solver = new solver_1.Solver();\n        }\n        this.child_views = {};\n        this.build_child_views();\n        return this.connect_signals();\n    };\n    LayoutDOMView.prototype.remove = function () {\n        var _, ref, view;\n        ref = this.child_views;\n        for (_ in ref) {\n            view = ref[_];\n            view.remove();\n        }\n        this.child_views = {};\n        return LayoutDOMView.__super__.remove.call(this);\n    };\n    LayoutDOMView.prototype.has_finished = function () {\n        var _, child, ref;\n        if (!LayoutDOMView.__super__.has_finished.call(this)) {\n            return false;\n        }\n        ref = this.child_views;\n        for (_ in ref) {\n            child = ref[_];\n            if (!child.has_finished()) {\n                return false;\n            }\n        }\n        return true;\n    };\n    LayoutDOMView.prototype.notify_finished = function () {\n        if (!this.is_root) {\n            return LayoutDOMView.__super__.notify_finished.call(this);\n        }\n        else {\n            if (!this._idle_notified && this.has_finished()) {\n                if (this.model.document != null) {\n                    this._idle_notified = true;\n                    return this.model.document.notify_idle(this.model);\n                }\n            }\n        }\n    };\n    LayoutDOMView.prototype._calc_width_height = function () {\n        var height, measuring, ref, width;\n        measuring = this.el;\n        while (true) {\n            measuring = measuring.parentNode;\n            if (measuring == null) {\n                logging_1.logger.warn(\"detached element\");\n                width = height = null;\n                break;\n            }\n            ref = measuring.getBoundingClientRect(), width = ref.width, height = ref.height;\n            if (height !== 0) {\n                break;\n            }\n        }\n        return [width, height];\n    };\n    LayoutDOMView.prototype._init_solver = function () {\n        var constraint, constraints, edit_variable, editables, i, j, len, len1, ref, strength, variables;\n        this._root_width = new solver_1.Variable(\"root_width\");\n        this._root_height = new solver_1.Variable(\"root_height\");\n        this._solver.add_edit_variable(this._root_width);\n        this._solver.add_edit_variable(this._root_height);\n        editables = this.model.get_edit_variables();\n        constraints = this.model.get_constraints();\n        variables = this.model.get_constrained_variables();\n        for (i = 0, len = editables.length; i < len; i++) {\n            ref = editables[i], edit_variable = ref.edit_variable, strength = ref.strength;\n            this._solver.add_edit_variable(edit_variable, strength);\n        }\n        for (j = 0, len1 = constraints.length; j < len1; j++) {\n            constraint = constraints[j];\n            this._solver.add_constraint(constraint);\n        }\n        if (variables.width != null) {\n            this._solver.add_constraint(solver_1.EQ(variables.width, this._root_width));\n        }\n        if (variables.height != null) {\n            this._solver.add_constraint(solver_1.EQ(variables.height, this._root_height));\n        }\n        return this._solver.update_variables();\n    };\n    LayoutDOMView.prototype._suggest_dims = function (width, height) {\n        var ref, variables;\n        variables = this.model.get_constrained_variables();\n        if ((variables.width != null) || (variables.height != null)) {\n            if (width === null || height === null) {\n                ref = this._calc_width_height(), width = ref[0], height = ref[1];\n            }\n            if ((variables.width != null) && (width != null)) {\n                this._solver.suggest_value(this._root_width, width);\n            }\n            if ((variables.height != null) && (height != null)) {\n                this._solver.suggest_value(this._root_height, height);\n            }\n            return this._solver.update_variables();\n        }\n    };\n    LayoutDOMView.prototype.resize = function (width, height) {\n        if (width == null) {\n            width = null;\n        }\n        if (height == null) {\n            height = null;\n        }\n        if (!this.is_root) {\n            return this.root.resize(width, height);\n        }\n        else {\n            return this._do_layout(false, width, height);\n        }\n    };\n    LayoutDOMView.prototype.layout = function (full) {\n        if (full == null) {\n            full = true;\n        }\n        if (!this.is_root) {\n            return this.root.layout(full);\n        }\n        else {\n            return this._do_layout(full);\n        }\n    };\n    LayoutDOMView.prototype._do_layout = function (full, width, height) {\n        if (width == null) {\n            width = null;\n        }\n        if (height == null) {\n            height = null;\n        }\n        if (full) {\n            this._solver.clear();\n            this._init_solver();\n        }\n        this._suggest_dims(width, height);\n        this._layout();\n        this._layout();\n        this._layout(true);\n        return this.notify_finished();\n    };\n    LayoutDOMView.prototype._layout = function (final) {\n        var child, child_view, i, len, ref;\n        if (final == null) {\n            final = false;\n        }\n        ref = this.model.get_layoutable_children();\n        for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            child_view = this.child_views[child.id];\n            if (child_view._layout != null) {\n                child_view._layout(final);\n            }\n        }\n        this.render();\n        if (final) {\n            return this._has_finished = true;\n        }\n    };\n    LayoutDOMView.prototype.rebuild_child_views = function () {\n        this.solver.clear();\n        this.build_child_views();\n        return this.layout();\n    };\n    LayoutDOMView.prototype.build_child_views = function () {\n        var child, child_view, children, i, len, results;\n        children = this.model.get_layoutable_children();\n        build_views_1.build_views(this.child_views, children, {\n            parent: this\n        });\n        dom_1.empty(this.el);\n        results = [];\n        for (i = 0, len = children.length; i < len; i++) {\n            child = children[i];\n            child_view = this.child_views[child.id];\n            results.push(this.el.appendChild(child_view.el));\n        }\n        return results;\n    };\n    LayoutDOMView.prototype.connect_signals = function () {\n        LayoutDOMView.__super__.connect_signals.call(this);\n        if (this.is_root) {\n            window.addEventListener(\"resize\", (function (_this) {\n                return function () {\n                    return _this.resize();\n                };\n            })(this));\n        }\n        return this.connect(this.model.properties.sizing_mode.change, (function (_this) {\n            return function () {\n                return _this.layout();\n            };\n        })(this));\n    };\n    LayoutDOMView.prototype._render_classes = function () {\n        var cls, i, len, ref, results;\n        this.el.className = \"\";\n        if (this.className != null) {\n            this.el.classList.add(this.className);\n        }\n        if (this.model.sizing_mode != null) {\n            this.el.classList.add(\"bk-layout-\" + this.model.sizing_mode);\n        }\n        if (this.model.css_classes != null) {\n            ref = this.model.css_classes;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n                cls = ref[i];\n                results.push(this.el.classList.add(cls));\n            }\n            return results;\n        }\n    };\n    LayoutDOMView.prototype.render = function () {\n        var height, width;\n        this._render_classes();\n        switch (this.model.sizing_mode) {\n            case 'fixed':\n                if (this.model.width != null) {\n                    width = this.model.width;\n                }\n                else {\n                    width = this.get_width();\n                    this.model.setv({\n                        width: width\n                    }, {\n                        silent: true\n                    });\n                }\n                if (this.model.height != null) {\n                    height = this.model.height;\n                }\n                else {\n                    height = this.get_height();\n                    this.model.setv({\n                        height: height\n                    }, {\n                        silent: true\n                    });\n                }\n                this.solver.suggest_value(this.model._width, width);\n                this.solver.suggest_value(this.model._height, height);\n                this.solver.update_variables();\n                this.el.style.position = \"relative\";\n                this.el.style.left = \"\";\n                this.el.style.top = \"\";\n                this.el.style.width = width + \"px\";\n                return this.el.style.height = height + \"px\";\n            case 'scale_width':\n                height = this.get_height();\n                this.solver.suggest_value(this.model._height, height);\n                this.solver.update_variables();\n                this.el.style.position = \"relative\";\n                this.el.style.left = \"\";\n                this.el.style.top = \"\";\n                this.el.style.width = this.model._width.value + \"px\";\n                return this.el.style.height = this.model._height.value + \"px\";\n            case 'scale_height':\n                width = this.get_width();\n                this.solver.suggest_value(this.model._width, width);\n                this.solver.update_variables();\n                this.el.style.position = \"relative\";\n                this.el.style.left = \"\";\n                this.el.style.top = \"\";\n                this.el.style.width = this.model._width.value + \"px\";\n                return this.el.style.height = this.model._height.value + \"px\";\n            case 'stretch_both':\n                this.el.style.position = \"absolute\";\n                this.el.style.left = this.model._dom_left.value + \"px\";\n                this.el.style.top = this.model._dom_top.value + \"px\";\n                this.el.style.width = this.model._width.value + \"px\";\n                return this.el.style.height = this.model._height.value + \"px\";\n        }\n    };\n    LayoutDOMView.prototype.get_height = function () {\n        return null;\n    };\n    LayoutDOMView.prototype.get_width = function () {\n        return null;\n    };\n    return LayoutDOMView;\n})(dom_view_1.DOMView);\nexports.LayoutDOM = (function (superClass) {\n    extend1(LayoutDOM, superClass);\n    function LayoutDOM() {\n        return LayoutDOM.__super__.constructor.apply(this, arguments);\n    }\n    LayoutDOM.prototype.type = \"LayoutDOM\";\n    LayoutDOM.prototype.initialize = function (attrs, options) {\n        LayoutDOM.__super__.initialize.call(this, attrs, options);\n        this._width = new solver_1.Variable(\"_width \" + this.id);\n        this._height = new solver_1.Variable(\"_height \" + this.id);\n        this._left = new solver_1.Variable(\"_left \" + this.id);\n        this._right = new solver_1.Variable(\"_right \" + this.id);\n        this._top = new solver_1.Variable(\"_top \" + this.id);\n        this._bottom = new solver_1.Variable(\"_bottom \" + this.id);\n        this._dom_top = new solver_1.Variable(\"_dom_top \" + this.id);\n        this._dom_left = new solver_1.Variable(\"_dom_left \" + this.id);\n        this._width_minus_right = new solver_1.Variable(\"_width_minus_right \" + this.id);\n        this._height_minus_bottom = new solver_1.Variable(\"_height_minus_bottom \" + this.id);\n        this._whitespace_top = new solver_1.Variable();\n        this._whitespace_bottom = new solver_1.Variable();\n        this._whitespace_left = new solver_1.Variable();\n        return this._whitespace_right = new solver_1.Variable();\n    };\n    LayoutDOM.getters({\n        layout_bbox: function () {\n            return {\n                top: this._top.value,\n                left: this._left.value,\n                width: this._width.value,\n                height: this._height.value,\n                right: this._right.value,\n                bottom: this._bottom.value,\n                dom_top: this._dom_top.value,\n                dom_left: this._dom_left.value\n            };\n        }\n    });\n    LayoutDOM.prototype.dump_layout = function () {\n        var child, i, len, ref, results;\n        console.log(this.toString(), this.layout_bbox);\n        ref = this.get_layoutable_children();\n        results = [];\n        for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            results.push(child.dump_layout());\n        }\n        return results;\n    };\n    LayoutDOM.prototype.get_constraints = function () {\n        return [solver_1.GE(this._dom_left), solver_1.GE(this._dom_top), solver_1.GE(this._left), solver_1.GE(this._width, [-1, this._right]), solver_1.GE(this._top), solver_1.GE(this._height, [-1, this._bottom]), solver_1.EQ(this._width_minus_right, [-1, this._width], this._right), solver_1.EQ(this._height_minus_bottom, [-1, this._height], this._bottom)];\n    };\n    LayoutDOM.prototype.get_layoutable_children = function () {\n        return [];\n    };\n    LayoutDOM.prototype.get_edit_variables = function () {\n        var edit_variables;\n        edit_variables = [];\n        if (this.sizing_mode === 'fixed') {\n            edit_variables.push({\n                edit_variable: this._height,\n                strength: solver_1.Strength.strong\n            });\n            edit_variables.push({\n                edit_variable: this._width,\n                strength: solver_1.Strength.strong\n            });\n        }\n        if (this.sizing_mode === 'scale_width') {\n            edit_variables.push({\n                edit_variable: this._height,\n                strength: solver_1.Strength.strong\n            });\n        }\n        if (this.sizing_mode === 'scale_height') {\n            edit_variables.push({\n                edit_variable: this._width,\n                strength: solver_1.Strength.strong\n            });\n        }\n        return edit_variables;\n    };\n    LayoutDOM.prototype.get_constrained_variables = function () {\n        var vars;\n        vars = {\n            origin_x: this._dom_left,\n            origin_y: this._dom_top,\n            whitespace_top: this._whitespace_top,\n            whitespace_bottom: this._whitespace_bottom,\n            whitespace_left: this._whitespace_left,\n            whitespace_right: this._whitespace_right\n        };\n        switch (this.sizing_mode) {\n            case 'stretch_both':\n                vars.width = this._width;\n                vars.height = this._height;\n                break;\n            case 'scale_width':\n                vars.width = this._width;\n                break;\n            case 'scale_height':\n                vars.height = this._height;\n        }\n        return vars;\n    };\n    LayoutDOM.define({\n        height: [p.Number],\n        width: [p.Number],\n        disabled: [p.Bool, false],\n        sizing_mode: [p.SizingMode, \"fixed\"],\n        css_classes: [p.Array]\n    });\n    return LayoutDOM;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar box_1 = require(\"./box\");\nexports.RowView = (function (superClass) {\n    extend(RowView, superClass);\n    function RowView() {\n        return RowView.__super__.constructor.apply(this, arguments);\n    }\n    RowView.prototype.className = \"bk-grid-row\";\n    return RowView;\n})(box_1.BoxView);\nexports.Row = (function (superClass) {\n    extend(Row, superClass);\n    Row.prototype.type = 'Row';\n    Row.prototype.default_view = exports.RowView;\n    function Row(attrs, options) {\n        Row.__super__.constructor.call(this, attrs, options);\n        this._horizontal = true;\n    }\n    return Row;\n})(box_1.Box);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar layout_dom_1 = require(\"./layout_dom\");\nvar object_1 = require(\"core/util/object\");\nexports.SpacerView = (function (superClass) {\n    extend1(SpacerView, superClass);\n    function SpacerView() {\n        return SpacerView.__super__.constructor.apply(this, arguments);\n    }\n    SpacerView.prototype.className = \"bk-spacer-box\";\n    SpacerView.prototype.render = function () {\n        SpacerView.__super__.render.call(this);\n        if (this.sizing_mode === \"fixed\") {\n            this.el.style.width = this.model.width + \"px\";\n            return this.el.style.height = this.model.height + \"px\";\n        }\n    };\n    SpacerView.prototype.get_height = function () {\n        return 1;\n    };\n    return SpacerView;\n})(layout_dom_1.LayoutDOMView);\nexports.Spacer = (function (superClass) {\n    extend1(Spacer, superClass);\n    function Spacer() {\n        return Spacer.__super__.constructor.apply(this, arguments);\n    }\n    Spacer.prototype.type = 'Spacer';\n    Spacer.prototype.default_view = exports.SpacerView;\n    Spacer.prototype.get_constrained_variables = function () {\n        return object_1.extend({}, Spacer.__super__.get_constrained_variables.call(this), {\n            on_edge_align_top: this._top,\n            on_edge_align_bottom: this._height_minus_bottom,\n            on_edge_align_left: this._left,\n            on_edge_align_right: this._width_minus_right,\n            box_cell_align_top: this._top,\n            box_cell_align_bottom: this._height_minus_bottom,\n            box_cell_align_left: this._left,\n            box_cell_align_right: this._width_minus_right,\n            box_equal_size_top: this._top,\n            box_equal_size_bottom: this._height_minus_bottom,\n            box_equal_size_left: this._left,\n            box_equal_size_right: this._width_minus_right\n        });\n    };\n    return Spacer;\n})(layout_dom_1.LayoutDOM);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nvar layout_dom_1 = require(\"../layouts/layout_dom\");\nexports.WidgetBoxView = (function (superClass) {\n    extend1(WidgetBoxView, superClass);\n    function WidgetBoxView() {\n        return WidgetBoxView.__super__.constructor.apply(this, arguments);\n    }\n    WidgetBoxView.prototype.className = \"bk-widget-box\";\n    WidgetBoxView.prototype.connect_signals = function () {\n        WidgetBoxView.__super__.connect_signals.call(this);\n        return this.connect(this.model.properties.children.change, (function (_this) {\n            return function () {\n                return _this.rebuild_child_views();\n            };\n        })(this));\n    };\n    WidgetBoxView.prototype.render = function () {\n        var css_width, height, width;\n        this._render_classes();\n        if (this.model.sizing_mode === 'fixed' || this.model.sizing_mode === 'scale_height') {\n            width = this.get_width();\n            if (this.model._width.value !== width) {\n                this.solver.suggest_value(this.model._width, width);\n            }\n        }\n        if (this.model.sizing_mode === 'fixed' || this.model.sizing_mode === 'scale_width') {\n            height = this.get_height();\n            if (this.model._height.value !== height) {\n                this.solver.suggest_value(this.model._height, height);\n            }\n        }\n        this.solver.update_variables();\n        if (this.model.sizing_mode === 'stretch_both') {\n            this.el.style.position = 'absolute';\n            this.el.style.left = this.model._dom_left.value + \"px\";\n            this.el.style.top = this.model._dom_top.value + \"px\";\n            this.el.style.width = this.model._width.value + \"px\";\n            return this.el.style.height = this.model._height.value + \"px\";\n        }\n        else {\n            if (this.model._width.value - 20 > 0) {\n                css_width = (this.model._width.value - 20) + \"px\";\n            }\n            else {\n                css_width = \"100%\";\n            }\n            return this.el.style.width = css_width;\n        }\n    };\n    WidgetBoxView.prototype.get_height = function () {\n        var child_view, height, key, ref;\n        height = 0;\n        ref = this.child_views;\n        for (key in ref) {\n            if (!hasProp.call(ref, key))\n                continue;\n            child_view = ref[key];\n            height += child_view.el.scrollHeight;\n        }\n        return height + 20;\n    };\n    WidgetBoxView.prototype.get_width = function () {\n        var child_view, child_width, key, ref, width;\n        if (this.model.width != null) {\n            return this.model.width;\n        }\n        else {\n            width = this.el.scrollWidth + 20;\n            ref = this.child_views;\n            for (key in ref) {\n                if (!hasProp.call(ref, key))\n                    continue;\n                child_view = ref[key];\n                child_width = child_view.el.scrollWidth;\n                if (child_width > width) {\n                    width = child_width;\n                }\n            }\n            return width;\n        }\n    };\n    return WidgetBoxView;\n})(layout_dom_1.LayoutDOMView);\nexports.WidgetBox = (function (superClass) {\n    extend1(WidgetBox, superClass);\n    function WidgetBox() {\n        return WidgetBox.__super__.constructor.apply(this, arguments);\n    }\n    WidgetBox.prototype.type = 'WidgetBox';\n    WidgetBox.prototype.default_view = exports.WidgetBoxView;\n    WidgetBox.prototype.initialize = function (options) {\n        WidgetBox.__super__.initialize.call(this, options);\n        if (this.sizing_mode === 'fixed' && this.width === null) {\n            this.width = 300;\n            logging_1.logger.info(\"WidgetBox mode is fixed, but no width specified. Using default of 300.\");\n        }\n        if (this.sizing_mode === 'scale_height') {\n            return logging_1.logger.warn(\"sizing_mode `scale_height` is not experimental for WidgetBox. Please report your results to the bokeh dev team so we can improve.\");\n        }\n    };\n    WidgetBox.prototype.get_edit_variables = function () {\n        var child, edit_variables, i, len, ref;\n        edit_variables = WidgetBox.__super__.get_edit_variables.call(this);\n        ref = this.get_layoutable_children();\n        for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            edit_variables = edit_variables.concat(child.get_edit_variables());\n        }\n        return edit_variables;\n    };\n    WidgetBox.prototype.get_constraints = function () {\n        var child, constraints, i, len, ref;\n        constraints = WidgetBox.__super__.get_constraints.call(this);\n        ref = this.get_layoutable_children();\n        for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            constraints = constraints.concat(child.get_constraints());\n        }\n        return constraints;\n    };\n    WidgetBox.prototype.get_constrained_variables = function () {\n        var vars;\n        vars = object_1.extend({}, WidgetBox.__super__.get_constrained_variables.call(this), {\n            on_edge_align_top: this._top,\n            on_edge_align_bottom: this._height_minus_bottom,\n            on_edge_align_left: this._left,\n            on_edge_align_right: this._width_minus_right,\n            box_cell_align_top: this._top,\n            box_cell_align_bottom: this._height_minus_bottom,\n            box_cell_align_left: this._left,\n            box_cell_align_right: this._width_minus_right,\n            box_equal_size_top: this._top,\n            box_equal_size_bottom: this._height_minus_bottom\n        });\n        if (this.sizing_mode !== 'fixed') {\n            vars.box_equal_size_left = this._left;\n            vars.box_equal_size_right = this._width_minus_right;\n        }\n        return vars;\n    };\n    WidgetBox.prototype.get_layoutable_children = function () {\n        return this.children;\n    };\n    WidgetBox.define({\n        children: [p.Array, []]\n    });\n    return WidgetBox;\n})(layout_dom_1.LayoutDOM);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar color_mapper_1 = require(\"./color_mapper\");\nexports.CategoricalColorMapper = (function (superClass) {\n    extend(CategoricalColorMapper, superClass);\n    function CategoricalColorMapper() {\n        return CategoricalColorMapper.__super__.constructor.apply(this, arguments);\n    }\n    CategoricalColorMapper.prototype.type = \"CategoricalColorMapper\";\n    CategoricalColorMapper.define({\n        factors: [p.Array]\n    });\n    CategoricalColorMapper.prototype._get_values = function (data, palette) {\n        var color, d, i, key, len, values;\n        values = [];\n        for (i = 0, len = data.length; i < len; i++) {\n            d = data[i];\n            key = this.factors.indexOf(d);\n            if (key < 0 || key >= palette.length) {\n                color = this.nan_color;\n            }\n            else {\n                color = palette[key];\n            }\n            values.push(color);\n        }\n        return values;\n    };\n    return CategoricalColorMapper;\n})(color_mapper_1.ColorMapper);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar transform_1 = require(\"../transforms/transform\");\nvar types_1 = require(\"core/util/types\");\nexports.ColorMapper = (function (superClass) {\n    extend(ColorMapper, superClass);\n    function ColorMapper() {\n        return ColorMapper.__super__.constructor.apply(this, arguments);\n    }\n    ColorMapper.prototype.type = \"ColorMapper\";\n    ColorMapper.define({\n        palette: [p.Any],\n        nan_color: [p.Color, \"gray\"]\n    });\n    ColorMapper.prototype.initialize = function (attrs, options) {\n        ColorMapper.__super__.initialize.call(this, attrs, options);\n        this._little_endian = this._is_little_endian();\n        this._palette = this._build_palette(this.palette);\n        return this.connect(this.change, function () {\n            return this._palette = this._build_palette(this.palette);\n        });\n    };\n    ColorMapper.prototype.v_map_screen = function (data, image_glyph) {\n        var buf, color, i, j, k, ref, ref1, value, values;\n        if (image_glyph == null) {\n            image_glyph = false;\n        }\n        values = this._get_values(data, this._palette, image_glyph);\n        buf = new ArrayBuffer(data.length * 4);\n        color = new Uint32Array(buf);\n        if (this._little_endian) {\n            for (i = j = 0, ref = data.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                value = values[i];\n                color[i] = (0xff << 24) | ((value & 0xff0000) >> 16) | (value & 0xff00) | ((value & 0xff) << 16);\n            }\n        }\n        else {\n            for (i = k = 0, ref1 = data.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n                value = values[i];\n                color[i] = (value << 8) | 0xff;\n            }\n        }\n        return buf;\n    };\n    ColorMapper.prototype.compute = function (x) {\n        return null;\n    };\n    ColorMapper.prototype.v_compute = function (xs) {\n        var values;\n        values = this._get_values(xs, this.palette);\n        return values;\n    };\n    ColorMapper.prototype._get_values = function (data, palette, image_glyph) {\n        if (image_glyph == null) {\n            image_glyph = false;\n        }\n        return [];\n    };\n    ColorMapper.prototype._is_little_endian = function () {\n        var buf, buf32, buf8, little_endian;\n        buf = new ArrayBuffer(4);\n        buf8 = new Uint8Array(buf);\n        buf32 = new Uint32Array(buf);\n        buf32[1] = 0x0a0b0c0d;\n        little_endian = true;\n        if (buf8[4] === 0x0a && buf8[5] === 0x0b && buf8[6] === 0x0c && buf8[7] === 0x0d) {\n            little_endian = false;\n        }\n        return little_endian;\n    };\n    ColorMapper.prototype._build_palette = function (palette) {\n        var _convert, i, j, new_palette, ref;\n        new_palette = new Uint32Array(palette.length);\n        _convert = function (value) {\n            if (types_1.isNumber(value)) {\n                return value;\n            }\n            else {\n                return parseInt(value.slice(1), 16);\n            }\n        };\n        for (i = j = 0, ref = palette.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            new_palette[i] = _convert(palette[i]);\n        }\n        return new_palette;\n    };\n    return ColorMapper;\n})(transform_1.Transform);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar categorical_color_mapper_1 = require(\"./categorical_color_mapper\");\nexports.CategoricalColorMapper = categorical_color_mapper_1.CategoricalColorMapper;\nvar color_mapper_1 = require(\"./color_mapper\");\nexports.ColorMapper = color_mapper_1.ColorMapper;\nvar linear_color_mapper_1 = require(\"./linear_color_mapper\");\nexports.LinearColorMapper = linear_color_mapper_1.LinearColorMapper;\nvar log_color_mapper_1 = require(\"./log_color_mapper\");\nexports.LogColorMapper = log_color_mapper_1.LogColorMapper;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar color_1 = require(\"core/util/color\");\nvar array_1 = require(\"core/util/array\");\nvar color_mapper_1 = require(\"./color_mapper\");\nexports.LinearColorMapper = (function (superClass) {\n    extend(LinearColorMapper, superClass);\n    function LinearColorMapper() {\n        return LinearColorMapper.__super__.constructor.apply(this, arguments);\n    }\n    LinearColorMapper.prototype.type = \"LinearColorMapper\";\n    LinearColorMapper.define({\n        high: [p.Number],\n        low: [p.Number],\n        high_color: [p.Color],\n        low_color: [p.Color]\n    });\n    LinearColorMapper.prototype.initialize = function (attrs, options) {\n        LinearColorMapper.__super__.initialize.call(this, attrs, options);\n        this._nan_color = this._build_palette([color_1.color2hex(this.nan_color)])[0];\n        this._high_color = this.high_color != null ? this._build_palette([color_1.color2hex(this.high_color)])[0] : void 0;\n        return this._low_color = this.low_color != null ? this._build_palette([color_1.color2hex(this.low_color)])[0] : void 0;\n    };\n    LinearColorMapper.prototype._get_values = function (data, palette, image_glyph) {\n        var d, high, high_color, i, key, len, low, low_color, max_key, nan_color, norm_factor, normed_d, normed_interval, ref, ref1, values;\n        if (image_glyph == null) {\n            image_glyph = false;\n        }\n        low = (ref = this.low) != null ? ref : array_1.min(data);\n        high = (ref1 = this.high) != null ? ref1 : array_1.max(data);\n        max_key = palette.length - 1;\n        values = [];\n        nan_color = image_glyph ? this._nan_color : this.nan_color;\n        low_color = image_glyph ? this._low_color : this.low_color;\n        high_color = image_glyph ? this._high_color : this.high_color;\n        norm_factor = 1 / (high - low);\n        normed_interval = 1 / palette.length;\n        for (i = 0, len = data.length; i < len; i++) {\n            d = data[i];\n            if (isNaN(d)) {\n                values.push(nan_color);\n                continue;\n            }\n            if (d === high) {\n                values.push(palette[max_key]);\n                continue;\n            }\n            normed_d = (d - low) * norm_factor;\n            key = Math.floor(normed_d / normed_interval);\n            if (key < 0) {\n                if (this.low_color != null) {\n                    values.push(low_color);\n                }\n                else {\n                    values.push(palette[0]);\n                }\n            }\n            else if (key > max_key) {\n                if (this.high_color != null) {\n                    values.push(high_color);\n                }\n                else {\n                    values.push(palette[max_key]);\n                }\n            }\n            else {\n                values.push(palette[key]);\n            }\n        }\n        return values;\n    };\n    return LinearColorMapper;\n})(color_mapper_1.ColorMapper);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log1p, ref, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar color_1 = require(\"core/util/color\");\nvar array_1 = require(\"core/util/array\");\nvar color_mapper_1 = require(\"./color_mapper\");\nlog1p = (ref = Math.log1p) != null ? ref : function (x) {\n    return Math.log(1 + x);\n};\nexports.LogColorMapper = (function (superClass) {\n    extend(LogColorMapper, superClass);\n    function LogColorMapper() {\n        return LogColorMapper.__super__.constructor.apply(this, arguments);\n    }\n    LogColorMapper.prototype.type = \"LogColorMapper\";\n    LogColorMapper.define({\n        high: [p.Number],\n        low: [p.Number],\n        high_color: [p.Color],\n        low_color: [p.Color]\n    });\n    LogColorMapper.prototype.initialize = function (attrs, options) {\n        LogColorMapper.__super__.initialize.call(this, attrs, options);\n        this._nan_color = this._build_palette([color_1.color2hex(this.nan_color)])[0];\n        this._high_color = this.high_color != null ? this._build_palette([color_1.color2hex(this.high_color)])[0] : void 0;\n        return this._low_color = this.low_color != null ? this._build_palette([color_1.color2hex(this.low_color)])[0] : void 0;\n    };\n    LogColorMapper.prototype._get_values = function (data, palette, image_glyph) {\n        var d, high, high_color, i, key, len, log, low, low_color, max_key, n, nan_color, ref1, ref2, scale, values;\n        if (image_glyph == null) {\n            image_glyph = false;\n        }\n        n = palette.length;\n        low = (ref1 = this.low) != null ? ref1 : array_1.min(data);\n        high = (ref2 = this.high) != null ? ref2 : array_1.max(data);\n        scale = n / (log1p(high) - log1p(low));\n        max_key = palette.length - 1;\n        values = [];\n        nan_color = image_glyph ? this._nan_color : this.nan_color;\n        high_color = image_glyph ? this._high_color : this.high_color;\n        low_color = image_glyph ? this._low_color : this.low_color;\n        for (i = 0, len = data.length; i < len; i++) {\n            d = data[i];\n            if (isNaN(d)) {\n                values.push(nan_color);\n                continue;\n            }\n            if (d > high) {\n                if (this.high_color != null) {\n                    values.push(high_color);\n                }\n                else {\n                    values.push(palette[max_key]);\n                }\n                continue;\n            }\n            if (d === high) {\n                values.push(palette[max_key]);\n                continue;\n            }\n            if (d < low) {\n                if (this.low_color != null) {\n                    values.push(low_color);\n                }\n                else {\n                    values.push(palette[0]);\n                }\n                continue;\n            }\n            log = log1p(d) - log1p(low);\n            key = Math.floor(log * scale);\n            if (key > max_key) {\n                key = max_key;\n            }\n            values.push(palette[key]);\n        }\n        return values;\n    };\n    return LogColorMapper;\n})(color_mapper_1.ColorMapper);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SQ3, _mk_model, _one_cross, _one_diamond, _one_tri, _one_x, asterisk, circle_cross, circle_x, cross, diamond, diamond_cross, inverted_triangle, square, square_cross, square_x, triangle, x, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar marker_1 = require(\"./marker\");\nSQ3 = Math.sqrt(3);\n_one_x = function (ctx, r) {\n    ctx.moveTo(-r, r);\n    ctx.lineTo(r, -r);\n    ctx.moveTo(-r, -r);\n    return ctx.lineTo(r, r);\n};\n_one_cross = function (ctx, r) {\n    ctx.moveTo(0, r);\n    ctx.lineTo(0, -r);\n    ctx.moveTo(-r, 0);\n    return ctx.lineTo(r, 0);\n};\n_one_diamond = function (ctx, r) {\n    ctx.moveTo(0, r);\n    ctx.lineTo(r / 1.5, 0);\n    ctx.lineTo(0, -r);\n    ctx.lineTo(-r / 1.5, 0);\n    return ctx.closePath();\n};\n_one_tri = function (ctx, r) {\n    var a, h;\n    h = r * SQ3;\n    a = h / 3;\n    ctx.moveTo(-r, a);\n    ctx.lineTo(r, a);\n    ctx.lineTo(0, a - h);\n    return ctx.closePath();\n};\nasterisk = function (ctx, i, sx, sy, r, line, fill) {\n    var r2;\n    r2 = r * 0.65;\n    _one_cross(ctx, r);\n    _one_x(ctx, r2);\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        ctx.stroke();\n    }\n};\ncircle_cross = function (ctx, i, sx, sy, r, line, fill) {\n    ctx.arc(0, 0, r, 0, 2 * Math.PI, false);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        _one_cross(ctx, r);\n        ctx.stroke();\n    }\n};\ncircle_x = function (ctx, i, sx, sy, r, line, fill) {\n    ctx.arc(0, 0, r, 0, 2 * Math.PI, false);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        _one_x(ctx, r);\n        ctx.stroke();\n    }\n};\ncross = function (ctx, i, sx, sy, r, line, fill) {\n    _one_cross(ctx, r);\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        ctx.stroke();\n    }\n};\ndiamond = function (ctx, i, sx, sy, r, line, fill) {\n    _one_diamond(ctx, r);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        ctx.stroke();\n    }\n};\ndiamond_cross = function (ctx, i, sx, sy, r, line, fill) {\n    _one_diamond(ctx, r);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        _one_cross(ctx, r);\n        ctx.stroke();\n    }\n};\ninverted_triangle = function (ctx, i, sx, sy, r, line, fill) {\n    ctx.rotate(Math.PI);\n    _one_tri(ctx, r);\n    ctx.rotate(-Math.PI);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        ctx.stroke();\n    }\n};\nsquare = function (ctx, i, sx, sy, r, line, fill) {\n    var size;\n    size = 2 * r;\n    ctx.rect(-r, -r, size, size);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        ctx.stroke();\n    }\n};\nsquare_cross = function (ctx, i, sx, sy, r, line, fill) {\n    var size;\n    size = 2 * r;\n    ctx.rect(-r, -r, size, size);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        _one_cross(ctx, r);\n        ctx.stroke();\n    }\n};\nsquare_x = function (ctx, i, sx, sy, r, line, fill) {\n    var size;\n    size = 2 * r;\n    ctx.rect(-r, -r, size, size);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        _one_x(ctx, r);\n        ctx.stroke();\n    }\n};\ntriangle = function (ctx, i, sx, sy, r, line, fill) {\n    _one_tri(ctx, r);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        ctx.stroke();\n    }\n};\nx = function (ctx, i, sx, sy, r, line, fill) {\n    _one_x(ctx, r);\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        ctx.stroke();\n    }\n};\n_mk_model = function (type, f) {\n    var model, view;\n    view = (function (superClass) {\n        extend(view, superClass);\n        function view() {\n            return view.__super__.constructor.apply(this, arguments);\n        }\n        view.prototype._render_one = f;\n        return view;\n    })(marker_1.MarkerView);\n    model = (function (superClass) {\n        extend(model, superClass);\n        function model() {\n            return model.__super__.constructor.apply(this, arguments);\n        }\n        model.prototype.default_view = view;\n        model.prototype.type = type;\n        return model;\n    })(marker_1.Marker);\n    return model;\n};\nexports.Asterisk = _mk_model('Asterisk', asterisk);\nexports.CircleCross = _mk_model('CircleCross', circle_cross);\nexports.CircleX = _mk_model('CircleX', circle_x);\nexports.Cross = _mk_model('Cross', cross);\nexports.Diamond = _mk_model('Diamond', diamond);\nexports.DiamondCross = _mk_model('DiamondCross', diamond_cross);\nexports.InvertedTriangle = _mk_model('InvertedTriangle', inverted_triangle);\nexports.Square = _mk_model('Square', square);\nexports.SquareCross = _mk_model('SquareCross', square_cross);\nexports.SquareX = _mk_model('SquareX', square_x);\nexports.Triangle = _mk_model('Triangle', triangle);\nexports.X = _mk_model('X', x);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"../glyphs/xy_glyph\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nexports.MarkerView = (function (superClass) {\n    extend(MarkerView, superClass);\n    function MarkerView() {\n        return MarkerView.__super__.constructor.apply(this, arguments);\n    }\n    MarkerView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        var angle, data, indices, size, sx, sy;\n        indices = [index];\n        sx = {};\n        sx[index] = (x0 + x1) / 2;\n        sy = {};\n        sy[index] = (y0 + y1) / 2;\n        size = {};\n        size[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.4;\n        angle = {};\n        angle[index] = this._angle[index];\n        data = {\n            sx: sx,\n            sy: sy,\n            _size: size,\n            _angle: angle\n        };\n        return this._render(ctx, indices, data);\n    };\n    MarkerView.prototype._render = function (ctx, indices, arg) {\n        var _angle, _size, i, j, len, r, results, sx, sy;\n        sx = arg.sx, sy = arg.sy, _size = arg._size, _angle = arg._angle;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + _size[i] + _angle[i])) {\n                continue;\n            }\n            r = _size[i] / 2;\n            ctx.beginPath();\n            ctx.translate(sx[i], sy[i]);\n            if (_angle[i]) {\n                ctx.rotate(_angle[i]);\n            }\n            this._render_one(ctx, i, sx[i], sy[i], r, this.visuals.line, this.visuals.fill);\n            if (_angle[i]) {\n                ctx.rotate(-_angle[i]);\n            }\n            results.push(ctx.translate(-sx[i], -sy[i]));\n        }\n        return results;\n    };\n    MarkerView.prototype._mask_data = function (all_indices) {\n        var bbox, hr, ref, ref1, vr, vx0, vx1, vy0, vy1, x0, x1, y0, y1;\n        hr = this.renderer.plot_view.frame.h_range;\n        vx0 = hr.start - this.max_size;\n        vx1 = hr.end + this.max_size;\n        ref = this.renderer.xscale.v_invert([vx0, vx1], true), x0 = ref[0], x1 = ref[1];\n        vr = this.renderer.plot_view.frame.v_range;\n        vy0 = vr.start - this.max_size;\n        vy1 = vr.end + this.max_size;\n        ref1 = this.renderer.yscale.v_invert([vy0, vy1], true), y0 = ref1[0], y1 = ref1[1];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        return this.index.indices(bbox);\n    };\n    MarkerView.prototype._hit_point = function (geometry) {\n        var bbox, candidates, dist, hits, i, j, len, ref, ref1, ref2, s2, sx, sy, vx, vx0, vx1, vy, vy0, vy1, x0, x1, y0, y1;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        sx = this.renderer.plot_view.canvas.vx_to_sx(vx);\n        sy = this.renderer.plot_view.canvas.vy_to_sy(vy);\n        vx0 = vx - this.max_size;\n        vx1 = vx + this.max_size;\n        ref1 = this.renderer.xscale.v_invert([vx0, vx1], true), x0 = ref1[0], x1 = ref1[1];\n        vy0 = vy - this.max_size;\n        vy1 = vy + this.max_size;\n        ref2 = this.renderer.yscale.v_invert([vy0, vy1], true), y0 = ref2[0], y1 = ref2[1];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        candidates = this.index.indices(bbox);\n        hits = [];\n        for (j = 0, len = candidates.length; j < len; j++) {\n            i = candidates[j];\n            s2 = this._size[i] / 2;\n            dist = Math.abs(this.sx[i] - sx) + Math.abs(this.sy[i] - sy);\n            if (Math.abs(this.sx[i] - sx) <= s2 && Math.abs(this.sy[i] - sy) <= s2) {\n                hits.push([i, dist]);\n            }\n        }\n        return hittest.create_1d_hit_test_result(hits);\n    };\n    MarkerView.prototype._hit_span = function (geometry) {\n        var bbox, hits, maxX, maxY, minX, minY, ms, ref, ref1, ref2, ref3, result, vx, vx0, vx1, vy, vy0, vy1, x0, x1, y0, y1;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        ref1 = this.bounds(), minX = ref1.minX, minY = ref1.minY, maxX = ref1.maxX, maxY = ref1.maxY;\n        result = hittest.create_hit_test_result();\n        if (geometry.direction === 'h') {\n            y0 = minY;\n            y1 = maxY;\n            ms = this.max_size / 2;\n            vx0 = vx - ms;\n            vx1 = vx + ms;\n            ref2 = this.renderer.xscale.v_invert([vx0, vx1], true), x0 = ref2[0], x1 = ref2[1];\n        }\n        else {\n            x0 = minX;\n            x1 = maxX;\n            ms = this.max_size / 2;\n            vy0 = vy - ms;\n            vy1 = vy + ms;\n            ref3 = this.renderer.yscale.v_invert([vy0, vy1], true), y0 = ref3[0], y1 = ref3[1];\n        }\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        hits = this.index.indices(bbox);\n        result['1d'].indices = hits;\n        return result;\n    };\n    MarkerView.prototype._hit_rect = function (geometry) {\n        var bbox, ref, ref1, result, x0, x1, y0, y1;\n        ref = this.renderer.xscale.v_invert([geometry.vx0, geometry.vx1], true), x0 = ref[0], x1 = ref[1];\n        ref1 = this.renderer.yscale.v_invert([geometry.vy0, geometry.vy1], true), y0 = ref1[0], y1 = ref1[1];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = this.index.indices(bbox);\n        return result;\n    };\n    MarkerView.prototype._hit_poly = function (geometry) {\n        var candidates, hits, i, idx, j, k, ref, ref1, ref2, result, results, sx, sy, vx, vy;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        sx = this.renderer.plot_view.canvas.v_vx_to_sx(vx);\n        sy = this.renderer.plot_view.canvas.v_vy_to_sy(vy);\n        candidates = (function () {\n            results = [];\n            for (var j = 0, ref1 = this.sx.length; 0 <= ref1 ? j < ref1 : j > ref1; 0 <= ref1 ? j++ : j--) {\n                results.push(j);\n            }\n            return results;\n        }).apply(this);\n        hits = [];\n        for (i = k = 0, ref2 = candidates.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {\n            idx = candidates[i];\n            if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy)) {\n                hits.push(idx);\n            }\n        }\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    return MarkerView;\n})(xy_glyph_1.XYGlyphView);\nexports.Marker = (function (superClass) {\n    extend(Marker, superClass);\n    function Marker() {\n        return Marker.__super__.constructor.apply(this, arguments);\n    }\n    Marker.mixins(['line', 'fill']);\n    Marker.define({\n        size: [\n            p.DistanceSpec, {\n                units: \"screen\",\n                value: 4\n            }\n        ],\n        angle: [p.AngleSpec, 0]\n    });\n    return Marker;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar logging_1 = require(\"core/logging\");\nvar gmap_plot_canvas_1 = require(\"./gmap_plot_canvas\");\nvar plot_1 = require(\"./plot\");\nvar p = require(\"core/properties\");\nvar model_1 = require(\"../../model\");\nexports.MapOptions = (function (superClass) {\n    extend(MapOptions, superClass);\n    function MapOptions() {\n        return MapOptions.__super__.constructor.apply(this, arguments);\n    }\n    MapOptions.prototype.type = 'MapOptions';\n    MapOptions.define({\n        lat: [p.Number],\n        lng: [p.Number],\n        zoom: [p.Number, 12]\n    });\n    return MapOptions;\n})(model_1.Model);\nexports.GMapOptions = (function (superClass) {\n    extend(GMapOptions, superClass);\n    function GMapOptions() {\n        return GMapOptions.__super__.constructor.apply(this, arguments);\n    }\n    GMapOptions.prototype.type = 'GMapOptions';\n    GMapOptions.define({\n        map_type: [p.String, \"roadmap\"],\n        scale_control: [p.Bool, false],\n        styles: [p.String]\n    });\n    return GMapOptions;\n})(exports.MapOptions);\nexports.GMapPlotView = (function (superClass) {\n    extend(GMapPlotView, superClass);\n    function GMapPlotView() {\n        return GMapPlotView.__super__.constructor.apply(this, arguments);\n    }\n    return GMapPlotView;\n})(plot_1.PlotView);\nexports.GMapPlot = (function (superClass) {\n    extend(GMapPlot, superClass);\n    function GMapPlot() {\n        return GMapPlot.__super__.constructor.apply(this, arguments);\n    }\n    GMapPlot.prototype.type = 'GMapPlot';\n    GMapPlot.prototype.default_view = exports.GMapPlotView;\n    GMapPlot.prototype.initialize = function (options) {\n        GMapPlot.__super__.initialize.call(this, options);\n        if (!this.api_key) {\n            return logging_1.logger.error(\"api_key is required. See https://developers.google.com/maps/documentation/javascript/get-api-key for more information on how to obtain your own.\");\n        }\n    };\n    GMapPlot.prototype._init_plot_canvas = function () {\n        return new gmap_plot_canvas_1.GMapPlotCanvas({\n            plot: this\n        });\n    };\n    GMapPlot.define({\n        map_options: [p.Instance],\n        api_key: [p.String]\n    });\n    return GMapPlot;\n})(plot_1.Plot);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar gmaps_ready, load_google_api, bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar proj4_1 = require(\"core/util/proj4\");\nvar plot_canvas_1 = require(\"./plot_canvas\");\nvar signaling_1 = require(\"core/signaling\");\ngmaps_ready = new signaling_1.Signal(this, \"gmaps_ready\");\nload_google_api = function (api_key) {\n    var script;\n    window._bokeh_gmaps_callback = function () {\n        return gmaps_ready.emit();\n    };\n    script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.src = \"https://maps.googleapis.com/maps/api/js?key=\" + api_key + \"&callback=_bokeh_gmaps_callback\";\n    return document.body.appendChild(script);\n};\nexports.GMapPlotCanvasView = (function (superClass) {\n    extend1(GMapPlotCanvasView, superClass);\n    function GMapPlotCanvasView() {\n        this._set_bokeh_ranges = bind(this._set_bokeh_ranges, this);\n        this._get_projected_bounds = bind(this._get_projected_bounds, this);\n        this._get_latlon_bounds = bind(this._get_latlon_bounds, this);\n        return GMapPlotCanvasView.__super__.constructor.apply(this, arguments);\n    }\n    GMapPlotCanvasView.prototype.initialize = function (options) {\n        var mo, ref;\n        this.pause();\n        GMapPlotCanvasView.__super__.initialize.call(this, options);\n        this._tiles_loaded = false;\n        this.zoom_count = 0;\n        mo = this.model.plot.map_options;\n        this.initial_zoom = mo.zoom;\n        this.initial_lat = mo.lat;\n        this.initial_lng = mo.lng;\n        this.canvas_view.map_el.style.position = \"absolute\";\n        if (((ref = window.google) != null ? ref.maps : void 0) == null) {\n            if (window._bokeh_gmaps_callback == null) {\n                load_google_api(this.model.plot.api_key);\n            }\n            gmaps_ready.connect((function (_this) {\n                return function () {\n                    return _this.request_render();\n                };\n            })(this));\n        }\n        return this.unpause();\n    };\n    GMapPlotCanvasView.prototype.update_range = function (range_info) {\n        var mo, new_map_zoom, old_map_zoom, proj_xend, proj_xstart, proj_yend, proj_ystart, ref, zoom_change;\n        if (range_info == null) {\n            mo = this.model.plot.map_options;\n            this.map.setCenter({\n                lat: this.initial_lat,\n                lng: this.initial_lng\n            });\n            this.map.setOptions({\n                zoom: this.initial_zoom\n            });\n            GMapPlotCanvasView.__super__.update_range.call(this, null);\n        }\n        else if ((range_info.sdx != null) || (range_info.sdy != null)) {\n            this.map.panBy(range_info.sdx, range_info.sdy);\n            GMapPlotCanvasView.__super__.update_range.call(this, range_info);\n        }\n        else if (range_info.factor != null) {\n            if (this.zoom_count !== 10) {\n                this.zoom_count += 1;\n                return;\n            }\n            this.zoom_count = 0;\n            this.pause();\n            GMapPlotCanvasView.__super__.update_range.call(this, range_info);\n            if (range_info.factor < 0) {\n                zoom_change = -1;\n            }\n            else {\n                zoom_change = 1;\n            }\n            old_map_zoom = this.map.getZoom();\n            new_map_zoom = old_map_zoom + zoom_change;\n            if (new_map_zoom >= 2) {\n                this.map.setZoom(new_map_zoom);\n                ref = this._get_projected_bounds(), proj_xstart = ref[0], proj_xend = ref[1], proj_ystart = ref[2], proj_yend = ref[3];\n                if ((proj_xend - proj_xstart) < 0) {\n                    this.map.setZoom(old_map_zoom);\n                }\n            }\n            this.unpause();\n        }\n        return this._set_bokeh_ranges();\n    };\n    GMapPlotCanvasView.prototype._build_map = function () {\n        var map_options, maps, mo;\n        maps = window.google.maps;\n        this.map_types = {\n            satellite: maps.MapTypeId.SATELLITE,\n            terrain: maps.MapTypeId.TERRAIN,\n            roadmap: maps.MapTypeId.ROADMAP,\n            hybrid: maps.MapTypeId.HYBRID\n        };\n        mo = this.model.plot.map_options;\n        map_options = {\n            center: new maps.LatLng(mo.lat, mo.lng),\n            zoom: mo.zoom,\n            disableDefaultUI: true,\n            mapTypeId: this.map_types[mo.map_type],\n            scaleControl: mo.scale_control\n        };\n        if (mo.styles != null) {\n            map_options.styles = JSON.parse(mo.styles);\n        }\n        this.map = new maps.Map(this.canvas_view.map_el, map_options);\n        maps.event.addListener(this.map, 'idle', (function (_this) {\n            return function () {\n                return _this._set_bokeh_ranges();\n            };\n        })(this));\n        maps.event.addListener(this.map, 'bounds_changed', (function (_this) {\n            return function () {\n                return _this._set_bokeh_ranges();\n            };\n        })(this));\n        maps.event.addListenerOnce(this.map, 'tilesloaded', (function (_this) {\n            return function () {\n                return _this._render_finished();\n            };\n        })(this));\n        this.connect(this.model.plot.properties.map_options.change, (function (_this) {\n            return function () {\n                return _this._update_options();\n            };\n        })(this));\n        this.connect(this.model.plot.map_options.properties.styles.change, (function (_this) {\n            return function () {\n                return _this._update_styles();\n            };\n        })(this));\n        this.connect(this.model.plot.map_options.properties.lat.change, (function (_this) {\n            return function () {\n                return _this._update_center('lat');\n            };\n        })(this));\n        this.connect(this.model.plot.map_options.properties.lng.change, (function (_this) {\n            return function () {\n                return _this._update_center('lng');\n            };\n        })(this));\n        this.connect(this.model.plot.map_options.properties.zoom.change, (function (_this) {\n            return function () {\n                return _this._update_zoom();\n            };\n        })(this));\n        this.connect(this.model.plot.map_options.properties.map_type.change, (function (_this) {\n            return function () {\n                return _this._update_map_type();\n            };\n        })(this));\n        return this.connect(this.model.plot.map_options.properties.scale_control.change, (function (_this) {\n            return function () {\n                return _this._update_scale_control();\n            };\n        })(this));\n    };\n    GMapPlotCanvasView.prototype._render_finished = function () {\n        this._tiles_loaded = true;\n        return this.notify_finished();\n    };\n    GMapPlotCanvasView.prototype.has_finished = function () {\n        return GMapPlotCanvasView.__super__.has_finished.call(this) && this._tiles_loaded === true;\n    };\n    GMapPlotCanvasView.prototype._get_latlon_bounds = function () {\n        var bottom_left, bounds, top_right, xend, xstart, yend, ystart;\n        bounds = this.map.getBounds();\n        top_right = bounds.getNorthEast();\n        bottom_left = bounds.getSouthWest();\n        xstart = bottom_left.lng();\n        xend = top_right.lng();\n        ystart = bottom_left.lat();\n        yend = top_right.lat();\n        return [xstart, xend, ystart, yend];\n    };\n    GMapPlotCanvasView.prototype._get_projected_bounds = function () {\n        var proj_xend, proj_xstart, proj_yend, proj_ystart, ref, ref1, ref2, xend, xstart, yend, ystart;\n        ref = this._get_latlon_bounds(), xstart = ref[0], xend = ref[1], ystart = ref[2], yend = ref[3];\n        ref1 = proj4_1.proj4(proj4_1.mercator, [xstart, ystart]), proj_xstart = ref1[0], proj_ystart = ref1[1];\n        ref2 = proj4_1.proj4(proj4_1.mercator, [xend, yend]), proj_xend = ref2[0], proj_yend = ref2[1];\n        return [proj_xstart, proj_xend, proj_ystart, proj_yend];\n    };\n    GMapPlotCanvasView.prototype._set_bokeh_ranges = function () {\n        var proj_xend, proj_xstart, proj_yend, proj_ystart, ref;\n        ref = this._get_projected_bounds(), proj_xstart = ref[0], proj_xend = ref[1], proj_ystart = ref[2], proj_yend = ref[3];\n        this.frame.x_range.setv({\n            start: proj_xstart,\n            end: proj_xend\n        });\n        return this.frame.y_range.setv({\n            start: proj_ystart,\n            end: proj_yend\n        });\n    };\n    GMapPlotCanvasView.prototype._update_center = function (fld) {\n        var c;\n        c = this.map.getCenter().toJSON();\n        c[fld] = this.model.plot.map_options[fld];\n        this.map.setCenter(c);\n        return this._set_bokeh_ranges();\n    };\n    GMapPlotCanvasView.prototype._update_map_type = function () {\n        var maps;\n        maps = window.google.maps;\n        return this.map.setOptions({\n            mapTypeId: this.map_types[this.model.plot.map_options.map_type]\n        });\n    };\n    GMapPlotCanvasView.prototype._update_scale_control = function () {\n        var maps;\n        maps = window.google.maps;\n        return this.map.setOptions({\n            scaleControl: this.model.plot.map_options.scale_control\n        });\n    };\n    GMapPlotCanvasView.prototype._update_options = function () {\n        this._update_styles();\n        this._update_center('lat');\n        this._update_center('lng');\n        this._update_zoom();\n        return this._update_map_type();\n    };\n    GMapPlotCanvasView.prototype._update_styles = function () {\n        return this.map.setOptions({\n            styles: JSON.parse(this.model.plot.map_options.styles)\n        });\n    };\n    GMapPlotCanvasView.prototype._update_zoom = function () {\n        this.map.setOptions({\n            zoom: this.model.plot.map_options.zoom\n        });\n        return this._set_bokeh_ranges();\n    };\n    GMapPlotCanvasView.prototype._map_hook = function (ctx, frame_box) {\n        var height, left, ref, top, width;\n        left = frame_box[0], top = frame_box[1], width = frame_box[2], height = frame_box[3];\n        this.canvas_view.map_el.style.top = top + \"px\";\n        this.canvas_view.map_el.style.left = left + \"px\";\n        this.canvas_view.map_el.style.width = width + \"px\";\n        this.canvas_view.map_el.style.height = height + \"px\";\n        if ((this.map == null) && (((ref = window.google) != null ? ref.maps : void 0) != null)) {\n            return this._build_map();\n        }\n    };\n    GMapPlotCanvasView.prototype._paint_empty = function (ctx, frame_box) {\n        var ih, iw, left, oh, ow, top;\n        ow = this.canvas._width.value;\n        oh = this.canvas._height.value;\n        left = frame_box[0], top = frame_box[1], iw = frame_box[2], ih = frame_box[3];\n        ctx.clearRect(0, 0, ow, oh);\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(0, oh);\n        ctx.lineTo(ow, oh);\n        ctx.lineTo(ow, 0);\n        ctx.lineTo(0, 0);\n        ctx.moveTo(left, top);\n        ctx.lineTo(left + iw, top);\n        ctx.lineTo(left + iw, top + ih);\n        ctx.lineTo(left, top + ih);\n        ctx.lineTo(left, top);\n        ctx.closePath();\n        ctx.fillStyle = this.model.plot.border_fill_color;\n        return ctx.fill();\n    };\n    return GMapPlotCanvasView;\n})(plot_canvas_1.PlotCanvasView);\nexports.GMapPlotCanvas = (function (superClass) {\n    extend1(GMapPlotCanvas, superClass);\n    function GMapPlotCanvas() {\n        return GMapPlotCanvas.__super__.constructor.apply(this, arguments);\n    }\n    GMapPlotCanvas.prototype.type = 'GMapPlotCanvas';\n    GMapPlotCanvas.prototype.default_view = exports.GMapPlotCanvasView;\n    GMapPlotCanvas.prototype.initialize = function (attrs, options) {\n        this.use_map = true;\n        return GMapPlotCanvas.__super__.initialize.call(this, attrs, options);\n    };\n    return GMapPlotCanvas;\n})(plot_canvas_1.PlotCanvas);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar gmap_plot_1 = require(\"./gmap_plot\");\nexports.MapOptions = gmap_plot_1.MapOptions;\nvar gmap_plot_2 = require(\"./gmap_plot\");\nexports.GMapOptions = gmap_plot_2.GMapOptions;\nvar gmap_plot_3 = require(\"./gmap_plot\");\nexports.GMapPlot = gmap_plot_3.GMapPlot;\nvar gmap_plot_canvas_1 = require(\"./gmap_plot_canvas\");\nexports.GMapPlotCanvas = gmap_plot_canvas_1.GMapPlotCanvas;\nvar plot_1 = require(\"./plot\");\nexports.Plot = plot_1.Plot;\nvar plot_canvas_1 = require(\"./plot_canvas\");\nexports.PlotCanvas = plot_canvas_1.PlotCanvas;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, slice = [].slice;\nvar solver_1 = require(\"core/layout/solver\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nvar types_1 = require(\"core/util/types\");\nvar layout_dom_1 = require(\"../layouts/layout_dom\");\nvar title_1 = require(\"../annotations/title\");\nvar linear_scale_1 = require(\"../scales/linear_scale\");\nvar toolbar_1 = require(\"../tools/toolbar\");\nvar tool_events_1 = require(\"../tools/tool_events\");\nvar plot_canvas_1 = require(\"./plot_canvas\");\nvar column_data_source_1 = require(\"../sources/column_data_source\");\nvar glyph_renderer_1 = require(\"../renderers/glyph_renderer\");\nvar bokeh_events_1 = require(\"core/bokeh_events\");\nexports.PlotView = (function (superClass) {\n    extend1(PlotView, superClass);\n    function PlotView() {\n        return PlotView.__super__.constructor.apply(this, arguments);\n    }\n    PlotView.prototype.className = \"bk-plot-layout\";\n    PlotView.prototype.connect_signals = function () {\n        var title_msg;\n        PlotView.__super__.connect_signals.call(this);\n        title_msg = \"Title object cannot be replaced. Try changing properties on title to update it after initialization.\";\n        return this.connect(this.model.properties.title.change, (function (_this) {\n            return function () {\n                return logging_1.logger.warn(title_msg);\n            };\n        })(this));\n    };\n    PlotView.prototype.render = function () {\n        var height, ref, width;\n        PlotView.__super__.render.call(this);\n        if (this.model.sizing_mode === 'scale_both') {\n            ref = this.get_width_height(), width = ref[0], height = ref[1];\n            this.solver.suggest_value(this.model._width, width);\n            this.solver.suggest_value(this.model._height, height);\n            this.solver.update_variables();\n            this.el.style.position = 'absolute';\n            this.el.style.left = this.model._dom_left.value + \"px\";\n            this.el.style.top = this.model._dom_top.value + \"px\";\n            this.el.style.width = this.model._width.value + \"px\";\n            return this.el.style.height = this.model._height.value + \"px\";\n        }\n    };\n    PlotView.prototype.get_width_height = function () {\n        var ar, height, new_height_1, new_height_2, new_width_1, new_width_2, parent_height, parent_width, width;\n        parent_height = this.el.parentNode.clientHeight;\n        parent_width = this.el.parentNode.clientWidth;\n        ar = this.model.get_aspect_ratio();\n        new_width_1 = parent_width;\n        new_height_1 = parent_width / ar;\n        new_width_2 = parent_height * ar;\n        new_height_2 = parent_height;\n        if (new_width_1 < new_width_2) {\n            width = new_width_1;\n            height = new_height_1;\n        }\n        else {\n            width = new_width_2;\n            height = new_height_2;\n        }\n        return [width, height];\n    };\n    PlotView.prototype.get_height = function () {\n        return this.model._width.value / this.model.get_aspect_ratio();\n    };\n    PlotView.prototype.get_width = function () {\n        return this.model._height.value * this.model.get_aspect_ratio();\n    };\n    PlotView.prototype.save = function (name) {\n        return this.plot_canvas_view.save(name);\n    };\n    PlotView.getters({\n        plot_canvas_view: function () {\n            var view;\n            return ((function () {\n                var i, len, ref, results;\n                ref = object_1.values(this.child_views);\n                results = [];\n                for (i = 0, len = ref.length; i < len; i++) {\n                    view = ref[i];\n                    if (view instanceof plot_canvas_1.PlotCanvasView) {\n                        results.push(view);\n                    }\n                }\n                return results;\n            }).call(this))[0];\n        }\n    });\n    return PlotView;\n})(layout_dom_1.LayoutDOMView);\nexports.Plot = (function (superClass) {\n    extend1(Plot, superClass);\n    function Plot() {\n        return Plot.__super__.constructor.apply(this, arguments);\n    }\n    Plot.prototype.type = 'Plot';\n    Plot.prototype.default_view = exports.PlotView;\n    Plot.prototype.initialize = function (options) {\n        var _set_sizeable, i, j, k, l, layout_renderers, len, len1, len2, len3, plots, ref, ref1, ref2, ref3, renderer, side, title, xr, yr;\n        Plot.__super__.initialize.call(this, options);\n        ref = object_1.values(this.extra_x_ranges).concat(this.x_range);\n        for (i = 0, len = ref.length; i < len; i++) {\n            xr = ref[i];\n            plots = xr.plots;\n            if (types_1.isArray(plots)) {\n                plots = plots.concat(this);\n                xr.setv('plots', plots, {\n                    silent: true\n                });\n            }\n        }\n        ref1 = object_1.values(this.extra_y_ranges).concat(this.y_range);\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n            yr = ref1[j];\n            plots = yr.plots;\n            if (types_1.isArray(plots)) {\n                plots = plots.concat(this);\n                yr.setv('plots', plots, {\n                    silent: true\n                });\n            }\n        }\n        this._horizontal = (ref2 = this.toolbar_location) === 'left' || ref2 === 'right';\n        if (this.min_border != null) {\n            if (this.min_border_top == null) {\n                this.min_border_top = this.min_border;\n            }\n            if (this.min_border_bottom == null) {\n                this.min_border_bottom = this.min_border;\n            }\n            if (this.min_border_left == null) {\n                this.min_border_left = this.min_border;\n            }\n            if (this.min_border_right == null) {\n                this.min_border_right = this.min_border;\n            }\n        }\n        if (this.title != null) {\n            title = types_1.isString(this.title) ? new title_1.Title({\n                text: this.title\n            }) : this.title;\n            this.add_layout(title, this.title_location);\n        }\n        this._plot_canvas = this._init_plot_canvas();\n        this.toolbar.toolbar_location = this.toolbar_location;\n        this.toolbar.toolbar_sticky = this.toolbar_sticky;\n        this.plot_canvas.toolbar = this.toolbar;\n        if (this.width == null) {\n            this.width = this.plot_width;\n        }\n        if (this.height == null) {\n            this.height = this.plot_height;\n        }\n        ref3 = ['above', 'below', 'left', 'right'];\n        for (k = 0, len2 = ref3.length; k < len2; k++) {\n            side = ref3[k];\n            layout_renderers = this.getv(side);\n            for (l = 0, len3 = layout_renderers.length; l < len3; l++) {\n                renderer = layout_renderers[l];\n                renderer.add_panel(side);\n            }\n        }\n        _set_sizeable = (function (_this) {\n            return function (model) {\n                return model._sizeable = !_this._horizontal ? model._height : model._width;\n            };\n        })(this);\n        _set_sizeable(this);\n        return _set_sizeable(this.plot_canvas);\n    };\n    Plot.prototype._init_plot_canvas = function () {\n        return new plot_canvas_1.PlotCanvas({\n            plot: this\n        });\n    };\n    Plot.getters({\n        plot_canvas: function () {\n            return this._plot_canvas;\n        }\n    });\n    Plot.prototype._doc_attached = function () {\n        this.plot_canvas.attach_document(this.document);\n        return Plot.__super__._doc_attached.call(this);\n    };\n    Plot.prototype.add_renderers = function () {\n        var new_renderers, renderers;\n        new_renderers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        renderers = this.renderers;\n        renderers = renderers.concat(new_renderers);\n        return this.renderers = renderers;\n    };\n    Plot.prototype.add_layout = function (renderer, side) {\n        var side_renderers;\n        if (side == null) {\n            side = \"center\";\n        }\n        if (renderer.props.plot != null) {\n            renderer.plot = this;\n        }\n        if (side !== 'center') {\n            side_renderers = this.getv(side);\n            side_renderers.push(renderer);\n            renderer.add_panel(side);\n        }\n        return this.add_renderers(renderer);\n    };\n    Plot.prototype.add_glyph = function (glyph, source, attrs) {\n        var renderer;\n        if (attrs == null) {\n            attrs = {};\n        }\n        if (source == null) {\n            source = new column_data_source_1.ColumnDataSource();\n        }\n        attrs = object_1.extend({}, attrs, {\n            data_source: source,\n            glyph: glyph\n        });\n        renderer = new glyph_renderer_1.GlyphRenderer(attrs);\n        this.add_renderers(renderer);\n        return renderer;\n    };\n    Plot.prototype.add_tools = function () {\n        var attrs, new_tools, tool, tools;\n        tools = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        new_tools = (function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = tools.length; i < len; i++) {\n                tool = tools[i];\n                if (tool.overlay != null) {\n                    this.add_renderers(tool.overlay);\n                }\n                if (tool.plot != null) {\n                    results.push(tool);\n                }\n                else {\n                    attrs = object_1.clone(tool.attributes);\n                    attrs.plot = this;\n                    results.push(new tool.constructor(attrs));\n                }\n            }\n            return results;\n        }).call(this);\n        return this.toolbar.tools = this.toolbar.tools.concat(new_tools);\n    };\n    Plot.prototype.get_aspect_ratio = function () {\n        return this.width / this.height;\n    };\n    Plot.prototype.get_layoutable_children = function () {\n        var children;\n        children = [this.plot_canvas];\n        if (this.toolbar_location != null) {\n            children = [this.toolbar, this.plot_canvas];\n        }\n        return children;\n    };\n    Plot.prototype.get_edit_variables = function () {\n        var child, edit_variables, i, len, ref;\n        edit_variables = Plot.__super__.get_edit_variables.call(this);\n        if (this.sizing_mode === 'scale_both') {\n            edit_variables.push({\n                edit_variable: this._width,\n                strength: solver_1.Strength.strong\n            });\n            edit_variables.push({\n                edit_variable: this._height,\n                strength: solver_1.Strength.strong\n            });\n        }\n        ref = this.get_layoutable_children();\n        for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            edit_variables = edit_variables.concat(child.get_edit_variables());\n        }\n        return edit_variables;\n    };\n    Plot.prototype.get_constraints = function () {\n        var child, constraints, i, len, ref, ref1, ref2, sticky_edge;\n        constraints = Plot.__super__.get_constraints.call(this);\n        if (this.toolbar_location != null) {\n            if (this.toolbar_sticky === true) {\n                constraints.push(solver_1.EQ(this._sizeable, [-1, this.plot_canvas._sizeable]));\n            }\n            else {\n                constraints.push(solver_1.EQ(this._sizeable, [-1, this.plot_canvas._sizeable], [-1, this.toolbar._sizeable]));\n            }\n            if (!this._horizontal) {\n                constraints.push(solver_1.EQ(this._width, [-1, this.plot_canvas._width]));\n            }\n            else {\n                constraints.push(solver_1.EQ(this._height, [-1, this.plot_canvas._height]));\n            }\n            if (this.toolbar_location === 'above') {\n                sticky_edge = this.toolbar_sticky === true ? this.plot_canvas._top : this.plot_canvas._dom_top;\n                constraints.push(solver_1.EQ(sticky_edge, [-1, this.toolbar._dom_top], [-1, this.toolbar._height]));\n            }\n            if (this.toolbar_location === 'below') {\n                if (this.toolbar_sticky === false) {\n                    constraints.push(solver_1.EQ(this.toolbar._dom_top, [-1, this.plot_canvas._height], this.toolbar._bottom, [-1, this.toolbar._height]));\n                }\n                if (this.toolbar_sticky === true) {\n                    constraints.push(solver_1.GE(this.plot_canvas.below_panel._height, [-1, this.toolbar._height]));\n                    constraints.push(solver_1.WEAK_EQ(this.toolbar._dom_top, [-1, this.plot_canvas._height], this.plot_canvas.below_panel._height));\n                }\n            }\n            if (this.toolbar_location === 'left') {\n                sticky_edge = this.toolbar_sticky === true ? this.plot_canvas._left : this.plot_canvas._dom_left;\n                constraints.push(solver_1.EQ(sticky_edge, [-1, this.toolbar._dom_left], [-1, this.toolbar._width]));\n            }\n            if (this.toolbar_location === 'right') {\n                if (this.toolbar_sticky === false) {\n                    constraints.push(solver_1.EQ(this.toolbar._dom_left, [-1, this.plot_canvas._width], this.toolbar._right, [-1, this.toolbar._width]));\n                }\n                if (this.toolbar_sticky === true) {\n                    constraints.push(solver_1.GE(this.plot_canvas.right_panel._width, [-1, this.toolbar._width]));\n                    constraints.push(solver_1.WEAK_EQ(this.toolbar._dom_left, [-1, this.plot_canvas._width], this.plot_canvas.right_panel._width));\n                }\n            }\n            if ((ref = this.toolbar_location) === 'above' || ref === 'below') {\n                constraints.push(solver_1.EQ(this._width, [-1, this.toolbar._width], [-1, this.plot_canvas._width_minus_right]));\n            }\n            if ((ref1 = this.toolbar_location) === 'left' || ref1 === 'right') {\n                constraints.push(solver_1.EQ(this._height, [-1, this.toolbar._height], [-1, this.plot_canvas.above_panel._height]));\n                constraints.push(solver_1.EQ(this.toolbar._dom_top, [-1, this.plot_canvas.above_panel._height]));\n            }\n        }\n        if (this.toolbar_location == null) {\n            constraints.push(solver_1.EQ(this._width, [-1, this.plot_canvas._width]));\n            constraints.push(solver_1.EQ(this._height, [-1, this.plot_canvas._height]));\n        }\n        ref2 = this.get_layoutable_children();\n        for (i = 0, len = ref2.length; i < len; i++) {\n            child = ref2[i];\n            constraints = constraints.concat(child.get_constraints());\n        }\n        return constraints;\n    };\n    Plot.prototype.get_constrained_variables = function () {\n        var vars;\n        vars = object_1.extend({}, Plot.__super__.get_constrained_variables.call(this), {\n            on_edge_align_top: this.plot_canvas._top,\n            on_edge_align_bottom: this.plot_canvas._height_minus_bottom,\n            on_edge_align_left: this.plot_canvas._left,\n            on_edge_align_right: this.plot_canvas._width_minus_right,\n            box_cell_align_top: this.plot_canvas._top,\n            box_cell_align_bottom: this.plot_canvas._height_minus_bottom,\n            box_cell_align_left: this.plot_canvas._left,\n            box_cell_align_right: this.plot_canvas._width_minus_right,\n            box_equal_size_top: this.plot_canvas._top,\n            box_equal_size_bottom: this.plot_canvas._height_minus_bottom\n        });\n        if (this.sizing_mode !== 'fixed') {\n            vars.box_equal_size_left = this.plot_canvas._left;\n            vars.box_equal_size_right = this.plot_canvas._width_minus_right;\n        }\n        return vars;\n    };\n    Plot.mixins(['line:outline_', 'fill:background_', 'fill:border_']);\n    Plot.define({\n        toolbar: [\n            p.Instance, function () {\n                return new toolbar_1.Toolbar();\n            }\n        ],\n        toolbar_location: [p.Location, 'right'],\n        toolbar_sticky: [p.Bool, true],\n        plot_width: [p.Number, 600],\n        plot_height: [p.Number, 600],\n        title: [\n            p.Any, function () {\n                return new title_1.Title({\n                    text: \"\"\n                });\n            }\n        ],\n        title_location: [p.Location, 'above'],\n        h_symmetry: [p.Bool, true],\n        v_symmetry: [p.Bool, false],\n        above: [p.Array, []],\n        below: [p.Array, []],\n        left: [p.Array, []],\n        right: [p.Array, []],\n        renderers: [p.Array, []],\n        x_range: [p.Instance],\n        extra_x_ranges: [p.Any, {}],\n        y_range: [p.Instance],\n        extra_y_ranges: [p.Any, {}],\n        x_scale: [\n            p.Instance, function () {\n                return new linear_scale_1.LinearScale();\n            }\n        ],\n        y_scale: [\n            p.Instance, function () {\n                return new linear_scale_1.LinearScale();\n            }\n        ],\n        tool_events: [\n            p.Instance, function () {\n                return new tool_events_1.ToolEvents();\n            }\n        ],\n        lod_factor: [p.Number, 10],\n        lod_interval: [p.Number, 300],\n        lod_threshold: [p.Number, 2000],\n        lod_timeout: [p.Number, 500],\n        hidpi: [p.Bool, true],\n        output_backend: [p.OutputBackend, \"canvas\"],\n        min_border: [p.Number, 5],\n        min_border_top: [p.Number, null],\n        min_border_left: [p.Number, null],\n        min_border_bottom: [p.Number, null],\n        min_border_right: [p.Number, null],\n        inner_width: [p.Number],\n        inner_height: [p.Number],\n        layout_width: [p.Number],\n        layout_height: [p.Number]\n    });\n    Plot.override({\n        outline_line_color: '#e5e5e5',\n        border_fill_color: \"#ffffff\",\n        background_fill_color: \"#ffffff\"\n    });\n    Plot.getters({\n        all_renderers: function () {\n            var i, len, ref, renderers, tool;\n            renderers = this.renderers;\n            ref = this.toolbar.tools;\n            for (i = 0, len = ref.length; i < len; i++) {\n                tool = ref[i];\n                renderers = renderers.concat(tool.synthetic_renderers);\n            }\n            return renderers;\n        },\n        x_mapper_type: function () {\n            log.warning(\"x_mapper_type attr is deprecated, use x_scale\");\n            return this.x_scale;\n        },\n        y_mapper_type: function () {\n            log.warning(\"y_mapper_type attr is deprecated, use y_scale\");\n            return this.y_scale;\n        },\n        webgl: function () {\n            log.warning(\"webgl attr is deprecated, use output_backend\");\n            return this.output_backend === \"webgl\";\n        }\n    });\n    return Plot;\n})(layout_dom_1.LayoutDOM);\nbokeh_events_1.register_with_event(bokeh_events_1.UIEvent, exports.Plot);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar global_glcanvas, extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar canvas_1 = require(\"../canvas/canvas\");\nvar cartesian_frame_1 = require(\"../canvas/cartesian_frame\");\nvar data_range1d_1 = require(\"../ranges/data_range1d\");\nvar glyph_renderer_1 = require(\"../renderers/glyph_renderer\");\nvar layout_dom_1 = require(\"../layouts/layout_dom\");\nvar signaling_1 = require(\"core/signaling\");\nvar build_views_1 = require(\"core/build_views\");\nvar ui_events_1 = require(\"core/ui_events\");\nvar bokeh_events_1 = require(\"core/bokeh_events\");\nvar layout_canvas_1 = require(\"core/layout/layout_canvas\");\nvar visuals_1 = require(\"core/visuals\");\nvar dom_view_1 = require(\"core/dom_view\");\nvar solver_1 = require(\"core/layout/solver\");\nvar logging_1 = require(\"core/logging\");\nvar enums = require(\"core/enums\");\nvar p = require(\"core/properties\");\nvar throttle_1 = require(\"core/util/throttle\");\nvar types_1 = require(\"core/util/types\");\nvar array_1 = require(\"core/util/array\");\nvar object_1 = require(\"core/util/object\");\nvar side_panel_1 = require(\"core/layout/side_panel\");\nglobal_glcanvas = null;\nexports.PlotCanvasView = (function (superClass) {\n    extend1(PlotCanvasView, superClass);\n    function PlotCanvasView() {\n        return PlotCanvasView.__super__.constructor.apply(this, arguments);\n    }\n    PlotCanvasView.prototype.className = \"bk-plot-wrapper\";\n    PlotCanvasView.prototype.state = {\n        history: [],\n        index: -1\n    };\n    PlotCanvasView.prototype.view_options = function () {\n        return object_1.extend({\n            plot_view: this,\n            parent: this\n        }, this.options);\n    };\n    PlotCanvasView.prototype.pause = function () {\n        if (this._is_paused == null) {\n            return this._is_paused = 1;\n        }\n        else {\n            return this._is_paused += 1;\n        }\n    };\n    PlotCanvasView.prototype.unpause = function (no_render) {\n        if (no_render == null) {\n            no_render = false;\n        }\n        this._is_paused -= 1;\n        if (this._is_paused === 0 && !no_render) {\n            return this.request_render();\n        }\n    };\n    PlotCanvasView.prototype.request_render = function () {\n        return this.request_paint();\n    };\n    PlotCanvasView.prototype.request_paint = function () {\n        if (!this.is_paused) {\n            this.throttled_paint();\n        }\n    };\n    PlotCanvasView.prototype.remove = function () {\n        build_views_1.remove_views(this.renderer_views);\n        build_views_1.remove_views(this.tool_views);\n        this.canvas_view.remove();\n        this.canvas_view = null;\n        return PlotCanvasView.__super__.remove.call(this);\n    };\n    PlotCanvasView.prototype.initialize = function (options) {\n        var j, len, level, ref;\n        this.pause();\n        PlotCanvasView.__super__.initialize.call(this, options);\n        this.force_paint = new signaling_1.Signal(this, \"force_paint\");\n        this.state_changed = new signaling_1.Signal(this, \"state_changed\");\n        this.lod_started = false;\n        this.visuals = new visuals_1.Visuals(this.model.plot);\n        this._initial_state_info = {\n            range: null,\n            selection: {},\n            dimensions: {\n                width: this.model.canvas._width.value,\n                height: this.model.canvas._height.value\n            }\n        };\n        this.frame = this.model.frame;\n        this.canvas = this.model.canvas;\n        this.canvas_view = new this.canvas.default_view({\n            model: this.canvas,\n            parent: this\n        });\n        this.el.appendChild(this.canvas_view.el);\n        this.canvas_view.render();\n        if (this.model.plot.output_backend === \"webgl\") {\n            this.init_webgl();\n        }\n        this.throttled_paint = throttle_1.throttle(((function (_this) {\n            return function () {\n                return _this.force_paint.emit();\n            };\n        })(this)), 15);\n        this.ui_event_bus = new ui_events_1.UIEvents(this, this.model.toolbar, this.canvas_view.el, this.model.plot);\n        this.levels = {};\n        ref = enums.RenderLevel;\n        for (j = 0, len = ref.length; j < len; j++) {\n            level = ref[j];\n            this.levels[level] = {};\n        }\n        this.renderer_views = {};\n        this.tool_views = {};\n        this.build_levels();\n        this.build_tools();\n        this.connect_signals();\n        this.update_dataranges();\n        this.unpause(true);\n        logging_1.logger.debug(\"PlotView initialized\");\n        return this;\n    };\n    PlotCanvasView.prototype.set_cursor = function (cursor) {\n        if (cursor == null) {\n            cursor = \"default\";\n        }\n        return this.canvas_view.el.style.cursor = cursor;\n    };\n    PlotCanvasView.getters({\n        canvas_overlays: function () {\n            return this.canvas_view.overlays_el;\n        },\n        is_paused: function () {\n            return (this._is_paused != null) && this._is_paused !== 0;\n        }\n    });\n    PlotCanvasView.prototype.init_webgl = function () {\n        var ctx, glcanvas, opts;\n        ctx = this.canvas_view.ctx;\n        glcanvas = global_glcanvas;\n        if (glcanvas == null) {\n            global_glcanvas = glcanvas = document.createElement('canvas');\n            opts = {\n                'premultipliedAlpha': true\n            };\n            glcanvas.gl = glcanvas.getContext(\"webgl\", opts) || glcanvas.getContext(\"experimental-webgl\", opts);\n        }\n        if (glcanvas.gl != null) {\n            return ctx.glcanvas = glcanvas;\n        }\n        else {\n            return logging_1.logger.warn('WebGL is not supported, falling back to 2D canvas.');\n        }\n    };\n    PlotCanvasView.prototype.prepare_webgl = function (ratio, frame_box) {\n        var canvas, ctx, flipped_top, gl;\n        ctx = this.canvas_view.ctx;\n        canvas = this.canvas_view.get_canvas_element();\n        if (ctx.glcanvas) {\n            ctx.glcanvas.width = canvas.width;\n            ctx.glcanvas.height = canvas.height;\n            gl = ctx.glcanvas.gl;\n            gl.viewport(0, 0, ctx.glcanvas.width, ctx.glcanvas.height);\n            gl.clearColor(0, 0, 0, 0);\n            gl.clear(gl.COLOR_BUFFER_BIT || gl.DEPTH_BUFFER_BIT);\n            gl.enable(gl.SCISSOR_TEST);\n            flipped_top = ctx.glcanvas.height - ratio * (frame_box[1] + frame_box[3]);\n            gl.scissor(ratio * frame_box[0], flipped_top, ratio * frame_box[2], ratio * frame_box[3]);\n            gl.enable(gl.BLEND);\n            return gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.ONE);\n        }\n    };\n    PlotCanvasView.prototype.blit_webgl = function (ratio) {\n        var ctx;\n        ctx = this.canvas_view.ctx;\n        if (ctx.glcanvas) {\n            logging_1.logger.debug('drawing with WebGL');\n            ctx.restore();\n            ctx.drawImage(ctx.glcanvas, 0, 0);\n            ctx.save();\n            ctx.scale(ratio, ratio);\n            return ctx.translate(0.5, 0.5);\n        }\n    };\n    PlotCanvasView.prototype.update_dataranges = function () {\n        var bds, bounds, bounds_to_use, calculate_log_bounds, follow_enabled, frame, has_bounds, j, k, l, len, len1, len2, len3, len4, log_bds, log_bounds, m, n, o, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, v, xr, yr;\n        frame = this.model.frame;\n        bounds = {};\n        log_bounds = {};\n        calculate_log_bounds = false;\n        ref = object_1.values(frame.x_ranges).concat(object_1.values(frame.y_ranges));\n        for (j = 0, len = ref.length; j < len; j++) {\n            r = ref[j];\n            if (r instanceof data_range1d_1.DataRange1d) {\n                if (r.scale_hint === \"log\") {\n                    calculate_log_bounds = true;\n                }\n            }\n        }\n        ref1 = this.renderer_views;\n        for (k in ref1) {\n            v = ref1[k];\n            bds = (ref2 = v.glyph) != null ? typeof ref2.bounds === \"function\" ? ref2.bounds() : void 0 : void 0;\n            if (bds != null) {\n                bounds[k] = bds;\n            }\n            if (calculate_log_bounds) {\n                log_bds = (ref3 = v.glyph) != null ? typeof ref3.log_bounds === \"function\" ? ref3.log_bounds() : void 0 : void 0;\n                if (log_bds != null) {\n                    log_bounds[k] = log_bds;\n                }\n            }\n        }\n        follow_enabled = false;\n        has_bounds = false;\n        ref4 = object_1.values(frame.x_ranges);\n        for (l = 0, len1 = ref4.length; l < len1; l++) {\n            xr = ref4[l];\n            if (xr instanceof data_range1d_1.DataRange1d) {\n                bounds_to_use = xr.scale_hint === \"log\" ? log_bounds : bounds;\n                xr.update(bounds_to_use, 0, this.model.id);\n                if (xr.follow) {\n                    follow_enabled = true;\n                }\n            }\n            if (xr.bounds != null) {\n                has_bounds = true;\n            }\n        }\n        ref5 = object_1.values(frame.y_ranges);\n        for (m = 0, len2 = ref5.length; m < len2; m++) {\n            yr = ref5[m];\n            if (yr instanceof data_range1d_1.DataRange1d) {\n                bounds_to_use = yr.scale_hint === \"log\" ? log_bounds : bounds;\n                yr.update(bounds_to_use, 1, this.model.id);\n                if (yr.follow) {\n                    follow_enabled = true;\n                }\n            }\n            if (yr.bounds != null) {\n                has_bounds = true;\n            }\n        }\n        if (follow_enabled && has_bounds) {\n            logging_1.logger.warn('Follow enabled so bounds are unset.');\n            ref6 = object_1.values(frame.x_ranges);\n            for (n = 0, len3 = ref6.length; n < len3; n++) {\n                xr = ref6[n];\n                xr.bounds = null;\n            }\n            ref7 = object_1.values(frame.y_ranges);\n            for (o = 0, len4 = ref7.length; o < len4; o++) {\n                yr = ref7[o];\n                yr.bounds = null;\n            }\n        }\n        return this.range_update_timestamp = Date.now();\n    };\n    PlotCanvasView.prototype.map_to_screen = function (x, y, x_name, y_name) {\n        if (x_name == null) {\n            x_name = 'default';\n        }\n        if (y_name == null) {\n            y_name = 'default';\n        }\n        return this.frame.map_to_screen(x, y, this.canvas, x_name, y_name);\n    };\n    PlotCanvasView.prototype.push_state = function (type, info) {\n        var prev_info, ref;\n        prev_info = ((ref = this.state.history[this.state.index]) != null ? ref.info : void 0) || {};\n        info = object_1.extend({}, this._initial_state_info, prev_info, info);\n        this.state.history.slice(0, this.state.index + 1);\n        this.state.history.push({\n            type: type,\n            info: info\n        });\n        this.state.index = this.state.history.length - 1;\n        return this.state_changed.emit();\n    };\n    PlotCanvasView.prototype.clear_state = function () {\n        this.state = {\n            history: [],\n            index: -1\n        };\n        return this.state_changed.emit();\n    };\n    PlotCanvasView.prototype.can_undo = function () {\n        return this.state.index >= 0;\n    };\n    PlotCanvasView.prototype.can_redo = function () {\n        return this.state.index < this.state.history.length - 1;\n    };\n    PlotCanvasView.prototype.undo = function () {\n        if (this.can_undo()) {\n            this.state.index -= 1;\n            this._do_state_change(this.state.index);\n            return this.state_changed.emit();\n        }\n    };\n    PlotCanvasView.prototype.redo = function () {\n        if (this.can_redo()) {\n            this.state.index += 1;\n            this._do_state_change(this.state.index);\n            return this.state_changed.emit();\n        }\n    };\n    PlotCanvasView.prototype._do_state_change = function (index) {\n        var info, ref;\n        info = ((ref = this.state.history[index]) != null ? ref.info : void 0) || this._initial_state_info;\n        if (info.range != null) {\n            this.update_range(info.range);\n        }\n        if (info.selection != null) {\n            this.update_selection(info.selection);\n        }\n        if (info.dimensions != null) {\n            return this.canvas_view.set_dims([info.dimensions.width, info.dimensions.height]);\n        }\n    };\n    PlotCanvasView.prototype.reset_dimensions = function () {\n        return this.update_dimensions(this.canvas.initial_width, this.canvas.initial_height);\n    };\n    PlotCanvasView.prototype.update_dimensions = function (width, height) {\n        this.pause();\n        this.model.plot.width = width;\n        this.model.plot.height = height;\n        this.parent.layout();\n        return this.unpause();\n    };\n    PlotCanvasView.prototype.get_selection = function () {\n        var j, len, ref, renderer, selected, selection;\n        selection = [];\n        ref = this.model.plot.renderers;\n        for (j = 0, len = ref.length; j < len; j++) {\n            renderer = ref[j];\n            if (renderer instanceof glyph_renderer_1.GlyphRenderer) {\n                selected = renderer.data_source.selected;\n                selection[renderer.id] = selected;\n            }\n        }\n        return selection;\n    };\n    PlotCanvasView.prototype.update_selection = function (selection) {\n        var ds, j, len, ref, ref1, renderer, results;\n        ref = this.model.plot.renderers;\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n            renderer = ref[j];\n            if (!(renderer instanceof glyph_renderer_1.GlyphRenderer)) {\n                continue;\n            }\n            ds = renderer.data_source;\n            if (selection != null) {\n                if (ref1 = renderer.id, indexOf.call(selection, ref1) >= 0) {\n                    results.push(ds.selected = selection[renderer.id]);\n                }\n                else {\n                    results.push(void 0);\n                }\n            }\n            else {\n                results.push(ds.selection_manager.clear());\n            }\n        }\n        return results;\n    };\n    PlotCanvasView.prototype.reset_selection = function () {\n        return this.update_selection(null);\n    };\n    PlotCanvasView.prototype._update_ranges_together = function (range_info_iter) {\n        var j, l, len, len1, range_info, ref, ref1, results, rng, weight;\n        weight = 1.0;\n        for (j = 0, len = range_info_iter.length; j < len; j++) {\n            ref = range_info_iter[j], rng = ref[0], range_info = ref[1];\n            weight = Math.min(weight, this._get_weight_to_constrain_interval(rng, range_info));\n        }\n        if (weight < 1) {\n            results = [];\n            for (l = 0, len1 = range_info_iter.length; l < len1; l++) {\n                ref1 = range_info_iter[l], rng = ref1[0], range_info = ref1[1];\n                range_info['start'] = weight * range_info['start'] + (1 - weight) * rng.start;\n                results.push(range_info['end'] = weight * range_info['end'] + (1 - weight) * rng.end);\n            }\n            return results;\n        }\n    };\n    PlotCanvasView.prototype._update_ranges_individually = function (range_info_iter, is_panning, is_scrolling) {\n        var hit_bound, j, l, len, len1, max, min, new_interval, range_info, ref, ref1, results, reversed, rng, weight;\n        hit_bound = false;\n        for (j = 0, len = range_info_iter.length; j < len; j++) {\n            ref = range_info_iter[j], rng = ref[0], range_info = ref[1];\n            reversed = rng.start > rng.end;\n            if (!is_scrolling) {\n                weight = this._get_weight_to_constrain_interval(rng, range_info);\n                if (weight < 1) {\n                    range_info['start'] = weight * range_info['start'] + (1 - weight) * rng.start;\n                    range_info['end'] = weight * range_info['end'] + (1 - weight) * rng.end;\n                }\n            }\n            if (rng.bounds != null) {\n                min = rng.bounds[0];\n                max = rng.bounds[1];\n                new_interval = Math.abs(range_info['end'] - range_info['start']);\n                if (reversed) {\n                    if (min != null) {\n                        if (min >= range_info['end']) {\n                            hit_bound = true;\n                            range_info['end'] = min;\n                            if ((is_panning != null) || (is_scrolling != null)) {\n                                range_info['start'] = min + new_interval;\n                            }\n                        }\n                    }\n                    if (max != null) {\n                        if (max <= range_info['start']) {\n                            hit_bound = true;\n                            range_info['start'] = max;\n                            if ((is_panning != null) || (is_scrolling != null)) {\n                                range_info['end'] = max - new_interval;\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (min != null) {\n                        if (min >= range_info['start']) {\n                            hit_bound = true;\n                            range_info['start'] = min;\n                            if ((is_panning != null) || (is_scrolling != null)) {\n                                range_info['end'] = min + new_interval;\n                            }\n                        }\n                    }\n                    if (max != null) {\n                        if (max <= range_info['end']) {\n                            hit_bound = true;\n                            range_info['end'] = max;\n                            if ((is_panning != null) || (is_scrolling != null)) {\n                                range_info['start'] = max - new_interval;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (is_scrolling && hit_bound) {\n            return;\n        }\n        results = [];\n        for (l = 0, len1 = range_info_iter.length; l < len1; l++) {\n            ref1 = range_info_iter[l], rng = ref1[0], range_info = ref1[1];\n            rng.have_updated_interactively = true;\n            if (rng.start !== range_info['start'] || rng.end !== range_info['end']) {\n                results.push(rng.setv(range_info));\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    PlotCanvasView.prototype._get_weight_to_constrain_interval = function (rng, range_info) {\n        var max, max_interval, max_interval2, min, min_interval, new_interval, old_interval, ref, weight;\n        min_interval = rng.min_interval;\n        max_interval = rng.max_interval;\n        weight = 1.0;\n        if (rng.bounds != null) {\n            ref = rng.bounds, min = ref[0], max = ref[1];\n            if ((min != null) && (max != null)) {\n                max_interval2 = Math.abs(max - min);\n                max_interval = max_interval != null ? Math.min(max_interval, max_interval2) : max_interval2;\n            }\n        }\n        if ((min_interval != null) || (max_interval != null)) {\n            old_interval = Math.abs(rng.end - rng.start);\n            new_interval = Math.abs(range_info['end'] - range_info['start']);\n            if (min_interval > 0 && new_interval < min_interval) {\n                weight = (old_interval - min_interval) / (old_interval - new_interval);\n            }\n            if (max_interval > 0 && new_interval > max_interval) {\n                weight = (max_interval - old_interval) / (new_interval - old_interval);\n            }\n            weight = Math.max(0.0, Math.min(1.0, weight));\n        }\n        return weight;\n    };\n    PlotCanvasView.prototype.update_range = function (range_info, is_panning, is_scrolling) {\n        var name, range_info_iter, ref, ref1, ref2, ref3, rng;\n        this.pause();\n        if (range_info == null) {\n            ref = this.frame.x_ranges;\n            for (name in ref) {\n                rng = ref[name];\n                rng.reset();\n            }\n            ref1 = this.frame.y_ranges;\n            for (name in ref1) {\n                rng = ref1[name];\n                rng.reset();\n            }\n            this.update_dataranges();\n        }\n        else {\n            range_info_iter = [];\n            ref2 = this.frame.x_ranges;\n            for (name in ref2) {\n                rng = ref2[name];\n                range_info_iter.push([rng, range_info.xrs[name]]);\n            }\n            ref3 = this.frame.y_ranges;\n            for (name in ref3) {\n                rng = ref3[name];\n                range_info_iter.push([rng, range_info.yrs[name]]);\n            }\n            if (is_scrolling) {\n                this._update_ranges_together(range_info_iter);\n            }\n            this._update_ranges_individually(range_info_iter, is_panning, is_scrolling);\n        }\n        return this.unpause();\n    };\n    PlotCanvasView.prototype.reset_range = function () {\n        return this.update_range(null);\n    };\n    PlotCanvasView.prototype.build_levels = function () {\n        var id_, j, l, len, len1, model, new_renderer_views, old_renderers, renderer_models, renderers_to_remove, view;\n        renderer_models = this.model.plot.all_renderers;\n        old_renderers = Object.keys(this.renderer_views);\n        new_renderer_views = build_views_1.build_views(this.renderer_views, renderer_models, this.view_options());\n        renderers_to_remove = array_1.difference(old_renderers, (function () {\n            var j, len, results;\n            results = [];\n            for (j = 0, len = renderer_models.length; j < len; j++) {\n                model = renderer_models[j];\n                results.push(model.id);\n            }\n            return results;\n        })());\n        for (j = 0, len = renderers_to_remove.length; j < len; j++) {\n            id_ = renderers_to_remove[j];\n            delete this.levels.glyph[id_];\n        }\n        for (l = 0, len1 = new_renderer_views.length; l < len1; l++) {\n            view = new_renderer_views[l];\n            this.levels[view.model.level][view.model.id] = view;\n            view.connect_signals();\n        }\n        return this;\n    };\n    PlotCanvasView.prototype.get_renderer_views = function () {\n        var j, len, r, ref, results;\n        ref = this.model.plot.renderers;\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n            r = ref[j];\n            results.push(this.levels[r.level][r.id]);\n        }\n        return results;\n    };\n    PlotCanvasView.prototype.build_tools = function () {\n        var j, len, new_tool_views, results, tool_models, tool_view;\n        tool_models = this.model.plot.toolbar.tools;\n        new_tool_views = build_views_1.build_views(this.tool_views, tool_models, this.view_options());\n        results = [];\n        for (j = 0, len = new_tool_views.length; j < len; j++) {\n            tool_view = new_tool_views[j];\n            tool_view.connect_signals();\n            results.push(this.ui_event_bus.register_tool(tool_view));\n        }\n        return results;\n    };\n    PlotCanvasView.prototype.connect_signals = function () {\n        var name, ref, ref1, rng;\n        PlotCanvasView.__super__.connect_signals.call(this);\n        this.connect(this.force_paint, (function (_this) {\n            return function () {\n                return _this.paint();\n            };\n        })(this));\n        ref = this.model.frame.x_ranges;\n        for (name in ref) {\n            rng = ref[name];\n            this.connect(rng.change, function () {\n                return this.request_render();\n            });\n        }\n        ref1 = this.model.frame.y_ranges;\n        for (name in ref1) {\n            rng = ref1[name];\n            this.connect(rng.change, function () {\n                return this.request_render();\n            });\n        }\n        this.connect(this.model.plot.properties.renderers.change, (function (_this) {\n            return function () {\n                return _this.build_levels();\n            };\n        })(this));\n        this.connect(this.model.plot.toolbar.properties.tools.change, (function (_this) {\n            return function () {\n                _this.build_levels();\n                return _this.build_tools();\n            };\n        })(this));\n        return this.connect(this.model.plot.change, function () {\n            return this.request_render();\n        });\n    };\n    PlotCanvasView.prototype.set_initial_range = function () {\n        var good_vals, name, ref, ref1, rng, xrs, yrs;\n        good_vals = true;\n        xrs = {};\n        ref = this.frame.x_ranges;\n        for (name in ref) {\n            rng = ref[name];\n            if ((rng.start == null) || (rng.end == null) || types_1.isStrictNaN(rng.start + rng.end)) {\n                good_vals = false;\n                break;\n            }\n            xrs[name] = {\n                start: rng.start,\n                end: rng.end\n            };\n        }\n        if (good_vals) {\n            yrs = {};\n            ref1 = this.frame.y_ranges;\n            for (name in ref1) {\n                rng = ref1[name];\n                if ((rng.start == null) || (rng.end == null) || types_1.isStrictNaN(rng.start + rng.end)) {\n                    good_vals = false;\n                    break;\n                }\n                yrs[name] = {\n                    start: rng.start,\n                    end: rng.end\n                };\n            }\n        }\n        if (good_vals) {\n            this._initial_state_info.range = this.initial_range_info = {\n                xrs: xrs,\n                yrs: yrs\n            };\n            return logging_1.logger.debug(\"initial ranges set\");\n        }\n        else {\n            return logging_1.logger.warn('could not set initial ranges');\n        }\n    };\n    PlotCanvasView.prototype.update_constraints = function () {\n        var _, ref, view;\n        this.solver.suggest_value(this.frame._width, this.canvas._width.value - 1);\n        this.solver.suggest_value(this.frame._height, this.canvas._height.value - 1);\n        ref = this.renderer_views;\n        for (_ in ref) {\n            view = ref[_];\n            if (view.model.panel != null) {\n                side_panel_1.update_panel_constraints(view);\n            }\n        }\n        return this.solver.update_variables();\n    };\n    PlotCanvasView.prototype._layout = function (final) {\n        if (final == null) {\n            final = false;\n        }\n        this.render();\n        if (final) {\n            this.model.plot.setv({\n                inner_width: Math.round(this.frame._width.value),\n                inner_height: Math.round(this.frame._height.value),\n                layout_width: Math.round(this.canvas._width.value),\n                layout_height: Math.round(this.canvas._height.value)\n            }, {\n                no_change: true\n            });\n            return this.request_paint();\n        }\n    };\n    PlotCanvasView.prototype.has_finished = function () {\n        var _, ref, renderer_views, view;\n        if (!PlotCanvasView.__super__.has_finished.call(this)) {\n            return false;\n        }\n        ref = this.levels;\n        for (_ in ref) {\n            renderer_views = ref[_];\n            for (_ in renderer_views) {\n                view = renderer_views[_];\n                if (!view.has_finished()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    PlotCanvasView.prototype.render = function () {\n        var height, width;\n        width = this.model._width.value;\n        height = this.model._height.value;\n        this.canvas_view.set_dims([width, height]);\n        this.update_constraints();\n        this.el.style.position = 'absolute';\n        this.el.style.left = this.model._dom_left.value + \"px\";\n        this.el.style.top = this.model._dom_top.value + \"px\";\n        this.el.style.width = this.model._width.value + \"px\";\n        return this.el.style.height = this.model._height.value + \"px\";\n    };\n    PlotCanvasView.prototype.paint = function () {\n        var ctx, frame_box, k, lod_timeout, ratio, ref, v;\n        if (this.is_paused) {\n            return;\n        }\n        logging_1.logger.trace(\"PlotCanvas.render() for \" + this.model.id);\n        this.canvas_view.prepare_canvas();\n        if (Date.now() - this.interactive_timestamp < this.model.plot.lod_interval) {\n            if (!this.lod_started) {\n                this.model.plot.trigger_event(new bokeh_events_1.LODStart({}));\n                this.lod_started = true;\n            }\n            this.interactive = true;\n            lod_timeout = this.model.plot.lod_timeout;\n            setTimeout((function (_this) {\n                return function () {\n                    if (_this.interactive && (Date.now() - _this.interactive_timestamp) > lod_timeout) {\n                        _this.interactive = false;\n                    }\n                    return _this.request_render();\n                };\n            })(this), lod_timeout);\n        }\n        else {\n            this.interactive = false;\n            if (this.lod_started) {\n                this.model.plot.trigger_event(new bokeh_events_1.LODEnd({}));\n                this.lod_started = false;\n            }\n        }\n        ref = this.renderer_views;\n        for (k in ref) {\n            v = ref[k];\n            if ((this.range_update_timestamp == null) || v.set_data_timestamp > this.range_update_timestamp) {\n                this.update_dataranges();\n                break;\n            }\n        }\n        this.model.frame._update_scales();\n        ctx = this.canvas_view.ctx;\n        ctx.pixel_ratio = ratio = this.canvas.pixel_ratio;\n        ctx.save();\n        ctx.scale(ratio, ratio);\n        ctx.translate(0.5, 0.5);\n        frame_box = [this.canvas.vx_to_sx(this.frame._left.value), this.canvas.vy_to_sy(this.frame._top.value), this.frame._width.value, this.frame._height.value];\n        this._map_hook(ctx, frame_box);\n        this._paint_empty(ctx, frame_box);\n        this.prepare_webgl(ratio, frame_box);\n        ctx.save();\n        if (this.visuals.outline_line.doit) {\n            this.visuals.outline_line.set_value(ctx);\n            ctx.strokeRect.apply(ctx, frame_box);\n        }\n        ctx.restore();\n        this._paint_levels(ctx, ['image', 'underlay', 'glyph'], frame_box);\n        this.blit_webgl(ratio);\n        this._paint_levels(ctx, ['annotation'], frame_box);\n        this._paint_levels(ctx, ['overlay']);\n        if (this.initial_range_info == null) {\n            this.set_initial_range();\n        }\n        ctx.restore();\n        if (!this._has_finished) {\n            this._has_finished = true;\n            return this.notify_finished();\n        }\n    };\n    PlotCanvasView.prototype._paint_levels = function (ctx, levels, clip_region) {\n        var i, indices, j, l, len, len1, len2, level, m, ref, renderer, renderer_view, renderer_views, sortKey;\n        ctx.save();\n        if ((clip_region != null) && this.model.plot.output_backend === \"canvas\") {\n            ctx.beginPath();\n            ctx.rect.apply(ctx, clip_region);\n            ctx.clip();\n        }\n        indices = {};\n        ref = this.model.plot.renderers;\n        for (i = j = 0, len = ref.length; j < len; i = ++j) {\n            renderer = ref[i];\n            indices[renderer.id] = i;\n        }\n        sortKey = function (renderer_view) {\n            return indices[renderer_view.model.id];\n        };\n        for (l = 0, len1 = levels.length; l < len1; l++) {\n            level = levels[l];\n            renderer_views = array_1.sortBy(object_1.values(this.levels[level]), sortKey);\n            for (m = 0, len2 = renderer_views.length; m < len2; m++) {\n                renderer_view = renderer_views[m];\n                renderer_view.render();\n            }\n        }\n        return ctx.restore();\n    };\n    PlotCanvasView.prototype._map_hook = function (ctx, frame_box) { };\n    PlotCanvasView.prototype._paint_empty = function (ctx, frame_box) {\n        ctx.clearRect(0, 0, this.canvas_view.model._width.value, this.canvas_view.model._height.value);\n        if (this.visuals.border_fill.doit) {\n            this.visuals.border_fill.set_value(ctx);\n            ctx.fillRect(0, 0, this.canvas_view.model._width.value, this.canvas_view.model._height.value);\n            ctx.clearRect.apply(ctx, frame_box);\n        }\n        if (this.visuals.background_fill.doit) {\n            this.visuals.background_fill.set_value(ctx);\n            return ctx.fillRect.apply(ctx, frame_box);\n        }\n    };\n    PlotCanvasView.prototype.save = function (name) {\n        var blob, canvas, downloadLink, link, svg, svgblob;\n        if (this.model.plot.output_backend === \"canvas\") {\n            canvas = this.canvas_view.get_canvas_element();\n            if (canvas.msToBlob != null) {\n                blob = canvas.msToBlob();\n                return window.navigator.msSaveBlob(blob, name);\n            }\n            else {\n                link = document.createElement('a');\n                link.href = canvas.toDataURL('image/png');\n                link.download = name + \".png\";\n                link.target = \"_blank\";\n                return link.dispatchEvent(new MouseEvent('click'));\n            }\n        }\n        else if (this.model.plot.output_backend === \"svg\") {\n            svg = this.canvas_view.ctx.getSerializedSvg(true);\n            svgblob = new Blob([svg], {\n                type: 'text/plain'\n            });\n            downloadLink = document.createElement(\"a\");\n            downloadLink.download = name + \".svg\";\n            downloadLink.innerHTML = \"Download svg\";\n            downloadLink.href = window.URL.createObjectURL(svgblob);\n            downloadLink.onclick = function (event) {\n                return document.body.removeChild(event.target);\n            };\n            downloadLink.style.display = \"none\";\n            document.body.appendChild(downloadLink);\n            return downloadLink.click();\n        }\n    };\n    return PlotCanvasView;\n})(dom_view_1.DOMView);\nexports.PlotCanvas = (function (superClass) {\n    extend1(PlotCanvas, superClass);\n    function PlotCanvas() {\n        return PlotCanvas.__super__.constructor.apply(this, arguments);\n    }\n    PlotCanvas.prototype.type = 'PlotCanvas';\n    PlotCanvas.prototype.default_view = exports.PlotCanvasView;\n    PlotCanvas.prototype.initialize = function (attrs, options) {\n        var ref;\n        PlotCanvas.__super__.initialize.call(this, attrs, options);\n        this.canvas = new canvas_1.Canvas({\n            map: (ref = this.use_map) != null ? ref : false,\n            initial_width: this.plot.plot_width,\n            initial_height: this.plot.plot_height,\n            use_hidpi: this.plot.hidpi,\n            output_backend: this.plot.output_backend\n        });\n        this.frame = new cartesian_frame_1.CartesianFrame({\n            x_range: this.plot.x_range,\n            extra_x_ranges: this.plot.extra_x_ranges,\n            x_scale: this.plot.x_scale,\n            y_range: this.plot.y_range,\n            extra_y_ranges: this.plot.extra_y_ranges,\n            y_scale: this.plot.y_scale\n        });\n        this.above_panel = new layout_canvas_1.LayoutCanvas();\n        this.below_panel = new layout_canvas_1.LayoutCanvas();\n        this.left_panel = new layout_canvas_1.LayoutCanvas();\n        this.right_panel = new layout_canvas_1.LayoutCanvas();\n        return logging_1.logger.debug(\"PlotCanvas initialized\");\n    };\n    PlotCanvas.prototype._doc_attached = function () {\n        this.canvas.attach_document(this.document);\n        this.frame.attach_document(this.document);\n        this.above_panel.attach_document(this.document);\n        this.below_panel.attach_document(this.document);\n        this.left_panel.attach_document(this.document);\n        this.right_panel.attach_document(this.document);\n        PlotCanvas.__super__._doc_attached.call(this);\n        return logging_1.logger.debug(\"PlotCanvas attached to document\");\n    };\n    PlotCanvas.override({\n        sizing_mode: 'stretch_both'\n    });\n    PlotCanvas.internal({\n        plot: [p.Instance],\n        toolbar: [p.Instance],\n        canvas: [p.Instance],\n        frame: [p.Instance]\n    });\n    PlotCanvas.prototype.get_layoutable_children = function () {\n        var children, collect_panels;\n        children = [this.above_panel, this.below_panel, this.left_panel, this.right_panel, this.canvas, this.frame];\n        collect_panels = function (layout_renderers) {\n            var j, len, r, results;\n            results = [];\n            for (j = 0, len = layout_renderers.length; j < len; j++) {\n                r = layout_renderers[j];\n                if (r.panel != null) {\n                    results.push(children.push(r.panel));\n                }\n                else {\n                    results.push(void 0);\n                }\n            }\n            return results;\n        };\n        collect_panels(this.plot.above);\n        collect_panels(this.plot.below);\n        collect_panels(this.plot.left);\n        collect_panels(this.plot.right);\n        return children;\n    };\n    PlotCanvas.prototype.get_edit_variables = function () {\n        var child, edit_variables, j, len, ref;\n        edit_variables = [];\n        ref = this.get_layoutable_children();\n        for (j = 0, len = ref.length; j < len; j++) {\n            child = ref[j];\n            edit_variables = edit_variables.concat(child.get_edit_variables());\n        }\n        return edit_variables;\n    };\n    PlotCanvas.prototype.get_constraints = function () {\n        var child, constraints, j, len, ref;\n        constraints = PlotCanvas.__super__.get_constraints.call(this);\n        constraints = constraints.concat(this._get_constant_constraints());\n        constraints = constraints.concat(this._get_side_constraints());\n        ref = this.get_layoutable_children();\n        for (j = 0, len = ref.length; j < len; j++) {\n            child = ref[j];\n            constraints = constraints.concat(child.get_constraints());\n        }\n        return constraints;\n    };\n    PlotCanvas.prototype._get_constant_constraints = function () {\n        return [solver_1.GE(this.above_panel._height, -this.plot.min_border_top), solver_1.GE(this.below_panel._height, -this.plot.min_border_bottom), solver_1.GE(this.left_panel._width, -this.plot.min_border_left), solver_1.GE(this.right_panel._width, -this.plot.min_border_right), solver_1.EQ(this.above_panel._top, [-1, this.canvas._top]), solver_1.EQ(this.above_panel._bottom, [-1, this.frame._top]), solver_1.EQ(this.below_panel._bottom, [-1, this.canvas._bottom]), solver_1.EQ(this.below_panel._top, [-1, this.frame._bottom]), solver_1.EQ(this.left_panel._left, [-1, this.canvas._left]), solver_1.EQ(this.left_panel._right, [-1, this.frame._left]), solver_1.EQ(this.right_panel._right, [-1, this.canvas._right]), solver_1.EQ(this.right_panel._left, [-1, this.frame._right]), solver_1.EQ(this.above_panel._height, [-1, this._top]), solver_1.EQ(this.above_panel._height, [-1, this.canvas._top], this.frame._top), solver_1.EQ(this.below_panel._height, [-1, this._height], this._bottom), solver_1.EQ(this.below_panel._height, [-1, this.frame._bottom]), solver_1.EQ(this.left_panel._width, [-1, this._left]), solver_1.EQ(this.left_panel._width, [-1, this.frame._left]), solver_1.EQ(this.right_panel._width, [-1, this._width], this._right), solver_1.EQ(this.right_panel._width, [-1, this.canvas._right], this.frame._right)];\n    };\n    PlotCanvas.prototype._get_side_constraints = function () {\n        var constraint, constraints, j, l, last, layout_renderers, len, len1, r, ref, side, sides;\n        constraints = [];\n        sides = [['above', this.plot.above], ['below', this.plot.below], ['left', this.plot.left], ['right', this.plot.right]];\n        for (j = 0, len = sides.length; j < len; j++) {\n            ref = sides[j], side = ref[0], layout_renderers = ref[1];\n            last = this.frame;\n            for (l = 0, len1 = layout_renderers.length; l < len1; l++) {\n                r = layout_renderers[l];\n                constraint = (function () {\n                    switch (side) {\n                        case \"above\":\n                            return solver_1.EQ(last.panel._top, [-1, r.panel._bottom]);\n                        case \"below\":\n                            return solver_1.EQ(last.panel._bottom, [-1, r.panel._top]);\n                        case \"left\":\n                            return solver_1.EQ(last.panel._left, [-1, r.panel._right]);\n                        case \"right\":\n                            return solver_1.EQ(last.panel._right, [-1, r.panel._left]);\n                    }\n                })();\n                constraints.push(constraint);\n                last = r;\n            }\n            if (layout_renderers.length !== 0) {\n                constraint = (function () {\n                    switch (side) {\n                        case \"above\":\n                            return solver_1.EQ(last.panel._top, [-1, this.above_panel._top]);\n                        case \"below\":\n                            return solver_1.EQ(last.panel._bottom, [-1, this.below_panel._bottom]);\n                        case \"left\":\n                            return solver_1.EQ(last.panel._left, [-1, this.left_panel._left]);\n                        case \"right\":\n                            return solver_1.EQ(last.panel._right, [-1, this.right_panel._right]);\n                    }\n                }).call(this);\n                constraints.push(constraint);\n            }\n        }\n        return constraints;\n    };\n    return PlotCanvas;\n})(layout_dom_1.LayoutDOM);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar range_1 = require(\"./range\");\nvar p = require(\"core/properties\");\nexports.DataRange = (function (superClass) {\n    extend(DataRange, superClass);\n    function DataRange() {\n        return DataRange.__super__.constructor.apply(this, arguments);\n    }\n    DataRange.prototype.type = 'DataRange';\n    DataRange.define({\n        names: [p.Array, []],\n        renderers: [p.Array, []]\n    });\n    return DataRange;\n})(range_1.Range);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar data_range_1 = require(\"./data_range\");\nvar glyph_renderer_1 = require(\"../renderers/glyph_renderer\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar bbox = require(\"core/util/bbox\");\nexports.DataRange1d = (function (superClass) {\n    extend(DataRange1d, superClass);\n    function DataRange1d() {\n        return DataRange1d.__super__.constructor.apply(this, arguments);\n    }\n    DataRange1d.prototype.type = 'DataRange1d';\n    DataRange1d.define({\n        start: [p.Number],\n        end: [p.Number],\n        range_padding: [p.Number, 0.1],\n        range_padding_units: [p.PaddingUnits, \"percent\"],\n        flipped: [p.Bool, false],\n        follow: [p.StartEnd],\n        follow_interval: [p.Number],\n        default_span: [p.Number, 2],\n        bounds: [p.Any],\n        min_interval: [p.Any],\n        max_interval: [p.Any]\n    });\n    DataRange1d.internal({\n        scale_hint: [p.String, 'auto']\n    });\n    DataRange1d.prototype.initialize = function (attrs, options) {\n        DataRange1d.__super__.initialize.call(this, attrs, options);\n        this.plot_bounds = {};\n        this.have_updated_interactively = false;\n        this._initial_start = this.start;\n        this._initial_end = this.end;\n        this._initial_range_padding = this.range_padding;\n        this._initial_range_padding_units = this.range_padding_units;\n        this._initial_follow = this.follow;\n        this._initial_follow_interval = this.follow_interval;\n        return this._initial_default_span = this.default_span;\n    };\n    DataRange1d.getters({\n        min: function () {\n            return Math.min(this.start, this.end);\n        },\n        max: function () {\n            return Math.max(this.start, this.end);\n        }\n    });\n    DataRange1d.prototype.computed_renderers = function () {\n        var all_renderers, i, j, len, len1, names, plot, r, ref, renderers, rs;\n        names = this.names;\n        renderers = this.renderers;\n        if (renderers.length === 0) {\n            ref = this.plots;\n            for (i = 0, len = ref.length; i < len; i++) {\n                plot = ref[i];\n                all_renderers = plot.renderers;\n                rs = (function () {\n                    var j, len1, results;\n                    results = [];\n                    for (j = 0, len1 = all_renderers.length; j < len1; j++) {\n                        r = all_renderers[j];\n                        if (r instanceof glyph_renderer_1.GlyphRenderer) {\n                            results.push(r);\n                        }\n                    }\n                    return results;\n                })();\n                renderers = renderers.concat(rs);\n            }\n        }\n        if (names.length > 0) {\n            renderers = (function () {\n                var j, len1, results;\n                results = [];\n                for (j = 0, len1 = renderers.length; j < len1; j++) {\n                    r = renderers[j];\n                    if (names.indexOf(r.name) >= 0) {\n                        results.push(r);\n                    }\n                }\n                return results;\n            })();\n        }\n        logging_1.logger.debug(\"computed \" + renderers.length + \" renderers for DataRange1d \" + this.id);\n        for (j = 0, len1 = renderers.length; j < len1; j++) {\n            r = renderers[j];\n            logging_1.logger.trace(\" - \" + r.type + \" \" + r.id);\n        }\n        return renderers;\n    };\n    DataRange1d.prototype._compute_plot_bounds = function (renderers, bounds) {\n        var i, len, r, result;\n        result = bbox.empty();\n        for (i = 0, len = renderers.length; i < len; i++) {\n            r = renderers[i];\n            if (bounds[r.id] != null) {\n                result = bbox.union(result, bounds[r.id]);\n            }\n        }\n        return result;\n    };\n    DataRange1d.prototype._compute_min_max = function (plot_bounds, dimension) {\n        var k, max, min, overall, ref, ref1, v;\n        overall = bbox.empty();\n        for (k in plot_bounds) {\n            v = plot_bounds[k];\n            overall = bbox.union(overall, v);\n        }\n        if (dimension === 0) {\n            ref = [overall.minX, overall.maxX], min = ref[0], max = ref[1];\n        }\n        else {\n            ref1 = [overall.minY, overall.maxY], min = ref1[0], max = ref1[1];\n        }\n        return [min, max];\n    };\n    DataRange1d.prototype._compute_range = function (min, max) {\n        var center, end, follow_interval, follow_sign, log_max, log_min, range_padding, ref, ref1, ref2, ref3, span, start;\n        range_padding = this.range_padding;\n        if ((range_padding != null) && range_padding > 0) {\n            if (this.scale_hint === \"log\") {\n                if (isNaN(min) || !isFinite(min) || min <= 0) {\n                    if (isNaN(max) || !isFinite(max) || max <= 0) {\n                        min = 0.1;\n                    }\n                    else {\n                        min = max / 100;\n                    }\n                    logging_1.logger.warn(\"could not determine minimum data value for log axis, DataRange1d using value \" + min);\n                }\n                if (isNaN(max) || !isFinite(max) || max <= 0) {\n                    if (isNaN(min) || !isFinite(min) || min <= 0) {\n                        max = 10;\n                    }\n                    else {\n                        max = min * 100;\n                    }\n                    logging_1.logger.warn(\"could not determine maximum data value for log axis, DataRange1d using value \" + max);\n                }\n                if (max === min) {\n                    span = this.default_span + 0.001;\n                    center = Math.log(min) / Math.log(10);\n                }\n                else {\n                    if (this.range_padding_units === \"percent\") {\n                        log_min = Math.log(min) / Math.log(10);\n                        log_max = Math.log(max) / Math.log(10);\n                        span = (log_max - log_min) * (1 + range_padding);\n                    }\n                    else {\n                        log_min = Math.log(min - range_padding) / Math.log(10);\n                        log_max = Math.log(max + range_padding) / Math.log(10);\n                        span = log_max - log_min;\n                    }\n                    center = (log_min + log_max) / 2.0;\n                }\n                ref = [Math.pow(10, center - span / 2.0), Math.pow(10, center + span / 2.0)], start = ref[0], end = ref[1];\n            }\n            else {\n                if (max === min) {\n                    span = this.default_span;\n                }\n                else {\n                    if (this.range_padding_units === \"percent\") {\n                        span = (max - min) * (1 + range_padding);\n                    }\n                    else {\n                        span = (max - min) + 2 * range_padding;\n                    }\n                }\n                center = (max + min) / 2.0;\n                ref1 = [center - span / 2.0, center + span / 2.0], start = ref1[0], end = ref1[1];\n            }\n        }\n        else {\n            ref2 = [min, max], start = ref2[0], end = ref2[1];\n        }\n        follow_sign = +1;\n        if (this.flipped) {\n            ref3 = [end, start], start = ref3[0], end = ref3[1];\n            follow_sign = -1;\n        }\n        follow_interval = this.follow_interval;\n        if ((follow_interval != null) && Math.abs(start - end) > follow_interval) {\n            if (this.follow === 'start') {\n                end = start + follow_sign * follow_interval;\n            }\n            else if (this.follow === 'end') {\n                start = end - follow_sign * follow_interval;\n            }\n        }\n        return [start, end];\n    };\n    DataRange1d.prototype.update = function (bounds, dimension, bounds_id) {\n        var _end, _start, end, max, min, new_range, ref, ref1, ref2, renderers, start;\n        if (this.have_updated_interactively) {\n            return;\n        }\n        renderers = this.computed_renderers();\n        this.plot_bounds[bounds_id] = this._compute_plot_bounds(renderers, bounds);\n        ref = this._compute_min_max(this.plot_bounds, dimension), min = ref[0], max = ref[1];\n        ref1 = this._compute_range(min, max), start = ref1[0], end = ref1[1];\n        if (this._initial_start != null) {\n            if (this.scale_hint === \"log\") {\n                if (this._initial_start > 0) {\n                    start = this._initial_start;\n                }\n            }\n            else {\n                start = this._initial_start;\n            }\n        }\n        if (this._initial_end != null) {\n            if (this.scale_hint === \"log\") {\n                if (this._initial_end > 0) {\n                    end = this._initial_end;\n                }\n            }\n            else {\n                end = this._initial_end;\n            }\n        }\n        ref2 = [this.start, this.end], _start = ref2[0], _end = ref2[1];\n        if (start !== _start || end !== _end) {\n            new_range = {};\n            if (start !== _start) {\n                new_range.start = start;\n            }\n            if (end !== _end) {\n                new_range.end = end;\n            }\n            this.setv(new_range);\n        }\n        if (this.bounds === 'auto') {\n            this.setv({\n                bounds: [start, end]\n            }, {\n                silent: true\n            });\n        }\n        return this.change.emit();\n    };\n    DataRange1d.prototype.reset = function () {\n        this.have_updated_interactively = false;\n        this.setv({\n            range_padding: this._initial_range_padding,\n            range_padding_units: this._initial_range_padding_units,\n            follow: this._initial_follow,\n            follow_interval: this._initial_follow_interval,\n            default_span: this._initial_default_span\n        }, {\n            silent: true\n        });\n        return this.change.emit();\n    };\n    return DataRange1d;\n})(data_range_1.DataRange);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar range_1 = require(\"./range\");\nvar p = require(\"core/properties\");\nexports.FactorRange = (function (superClass) {\n    extend(FactorRange, superClass);\n    function FactorRange() {\n        return FactorRange.__super__.constructor.apply(this, arguments);\n    }\n    FactorRange.prototype.type = 'FactorRange';\n    FactorRange.define({\n        offset: [p.Number, 0],\n        factors: [p.Array, []],\n        bounds: [p.Any],\n        min_interval: [p.Any],\n        max_interval: [p.Any]\n    });\n    FactorRange.internal({\n        _bounds_as_factors: [p.Any],\n        start: [p.Number],\n        end: [p.Number]\n    });\n    FactorRange.prototype.initialize = function (attrs, options) {\n        FactorRange.__super__.initialize.call(this, attrs, options);\n        if ((this.bounds != null) && this.bounds !== 'auto') {\n            this.setv({\n                _bounds_as_factors: this.bounds\n            }, {\n                silent: true\n            });\n        }\n        else {\n            this.setv({\n                _bounds_as_factors: this.factors\n            }, {\n                silent: true\n            });\n        }\n        this._init();\n        this.connect(this.properties.factors.change, function () {\n            return this._update_factors();\n        });\n        return this.connect(this.properties.offset.change, function () {\n            return this._init();\n        });\n    };\n    FactorRange.getters({\n        min: function () {\n            return this.start;\n        },\n        max: function () {\n            return this.end;\n        }\n    });\n    FactorRange.prototype.reset = function () {\n        this._init();\n        return this.change.emit();\n    };\n    FactorRange.prototype._update_factors = function () {\n        this.setv('_bounds_as_factors', this.factors, {\n            silent: true\n        });\n        return this._init();\n    };\n    FactorRange.prototype._init = function () {\n        var end, factors, start;\n        factors = this.factors;\n        if ((this.bounds != null) && this.bounds !== 'auto') {\n            factors = this._bounds_as_factors;\n            this.setv({\n                factors: factors\n            }, {\n                silent: true\n            });\n        }\n        start = 0.5 + this.offset;\n        end = factors.length + start;\n        this.setv({\n            start: start,\n            end: end\n        }, {\n            silent: true\n        });\n        if (this.bounds != null) {\n            return this.setv({\n                bounds: [start, end]\n            }, {\n                silent: true\n            });\n        }\n    };\n    return FactorRange;\n})(range_1.Range);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_range_1 = require(\"./data_range\");\nexports.DataRange = data_range_1.DataRange;\nvar data_range1d_1 = require(\"./data_range1d\");\nexports.DataRange1d = data_range1d_1.DataRange1d;\nvar factor_range_1 = require(\"./factor_range\");\nexports.FactorRange = factor_range_1.FactorRange;\nvar range_1 = require(\"./range\");\nexports.Range = range_1.Range;\nvar range1d_1 = require(\"./range1d\");\nexports.Range1d = range1d_1.Range1d;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nvar p = require(\"core/properties\");\nexports.Range = (function (superClass) {\n    extend(Range, superClass);\n    function Range() {\n        return Range.__super__.constructor.apply(this, arguments);\n    }\n    Range.prototype.type = 'Range';\n    Range.prototype.initialize = function (options) {\n        Range.__super__.initialize.call(this, options);\n        return this.connect(this.change, function () {\n            var ref;\n            return (ref = this.callback) != null ? ref.execute(this) : void 0;\n        });\n    };\n    Range.define({\n        callback: [p.Instance]\n    });\n    Range.internal({\n        plots: [p.Array, []]\n    });\n    Range.prototype.reset = function () {\n        \"This method should be reimplemented by subclasses and ensure that\\nthe callback, if exists, is executed at completion.\";\n        return this.change.emit();\n    };\n    return Range;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar range_1 = require(\"./range\");\nvar p = require(\"core/properties\");\nexports.Range1d = (function (superClass) {\n    extend(Range1d, superClass);\n    Range1d.prototype.type = 'Range1d';\n    Range1d.define({\n        start: [p.Number, 0],\n        end: [p.Number, 1],\n        bounds: [p.Any],\n        min_interval: [p.Any],\n        max_interval: [p.Any]\n    });\n    Range1d.prototype._set_auto_bounds = function () {\n        var max, min;\n        if (this.bounds === 'auto') {\n            min = Math.min(this._initial_start, this._initial_end);\n            max = Math.max(this._initial_start, this._initial_end);\n            return this.setv({\n                bounds: [min, max]\n            }, {\n                silent: true\n            });\n        }\n    };\n    function Range1d() {\n        var end, start;\n        if (this instanceof Range1d) {\n            return Range1d.__super__.constructor.apply(this, arguments);\n        }\n        else {\n            start = arguments[0], end = arguments[1];\n            return new Range1d({\n                start: start,\n                end: end\n            });\n        }\n    }\n    Range1d.prototype.initialize = function (attrs, options) {\n        Range1d.__super__.initialize.call(this, attrs, options);\n        this._initial_start = this.start;\n        this._initial_end = this.end;\n        return this._set_auto_bounds();\n    };\n    Range1d.getters({\n        min: function () {\n            return Math.min(this.start, this.end);\n        },\n        max: function () {\n            return Math.max(this.start, this.end);\n        }\n    });\n    Range1d.prototype.reset = function () {\n        this._set_auto_bounds();\n        if (this.start !== this._initial_start || this.end !== this._initial_end) {\n            return this.setv({\n                start: this._initial_start,\n                end: this._initial_end\n            });\n        }\n        else {\n            return this.change.emit();\n        }\n    };\n    return Range1d;\n})(range_1.Range);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar renderer_1 = require(\"./renderer\");\nvar remote_data_source_1 = require(\"../sources/remote_data_source\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nvar object_1 = require(\"core/util/object\");\nexports.GlyphRendererView = (function (superClass) {\n    extend1(GlyphRendererView, superClass);\n    function GlyphRendererView() {\n        return GlyphRendererView.__super__.constructor.apply(this, arguments);\n    }\n    GlyphRendererView.prototype.initialize = function (options) {\n        var base_glyph, decimated_glyph, glyph_attrs, has_fill, has_line, hover_glyph, mk_glyph, muted_glyph, nonselection_glyph, selection_glyph;\n        GlyphRendererView.__super__.initialize.call(this, options);\n        base_glyph = this.model.glyph;\n        has_fill = indexOf.call(base_glyph.mixins, \"fill\") >= 0;\n        has_line = indexOf.call(base_glyph.mixins, \"line\") >= 0;\n        glyph_attrs = object_1.clone(base_glyph.attributes);\n        delete glyph_attrs.id;\n        mk_glyph = function (defaults) {\n            var attrs;\n            attrs = object_1.clone(glyph_attrs);\n            if (has_fill) {\n                object_1.extend(attrs, defaults.fill);\n            }\n            if (has_line) {\n                object_1.extend(attrs, defaults.line);\n            }\n            return new base_glyph.constructor(attrs);\n        };\n        this.glyph = this.build_glyph_view(base_glyph);\n        selection_glyph = this.model.selection_glyph;\n        if (selection_glyph == null) {\n            selection_glyph = mk_glyph({\n                fill: {},\n                line: {}\n            });\n        }\n        else if (selection_glyph === \"auto\") {\n            selection_glyph = mk_glyph(this.model.selection_defaults);\n        }\n        this.selection_glyph = this.build_glyph_view(selection_glyph);\n        nonselection_glyph = this.model.nonselection_glyph;\n        if (nonselection_glyph == null) {\n            nonselection_glyph = mk_glyph({\n                fill: {},\n                line: {}\n            });\n        }\n        else if (nonselection_glyph === \"auto\") {\n            nonselection_glyph = mk_glyph(this.model.nonselection_defaults);\n        }\n        this.nonselection_glyph = this.build_glyph_view(nonselection_glyph);\n        hover_glyph = this.model.hover_glyph;\n        if (hover_glyph != null) {\n            this.hover_glyph = this.build_glyph_view(hover_glyph);\n        }\n        muted_glyph = this.model.muted_glyph;\n        if (muted_glyph != null) {\n            this.muted_glyph = this.build_glyph_view(muted_glyph);\n        }\n        decimated_glyph = mk_glyph(this.model.decimated_defaults);\n        this.decimated_glyph = this.build_glyph_view(decimated_glyph);\n        this.xscale = this.plot_view.frame.xscales[this.model.x_range_name];\n        this.yscale = this.plot_view.frame.yscales[this.model.y_range_name];\n        this.set_data(false);\n        if (this.model.data_source instanceof remote_data_source_1.RemoteDataSource) {\n            return this.model.data_source.setup(this.plot_view, this.glyph);\n        }\n    };\n    GlyphRendererView.getters({\n        xmapper: function () {\n            log.warning(\"xmapper attr is deprecated, use xscale\");\n            return this.xscale;\n        },\n        ymapper: function () {\n            log.warning(\"ymapper attr is deprecated, use yscale\");\n            return this.yscale;\n        }\n    });\n    GlyphRendererView.prototype.build_glyph_view = function (model) {\n        return new model.default_view({\n            model: model,\n            renderer: this,\n            plot_view: this.plot_view,\n            parent: this\n        });\n    };\n    GlyphRendererView.prototype.connect_signals = function () {\n        GlyphRendererView.__super__.connect_signals.call(this);\n        this.connect(this.model.change, function () {\n            return this.request_render();\n        });\n        this.connect(this.model.data_source.change, function () {\n            return this.set_data();\n        });\n        this.connect(this.model.data_source.streaming, function () {\n            return this.set_data();\n        });\n        this.connect(this.model.data_source.patching, function (indices) {\n            return this.set_data(true, indices);\n        });\n        this.connect(this.model.data_source.select, function () {\n            return this.request_render();\n        });\n        if (this.hover_glyph != null) {\n            this.connect(this.model.data_source.inspect, function () {\n                return this.request_render();\n            });\n        }\n        this.connect(this.model.glyph.transformchange, function () {\n            return this.set_data();\n        });\n        return this.connect(this.model.glyph.propchange, function () {\n            this.glyph.set_visuals(this.model.data_source);\n            return this.request_render();\n        });\n    };\n    GlyphRendererView.prototype.have_selection_glyphs = function () {\n        return (this.selection_glyph != null) && (this.nonselection_glyph != null);\n    };\n    GlyphRendererView.prototype.set_data = function (request_render, indices) {\n        var dt, i, j, k, length, lod_factor, ref, results, source, t0;\n        if (request_render == null) {\n            request_render = true;\n        }\n        t0 = Date.now();\n        source = this.model.data_source;\n        this.glyph.model.setv({\n            x_range_name: this.model.x_range_name,\n            y_range_name: this.model.y_range_name\n        }, {\n            silent: true\n        });\n        this.glyph.set_data(source, indices);\n        this.glyph.set_visuals(source);\n        this.decimated_glyph.set_visuals(source);\n        if (this.have_selection_glyphs()) {\n            this.selection_glyph.set_visuals(source);\n            this.nonselection_glyph.set_visuals(source);\n        }\n        if (this.hover_glyph != null) {\n            this.hover_glyph.set_visuals(source);\n        }\n        if (this.muted_glyph != null) {\n            this.muted_glyph.set_visuals(source);\n        }\n        length = source.get_length();\n        if (length == null) {\n            length = 1;\n        }\n        this.all_indices = (function () {\n            results = [];\n            for (var j = 0; 0 <= length ? j < length : j > length; 0 <= length ? j++ : j--) {\n                results.push(j);\n            }\n            return results;\n        }).apply(this);\n        lod_factor = this.plot_model.plot.lod_factor;\n        this.decimated = [];\n        for (i = k = 0, ref = Math.floor(this.all_indices.length / lod_factor); 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            this.decimated.push(this.all_indices[i * lod_factor]);\n        }\n        dt = Date.now() - t0;\n        logging_1.logger.debug(this.glyph.model.type + \" GlyphRenderer (\" + this.model.id + \"): set_data finished in \" + dt + \"ms\");\n        this.set_data_timestamp = Date.now();\n        if (request_render) {\n            return this.request_render();\n        }\n    };\n    GlyphRendererView.prototype.render = function () {\n        var ctx, dtmap, dtmask, dtrender, dtselect, dttot, glsupport, glyph, i, indices, inspected, j, k, len, len1, lod_threshold, nonselected, nonselection_glyph, selected, selected_mask, selection_glyph, t0, tmap, tmask, trender, tselect;\n        if (!this.model.visible) {\n            return;\n        }\n        t0 = Date.now();\n        glsupport = this.glyph.glglyph;\n        tmap = Date.now();\n        this.glyph.map_data();\n        dtmap = Date.now() - t0;\n        tmask = Date.now();\n        indices = this.glyph.mask_data(this.all_indices);\n        dtmask = Date.now() - tmask;\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        selected = this.model.data_source.selected;\n        if (!selected || selected.length === 0) {\n            selected = [];\n        }\n        else {\n            if (selected['0d'].glyph) {\n                selected = indices;\n            }\n            else if (selected['1d'].indices.length > 0) {\n                selected = selected['1d'].indices;\n            }\n            else {\n                selected = [];\n            }\n        }\n        inspected = this.model.data_source.inspected;\n        if (!inspected || inspected.length === 0) {\n            inspected = [];\n        }\n        else {\n            if (inspected['0d'].glyph) {\n                inspected = indices;\n            }\n            else if (inspected['1d'].indices.length > 0) {\n                inspected = inspected['1d'].indices;\n            }\n            else {\n                inspected = [];\n            }\n        }\n        lod_threshold = this.plot_model.plot.lod_threshold;\n        if (this.plot_view.interactive && !glsupport && (lod_threshold != null) && this.all_indices.length > lod_threshold) {\n            indices = this.decimated;\n            glyph = this.decimated_glyph;\n            nonselection_glyph = this.decimated_glyph;\n            selection_glyph = this.selection_glyph;\n        }\n        else {\n            glyph = this.model.muted && (this.muted_glyph != null) ? this.muted_glyph : this.glyph;\n            nonselection_glyph = this.nonselection_glyph;\n            selection_glyph = this.selection_glyph;\n        }\n        if ((this.hover_glyph != null) && inspected.length) {\n            indices = array_1.difference(indices, inspected);\n        }\n        if (!(selected.length && this.have_selection_glyphs())) {\n            trender = Date.now();\n            glyph.render(ctx, indices, this.glyph);\n            if (this.hover_glyph && inspected.length) {\n                this.hover_glyph.render(ctx, inspected, this.glyph);\n            }\n            dtrender = Date.now() - trender;\n        }\n        else {\n            tselect = Date.now();\n            selected_mask = {};\n            for (j = 0, len = selected.length; j < len; j++) {\n                i = selected[j];\n                selected_mask[i] = true;\n            }\n            selected = new Array();\n            nonselected = new Array();\n            for (k = 0, len1 = indices.length; k < len1; k++) {\n                i = indices[k];\n                if (selected_mask[i] != null) {\n                    selected.push(i);\n                }\n                else {\n                    nonselected.push(i);\n                }\n            }\n            dtselect = Date.now() - tselect;\n            trender = Date.now();\n            nonselection_glyph.render(ctx, nonselected, this.glyph);\n            selection_glyph.render(ctx, selected, this.glyph);\n            if (this.hover_glyph != null) {\n                this.hover_glyph.render(ctx, inspected, this.glyph);\n            }\n            dtrender = Date.now() - trender;\n        }\n        this.last_dtrender = dtrender;\n        dttot = Date.now() - t0;\n        logging_1.logger.debug(this.glyph.model.type + \" GlyphRenderer (\" + this.model.id + \"): render finished in \" + dttot + \"ms\");\n        logging_1.logger.trace(\" - map_data finished in       : \" + dtmap + \"ms\");\n        if (dtmask != null) {\n            logging_1.logger.trace(\" - mask_data finished in      : \" + dtmask + \"ms\");\n        }\n        if (dtselect != null) {\n            logging_1.logger.trace(\" - selection mask finished in : \" + dtselect + \"ms\");\n        }\n        logging_1.logger.trace(\" - glyph renders finished in  : \" + dtrender + \"ms\");\n        return ctx.restore();\n    };\n    GlyphRendererView.prototype.map_to_screen = function (x, y) {\n        return this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);\n    };\n    GlyphRendererView.prototype.draw_legend = function (ctx, x0, x1, y0, y1, field, label) {\n        var index;\n        index = this.model.get_reference_point(field, label);\n        return this.glyph.draw_legend_for_index(ctx, x0, x1, y0, y1, index);\n    };\n    GlyphRendererView.prototype.hit_test = function (geometry) {\n        return this.model.hit_test_helper(geometry, this.glyph);\n    };\n    return GlyphRendererView;\n})(renderer_1.RendererView);\nexports.GlyphRenderer = (function (superClass) {\n    extend1(GlyphRenderer, superClass);\n    function GlyphRenderer() {\n        return GlyphRenderer.__super__.constructor.apply(this, arguments);\n    }\n    GlyphRenderer.prototype.default_view = exports.GlyphRendererView;\n    GlyphRenderer.prototype.type = 'GlyphRenderer';\n    GlyphRenderer.prototype.get_reference_point = function (field, value) {\n        var data, i, index;\n        index = 0;\n        if ((field != null) && (this.data_source.get_column != null)) {\n            data = this.data_source.get_column(field);\n            if (data) {\n                i = data.indexOf(value);\n                if (i > 0) {\n                    index = i;\n                }\n            }\n        }\n        return index;\n    };\n    GlyphRenderer.prototype.hit_test_helper = function (geometry, glyph) {\n        if (this.visible) {\n            return glyph.hit_test(geometry);\n        }\n        else {\n            return null;\n        }\n    };\n    GlyphRenderer.define({\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default'],\n        data_source: [p.Instance],\n        glyph: [p.Instance],\n        hover_glyph: [p.Instance],\n        nonselection_glyph: [p.Any, 'auto'],\n        selection_glyph: [p.Any, 'auto'],\n        muted_glyph: [p.Instance],\n        muted: [p.Bool, false]\n    });\n    GlyphRenderer.override({\n        level: 'glyph'\n    });\n    GlyphRenderer.prototype.selection_defaults = {\n        fill: {},\n        line: {}\n    };\n    GlyphRenderer.prototype.decimated_defaults = {\n        fill: {\n            fill_alpha: 0.3,\n            fill_color: \"grey\"\n        },\n        line: {\n            line_alpha: 0.3,\n            line_color: \"grey\"\n        }\n    };\n    GlyphRenderer.prototype.nonselection_defaults = {\n        fill: {\n            fill_alpha: 0.2,\n            line_alpha: 0.2\n        },\n        line: {}\n    };\n    return GlyphRenderer;\n})(renderer_1.Renderer);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar renderer_1 = require(\"./renderer\");\nvar p = require(\"core/properties\");\nexports.GuideRenderer = (function (superClass) {\n    extend(GuideRenderer, superClass);\n    function GuideRenderer() {\n        return GuideRenderer.__super__.constructor.apply(this, arguments);\n    }\n    GuideRenderer.prototype.type = 'GuideRenderer';\n    GuideRenderer.define({\n        plot: [p.Instance]\n    });\n    GuideRenderer.override({\n        level: 'overlay'\n    });\n    return GuideRenderer;\n})(renderer_1.Renderer);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar glyph_renderer_1 = require(\"./glyph_renderer\");\nexports.GlyphRenderer = glyph_renderer_1.GlyphRenderer;\nvar guide_renderer_1 = require(\"./guide_renderer\");\nexports.GuideRenderer = guide_renderer_1.GuideRenderer;\nvar renderer_1 = require(\"./renderer\");\nexports.Renderer = renderer_1.Renderer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar dom_view_1 = require(\"core/dom_view\");\nvar visuals_1 = require(\"core/visuals\");\nvar p = require(\"core/properties\");\nvar proj = require(\"core/util/projections\");\nvar object_1 = require(\"core/util/object\");\nvar model_1 = require(\"../../model\");\nexports.RendererView = (function (superClass) {\n    extend1(RendererView, superClass);\n    function RendererView() {\n        return RendererView.__super__.constructor.apply(this, arguments);\n    }\n    RendererView.prototype.initialize = function (options) {\n        RendererView.__super__.initialize.call(this, options);\n        this.plot_view = options.plot_view;\n        this.visuals = new visuals_1.Visuals(this.model);\n        return this._has_finished = true;\n    };\n    RendererView.getters({\n        plot_model: function () {\n            return this.plot_view.model;\n        }\n    });\n    RendererView.prototype.request_render = function () {\n        return this.plot_view.request_render();\n    };\n    RendererView.prototype.set_data = function (source) {\n        var data, ref, ref1;\n        data = this.model.materialize_dataspecs(source);\n        object_1.extend(this, data);\n        if (this.plot_model.use_map) {\n            if (this._x != null) {\n                ref = proj.project_xy(this._x, this._y), this._x = ref[0], this._y = ref[1];\n            }\n            if (this._xs != null) {\n                return ref1 = proj.project_xsys(this._xs, this._ys), this._xs = ref1[0], this._ys = ref1[1], ref1;\n            }\n        }\n    };\n    RendererView.prototype.map_to_screen = function (x, y) {\n        return this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);\n    };\n    return RendererView;\n})(dom_view_1.DOMView);\nexports.Renderer = (function (superClass) {\n    extend1(Renderer, superClass);\n    function Renderer() {\n        return Renderer.__super__.constructor.apply(this, arguments);\n    }\n    Renderer.prototype.type = \"Renderer\";\n    Renderer.define({\n        level: [p.RenderLevel, null],\n        visible: [p.Bool, true]\n    });\n    return Renderer;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar linear_scale_1 = require(\"./linear_scale\");\nvar types_1 = require(\"core/util/types\");\nexports.CategoricalScale = (function (superClass) {\n    extend(CategoricalScale, superClass);\n    function CategoricalScale() {\n        return CategoricalScale.__super__.constructor.apply(this, arguments);\n    }\n    CategoricalScale.prototype.type = \"CategoricalScale\";\n    CategoricalScale.prototype.compute = function (x, return_synthetic) {\n        var factor, factors, percent, range, ref, result;\n        if (return_synthetic == null) {\n            return_synthetic = false;\n        }\n        if (types_1.isNumber(x)) {\n            if (return_synthetic) {\n                return x;\n            }\n            else {\n                return CategoricalScale.__super__.compute.call(this, x);\n            }\n        }\n        range = this.source_range;\n        factors = range.factors;\n        if (x.indexOf(':') >= 0) {\n            ref = x.split(':'), factor = ref[0], percent = ref[1];\n            percent = parseFloat(percent);\n            result = factors.indexOf(factor) + 0.5 + range.offset + percent;\n        }\n        else {\n            result = factors.indexOf(x) + 1 + range.offset;\n        }\n        if (return_synthetic) {\n            return result;\n        }\n        else {\n            return CategoricalScale.__super__.compute.call(this, result);\n        }\n    };\n    CategoricalScale.prototype.v_compute = function (xs, return_synthetic) {\n        var factor, factors, i, j, percent, range, ref, ref1, results, x;\n        if (return_synthetic == null) {\n            return_synthetic = false;\n        }\n        if (types_1.isNumber(xs[0])) {\n            if (return_synthetic) {\n                return xs;\n            }\n            else {\n                return CategoricalScale.__super__.v_compute.call(this, xs);\n            }\n        }\n        range = this.source_range;\n        factors = range.factors;\n        results = Array(xs.length);\n        for (i = j = 0, ref = xs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            x = xs[i];\n            if (x.indexOf(':') >= 0) {\n                ref1 = x.split(':'), factor = ref1[0], percent = ref1[1];\n                percent = parseFloat(percent);\n                results[i] = factors.indexOf(factor) + 0.5 + range.offset + percent;\n            }\n            else {\n                results[i] = factors.indexOf(x) + 1 + range.offset;\n            }\n        }\n        if (return_synthetic) {\n            return results;\n        }\n        else {\n            return CategoricalScale.__super__.v_compute.call(this, results);\n        }\n    };\n    CategoricalScale.prototype.invert = function (xprime, skip_cat) {\n        var factors, range;\n        if (skip_cat == null) {\n            skip_cat = false;\n        }\n        xprime = CategoricalScale.__super__.invert.call(this, xprime);\n        if (skip_cat) {\n            return xprime;\n        }\n        range = this.source_range;\n        factors = range.factors;\n        return factors[Math.floor(xprime - 0.5 - range.offset)];\n    };\n    CategoricalScale.prototype.v_invert = function (xprimes, skip_cat) {\n        var factors, i, j, k, range, ref, ref1, result, x;\n        if (skip_cat == null) {\n            skip_cat = false;\n        }\n        x = CategoricalScale.__super__.v_invert.call(this, xprimes);\n        for (i = j = 0, ref = x.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            x[i] = x[i];\n        }\n        if (skip_cat) {\n            return x;\n        }\n        result = Array(x);\n        range = this.source_range;\n        factors = range.factors;\n        for (i = k = 0, ref1 = xprimes.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n            result[i] = factors[Math.floor(x[i] - 0.5 - range.offset)];\n        }\n        return result;\n    };\n    return CategoricalScale;\n})(linear_scale_1.LinearScale);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar categorical_scale_1 = require(\"./categorical_scale\");\nexports.CategoricalScale = categorical_scale_1.CategoricalScale;\nvar linear_scale_1 = require(\"./linear_scale\");\nexports.LinearScale = linear_scale_1.LinearScale;\nvar log_scale_1 = require(\"./log_scale\");\nexports.LogScale = log_scale_1.LogScale;\nvar scale_1 = require(\"./scale\");\nexports.Scale = scale_1.Scale;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar scale_1 = require(\"./scale\");\nvar p = require(\"core/properties\");\nexports.LinearScale = (function (superClass) {\n    extend(LinearScale, superClass);\n    function LinearScale() {\n        return LinearScale.__super__.constructor.apply(this, arguments);\n    }\n    LinearScale.prototype.type = \"LinearScale\";\n    LinearScale.prototype.compute = function (x) {\n        var factor, offset, ref;\n        ref = this._compute_state(), factor = ref[0], offset = ref[1];\n        return factor * x + offset;\n    };\n    LinearScale.prototype.v_compute = function (xs) {\n        var factor, i, idx, len, offset, ref, result, x;\n        ref = this._compute_state(), factor = ref[0], offset = ref[1];\n        result = new Float64Array(xs.length);\n        for (idx = i = 0, len = xs.length; i < len; idx = ++i) {\n            x = xs[idx];\n            result[idx] = factor * x + offset;\n        }\n        return result;\n    };\n    LinearScale.prototype.invert = function (xprime) {\n        var factor, offset, ref;\n        ref = this._compute_state(), factor = ref[0], offset = ref[1];\n        return (xprime - offset) / factor;\n    };\n    LinearScale.prototype.v_invert = function (xprimes) {\n        var factor, i, idx, len, offset, ref, result, xprime;\n        ref = this._compute_state(), factor = ref[0], offset = ref[1];\n        result = new Float64Array(xprimes.length);\n        for (idx = i = 0, len = xprimes.length; i < len; idx = ++i) {\n            xprime = xprimes[idx];\n            result[idx] = (xprime - offset) / factor;\n        }\n        return result;\n    };\n    LinearScale.prototype._compute_state = function () {\n        var factor, offset, source_end, source_start, target_end, target_start;\n        source_start = this.source_range.start;\n        source_end = this.source_range.end;\n        target_start = this.target_range.start;\n        target_end = this.target_range.end;\n        factor = (target_end - target_start) / (source_end - source_start);\n        offset = -(factor * source_start) + target_start;\n        return [factor, offset];\n    };\n    LinearScale.internal({\n        source_range: [p.Any],\n        target_range: [p.Any]\n    });\n    return LinearScale;\n})(scale_1.Scale);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar scale_1 = require(\"./scale\");\nvar p = require(\"core/properties\");\nexports.LogScale = (function (superClass) {\n    extend(LogScale, superClass);\n    function LogScale() {\n        return LogScale.__super__.constructor.apply(this, arguments);\n    }\n    LogScale.prototype.type = \"LogScale\";\n    LogScale.prototype.compute = function (x) {\n        var _x, factor, inter_factor, inter_offset, offset, ref, value;\n        ref = this._compute_state(), factor = ref[0], offset = ref[1], inter_factor = ref[2], inter_offset = ref[3];\n        if (inter_factor === 0) {\n            value = 0;\n        }\n        else {\n            _x = (Math.log(x) - inter_offset) / inter_factor;\n            if (isFinite(_x)) {\n                value = _x * factor + offset;\n            }\n            else {\n                value = 0 / 0;\n            }\n        }\n        return value;\n    };\n    LogScale.prototype.v_compute = function (xs) {\n        var _x, factor, i, inter_factor, inter_offset, j, k, offset, ref, ref1, ref2, result, value;\n        ref = this._compute_state(), factor = ref[0], offset = ref[1], inter_factor = ref[2], inter_offset = ref[3];\n        result = new Float64Array(xs.length);\n        if (inter_factor === 0) {\n            for (i = j = 0, ref1 = xs.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n                result[i] = 0;\n            }\n        }\n        else {\n            for (i = k = 0, ref2 = xs.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {\n                _x = (Math.log(xs[i]) - inter_offset) / inter_factor;\n                if (isFinite(_x)) {\n                    value = _x * factor + offset;\n                }\n                else {\n                    value = 0 / 0;\n                }\n                result[i] = value;\n            }\n        }\n        return result;\n    };\n    LogScale.prototype.invert = function (xprime) {\n        var factor, inter_factor, inter_offset, offset, ref, value;\n        ref = this._compute_state(), factor = ref[0], offset = ref[1], inter_factor = ref[2], inter_offset = ref[3];\n        value = (xprime - offset) / factor;\n        return Math.exp(inter_factor * value + inter_offset);\n    };\n    LogScale.prototype.v_invert = function (xprimes) {\n        var factor, i, inter_factor, inter_offset, j, offset, ref, ref1, result, value;\n        ref = this._compute_state(), factor = ref[0], offset = ref[1], inter_factor = ref[2], inter_offset = ref[3];\n        result = new Float64Array(xprimes.length);\n        for (i = j = 0, ref1 = xprimes.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n            value = (xprimes[i] - offset) / factor;\n            result[i] = Math.exp(inter_factor * value + inter_offset);\n        }\n        return result;\n    };\n    LogScale.prototype._get_safe_factor = function (orig_start, orig_end) {\n        var end, log_val, ref, start;\n        if (orig_start < 0) {\n            start = 0;\n        }\n        else {\n            start = orig_start;\n        }\n        if (orig_end < 0) {\n            end = 0;\n        }\n        else {\n            end = orig_end;\n        }\n        if (start === end) {\n            if (start === 0) {\n                ref = [1, 10], start = ref[0], end = ref[1];\n            }\n            else {\n                log_val = Math.log(start) / Math.log(10);\n                start = Math.pow(10, Math.floor(log_val));\n                if (Math.ceil(log_val) !== Math.floor(log_val)) {\n                    end = Math.pow(10, Math.ceil(log_val));\n                }\n                else {\n                    end = Math.pow(10, Math.ceil(log_val) + 1);\n                }\n            }\n        }\n        return [start, end];\n    };\n    LogScale.prototype._compute_state = function () {\n        var end, factor, inter_factor, inter_offset, offset, ref, screen_range, source_end, source_start, start, target_end, target_start;\n        source_start = this.source_range.start;\n        source_end = this.source_range.end;\n        target_start = this.target_range.start;\n        target_end = this.target_range.end;\n        screen_range = target_end - target_start;\n        ref = this._get_safe_factor(source_start, source_end), start = ref[0], end = ref[1];\n        if (start === 0) {\n            inter_factor = Math.log(end);\n            inter_offset = 0;\n        }\n        else {\n            inter_factor = Math.log(end) - Math.log(start);\n            inter_offset = Math.log(start);\n        }\n        factor = screen_range;\n        offset = target_start;\n        return [factor, offset, inter_factor, inter_offset];\n    };\n    LogScale.internal({\n        source_range: [p.Any],\n        target_range: [p.Any]\n    });\n    return LogScale;\n})(scale_1.Scale);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, slice = [].slice;\nvar transforms_1 = require(\"../transforms\");\nexports.Scale = (function (superClass) {\n    extend(Scale, superClass);\n    function Scale() {\n        return Scale.__super__.constructor.apply(this, arguments);\n    }\n    Scale.prototype.map_to_target = function () {\n        var rest, x;\n        x = arguments[0], rest = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n        return this.compute.apply(this, [x].concat(slice.call(rest)));\n    };\n    Scale.prototype.v_map_to_target = function () {\n        var rest, xs;\n        xs = arguments[0], rest = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n        return this.v_compute.apply(this, [xs].concat(slice.call(rest)));\n    };\n    Scale.prototype.map_from_target = function (xprime) {\n        return this.invert(xprime);\n    };\n    Scale.prototype.v_map_from_target = function (xprimes) {\n        return this.v_invert(xprimes);\n    };\n    return Scale;\n})(transforms_1.Transform);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar remote_data_source_1 = require(\"./remote_data_source\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nexports.AjaxDataSource = (function (superClass) {\n    extend(AjaxDataSource, superClass);\n    function AjaxDataSource() {\n        this.get_data = bind(this.get_data, this);\n        this.setup = bind(this.setup, this);\n        this.destroy = bind(this.destroy, this);\n        return AjaxDataSource.__super__.constructor.apply(this, arguments);\n    }\n    AjaxDataSource.prototype.type = 'AjaxDataSource';\n    AjaxDataSource.define({\n        mode: [p.String, 'replace'],\n        content_type: [p.String, 'application/json'],\n        http_headers: [p.Any, {}],\n        max_size: [p.Number],\n        method: [p.String, 'POST'],\n        if_modified: [p.Bool, false]\n    });\n    AjaxDataSource.prototype.destroy = function () {\n        if (this.interval != null) {\n            return clearInterval(this.interval);\n        }\n    };\n    AjaxDataSource.prototype.setup = function (plot_view, glyph) {\n        this.pv = plot_view;\n        this.get_data(this.mode);\n        if (this.polling_interval) {\n            return this.interval = setInterval(this.get_data, this.polling_interval, this.mode, this.max_size, this.if_modified);\n        }\n    };\n    AjaxDataSource.prototype.get_data = function (mode, max_size, if_modified) {\n        var name, ref, value, xhr;\n        if (max_size == null) {\n            max_size = 0;\n        }\n        if (if_modified == null) {\n            if_modified = false;\n        }\n        xhr = new XMLHttpRequest();\n        xhr.open(this.method, this.data_url, true);\n        xhr.withCredentials = false;\n        xhr.setRequestHeader(\"Content-Type\", this.content_type);\n        ref = this.http_headers;\n        for (name in ref) {\n            value = ref[name];\n            xhr.setRequestHeader(name, value);\n        }\n        xhr.addEventListener(\"load\", (function (_this) {\n            return function () {\n                var column, data, i, len, original_data, ref1;\n                if (xhr.status === 200) {\n                    data = JSON.parse(xhr.responseText);\n                    switch (mode) {\n                        case 'replace':\n                            return _this.data = data;\n                        case 'append':\n                            original_data = _this.data;\n                            ref1 = _this.columns();\n                            for (i = 0, len = ref1.length; i < len; i++) {\n                                column = ref1[i];\n                                data[column] = original_data[column].concat(data[column]).slice(-max_size);\n                            }\n                            return _this.data = data;\n                    }\n                }\n            };\n        })(this));\n        xhr.addEventListener(\"error\", (function (_this) {\n            return function () {\n                return logging_1.logger.error(\"Failed to fetch JSON from \" + _this.data_url + \" with code \" + xhr.status);\n            };\n        })(this));\n        xhr.send();\n        return null;\n    };\n    return AjaxDataSource;\n})(remote_data_source_1.RemoteDataSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar columnar_data_source_1 = require(\"./columnar_data_source\");\nvar has_props_1 = require(\"core/has_props\");\nvar p = require(\"core/properties\");\nvar data_structures_1 = require(\"core/util/data_structures\");\nvar serialization = require(\"core/util/serialization\");\nvar types_1 = require(\"core/util/types\");\nexports.concat_typed_arrays = function (a, b) {\n    var c;\n    c = new a.constructor(a.length + b.length);\n    c.set(a, 0);\n    c.set(b, a.length);\n    return c;\n};\nexports.stream_to_column = function (col, new_col, rollover) {\n    var end, i, l, m, ref, ref1, ref2, start, tmp, total_len;\n    if (col.concat != null) {\n        col = col.concat(new_col);\n        if (col.length > rollover) {\n            col = col.slice(-rollover);\n        }\n        return col;\n    }\n    total_len = col.length + new_col.length;\n    if ((rollover != null) && total_len > rollover) {\n        start = total_len - rollover;\n        end = col.length;\n        if (col.length < rollover) {\n            tmp = new col.constructor(rollover);\n            tmp.set(col, 0);\n            col = tmp;\n        }\n        for (i = l = ref = start, ref1 = end; ref <= ref1 ? l < ref1 : l > ref1; i = ref <= ref1 ? ++l : --l) {\n            col[i - start] = col[i];\n        }\n        for (i = m = 0, ref2 = new_col.length; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {\n            col[i + (end - start)] = new_col[i];\n        }\n        return col;\n    }\n    tmp = new col.constructor(new_col);\n    return exports.concat_typed_arrays(col, tmp);\n};\nexports.slice = function (ind, length) {\n    var ref, ref1, ref2, ref3, start, step, stop;\n    if (types_1.isObject(ind)) {\n        return [(ref = ind.start) != null ? ref : 0, (ref1 = ind.stop) != null ? ref1 : length, (ref2 = ind.step) != null ? ref2 : 1];\n    }\n    return ref3 = [ind, ind + 1, 1], start = ref3[0], stop = ref3[1], step = ref3[2], ref3;\n};\nexports.patch_to_column = function (col, patch, shapes) {\n    var flat_index, i, ind, istart, istep, istop, item, j, jstart, jstep, jstop, l, len, m, n, patched, patched_range, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, shape, value;\n    patched = new data_structures_1.Set();\n    patched_range = false;\n    for (l = 0, len = patch.length; l < len; l++) {\n        ref = patch[l], ind = ref[0], value = ref[1];\n        if (!types_1.isArray(ind)) {\n            if (types_1.isNumber(ind)) {\n                value = [value];\n                patched.push(ind);\n            }\n            else {\n                patched_range = true;\n            }\n            ind = [0, 0, ind];\n            shape = [1, col.length];\n            item = col;\n        }\n        else {\n            patched.push(ind[0]);\n            shape = shapes[ind[0]];\n            item = col[ind[0]];\n        }\n        if (ind.length === 2) {\n            shape = [1, shape[0]];\n            ind = [ind[0], 0, ind[1]];\n        }\n        flat_index = 0;\n        ref1 = exports.slice(ind[1], shape[0]), istart = ref1[0], istop = ref1[1], istep = ref1[2];\n        ref2 = exports.slice(ind[2], shape[1]), jstart = ref2[0], jstop = ref2[1], jstep = ref2[2];\n        for (i = m = ref3 = istart, ref4 = istop, ref5 = istep; ref5 > 0 ? m < ref4 : m > ref4; i = m += ref5) {\n            for (j = n = ref6 = jstart, ref7 = jstop, ref8 = jstep; ref8 > 0 ? n < ref7 : n > ref7; j = n += ref8) {\n                if (patched_range) {\n                    patched.push(j);\n                }\n                item[i * shape[1] + j] = value[flat_index];\n                flat_index++;\n            }\n        }\n    }\n    return patched;\n};\nexports.ColumnDataSource = (function (superClass) {\n    extend(ColumnDataSource, superClass);\n    function ColumnDataSource() {\n        return ColumnDataSource.__super__.constructor.apply(this, arguments);\n    }\n    ColumnDataSource.prototype.type = 'ColumnDataSource';\n    ColumnDataSource.prototype.initialize = function (options) {\n        var ref;\n        ColumnDataSource.__super__.initialize.call(this, options);\n        return ref = serialization.decode_column_data(this.data), this.data = ref[0], this._shapes = ref[1], ref;\n    };\n    ColumnDataSource.define({\n        data: [p.Any, {}]\n    });\n    ColumnDataSource.prototype.attributes_as_json = function (include_defaults, value_to_json) {\n        var attrs, key, ref, value;\n        if (include_defaults == null) {\n            include_defaults = true;\n        }\n        if (value_to_json == null) {\n            value_to_json = ColumnDataSource._value_to_json;\n        }\n        attrs = {};\n        ref = this.serializable_attributes();\n        for (key in ref) {\n            if (!hasProp.call(ref, key))\n                continue;\n            value = ref[key];\n            if (key === 'data') {\n                value = serialization.encode_column_data(value, this._shapes);\n            }\n            if (include_defaults) {\n                attrs[key] = value;\n            }\n            else if (key in this._set_after_defaults) {\n                attrs[key] = value;\n            }\n        }\n        return value_to_json(\"attributes\", attrs, this);\n    };\n    ColumnDataSource._value_to_json = function (key, value, optional_parent_object) {\n        if (types_1.isObject(value) && key === 'data') {\n            return serialization.encode_column_data(value, optional_parent_object._shapes);\n        }\n        else {\n            return has_props_1.HasProps._value_to_json(key, value, optional_parent_object);\n        }\n    };\n    ColumnDataSource.prototype.stream = function (new_data, rollover) {\n        var data, k, v;\n        data = this.data;\n        for (k in new_data) {\n            v = new_data[k];\n            data[k] = exports.stream_to_column(data[k], new_data[k], rollover);\n        }\n        this.setv('data', data, {\n            silent: true\n        });\n        return this.streaming.emit();\n    };\n    ColumnDataSource.prototype.patch = function (patches) {\n        var data, k, patch, patched;\n        data = this.data;\n        patched = new data_structures_1.Set();\n        for (k in patches) {\n            patch = patches[k];\n            patched = patched.union(exports.patch_to_column(data[k], patch, this._shapes[k]));\n        }\n        this.setv('data', data, {\n            silent: true\n        });\n        return this.patching.emit(patched.values);\n    };\n    return ColumnDataSource;\n})(columnar_data_source_1.ColumnarDataSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar data_source_1 = require(\"./data_source\");\nvar signaling_1 = require(\"core/signaling\");\nvar logging_1 = require(\"core/logging\");\nvar selection_manager_1 = require(\"core/selection_manager\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nexports.ColumnarDataSource = (function (superClass) {\n    extend(ColumnarDataSource, superClass);\n    function ColumnarDataSource() {\n        return ColumnarDataSource.__super__.constructor.apply(this, arguments);\n    }\n    ColumnarDataSource.prototype.type = 'ColumnarDataSource';\n    ColumnarDataSource.define({\n        column_names: [p.Array, []]\n    });\n    ColumnarDataSource.internal({\n        selection_manager: [\n            p.Instance, function (self) {\n                return new selection_manager_1.SelectionManager({\n                    source: self\n                });\n            }\n        ],\n        inspected: [p.Any],\n        _shapes: [p.Any, {}]\n    });\n    ColumnarDataSource.prototype.initialize = function (options) {\n        ColumnarDataSource.__super__.initialize.call(this, options);\n        this.select = new signaling_1.Signal(this, \"select\");\n        this.inspect = new signaling_1.Signal(this, \"inspect\");\n        this.streaming = new signaling_1.Signal(this, \"streaming\");\n        return this.patching = new signaling_1.Signal(this, \"patching\");\n    };\n    ColumnarDataSource.prototype.get_column = function (colname) {\n        var ref;\n        return (ref = this.data[colname]) != null ? ref : null;\n    };\n    ColumnarDataSource.prototype.columns = function () {\n        return Object.keys(this.data);\n    };\n    ColumnarDataSource.prototype.get_length = function (soft) {\n        var _key, lengths, msg, val;\n        if (soft == null) {\n            soft = true;\n        }\n        lengths = array_1.uniq((function () {\n            var ref, results;\n            ref = this.data;\n            results = [];\n            for (_key in ref) {\n                val = ref[_key];\n                results.push(val.length);\n            }\n            return results;\n        }).call(this));\n        switch (lengths.length) {\n            case 0:\n                return null;\n            case 1:\n                return lengths[0];\n            default:\n                msg = \"data source has columns of inconsistent lengths\";\n                if (soft) {\n                    logging_1.logger.warn(msg);\n                    return lengths.sort()[0];\n                }\n                else {\n                    throw new Error(msg);\n                }\n        }\n    };\n    return ColumnarDataSource;\n})(data_source_1.DataSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.DataSource = (function (superClass) {\n    extend(DataSource, superClass);\n    function DataSource() {\n        return DataSource.__super__.constructor.apply(this, arguments);\n    }\n    DataSource.prototype.type = 'DataSource';\n    DataSource.define({\n        selected: [p.Any, hittest.create_hit_test_result()],\n        callback: [p.Any]\n    });\n    DataSource.prototype.initialize = function (options) {\n        DataSource.__super__.initialize.call(this, options);\n        return this.connect(this.properties.selected.change, (function (_this) {\n            return function () {\n                var callback;\n                callback = _this.callback;\n                if (callback != null) {\n                    if (types_1.isFunction(callback)) {\n                        return callback(_this);\n                    }\n                    else {\n                        return callback.execute(_this);\n                    }\n                }\n            };\n        })(this));\n    };\n    return DataSource;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar columnar_data_source_1 = require(\"./columnar_data_source\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nexports.GeoJSONDataSource = (function (superClass) {\n    extend(GeoJSONDataSource, superClass);\n    function GeoJSONDataSource() {\n        return GeoJSONDataSource.__super__.constructor.apply(this, arguments);\n    }\n    GeoJSONDataSource.prototype.type = 'GeoJSONDataSource';\n    GeoJSONDataSource.define({\n        geojson: [p.Any]\n    });\n    GeoJSONDataSource.internal({\n        data: [p.Any, {}]\n    });\n    GeoJSONDataSource.prototype.initialize = function (options) {\n        GeoJSONDataSource.__super__.initialize.call(this, options);\n        this._update_data();\n        return this.connect(this.properties.geojson.change, (function (_this) {\n            return function () {\n                return _this._update_data();\n            };\n        })(this));\n    };\n    GeoJSONDataSource.prototype._update_data = function () {\n        return this.data = this.geojson_to_column_data();\n    };\n    GeoJSONDataSource.prototype._get_new_list_array = function (length) {\n        var i, k, ref, results;\n        results = [];\n        for (i = k = 0, ref = length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            results.push([]);\n        }\n        return results;\n    };\n    GeoJSONDataSource.prototype._get_new_nan_array = function (length) {\n        var i, k, ref, results;\n        results = [];\n        for (i = k = 0, ref = length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            results.push(0 / 0);\n        }\n        return results;\n    };\n    GeoJSONDataSource.prototype._flatten_function = function (accumulator, currentItem) {\n        return accumulator.concat([[0 / 0, 0 / 0, 0 / 0]]).concat(currentItem);\n    };\n    GeoJSONDataSource.prototype._add_properties = function (item, data, i, item_count) {\n        var property, results;\n        results = [];\n        for (property in item.properties) {\n            if (!data.hasOwnProperty(property)) {\n                data[property] = this._get_new_nan_array(item_count);\n            }\n            results.push(data[property][i] = item.properties[property]);\n        }\n        return results;\n    };\n    GeoJSONDataSource.prototype._add_geometry = function (geometry, data, i) {\n        var coord_list, coords, exterior_ring, exterior_rings, flattened_coord_list, j, k, l, len, len1, len2, len3, len4, m, n, o, polygon, ref, ref1, ref2, ref3, ref4, ref5, results, results1, results2, results3;\n        switch (geometry.type) {\n            case \"Point\":\n                coords = geometry.coordinates;\n                data.x[i] = coords[0];\n                data.y[i] = coords[1];\n                return data.z[i] = (ref = coords[2]) != null ? ref : 0 / 0;\n            case \"LineString\":\n                coord_list = geometry.coordinates;\n                results = [];\n                for (j = k = 0, len = coord_list.length; k < len; j = ++k) {\n                    coords = coord_list[j];\n                    data.xs[i][j] = coords[0];\n                    data.ys[i][j] = coords[1];\n                    results.push(data.zs[i][j] = (ref1 = coords[2]) != null ? ref1 : 0 / 0);\n                }\n                return results;\n                break;\n            case \"Polygon\":\n                if (geometry.coordinates.length > 1) {\n                    logging_1.logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');\n                }\n                exterior_ring = geometry.coordinates[0];\n                results1 = [];\n                for (j = l = 0, len1 = exterior_ring.length; l < len1; j = ++l) {\n                    coords = exterior_ring[j];\n                    data.xs[i][j] = coords[0];\n                    data.ys[i][j] = coords[1];\n                    results1.push(data.zs[i][j] = (ref2 = coords[2]) != null ? ref2 : 0 / 0);\n                }\n                return results1;\n                break;\n            case \"MultiPoint\":\n                return logging_1.logger.warn('MultiPoint not supported in Bokeh');\n            case \"MultiLineString\":\n                flattened_coord_list = geometry.coordinates.reduce(this._flatten_function);\n                results2 = [];\n                for (j = m = 0, len2 = flattened_coord_list.length; m < len2; j = ++m) {\n                    coords = flattened_coord_list[j];\n                    data.xs[i][j] = coords[0];\n                    data.ys[i][j] = coords[1];\n                    results2.push(data.zs[i][j] = (ref3 = coords[2]) != null ? ref3 : 0 / 0);\n                }\n                return results2;\n                break;\n            case \"MultiPolygon\":\n                exterior_rings = [];\n                ref4 = geometry.coordinates;\n                for (n = 0, len3 = ref4.length; n < len3; n++) {\n                    polygon = ref4[n];\n                    if (polygon.length > 1) {\n                        logging_1.logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');\n                    }\n                    exterior_rings.push(polygon[0]);\n                }\n                flattened_coord_list = exterior_rings.reduce(this._flatten_function);\n                results3 = [];\n                for (j = o = 0, len4 = flattened_coord_list.length; o < len4; j = ++o) {\n                    coords = flattened_coord_list[j];\n                    data.xs[i][j] = coords[0];\n                    data.ys[i][j] = coords[1];\n                    results3.push(data.zs[i][j] = (ref5 = coords[2]) != null ? ref5 : 0 / 0);\n                }\n                return results3;\n                break;\n            default:\n                throw new Error('Invalid type ' + geometry.type);\n        }\n    };\n    GeoJSONDataSource.prototype._get_items_length = function (items) {\n        var count, g, geometry, i, item, j, k, l, len, len1, ref;\n        count = 0;\n        for (i = k = 0, len = items.length; k < len; i = ++k) {\n            item = items[i];\n            geometry = item.type === 'Feature' ? item.geometry : item;\n            if (geometry.type === 'GeometryCollection') {\n                ref = geometry.geometries;\n                for (j = l = 0, len1 = ref.length; l < len1; j = ++l) {\n                    g = ref[j];\n                    count += 1;\n                }\n            }\n            else {\n                count += 1;\n            }\n        }\n        return count;\n    };\n    GeoJSONDataSource.prototype.geojson_to_column_data = function () {\n        var arr_index, data, g, geojson, geometry, i, item, item_count, items, j, k, l, len, len1, ref, ref1;\n        geojson = JSON.parse(this.geojson);\n        if ((ref = geojson.type) !== 'GeometryCollection' && ref !== 'FeatureCollection') {\n            throw new Error('Bokeh only supports type GeometryCollection and FeatureCollection at top level');\n        }\n        if (geojson.type === 'GeometryCollection') {\n            if (geojson.geometries == null) {\n                throw new Error('No geometries found in GeometryCollection');\n            }\n            if (geojson.geometries.length === 0) {\n                throw new Error('geojson.geometries must have one or more items');\n            }\n            items = geojson.geometries;\n        }\n        if (geojson.type === 'FeatureCollection') {\n            if (geojson.features == null) {\n                throw new Error('No features found in FeaturesCollection');\n            }\n            if (geojson.features.length === 0) {\n                throw new Error('geojson.features must have one or more items');\n            }\n            items = geojson.features;\n        }\n        item_count = this._get_items_length(items);\n        data = {\n            'x': this._get_new_nan_array(item_count),\n            'y': this._get_new_nan_array(item_count),\n            'z': this._get_new_nan_array(item_count),\n            'xs': this._get_new_list_array(item_count),\n            'ys': this._get_new_list_array(item_count),\n            'zs': this._get_new_list_array(item_count)\n        };\n        arr_index = 0;\n        for (i = k = 0, len = items.length; k < len; i = ++k) {\n            item = items[i];\n            geometry = item.type === 'Feature' ? item.geometry : item;\n            if (geometry.type === 'GeometryCollection') {\n                ref1 = geometry.geometries;\n                for (j = l = 0, len1 = ref1.length; l < len1; j = ++l) {\n                    g = ref1[j];\n                    this._add_geometry(g, data, arr_index);\n                    if (item.type === 'Feature') {\n                        this._add_properties(item, data, arr_index, item_count);\n                    }\n                    arr_index += 1;\n                }\n            }\n            else {\n                this._add_geometry(geometry, data, arr_index);\n                if (item.type === 'Feature') {\n                    this._add_properties(item, data, arr_index, item_count);\n                }\n                arr_index += 1;\n            }\n        }\n        return data;\n    };\n    return GeoJSONDataSource;\n})(columnar_data_source_1.ColumnarDataSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ajax_data_source_1 = require(\"./ajax_data_source\");\nexports.AjaxDataSource = ajax_data_source_1.AjaxDataSource;\nvar column_data_source_1 = require(\"./column_data_source\");\nexports.ColumnDataSource = column_data_source_1.ColumnDataSource;\nvar columnar_data_source_1 = require(\"./columnar_data_source\");\nexports.ColumnarDataSource = columnar_data_source_1.ColumnarDataSource;\nvar data_source_1 = require(\"./data_source\");\nexports.DataSource = data_source_1.DataSource;\nvar geojson_data_source_1 = require(\"./geojson_data_source\");\nexports.GeoJSONDataSource = geojson_data_source_1.GeoJSONDataSource;\nvar remote_data_source_1 = require(\"./remote_data_source\");\nexports.RemoteDataSource = remote_data_source_1.RemoteDataSource;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar column_data_source_1 = require(\"./column_data_source\");\nvar p = require(\"core/properties\");\nexports.RemoteDataSource = (function (superClass) {\n    extend(RemoteDataSource, superClass);\n    function RemoteDataSource() {\n        return RemoteDataSource.__super__.constructor.apply(this, arguments);\n    }\n    RemoteDataSource.prototype.type = 'RemoteDataSource';\n    RemoteDataSource.define({\n        data_url: [p.String],\n        polling_interval: [p.Number]\n    });\n    return RemoteDataSource;\n})(column_data_source_1.ColumnDataSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar clamp, log, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, slice = [].slice;\nvar continuous_ticker_1 = require(\"./continuous_ticker\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nclamp = function (x, min_val, max_val) {\n    return Math.max(min_val, Math.min(max_val, x));\n};\nlog = function (x, base) {\n    if (base == null) {\n        base = Math.E;\n    }\n    return Math.log(x) / Math.log(base);\n};\nexports.AdaptiveTicker = (function (superClass) {\n    extend(AdaptiveTicker, superClass);\n    function AdaptiveTicker() {\n        return AdaptiveTicker.__super__.constructor.apply(this, arguments);\n    }\n    AdaptiveTicker.prototype.type = 'AdaptiveTicker';\n    AdaptiveTicker.define({\n        base: [p.Number, 10.0],\n        mantissas: [p.Array, [1, 2, 5]],\n        min_interval: [p.Number, 0.0],\n        max_interval: [p.Number]\n    });\n    AdaptiveTicker.prototype.initialize = function (attrs, options) {\n        var prefix_mantissa, suffix_mantissa;\n        AdaptiveTicker.__super__.initialize.call(this, attrs, options);\n        prefix_mantissa = array_1.nth(this.mantissas, -1) / this.base;\n        suffix_mantissa = array_1.nth(this.mantissas, 0) * this.base;\n        this.extended_mantissas = [prefix_mantissa].concat(slice.call(this.mantissas), [suffix_mantissa]);\n        return this.base_factor = this.get_min_interval() === 0.0 ? 1.0 : this.get_min_interval();\n    };\n    AdaptiveTicker.prototype.get_interval = function (data_low, data_high, desired_n_ticks) {\n        var best_mantissa, candidate_mantissas, data_range, errors, ideal_interval, ideal_magnitude, ideal_mantissa, interval, interval_exponent;\n        data_range = data_high - data_low;\n        ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);\n        interval_exponent = Math.floor(log(ideal_interval / this.base_factor, this.base));\n        ideal_magnitude = Math.pow(this.base, interval_exponent) * this.base_factor;\n        ideal_mantissa = ideal_interval / ideal_magnitude;\n        candidate_mantissas = this.extended_mantissas;\n        errors = candidate_mantissas.map(function (mantissa) {\n            return Math.abs(desired_n_ticks - (data_range / (mantissa * ideal_magnitude)));\n        });\n        best_mantissa = candidate_mantissas[array_1.argmin(errors)];\n        interval = best_mantissa * ideal_magnitude;\n        return clamp(interval, this.get_min_interval(), this.get_max_interval());\n    };\n    return AdaptiveTicker;\n})(continuous_ticker_1.ContinuousTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar adaptive_ticker_1 = require(\"./adaptive_ticker\");\nexports.BasicTicker = (function (superClass) {\n    extend(BasicTicker, superClass);\n    function BasicTicker() {\n        return BasicTicker.__super__.constructor.apply(this, arguments);\n    }\n    BasicTicker.prototype.type = 'BasicTicker';\n    return BasicTicker;\n})(adaptive_ticker_1.AdaptiveTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar ticker_1 = require(\"./ticker\");\nexports.CategoricalTicker = (function (superClass) {\n    extend(CategoricalTicker, superClass);\n    function CategoricalTicker() {\n        return CategoricalTicker.__super__.constructor.apply(this, arguments);\n    }\n    CategoricalTicker.prototype.type = 'CategoricalTicker';\n    CategoricalTicker.prototype.get_ticks = function (start, end, range, cross_loc, arg) {\n        var desired_n_ticks, factors, i, ii, j, majors, ref;\n        desired_n_ticks = arg.desired_n_ticks;\n        majors = [];\n        factors = range.factors;\n        for (i = j = 0, ref = factors.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            ii = i + range.offset;\n            if ((ii + 1) > start && (ii + 1) < end) {\n                majors.push(factors[i]);\n            }\n        }\n        return {\n            \"major\": majors,\n            \"minor\": []\n        };\n    };\n    return CategoricalTicker;\n})(ticker_1.Ticker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar continuous_ticker_1 = require(\"./continuous_ticker\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nvar object_1 = require(\"core/util/object\");\nexports.CompositeTicker = (function (superClass) {\n    extend(CompositeTicker, superClass);\n    function CompositeTicker() {\n        return CompositeTicker.__super__.constructor.apply(this, arguments);\n    }\n    CompositeTicker.prototype.type = 'CompositeTicker';\n    CompositeTicker.define({\n        tickers: [p.Array, []]\n    });\n    CompositeTicker.getters({\n        min_intervals: function () {\n            var i, len, ref, results, ticker;\n            ref = this.tickers;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n                ticker = ref[i];\n                results.push(ticker.get_min_interval());\n            }\n            return results;\n        },\n        max_intervals: function () {\n            var i, len, ref, results, ticker;\n            ref = this.tickers;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n                ticker = ref[i];\n                results.push(ticker.get_max_interval());\n            }\n            return results;\n        },\n        min_interval: function () {\n            return this.min_intervals[0];\n        },\n        max_interval: function () {\n            return this.max_intervals[0];\n        }\n    });\n    CompositeTicker.prototype.get_best_ticker = function (data_low, data_high, desired_n_ticks) {\n        var best_index, best_ticker, best_ticker_ndx, data_range, errors, ideal_interval, intervals, ticker_ndxs;\n        data_range = data_high - data_low;\n        ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);\n        ticker_ndxs = [array_1.sortedIndex(this.min_intervals, ideal_interval) - 1, array_1.sortedIndex(this.max_intervals, ideal_interval)];\n        intervals = [this.min_intervals[ticker_ndxs[0]], this.max_intervals[ticker_ndxs[1]]];\n        errors = intervals.map(function (interval) {\n            return Math.abs(desired_n_ticks - (data_range / interval));\n        });\n        if (object_1.isEmpty(errors.filter(function (e) {\n            return !isNaN(e);\n        }))) {\n            best_ticker = this.tickers[0];\n        }\n        else {\n            best_index = array_1.argmin(errors);\n            best_ticker_ndx = ticker_ndxs[best_index];\n            best_ticker = this.tickers[best_ticker_ndx];\n        }\n        return best_ticker;\n    };\n    CompositeTicker.prototype.get_interval = function (data_low, data_high, desired_n_ticks) {\n        var best_ticker;\n        best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);\n        return best_ticker.get_interval(data_low, data_high, desired_n_ticks);\n    };\n    CompositeTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        var best_ticker, ticks;\n        best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);\n        ticks = best_ticker.get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks);\n        return ticks;\n    };\n    return CompositeTicker;\n})(continuous_ticker_1.ContinuousTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar ticker_1 = require(\"./ticker\");\nvar p = require(\"core/properties\");\nexports.ContinuousTicker = (function (superClass) {\n    extend(ContinuousTicker, superClass);\n    function ContinuousTicker() {\n        return ContinuousTicker.__super__.constructor.apply(this, arguments);\n    }\n    ContinuousTicker.prototype.type = 'ContinuousTicker';\n    ContinuousTicker.define({\n        num_minor_ticks: [p.Number, 5],\n        desired_num_ticks: [p.Number, 6]\n    });\n    ContinuousTicker.prototype.get_interval = void 0;\n    ContinuousTicker.prototype.get_min_interval = function () {\n        return this.min_interval;\n    };\n    ContinuousTicker.prototype.get_max_interval = function () {\n        var ref;\n        return (ref = this.max_interval) != null ? ref : 2e308;\n    };\n    ContinuousTicker.prototype.get_ideal_interval = function (data_low, data_high, desired_n_ticks) {\n        var data_range;\n        data_range = data_high - data_low;\n        return data_range / desired_n_ticks;\n    };\n    return ContinuousTicker;\n})(ticker_1.Ticker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ONE_HOUR, ONE_MILLI, ONE_MINUTE, ONE_MONTH, ONE_SECOND, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar array_1 = require(\"core/util/array\");\nvar adaptive_ticker_1 = require(\"./adaptive_ticker\");\nvar composite_ticker_1 = require(\"./composite_ticker\");\nvar days_ticker_1 = require(\"./days_ticker\");\nvar months_ticker_1 = require(\"./months_ticker\");\nvar years_ticker_1 = require(\"./years_ticker\");\nvar util = require(\"./util\");\nONE_MILLI = util.ONE_MILLI;\nONE_SECOND = util.ONE_SECOND;\nONE_MINUTE = util.ONE_MINUTE;\nONE_HOUR = util.ONE_HOUR;\nONE_MONTH = util.ONE_MONTH;\nexports.DatetimeTicker = (function (superClass) {\n    extend(DatetimeTicker, superClass);\n    function DatetimeTicker() {\n        return DatetimeTicker.__super__.constructor.apply(this, arguments);\n    }\n    DatetimeTicker.prototype.type = 'DatetimeTicker';\n    DatetimeTicker.override({\n        num_minor_ticks: 0,\n        tickers: function () {\n            return [\n                new adaptive_ticker_1.AdaptiveTicker({\n                    mantissas: [1, 2, 5],\n                    base: 10,\n                    min_interval: 0,\n                    max_interval: 500 * ONE_MILLI,\n                    num_minor_ticks: 0\n                }), new adaptive_ticker_1.AdaptiveTicker({\n                    mantissas: [1, 2, 5, 10, 15, 20, 30],\n                    base: 60,\n                    min_interval: ONE_SECOND,\n                    max_interval: 30 * ONE_MINUTE,\n                    num_minor_ticks: 0\n                }), new adaptive_ticker_1.AdaptiveTicker({\n                    mantissas: [1, 2, 4, 6, 8, 12],\n                    base: 24.0,\n                    min_interval: ONE_HOUR,\n                    max_interval: 12 * ONE_HOUR,\n                    num_minor_ticks: 0\n                }), new days_ticker_1.DaysTicker({\n                    days: array_1.range(1, 32)\n                }), new days_ticker_1.DaysTicker({\n                    days: array_1.range(1, 31, 3)\n                }), new days_ticker_1.DaysTicker({\n                    days: [1, 8, 15, 22]\n                }), new days_ticker_1.DaysTicker({\n                    days: [1, 15]\n                }), new months_ticker_1.MonthsTicker({\n                    months: array_1.range(0, 12, 1)\n                }), new months_ticker_1.MonthsTicker({\n                    months: array_1.range(0, 12, 2)\n                }), new months_ticker_1.MonthsTicker({\n                    months: array_1.range(0, 12, 4)\n                }), new months_ticker_1.MonthsTicker({\n                    months: array_1.range(0, 12, 6)\n                }), new years_ticker_1.YearsTicker({})\n            ];\n        }\n    });\n    return DatetimeTicker;\n})(composite_ticker_1.CompositeTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ONE_DAY, copy_date, date_range_by_month, last_month_no_later_than, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar single_interval_ticker_1 = require(\"./single_interval_ticker\");\nvar util = require(\"./util\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\ncopy_date = util.copy_date;\nlast_month_no_later_than = util.last_month_no_later_than;\nONE_DAY = util.ONE_DAY;\ndate_range_by_month = function (start_time, end_time) {\n    var date, dates, end_date, prev_end_date, start_date;\n    start_date = last_month_no_later_than(new Date(start_time));\n    end_date = last_month_no_later_than(new Date(end_time));\n    prev_end_date = copy_date(end_date);\n    end_date.setUTCMonth(end_date.getUTCMonth() + 1);\n    dates = [];\n    date = start_date;\n    while (true) {\n        dates.push(copy_date(date));\n        date.setUTCMonth(date.getUTCMonth() + 1);\n        if (date > end_date) {\n            break;\n        }\n    }\n    return dates;\n};\nexports.DaysTicker = (function (superClass) {\n    extend(DaysTicker, superClass);\n    function DaysTicker() {\n        return DaysTicker.__super__.constructor.apply(this, arguments);\n    }\n    DaysTicker.prototype.type = 'DaysTicker';\n    DaysTicker.define({\n        days: [p.Array, []]\n    });\n    DaysTicker.prototype.initialize = function (attrs, options) {\n        var days, interval;\n        attrs.num_minor_ticks = 0;\n        DaysTicker.__super__.initialize.call(this, attrs, options);\n        days = this.days;\n        interval = days.length > 1 ? (days[1] - days[0]) * ONE_DAY : 31 * ONE_DAY;\n        return this.interval = interval;\n    };\n    DaysTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        var all_ticks, date, day_date, day_dates, days, days_of_month, interval, month_dates, ticks_in_range;\n        month_dates = date_range_by_month(data_low, data_high);\n        days = this.days;\n        days_of_month = (function (_this) {\n            return function (month_date, interval) {\n                var dates, day, day_date, future_date, i, len;\n                dates = [];\n                for (i = 0, len = days.length; i < len; i++) {\n                    day = days[i];\n                    day_date = copy_date(month_date);\n                    day_date.setUTCDate(day);\n                    future_date = new Date(day_date.getTime() + (interval / 2));\n                    if (future_date.getUTCMonth() === month_date.getUTCMonth()) {\n                        dates.push(day_date);\n                    }\n                }\n                return dates;\n            };\n        })(this);\n        interval = this.interval;\n        day_dates = array_1.concat((function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = month_dates.length; i < len; i++) {\n                date = month_dates[i];\n                results.push(days_of_month(date, interval));\n            }\n            return results;\n        })());\n        all_ticks = (function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = day_dates.length; i < len; i++) {\n                day_date = day_dates[i];\n                results.push(day_date.getTime());\n            }\n            return results;\n        })();\n        ticks_in_range = all_ticks.filter(function (tick) {\n            return (data_low <= tick && tick <= data_high);\n        });\n        return {\n            \"major\": ticks_in_range,\n            \"minor\": []\n        };\n    };\n    return DaysTicker;\n})(single_interval_ticker_1.SingleIntervalTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar continuous_ticker_1 = require(\"./continuous_ticker\");\nvar p = require(\"core/properties\");\nexports.FixedTicker = (function (superClass) {\n    extend(FixedTicker, superClass);\n    function FixedTicker() {\n        return FixedTicker.__super__.constructor.apply(this, arguments);\n    }\n    FixedTicker.prototype.type = 'FixedTicker';\n    FixedTicker.define({\n        ticks: [p.Array, []]\n    });\n    FixedTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        return {\n            major: this.ticks,\n            minor: []\n        };\n    };\n    return FixedTicker;\n})(continuous_ticker_1.ContinuousTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar adaptive_ticker_1 = require(\"./adaptive_ticker\");\nexports.AdaptiveTicker = adaptive_ticker_1.AdaptiveTicker;\nvar basic_ticker_1 = require(\"./basic_ticker\");\nexports.BasicTicker = basic_ticker_1.BasicTicker;\nvar categorical_ticker_1 = require(\"./categorical_ticker\");\nexports.CategoricalTicker = categorical_ticker_1.CategoricalTicker;\nvar composite_ticker_1 = require(\"./composite_ticker\");\nexports.CompositeTicker = composite_ticker_1.CompositeTicker;\nvar continuous_ticker_1 = require(\"./continuous_ticker\");\nexports.ContinuousTicker = continuous_ticker_1.ContinuousTicker;\nvar datetime_ticker_1 = require(\"./datetime_ticker\");\nexports.DatetimeTicker = datetime_ticker_1.DatetimeTicker;\nvar days_ticker_1 = require(\"./days_ticker\");\nexports.DaysTicker = days_ticker_1.DaysTicker;\nvar fixed_ticker_1 = require(\"./fixed_ticker\");\nexports.FixedTicker = fixed_ticker_1.FixedTicker;\nvar log_ticker_1 = require(\"./log_ticker\");\nexports.LogTicker = log_ticker_1.LogTicker;\nvar mercator_ticker_1 = require(\"./mercator_ticker\");\nexports.MercatorTicker = mercator_ticker_1.MercatorTicker;\nvar months_ticker_1 = require(\"./months_ticker\");\nexports.MonthsTicker = months_ticker_1.MonthsTicker;\nvar single_interval_ticker_1 = require(\"./single_interval_ticker\");\nexports.SingleIntervalTicker = single_interval_ticker_1.SingleIntervalTicker;\nvar ticker_1 = require(\"./ticker\");\nexports.Ticker = ticker_1.Ticker;\nvar years_ticker_1 = require(\"./years_ticker\");\nexports.YearsTicker = years_ticker_1.YearsTicker;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar array_1 = require(\"core/util/array\");\nvar adaptive_ticker_1 = require(\"./adaptive_ticker\");\nexports.LogTicker = (function (superClass) {\n    extend(LogTicker, superClass);\n    function LogTicker() {\n        return LogTicker.__super__.constructor.apply(this, arguments);\n    }\n    LogTicker.prototype.type = 'LogTicker';\n    LogTicker.override({\n        mantissas: [1, 5]\n    });\n    LogTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        var base, end_factor, endlog, factor, factors, i, interval, j, k, l, len, len1, len2, len3, len4, len5, log_high, log_interval, log_low, m, minor_interval, minor_offsets, minor_ticks, n, num_minor_ticks, o, ref, start_factor, startlog, tick, ticks, x;\n        num_minor_ticks = this.num_minor_ticks;\n        minor_ticks = [];\n        base = this.base;\n        log_low = Math.log(data_low) / Math.log(base);\n        log_high = Math.log(data_high) / Math.log(base);\n        log_interval = log_high - log_low;\n        if (!isFinite(log_interval)) {\n            ticks = [];\n        }\n        else if (log_interval < 2) {\n            interval = this.get_interval(data_low, data_high, desired_n_ticks);\n            start_factor = Math.floor(data_low / interval);\n            end_factor = Math.ceil(data_high / interval);\n            factors = array_1.range(start_factor, end_factor + 1);\n            ticks = (function () {\n                var j, len, results;\n                results = [];\n                for (j = 0, len = factors.length; j < len; j++) {\n                    factor = factors[j];\n                    if (factor !== 0) {\n                        results.push(factor * interval);\n                    }\n                }\n                return results;\n            })();\n            ticks = ticks.filter(function (tick) {\n                return (data_low <= tick && tick <= data_high);\n            });\n            if (num_minor_ticks > 0 && ticks.length > 0) {\n                minor_interval = interval / num_minor_ticks;\n                minor_offsets = (function () {\n                    var j, ref, results;\n                    results = [];\n                    for (i = j = 0, ref = num_minor_ticks; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                        results.push(i * minor_interval);\n                    }\n                    return results;\n                })();\n                ref = minor_offsets.slice(1, +minor_offsets.length + 1 || 9e9);\n                for (j = 0, len = ref.length; j < len; j++) {\n                    x = ref[j];\n                    minor_ticks.push(ticks[0] - x);\n                }\n                for (k = 0, len1 = ticks.length; k < len1; k++) {\n                    tick = ticks[k];\n                    for (l = 0, len2 = minor_offsets.length; l < len2; l++) {\n                        x = minor_offsets[l];\n                        minor_ticks.push(tick + x);\n                    }\n                }\n            }\n        }\n        else {\n            startlog = Math.ceil(log_low * 0.999999);\n            endlog = Math.floor(log_high * 1.000001);\n            interval = Math.ceil((endlog - startlog) / 9.0);\n            ticks = array_1.range(startlog, endlog + 1, interval);\n            ticks = ticks.map(function (i) {\n                return Math.pow(base, i);\n            });\n            ticks = ticks.filter(function (tick) {\n                return (data_low <= tick && tick <= data_high);\n            });\n            if (num_minor_ticks > 0 && ticks.length > 0) {\n                minor_interval = Math.pow(base, interval) / num_minor_ticks;\n                minor_offsets = (function () {\n                    var m, ref1, results;\n                    results = [];\n                    for (i = m = 1, ref1 = num_minor_ticks; 1 <= ref1 ? m <= ref1 : m >= ref1; i = 1 <= ref1 ? ++m : --m) {\n                        results.push(i * minor_interval);\n                    }\n                    return results;\n                })();\n                for (m = 0, len3 = minor_offsets.length; m < len3; m++) {\n                    x = minor_offsets[m];\n                    minor_ticks.push(ticks[0] / x);\n                }\n                minor_ticks.push(ticks[0]);\n                for (n = 0, len4 = ticks.length; n < len4; n++) {\n                    tick = ticks[n];\n                    for (o = 0, len5 = minor_offsets.length; o < len5; o++) {\n                        x = minor_offsets[o];\n                        minor_ticks.push(tick * x);\n                    }\n                }\n            }\n        }\n        return {\n            major: ticks,\n            minor: minor_ticks\n        };\n    };\n    return LogTicker;\n})(adaptive_ticker_1.AdaptiveTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar basic_ticker_1 = require(\"./basic_ticker\");\nvar p = require(\"core/properties\");\nvar proj4_1 = require(\"core/util/proj4\");\nexports.MercatorTicker = (function (superClass) {\n    extend(MercatorTicker, superClass);\n    function MercatorTicker() {\n        return MercatorTicker.__super__.constructor.apply(this, arguments);\n    }\n    MercatorTicker.prototype.type = 'MercatorTicker';\n    MercatorTicker.define({\n        dimension: [p.LatLon]\n    });\n    MercatorTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        var _, i, j, k, l, lat, len, len1, len2, len3, lon, proj_cross_loc, proj_high, proj_low, proj_ticks, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, tick, ticks;\n        if (this.dimension == null) {\n            throw new Error(\"MercatorTicker.dimension not configured\");\n        }\n        if (this.dimension === \"lon\") {\n            ref = proj4_1.proj4(proj4_1.mercator).inverse([data_low, cross_loc]), proj_low = ref[0], proj_cross_loc = ref[1];\n            ref1 = proj4_1.proj4(proj4_1.mercator).inverse([data_high, cross_loc]), proj_high = ref1[0], proj_cross_loc = ref1[1];\n        }\n        else {\n            ref2 = proj4_1.proj4(proj4_1.mercator).inverse([cross_loc, data_low]), proj_cross_loc = ref2[0], proj_low = ref2[1];\n            ref3 = proj4_1.proj4(proj4_1.mercator).inverse([cross_loc, data_high]), proj_cross_loc = ref3[0], proj_high = ref3[1];\n        }\n        proj_ticks = MercatorTicker.__super__.get_ticks_no_defaults.call(this, proj_low, proj_high, cross_loc, desired_n_ticks);\n        ticks = {\n            major: [],\n            minor: []\n        };\n        if (this.dimension === \"lon\") {\n            ref4 = proj_ticks.major;\n            for (i = 0, len = ref4.length; i < len; i++) {\n                tick = ref4[i];\n                ref5 = proj4_1.proj4(proj4_1.mercator).forward([tick, proj_cross_loc]), lon = ref5[0], _ = ref5[1];\n                ticks.major.push(lon);\n            }\n            ref6 = proj_ticks.minor;\n            for (j = 0, len1 = ref6.length; j < len1; j++) {\n                tick = ref6[j];\n                ref7 = proj4_1.proj4(proj4_1.mercator).forward([tick, proj_cross_loc]), lon = ref7[0], _ = ref7[1];\n                ticks.minor.push(lon);\n            }\n        }\n        else {\n            ref8 = proj_ticks.major;\n            for (k = 0, len2 = ref8.length; k < len2; k++) {\n                tick = ref8[k];\n                ref9 = proj4_1.proj4(proj4_1.mercator).forward([proj_cross_loc, tick]), _ = ref9[0], lat = ref9[1];\n                ticks.major.push(lat);\n            }\n            ref10 = proj_ticks.minor;\n            for (l = 0, len3 = ref10.length; l < len3; l++) {\n                tick = ref10[l];\n                ref11 = proj4_1.proj4(proj4_1.mercator).forward([proj_cross_loc, tick]), _ = ref11[0], lat = ref11[1];\n                ticks.minor.push(lat);\n            }\n        }\n        return ticks;\n    };\n    return MercatorTicker;\n})(basic_ticker_1.BasicTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ONE_MONTH, copy_date, date_range_by_year, last_year_no_later_than, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar single_interval_ticker_1 = require(\"./single_interval_ticker\");\nvar util = require(\"./util\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\ncopy_date = util.copy_date;\nlast_year_no_later_than = util.last_year_no_later_than;\nONE_MONTH = util.ONE_MONTH;\ndate_range_by_year = function (start_time, end_time) {\n    var date, dates, end_date, start_date;\n    start_date = last_year_no_later_than(new Date(start_time));\n    end_date = last_year_no_later_than(new Date(end_time));\n    end_date.setUTCFullYear(end_date.getUTCFullYear() + 1);\n    dates = [];\n    date = start_date;\n    while (true) {\n        dates.push(copy_date(date));\n        date.setUTCFullYear(date.getUTCFullYear() + 1);\n        if (date > end_date) {\n            break;\n        }\n    }\n    return dates;\n};\nexports.MonthsTicker = (function (superClass) {\n    extend(MonthsTicker, superClass);\n    function MonthsTicker() {\n        return MonthsTicker.__super__.constructor.apply(this, arguments);\n    }\n    MonthsTicker.prototype.type = 'MonthsTicker';\n    MonthsTicker.define({\n        months: [p.Array, []]\n    });\n    MonthsTicker.prototype.initialize = function (attrs, options) {\n        var interval, months;\n        MonthsTicker.__super__.initialize.call(this, attrs, options);\n        months = this.months;\n        interval = months.length > 1 ? (months[1] - months[0]) * ONE_MONTH : 12 * ONE_MONTH;\n        return this.interval = interval;\n    };\n    MonthsTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        var all_ticks, date, month_date, month_dates, months, months_of_year, ticks_in_range, year_dates;\n        year_dates = date_range_by_year(data_low, data_high);\n        months = this.months;\n        months_of_year = function (year_date) {\n            return months.map(function (month) {\n                var month_date;\n                month_date = copy_date(year_date);\n                month_date.setUTCMonth(month);\n                return month_date;\n            });\n        };\n        month_dates = array_1.concat((function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = year_dates.length; i < len; i++) {\n                date = year_dates[i];\n                results.push(months_of_year(date));\n            }\n            return results;\n        })());\n        all_ticks = (function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = month_dates.length; i < len; i++) {\n                month_date = month_dates[i];\n                results.push(month_date.getTime());\n            }\n            return results;\n        })();\n        ticks_in_range = all_ticks.filter(function (tick) {\n            return (data_low <= tick && tick <= data_high);\n        });\n        return {\n            \"major\": ticks_in_range,\n            \"minor\": []\n        };\n    };\n    return MonthsTicker;\n})(single_interval_ticker_1.SingleIntervalTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar continuous_ticker_1 = require(\"./continuous_ticker\");\nvar p = require(\"core/properties\");\nexports.SingleIntervalTicker = (function (superClass) {\n    extend(SingleIntervalTicker, superClass);\n    function SingleIntervalTicker() {\n        return SingleIntervalTicker.__super__.constructor.apply(this, arguments);\n    }\n    SingleIntervalTicker.prototype.type = 'SingleIntervalTicker';\n    SingleIntervalTicker.define({\n        interval: [p.Number]\n    });\n    SingleIntervalTicker.getters({\n        min_interval: function () {\n            return this.interval;\n        },\n        max_interval: function () {\n            return this.interval;\n        }\n    });\n    SingleIntervalTicker.prototype.get_interval = function (data_low, data_high, n_desired_ticks) {\n        return this.interval;\n    };\n    return SingleIntervalTicker;\n})(continuous_ticker_1.ContinuousTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nvar array_1 = require(\"core/util/array\");\nvar types_1 = require(\"core/util/types\");\nexports.Ticker = (function (superClass) {\n    extend(Ticker, superClass);\n    function Ticker() {\n        return Ticker.__super__.constructor.apply(this, arguments);\n    }\n    Ticker.prototype.type = 'Ticker';\n    Ticker.prototype.get_ticks = function (data_low, data_high, range, cross_loc, arg) {\n        var desired_n_ticks;\n        desired_n_ticks = arg.desired_n_ticks;\n        return this.get_ticks_no_defaults(data_low, data_high, cross_loc, this.desired_num_ticks);\n    };\n    Ticker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        var end_factor, factor, factors, i, interval, j, k, l, len, len1, len2, minor_interval, minor_offsets, minor_ticks, num_minor_ticks, ref, start_factor, tick, ticks, x;\n        interval = this.get_interval(data_low, data_high, desired_n_ticks);\n        start_factor = Math.floor(data_low / interval);\n        end_factor = Math.ceil(data_high / interval);\n        if (types_1.isStrictNaN(start_factor) || types_1.isStrictNaN(end_factor)) {\n            factors = [];\n        }\n        else {\n            factors = array_1.range(start_factor, end_factor + 1);\n        }\n        ticks = (function () {\n            var j, len, results;\n            results = [];\n            for (j = 0, len = factors.length; j < len; j++) {\n                factor = factors[j];\n                results.push(factor * interval);\n            }\n            return results;\n        })();\n        ticks = ticks.filter(function (tick) {\n            return (data_low <= tick && tick <= data_high);\n        });\n        num_minor_ticks = this.num_minor_ticks;\n        minor_ticks = [];\n        if (num_minor_ticks > 0 && ticks.length > 0) {\n            minor_interval = interval / num_minor_ticks;\n            minor_offsets = (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = num_minor_ticks; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(i * minor_interval);\n                }\n                return results;\n            })();\n            ref = minor_offsets.slice(1, +minor_offsets.length + 1 || 9e9);\n            for (j = 0, len = ref.length; j < len; j++) {\n                x = ref[j];\n                minor_ticks.push(ticks[0] - x);\n            }\n            for (k = 0, len1 = ticks.length; k < len1; k++) {\n                tick = ticks[k];\n                for (l = 0, len2 = minor_offsets.length; l < len2; l++) {\n                    x = minor_offsets[l];\n                    minor_ticks.push(tick + x);\n                }\n            }\n        }\n        return {\n            \"major\": ticks,\n            \"minor\": minor_ticks\n        };\n    };\n    return Ticker;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ONE_MILLI = 1.0;\nexports.ONE_SECOND = 1000.0;\nexports.ONE_MINUTE = 60.0 * exports.ONE_SECOND;\nexports.ONE_HOUR = 60 * exports.ONE_MINUTE;\nexports.ONE_DAY = 24 * exports.ONE_HOUR;\nexports.ONE_MONTH = 30 * exports.ONE_DAY;\nexports.ONE_YEAR = 365 * exports.ONE_DAY;\nexports.copy_date = function (date) {\n    return new Date(date.getTime());\n};\nexports.last_month_no_later_than = function (date) {\n    date = exports.copy_date(date);\n    date.setUTCDate(1);\n    date.setUTCHours(0);\n    date.setUTCMinutes(0);\n    date.setUTCSeconds(0);\n    date.setUTCMilliseconds(0);\n    return date;\n};\nexports.last_year_no_later_than = function (date) {\n    date = exports.last_month_no_later_than(date);\n    date.setUTCMonth(0);\n    return date;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ONE_YEAR, last_year_no_later_than, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar basic_ticker_1 = require(\"./basic_ticker\");\nvar single_interval_ticker_1 = require(\"./single_interval_ticker\");\nvar util = require(\"./util\");\nlast_year_no_later_than = util.last_year_no_later_than;\nONE_YEAR = util.ONE_YEAR;\nexports.YearsTicker = (function (superClass) {\n    extend(YearsTicker, superClass);\n    function YearsTicker() {\n        return YearsTicker.__super__.constructor.apply(this, arguments);\n    }\n    YearsTicker.prototype.type = 'YearsTicker';\n    YearsTicker.prototype.initialize = function (attrs, options) {\n        YearsTicker.__super__.initialize.call(this, attrs, options);\n        this.interval = ONE_YEAR;\n        return this.basic_ticker = new basic_ticker_1.BasicTicker({\n            num_minor_ticks: 0\n        });\n    };\n    YearsTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        var all_ticks, end_year, start_year, ticks_in_range, year, years;\n        start_year = last_year_no_later_than(new Date(data_low)).getUTCFullYear();\n        end_year = last_year_no_later_than(new Date(data_high)).getUTCFullYear();\n        years = this.basic_ticker.get_ticks_no_defaults(start_year, end_year, cross_loc, desired_n_ticks).major;\n        all_ticks = (function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = years.length; i < len; i++) {\n                year = years[i];\n                results.push(Date.UTC(year, 0, 1));\n            }\n            return results;\n        })();\n        ticks_in_range = all_ticks.filter(function (tick) {\n            return (data_low <= tick && tick <= data_high);\n        });\n        return {\n            major: ticks_in_range,\n            minor: []\n        };\n    };\n    return YearsTicker;\n})(single_interval_ticker_1.SingleIntervalTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar mercator_tile_source_1 = require(\"./mercator_tile_source\");\nvar p = require(\"core/properties\");\nexports.BBoxTileSource = (function (superClass) {\n    extend(BBoxTileSource, superClass);\n    function BBoxTileSource() {\n        return BBoxTileSource.__super__.constructor.apply(this, arguments);\n    }\n    BBoxTileSource.prototype.type = 'BBoxTileSource';\n    BBoxTileSource.define({\n        use_latlon: [p.Bool, false]\n    });\n    BBoxTileSource.prototype.get_image_url = function (x, y, z) {\n        var image_url, ref, ref1, xmax, xmin, ymax, ymin;\n        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n        if (this.use_latlon) {\n            ref = this.get_tile_geographic_bounds(x, y, z), xmin = ref[0], ymin = ref[1], xmax = ref[2], ymax = ref[3];\n        }\n        else {\n            ref1 = this.get_tile_meter_bounds(x, y, z), xmin = ref1[0], ymin = ref1[1], xmax = ref1[2], ymax = ref1[3];\n        }\n        return image_url.replace(\"{XMIN}\", xmin).replace(\"{YMIN}\", ymin).replace(\"{XMAX}\", xmax).replace(\"{YMAX}\", ymax);\n    };\n    return BBoxTileSource;\n})(mercator_tile_source_1.MercatorTileSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar renderer_1 = require(\"../renderers/renderer\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nexports.DynamicImageView = (function (superClass) {\n    extend(DynamicImageView, superClass);\n    function DynamicImageView() {\n        this._on_image_error = bind(this._on_image_error, this);\n        this._on_image_load = bind(this._on_image_load, this);\n        return DynamicImageView.__super__.constructor.apply(this, arguments);\n    }\n    DynamicImageView.prototype.connect_signals = function () {\n        DynamicImageView.__super__.connect_signals.call(this);\n        return this.connect(this.model.change, function () {\n            return this.request_render();\n        });\n    };\n    DynamicImageView.prototype.get_extent = function () {\n        return [this.x_range.start, this.y_range.start, this.x_range.end, this.y_range.end];\n    };\n    DynamicImageView.prototype._set_data = function () {\n        this.map_plot = this.plot_view.model.plot;\n        this.map_canvas = this.plot_view.canvas_view.ctx;\n        this.map_frame = this.plot_view.frame;\n        this.x_range = this.map_plot.x_range;\n        this.y_range = this.map_plot.y_range;\n        this.lastImage = void 0;\n        return this.extent = this.get_extent();\n    };\n    DynamicImageView.prototype._map_data = function () {\n        return this.initial_extent = this.get_extent();\n    };\n    DynamicImageView.prototype._on_image_load = function (e) {\n        var image_data;\n        image_data = e.target.image_data;\n        image_data.img = e.target;\n        image_data.loaded = true;\n        this.lastImage = image_data;\n        if (this.get_extent().join(':') === image_data.cache_key) {\n            return this.request_render();\n        }\n    };\n    DynamicImageView.prototype._on_image_error = function (e) {\n        var image_data;\n        logging_1.logger.error(\"Error loading image: \" + e.target.src);\n        image_data = e.target.image_data;\n        return this.model.image_source.remove_image(image_data);\n    };\n    DynamicImageView.prototype._create_image = function (bounds) {\n        var image;\n        image = new Image();\n        image.onload = this._on_image_load;\n        image.onerror = this._on_image_error;\n        image.alt = '';\n        image.image_data = {\n            bounds: bounds,\n            loaded: false,\n            cache_key: bounds.join(':')\n        };\n        this.model.image_source.add_image(image.image_data);\n        image.src = this.model.image_source.get_image_url(bounds[0], bounds[1], bounds[2], bounds[3], Math.ceil(this.map_frame._height.value), Math.ceil(this.map_frame._width.value));\n        return image;\n    };\n    DynamicImageView.prototype.render = function (ctx, indices, args) {\n        var extent, image_obj;\n        if (this.map_initialized == null) {\n            this._set_data();\n            this._map_data();\n            this.map_initialized = true;\n        }\n        extent = this.get_extent();\n        if (this.render_timer) {\n            clearTimeout(this.render_timer);\n        }\n        image_obj = this.model.image_source.images[extent.join(':')];\n        if ((image_obj != null) && image_obj.loaded) {\n            this._draw_image(extent.join(':'));\n            return;\n        }\n        if (this.lastImage != null) {\n            this._draw_image(this.lastImage.cache_key);\n        }\n        if (image_obj == null) {\n            return this.render_timer = setTimeout(((function (_this) {\n                return function () {\n                    return _this._create_image(extent);\n                };\n            })(this)), 125);\n        }\n    };\n    DynamicImageView.prototype._draw_image = function (image_key) {\n        var image_obj, ref, ref1, sh, sw, sx, sxmax, sxmin, sy, symax, symin;\n        image_obj = this.model.image_source.images[image_key];\n        if (image_obj != null) {\n            this.map_canvas.save();\n            this._set_rect();\n            this.map_canvas.globalAlpha = this.model.alpha;\n            ref = this.plot_view.frame.map_to_screen([image_obj.bounds[0]], [image_obj.bounds[3]], this.plot_view.canvas), sxmin = ref[0], symin = ref[1];\n            ref1 = this.plot_view.frame.map_to_screen([image_obj.bounds[2]], [image_obj.bounds[1]], this.plot_view.canvas), sxmax = ref1[0], symax = ref1[1];\n            sxmin = sxmin[0];\n            symin = symin[0];\n            sxmax = sxmax[0];\n            symax = symax[0];\n            sw = sxmax - sxmin;\n            sh = symax - symin;\n            sx = sxmin;\n            sy = symin;\n            this.map_canvas.drawImage(image_obj.img, sx, sy, sw, sh);\n            return this.map_canvas.restore();\n        }\n    };\n    DynamicImageView.prototype._set_rect = function () {\n        var h, l, outline_width, t, w;\n        outline_width = this.plot_model.plot.properties.outline_line_width.value();\n        l = this.plot_view.canvas.vx_to_sx(this.map_frame._left.value) + (outline_width / 2);\n        t = this.plot_view.canvas.vy_to_sy(this.map_frame._top.value) + (outline_width / 2);\n        w = this.map_frame._width.value - outline_width;\n        h = this.map_frame._height.value - outline_width;\n        this.map_canvas.rect(l, t, w, h);\n        return this.map_canvas.clip();\n    };\n    return DynamicImageView;\n})(renderer_1.RendererView);\nexports.DynamicImageRenderer = (function (superClass) {\n    extend(DynamicImageRenderer, superClass);\n    function DynamicImageRenderer() {\n        return DynamicImageRenderer.__super__.constructor.apply(this, arguments);\n    }\n    DynamicImageRenderer.prototype.default_view = exports.DynamicImageView;\n    DynamicImageRenderer.prototype.type = 'DynamicImageRenderer';\n    DynamicImageRenderer.define({\n        alpha: [p.Number, 1.0],\n        image_source: [p.Instance],\n        render_parents: [p.Bool, true]\n    });\n    DynamicImageRenderer.override({\n        level: 'underlay'\n    });\n    return DynamicImageRenderer;\n})(renderer_1.Renderer);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImagePool = (function () {\n    function ImagePool() {\n        this.images = [];\n    }\n    ImagePool.prototype.pop = function () {\n        var img;\n        img = this.images.pop();\n        if (img != null) {\n            return img;\n        }\n        else {\n            return new Image();\n        }\n    };\n    ImagePool.prototype.push = function (img) {\n        if (this.images.length > 50) {\n            return;\n        }\n        if (img.constructor === Array) {\n            return Array.prototype.push.apply(this.images, img);\n        }\n        else {\n            return this.images.push(img);\n        }\n    };\n    return ImagePool;\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar model_1 = require(\"../../model\");\nexports.ImageSource = (function (superClass) {\n    extend(ImageSource, superClass);\n    ImageSource.prototype.type = 'ImageSource';\n    ImageSource.define({\n        url: [p.String, ''],\n        extra_url_vars: [p.Any, {}]\n    });\n    function ImageSource(options) {\n        if (options == null) {\n            options = {};\n        }\n        ImageSource.__super__.constructor.apply(this, arguments);\n        this.images = {};\n        this.normalize_case();\n    }\n    ImageSource.prototype.normalize_case = function () {\n        'Note: should probably be refactored into subclasses.';\n        var url;\n        url = this.url;\n        url = url.replace('{xmin}', '{XMIN}');\n        url = url.replace('{ymin}', '{YMIN}');\n        url = url.replace('{xmax}', '{XMAX}');\n        url = url.replace('{ymax}', '{YMAX}');\n        url = url.replace('{height}', '{HEIGHT}');\n        url = url.replace('{width}', '{WIDTH}');\n        return this.url = url;\n    };\n    ImageSource.prototype.string_lookup_replace = function (str, lookup) {\n        var key, result_str, value;\n        result_str = str;\n        for (key in lookup) {\n            value = lookup[key];\n            result_str = result_str.replace('{' + key + '}', value.toString());\n        }\n        return result_str;\n    };\n    ImageSource.prototype.add_image = function (image_obj) {\n        return this.images[image_obj.cache_key] = image_obj;\n    };\n    ImageSource.prototype.remove_image = function (image_obj) {\n        return delete this.images[image_obj.cache_key];\n    };\n    ImageSource.prototype.get_image_url = function (xmin, ymin, xmax, ymax, height, width) {\n        var image_url;\n        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n        return image_url.replace(\"{XMIN}\", xmin).replace(\"{YMIN}\", ymin).replace(\"{XMAX}\", xmax).replace(\"{YMAX}\", ymax).replace(\"{WIDTH}\", width).replace(\"{HEIGHT}\", height);\n    };\n    return ImageSource;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bbox_tile_source_1 = require(\"./bbox_tile_source\");\nexports.BBoxTileSource = bbox_tile_source_1.BBoxTileSource;\nvar dynamic_image_renderer_1 = require(\"./dynamic_image_renderer\");\nexports.DynamicImageRenderer = dynamic_image_renderer_1.DynamicImageRenderer;\nvar image_source_1 = require(\"./image_source\");\nexports.ImageSource = image_source_1.ImageSource;\nvar mercator_tile_source_1 = require(\"./mercator_tile_source\");\nexports.MercatorTileSource = mercator_tile_source_1.MercatorTileSource;\nvar quadkey_tile_source_1 = require(\"./quadkey_tile_source\");\nexports.QUADKEYTileSource = quadkey_tile_source_1.QUADKEYTileSource;\nvar tile_renderer_1 = require(\"./tile_renderer\");\nexports.TileRenderer = tile_renderer_1.TileRenderer;\nvar tile_source_1 = require(\"./tile_source\");\nexports.TileSource = tile_source_1.TileSource;\nvar tms_tile_source_1 = require(\"./tms_tile_source\");\nexports.TMSTileSource = tms_tile_source_1.TMSTileSource;\nvar wmts_tile_source_1 = require(\"./wmts_tile_source\");\nexports.WMTSTileSource = wmts_tile_source_1.WMTSTileSource;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar tile_source_1 = require(\"./tile_source\");\nvar p = require(\"core/properties\");\nexports.MercatorTileSource = (function (superClass) {\n    extend(MercatorTileSource, superClass);\n    function MercatorTileSource() {\n        return MercatorTileSource.__super__.constructor.apply(this, arguments);\n    }\n    MercatorTileSource.prototype.type = 'MercatorTileSource';\n    MercatorTileSource.define({\n        wrap_around: [p.Bool, true]\n    });\n    MercatorTileSource.override({\n        x_origin_offset: 20037508.34,\n        y_origin_offset: 20037508.34,\n        initial_resolution: 156543.03392804097\n    });\n    MercatorTileSource.prototype.initialize = function (options) {\n        var z;\n        MercatorTileSource.__super__.initialize.call(this, options);\n        return this._resolutions = (function () {\n            var j, results;\n            results = [];\n            for (z = j = 0; j <= 30; z = ++j) {\n                results.push(this.get_resolution(z));\n            }\n            return results;\n        }).call(this);\n    };\n    MercatorTileSource.prototype._computed_initial_resolution = function () {\n        if (this.initial_resolution != null) {\n            return this.initial_resolution;\n        }\n        else {\n            return 2 * Math.PI * 6378137 / this.tile_size;\n        }\n    };\n    MercatorTileSource.prototype.is_valid_tile = function (x, y, z) {\n        if (!this.wrap_around) {\n            if (x < 0 || x >= Math.pow(2, z)) {\n                return false;\n            }\n        }\n        if (y < 0 || y >= Math.pow(2, z)) {\n            return false;\n        }\n        return true;\n    };\n    MercatorTileSource.prototype.retain_children = function (reference_tile) {\n        var key, max_zoom, min_zoom, quadkey, ref, results, tile;\n        quadkey = reference_tile.quadkey;\n        min_zoom = quadkey.length;\n        max_zoom = min_zoom + 3;\n        ref = this.tiles;\n        results = [];\n        for (key in ref) {\n            tile = ref[key];\n            if (tile.quadkey.indexOf(quadkey) === 0 && tile.quadkey.length > min_zoom && tile.quadkey.length <= max_zoom) {\n                results.push(tile.retain = true);\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    MercatorTileSource.prototype.retain_neighbors = function (reference_tile) {\n        var key, neighbor_radius, neighbor_x, neighbor_y, ref, ref1, ref2, ref3, results, tile, tx, ty, tz, x, y;\n        neighbor_radius = 4;\n        ref = reference_tile.tile_coords, tx = ref[0], ty = ref[1], tz = ref[2];\n        neighbor_x = (function () {\n            var j, ref1, ref2, results;\n            results = [];\n            for (x = j = ref1 = tx - neighbor_radius, ref2 = tx + neighbor_radius; ref1 <= ref2 ? j <= ref2 : j >= ref2; x = ref1 <= ref2 ? ++j : --j) {\n                results.push(x);\n            }\n            return results;\n        })();\n        neighbor_y = (function () {\n            var j, ref1, ref2, results;\n            results = [];\n            for (y = j = ref1 = ty - neighbor_radius, ref2 = ty + neighbor_radius; ref1 <= ref2 ? j <= ref2 : j >= ref2; y = ref1 <= ref2 ? ++j : --j) {\n                results.push(y);\n            }\n            return results;\n        })();\n        ref1 = this.tiles;\n        results = [];\n        for (key in ref1) {\n            tile = ref1[key];\n            if (tile.tile_coords[2] === tz && (ref2 = tile.tile_coords[0], indexOf.call(neighbor_x, ref2) >= 0) && (ref3 = tile.tile_coords[1], indexOf.call(neighbor_y, ref3) >= 0)) {\n                results.push(tile.retain = true);\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    MercatorTileSource.prototype.retain_parents = function (reference_tile) {\n        var key, quadkey, ref, results, tile;\n        quadkey = reference_tile.quadkey;\n        ref = this.tiles;\n        results = [];\n        for (key in ref) {\n            tile = ref[key];\n            results.push(tile.retain = quadkey.indexOf(tile.quadkey) === 0);\n        }\n        return results;\n    };\n    MercatorTileSource.prototype.children_by_tile_xyz = function (x, y, z) {\n        var b, child_tile_xyz, i, j, quad_key, ref, ref1, ref2, world_x;\n        world_x = this.calculate_world_x_by_tile_xyz(x, y, z);\n        if (world_x !== 0) {\n            ref = this.normalize_xyz(x, y, z), x = ref[0], y = ref[1], z = ref[2];\n        }\n        quad_key = this.tile_xyz_to_quadkey(x, y, z);\n        child_tile_xyz = [];\n        for (i = j = 0; j <= 3; i = j += 1) {\n            ref1 = this.quadkey_to_tile_xyz(quad_key + i.toString()), x = ref1[0], y = ref1[1], z = ref1[2];\n            if (world_x !== 0) {\n                ref2 = this.denormalize_xyz(x, y, z, world_x), x = ref2[0], y = ref2[1], z = ref2[2];\n            }\n            b = this.get_tile_meter_bounds(x, y, z);\n            if (b != null) {\n                child_tile_xyz.push([x, y, z, b]);\n            }\n        }\n        return child_tile_xyz;\n    };\n    MercatorTileSource.prototype.parent_by_tile_xyz = function (x, y, z) {\n        var parent_quad_key, quad_key;\n        quad_key = this.tile_xyz_to_quadkey(x, y, z);\n        parent_quad_key = quad_key.substring(0, quad_key.length - 1);\n        return this.quadkey_to_tile_xyz(parent_quad_key);\n    };\n    MercatorTileSource.prototype.get_resolution = function (level) {\n        return this._computed_initial_resolution() / Math.pow(2, level);\n    };\n    MercatorTileSource.prototype.get_resolution_by_extent = function (extent, height, width) {\n        var x_rs, y_rs;\n        x_rs = (extent[2] - extent[0]) / width;\n        y_rs = (extent[3] - extent[1]) / height;\n        return [x_rs, y_rs];\n    };\n    MercatorTileSource.prototype.get_level_by_extent = function (extent, height, width) {\n        var i, j, len, r, ref, resolution, x_rs, y_rs;\n        x_rs = (extent[2] - extent[0]) / width;\n        y_rs = (extent[3] - extent[1]) / height;\n        resolution = Math.max(x_rs, y_rs);\n        i = 0;\n        ref = this._resolutions;\n        for (j = 0, len = ref.length; j < len; j++) {\n            r = ref[j];\n            if (resolution > r) {\n                if (i === 0) {\n                    return 0;\n                }\n                if (i > 0) {\n                    return i - 1;\n                }\n            }\n            i += 1;\n        }\n    };\n    MercatorTileSource.prototype.get_closest_level_by_extent = function (extent, height, width) {\n        var closest, resolution, ress, x_rs, y_rs;\n        x_rs = (extent[2] - extent[0]) / width;\n        y_rs = (extent[3] - extent[1]) / height;\n        resolution = Math.max(x_rs, y_rs);\n        ress = this._resolutions;\n        closest = this._resolutions.reduce(function (previous, current) {\n            if (Math.abs(current - resolution) < Math.abs(previous - resolution)) {\n                return current;\n            }\n            return previous;\n        });\n        return this._resolutions.indexOf(closest);\n    };\n    MercatorTileSource.prototype.snap_to_zoom = function (extent, height, width, level) {\n        var desired_res, desired_x_delta, desired_y_delta, x_adjust, xmax, xmin, y_adjust, ymax, ymin;\n        desired_res = this._resolutions[level];\n        desired_x_delta = width * desired_res;\n        desired_y_delta = height * desired_res;\n        xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];\n        x_adjust = (desired_x_delta - (xmax - xmin)) / 2;\n        y_adjust = (desired_y_delta - (ymax - ymin)) / 2;\n        return [xmin - x_adjust, ymin - y_adjust, xmax + x_adjust, ymax + y_adjust];\n    };\n    MercatorTileSource.prototype.tms_to_wmts = function (x, y, z) {\n        'Note this works both ways';\n        return [x, Math.pow(2, z) - 1 - y, z];\n    };\n    MercatorTileSource.prototype.wmts_to_tms = function (x, y, z) {\n        'Note this works both ways';\n        return [x, Math.pow(2, z) - 1 - y, z];\n    };\n    MercatorTileSource.prototype.pixels_to_meters = function (px, py, level) {\n        var mx, my, res;\n        res = this.get_resolution(level);\n        mx = px * res - this.x_origin_offset;\n        my = py * res - this.y_origin_offset;\n        return [mx, my];\n    };\n    MercatorTileSource.prototype.meters_to_pixels = function (mx, my, level) {\n        var px, py, res;\n        res = this.get_resolution(level);\n        px = (mx + this.x_origin_offset) / res;\n        py = (my + this.y_origin_offset) / res;\n        return [px, py];\n    };\n    MercatorTileSource.prototype.pixels_to_tile = function (px, py) {\n        var tx, ty;\n        tx = Math.ceil(px / parseFloat(this.tile_size));\n        tx = tx === 0 ? tx : tx - 1;\n        ty = Math.max(Math.ceil(py / parseFloat(this.tile_size)) - 1, 0);\n        return [tx, ty];\n    };\n    MercatorTileSource.prototype.pixels_to_raster = function (px, py, level) {\n        var mapSize;\n        mapSize = this.tile_size << level;\n        return [px, mapSize - py];\n    };\n    MercatorTileSource.prototype.meters_to_tile = function (mx, my, level) {\n        var px, py, ref;\n        ref = this.meters_to_pixels(mx, my, level), px = ref[0], py = ref[1];\n        return this.pixels_to_tile(px, py);\n    };\n    MercatorTileSource.prototype.get_tile_meter_bounds = function (tx, ty, level) {\n        var ref, ref1, xmax, xmin, ymax, ymin;\n        ref = this.pixels_to_meters(tx * this.tile_size, ty * this.tile_size, level), xmin = ref[0], ymin = ref[1];\n        ref1 = this.pixels_to_meters((tx + 1) * this.tile_size, (ty + 1) * this.tile_size, level), xmax = ref1[0], ymax = ref1[1];\n        if ((xmin != null) && (ymin != null) && (xmax != null) && (ymax != null)) {\n            return [xmin, ymin, xmax, ymax];\n        }\n        else {\n            return void 0;\n        }\n    };\n    MercatorTileSource.prototype.get_tile_geographic_bounds = function (tx, ty, level) {\n        var bounds, maxLat, maxLon, minLat, minLon, ref;\n        bounds = this.get_tile_meter_bounds(tx, ty, level);\n        ref = this.utils.meters_extent_to_geographic(bounds), minLon = ref[0], minLat = ref[1], maxLon = ref[2], maxLat = ref[3];\n        return [minLon, minLat, maxLon, maxLat];\n    };\n    MercatorTileSource.prototype.get_tiles_by_extent = function (extent, level, tile_border) {\n        var j, k, ref, ref1, ref2, ref3, ref4, ref5, tiles, tx, txmax, txmin, ty, tymax, tymin, xmax, xmin, ymax, ymin;\n        if (tile_border == null) {\n            tile_border = 1;\n        }\n        xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];\n        ref = this.meters_to_tile(xmin, ymin, level), txmin = ref[0], tymin = ref[1];\n        ref1 = this.meters_to_tile(xmax, ymax, level), txmax = ref1[0], tymax = ref1[1];\n        txmin -= tile_border;\n        tymin -= tile_border;\n        txmax += tile_border;\n        tymax += tile_border;\n        tiles = [];\n        for (ty = j = ref2 = tymax, ref3 = tymin; j >= ref3; ty = j += -1) {\n            for (tx = k = ref4 = txmin, ref5 = txmax; k <= ref5; tx = k += 1) {\n                if (this.is_valid_tile(tx, ty, level)) {\n                    tiles.push([tx, ty, level, this.get_tile_meter_bounds(tx, ty, level)]);\n                }\n            }\n        }\n        tiles = this.sort_tiles_from_center(tiles, [txmin, tymin, txmax, tymax]);\n        return tiles;\n    };\n    MercatorTileSource.prototype.quadkey_to_tile_xyz = function (quadKey) {\n        'Computes tile x, y and z values based on quadKey.';\n        var i, j, mask, ref, tileX, tileY, tileZ, value;\n        tileX = 0;\n        tileY = 0;\n        tileZ = quadKey.length;\n        for (i = j = ref = tileZ; j > 0; i = j += -1) {\n            value = quadKey.charAt(tileZ - i);\n            mask = 1 << (i - 1);\n            switch (value) {\n                case '0':\n                    continue;\n                case '1':\n                    tileX |= mask;\n                    break;\n                case '2':\n                    tileY |= mask;\n                    break;\n                case '3':\n                    tileX |= mask;\n                    tileY |= mask;\n                    break;\n                default:\n                    throw new TypeError(\"Invalid Quadkey: \" + quadKey);\n            }\n        }\n        return [tileX, tileY, tileZ];\n    };\n    MercatorTileSource.prototype.tile_xyz_to_quadkey = function (x, y, z) {\n        'Computes quadkey value based on tile x, y and z values.';\n        var digit, i, j, mask, quadKey, ref;\n        quadKey = '';\n        for (i = j = ref = z; j > 0; i = j += -1) {\n            digit = 0;\n            mask = 1 << (i - 1);\n            if ((x & mask) !== 0) {\n                digit += 1;\n            }\n            if ((y & mask) !== 0) {\n                digit += 2;\n            }\n            quadKey += digit.toString();\n        }\n        return quadKey;\n    };\n    MercatorTileSource.prototype.children_by_tile_xyz = function (x, y, z) {\n        var b, child_tile_xyz, i, j, quad_key, ref;\n        quad_key = this.tile_xyz_to_quadkey(x, y, z);\n        child_tile_xyz = [];\n        for (i = j = 0; j <= 3; i = j += 1) {\n            ref = this.quadkey_to_tile_xyz(quad_key + i.toString()), x = ref[0], y = ref[1], z = ref[2];\n            b = this.get_tile_meter_bounds(x, y, z);\n            if (b != null) {\n                child_tile_xyz.push([x, y, z, b]);\n            }\n        }\n        return child_tile_xyz;\n    };\n    MercatorTileSource.prototype.parent_by_tile_xyz = function (x, y, z) {\n        var parent_quad_key, quad_key;\n        quad_key = this.tile_xyz_to_quadkey(x, y, z);\n        parent_quad_key = quad_key.substring(0, quad_key.length - 1);\n        return this.quadkey_to_tile_xyz(parent_quad_key);\n    };\n    MercatorTileSource.prototype.get_closest_parent_by_tile_xyz = function (x, y, z) {\n        var quad_key, ref, ref1, ref2, world_x;\n        world_x = this.calculate_world_x_by_tile_xyz(x, y, z);\n        ref = this.normalize_xyz(x, y, z), x = ref[0], y = ref[1], z = ref[2];\n        quad_key = this.tile_xyz_to_quadkey(x, y, z);\n        while (quad_key.length > 0) {\n            quad_key = quad_key.substring(0, quad_key.length - 1);\n            ref1 = this.quadkey_to_tile_xyz(quad_key), x = ref1[0], y = ref1[1], z = ref1[2];\n            ref2 = this.denormalize_xyz(x, y, z, world_x), x = ref2[0], y = ref2[1], z = ref2[2];\n            if (this.tile_xyz_to_key(x, y, z) in this.tiles) {\n                return [x, y, z];\n            }\n        }\n        return [0, 0, 0];\n    };\n    MercatorTileSource.prototype.normalize_xyz = function (x, y, z) {\n        var tile_count;\n        if (this.wrap_around) {\n            tile_count = Math.pow(2, z);\n            return [((x % tile_count) + tile_count) % tile_count, y, z];\n        }\n        else {\n            return [x, y, z];\n        }\n    };\n    MercatorTileSource.prototype.denormalize_xyz = function (x, y, z, world_x) {\n        return [x + world_x * Math.pow(2, z), y, z];\n    };\n    MercatorTileSource.prototype.denormalize_meters = function (meters_x, meters_y, level, world_x) {\n        return [meters_x + world_x * 2 * Math.PI * 6378137, meters_y];\n    };\n    MercatorTileSource.prototype.calculate_world_x_by_tile_xyz = function (x, y, z) {\n        return Math.floor(x / Math.pow(2, z));\n    };\n    return MercatorTileSource;\n})(tile_source_1.TileSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar mercator_tile_source_1 = require(\"./mercator_tile_source\");\nexports.QUADKEYTileSource = (function (superClass) {\n    extend(QUADKEYTileSource, superClass);\n    function QUADKEYTileSource() {\n        return QUADKEYTileSource.__super__.constructor.apply(this, arguments);\n    }\n    QUADKEYTileSource.prototype.type = 'QUADKEYTileSource';\n    QUADKEYTileSource.prototype.get_image_url = function (x, y, z) {\n        var image_url, quadKey, ref;\n        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n        ref = this.tms_to_wmts(x, y, z), x = ref[0], y = ref[1], z = ref[2];\n        quadKey = this.tile_xyz_to_quadkey(x, y, z);\n        return image_url.replace(\"{Q}\", quadKey);\n    };\n    return QUADKEYTileSource;\n})(mercator_tile_source_1.MercatorTileSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar image_pool_1 = require(\"./image_pool\");\nvar wmts_tile_source_1 = require(\"./wmts_tile_source\");\nvar renderer_1 = require(\"../renderers/renderer\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.TileRendererView = (function (superClass) {\n    extend(TileRendererView, superClass);\n    function TileRendererView() {\n        this._update = bind(this._update, this);\n        this._prefetch_tiles = bind(this._prefetch_tiles, this);\n        this._on_tile_error = bind(this._on_tile_error, this);\n        this._on_tile_cache_load = bind(this._on_tile_cache_load, this);\n        this._on_tile_load = bind(this._on_tile_load, this);\n        this._add_attribution = bind(this._add_attribution, this);\n        return TileRendererView.__super__.constructor.apply(this, arguments);\n    }\n    TileRendererView.prototype.initialize = function (options) {\n        this.attributionEl = null;\n        this._tiles = [];\n        return TileRendererView.__super__.initialize.apply(this, arguments);\n    };\n    TileRendererView.prototype.connect_signals = function () {\n        TileRendererView.__super__.connect_signals.call(this);\n        return this.connect(this.model.change, function () {\n            return this.request_render();\n        });\n    };\n    TileRendererView.prototype.get_extent = function () {\n        return [this.x_range.start, this.y_range.start, this.x_range.end, this.y_range.end];\n    };\n    TileRendererView.prototype._set_data = function () {\n        this.pool = new image_pool_1.ImagePool();\n        this.map_plot = this.plot_model.plot;\n        this.map_canvas = this.plot_view.canvas_view.ctx;\n        this.map_frame = this.plot_model.frame;\n        this.x_range = this.map_plot.x_range;\n        this.y_range = this.map_plot.y_range;\n        this.extent = this.get_extent();\n        this._last_height = void 0;\n        return this._last_width = void 0;\n    };\n    TileRendererView.prototype._add_attribution = function () {\n        var attribution, border_width, bottom_offset, max_width, overlays, right_offset;\n        attribution = this.model.tile_source.attribution;\n        if (types_1.isString(attribution) && attribution.length > 0) {\n            if (this.attributionEl == null) {\n                border_width = this.map_plot.outline_line_width;\n                bottom_offset = this.map_plot.min_border_bottom + border_width;\n                right_offset = this.map_frame._right.value - this.map_frame._width.value;\n                max_width = this.map_frame._width.value - border_width;\n                this.attributionEl = dom_1.div({\n                    \"class\": 'bk-tile-attribution',\n                    style: {\n                        position: 'absolute',\n                        bottom: bottom_offset + \"px\",\n                        right: right_offset + \"px\",\n                        'max-width': max_width + \"px\",\n                        'background-color': 'rgba(255,255,255,0.8)',\n                        'font-size': '9pt',\n                        'font-family': 'sans-serif'\n                    }\n                });\n                overlays = this.plot_view.canvas_view.events_el;\n                overlays.appendChild(this.attributionEl);\n            }\n            return this.attributionEl.innerHTML = attribution;\n        }\n    };\n    TileRendererView.prototype._map_data = function () {\n        var new_extent, zoom_level;\n        this.initial_extent = this.get_extent();\n        zoom_level = this.model.tile_source.get_level_by_extent(this.initial_extent, this.map_frame._height.value, this.map_frame._width.value);\n        new_extent = this.model.tile_source.snap_to_zoom(this.initial_extent, this.map_frame._height.value, this.map_frame._width.value, zoom_level);\n        this.x_range.start = new_extent[0];\n        this.y_range.start = new_extent[1];\n        this.x_range.end = new_extent[2];\n        this.y_range.end = new_extent[3];\n        return this._add_attribution();\n    };\n    TileRendererView.prototype._on_tile_load = function (e) {\n        var tile_data;\n        tile_data = e.target.tile_data;\n        tile_data.img = e.target;\n        tile_data.current = true;\n        tile_data.loaded = true;\n        return this.request_render();\n    };\n    TileRendererView.prototype._on_tile_cache_load = function (e) {\n        var tile_data;\n        tile_data = e.target.tile_data;\n        tile_data.img = e.target;\n        tile_data.loaded = true;\n        tile_data.finished = true;\n        return this.notify_finished();\n    };\n    TileRendererView.prototype._on_tile_error = function (e) {\n        var tile_data;\n        tile_data = e.target.tile_data;\n        return tile_data.finished = true;\n    };\n    TileRendererView.prototype._create_tile = function (x, y, z, bounds, cache_only) {\n        var normalized_coords, ref, tile;\n        if (cache_only == null) {\n            cache_only = false;\n        }\n        normalized_coords = this.model.tile_source.normalize_xyz(x, y, z);\n        tile = this.pool.pop();\n        if (cache_only) {\n            tile.onload = this._on_tile_cache_load;\n        }\n        else {\n            tile.onload = this._on_tile_load;\n        }\n        tile.onerror = this._on_tile_error;\n        tile.alt = '';\n        tile.tile_data = {\n            tile_coords: [x, y, z],\n            normalized_coords: normalized_coords,\n            quadkey: this.model.tile_source.tile_xyz_to_quadkey(x, y, z),\n            cache_key: this.model.tile_source.tile_xyz_to_key(x, y, z),\n            bounds: bounds,\n            loaded: false,\n            finished: false,\n            x_coord: bounds[0],\n            y_coord: bounds[3]\n        };\n        this.model.tile_source.tiles[tile.tile_data.cache_key] = tile.tile_data;\n        tile.src = (ref = this.model.tile_source).get_image_url.apply(ref, normalized_coords);\n        this._tiles.push(tile);\n        return tile;\n    };\n    TileRendererView.prototype._enforce_aspect_ratio = function () {\n        var extent, new_extent, zoom_level;\n        if (this._last_height !== this.map_frame._height.value || this._last_width !== this.map_frame._width.value) {\n            extent = this.get_extent();\n            zoom_level = this.model.tile_source.get_level_by_extent(extent, this.map_frame._height.value, this.map_frame._width.value);\n            new_extent = this.model.tile_source.snap_to_zoom(extent, this.map_frame._height.value, this.map_frame._width.value, zoom_level);\n            this.x_range.setv({\n                start: new_extent[0],\n                end: new_extent[2]\n            });\n            this.y_range.setv({\n                start: new_extent[1],\n                end: new_extent[3]\n            });\n            this.extent = new_extent;\n            this._last_height = this.map_frame._height.value;\n            this._last_width = this.map_frame._width.value;\n            return true;\n        }\n        return false;\n    };\n    TileRendererView.prototype.has_finished = function () {\n        var i, len, ref, tile;\n        if (!TileRendererView.__super__.has_finished.call(this)) {\n            return false;\n        }\n        if (this._tiles.length === 0) {\n            return false;\n        }\n        ref = this._tiles;\n        for (i = 0, len = ref.length; i < len; i++) {\n            tile = ref[i];\n            if (!tile.tile_data.finished) {\n                return false;\n            }\n        }\n        return true;\n    };\n    TileRendererView.prototype.render = function (ctx, indices, args) {\n        if (this.map_initialized == null) {\n            this._set_data();\n            this._map_data();\n            this.map_initialized = true;\n        }\n        if (this._enforce_aspect_ratio()) {\n            return;\n        }\n        this._update();\n        if (this.prefetch_timer != null) {\n            clearTimeout(this.prefetch_timer);\n        }\n        this.prefetch_timer = setTimeout(this._prefetch_tiles, 500);\n        if (this.has_finished()) {\n            return this.notify_finished();\n        }\n    };\n    TileRendererView.prototype._draw_tile = function (tile_key) {\n        var ref, ref1, sh, sw, sx, sxmax, sxmin, sy, symax, symin, tile_obj;\n        tile_obj = this.model.tile_source.tiles[tile_key];\n        if (tile_obj != null) {\n            ref = this.plot_view.frame.map_to_screen([tile_obj.bounds[0]], [tile_obj.bounds[3]], this.plot_view.canvas), sxmin = ref[0], symin = ref[1];\n            ref1 = this.plot_view.frame.map_to_screen([tile_obj.bounds[2]], [tile_obj.bounds[1]], this.plot_view.canvas), sxmax = ref1[0], symax = ref1[1];\n            sxmin = sxmin[0];\n            symin = symin[0];\n            sxmax = sxmax[0];\n            symax = symax[0];\n            sw = sxmax - sxmin;\n            sh = symax - symin;\n            sx = sxmin;\n            sy = symin;\n            return this.map_canvas.drawImage(tile_obj.img, sx, sy, sw, sh);\n        }\n    };\n    TileRendererView.prototype._set_rect = function () {\n        var h, l, outline_width, t, w;\n        outline_width = this.plot_model.plot.properties.outline_line_width.value();\n        l = this.plot_view.canvas.vx_to_sx(this.map_frame._left.value) + (outline_width / 2);\n        t = this.plot_view.canvas.vy_to_sy(this.map_frame._top.value) + (outline_width / 2);\n        w = this.map_frame._width.value - outline_width;\n        h = this.map_frame._height.value - outline_width;\n        this.map_canvas.rect(l, t, w, h);\n        return this.map_canvas.clip();\n    };\n    TileRendererView.prototype._render_tiles = function (tile_keys) {\n        var i, len, tile_key;\n        this.map_canvas.save();\n        this._set_rect();\n        this.map_canvas.globalAlpha = this.model.alpha;\n        for (i = 0, len = tile_keys.length; i < len; i++) {\n            tile_key = tile_keys[i];\n            this._draw_tile(tile_key);\n        }\n        return this.map_canvas.restore();\n    };\n    TileRendererView.prototype._prefetch_tiles = function () {\n        var bounds, c, cbounds, children, cx, cy, cz, extent, h, i, ref, results, t, tile_source, tiles, w, x, y, z, zoom_level;\n        tile_source = this.model.tile_source;\n        extent = this.get_extent();\n        h = this.map_frame._height.value;\n        w = this.map_frame._width.value;\n        zoom_level = this.model.tile_source.get_level_by_extent(extent, h, w);\n        tiles = this.model.tile_source.get_tiles_by_extent(extent, zoom_level);\n        results = [];\n        for (t = i = 0, ref = Math.min(10, tiles.length); i <= ref; t = i += 1) {\n            x = t[0], y = t[1], z = t[2], bounds = t[3];\n            children = this.model.tile_source.children_by_tile_xyz(x, y, z);\n            results.push((function () {\n                var j, len, results1;\n                results1 = [];\n                for (j = 0, len = children.length; j < len; j++) {\n                    c = children[j];\n                    cx = c[0], cy = c[1], cz = c[2], cbounds = c[3];\n                    if (tile_source.tile_xyz_to_key(cx, cy, cz) in tile_source.tiles) {\n                        continue;\n                    }\n                    else {\n                        results1.push(this._create_tile(cx, cy, cz, cbounds, true));\n                    }\n                }\n                return results1;\n            }).call(this));\n        }\n        return results;\n    };\n    TileRendererView.prototype._fetch_tiles = function (tiles) {\n        var bounds, i, len, results, t, x, y, z;\n        results = [];\n        for (i = 0, len = tiles.length; i < len; i++) {\n            t = tiles[i];\n            x = t[0], y = t[1], z = t[2], bounds = t[3];\n            results.push(this._create_tile(x, y, z, bounds));\n        }\n        return results;\n    };\n    TileRendererView.prototype._update = function () {\n        var bounds, c, cached, cbounds, child_key, children, cx, cy, cz, extent, h, i, j, k, key, len, len1, len2, max_zoom, min_zoom, need_load, parent_key, parent_tile, parents, px, py, pz, ref, snap_back, t, tile, tile_source, tiles, w, x, y, z, zoom_level, zooming_out;\n        tile_source = this.model.tile_source;\n        min_zoom = tile_source.min_zoom;\n        max_zoom = tile_source.max_zoom;\n        tile_source.update();\n        extent = this.get_extent();\n        zooming_out = this.extent[2] - this.extent[0] < extent[2] - extent[0];\n        h = this.map_frame._height.value;\n        w = this.map_frame._width.value;\n        zoom_level = tile_source.get_level_by_extent(extent, h, w);\n        snap_back = false;\n        if (zoom_level < min_zoom) {\n            extent = this.extent;\n            zoom_level = min_zoom;\n            snap_back = true;\n        }\n        else if (zoom_level > max_zoom) {\n            extent = this.extent;\n            zoom_level = max_zoom;\n            snap_back = true;\n        }\n        if (snap_back) {\n            this.x_range.setv({\n                x_range: {\n                    start: extent[0],\n                    end: extent[2]\n                }\n            });\n            this.y_range.setv({\n                start: extent[1],\n                end: extent[3]\n            });\n            this.extent = extent;\n        }\n        this.extent = extent;\n        tiles = tile_source.get_tiles_by_extent(extent, zoom_level);\n        parents = [];\n        need_load = [];\n        cached = [];\n        children = [];\n        for (i = 0, len = tiles.length; i < len; i++) {\n            t = tiles[i];\n            x = t[0], y = t[1], z = t[2], bounds = t[3];\n            key = tile_source.tile_xyz_to_key(x, y, z);\n            tile = tile_source.tiles[key];\n            if ((tile != null) && tile.loaded === true) {\n                cached.push(key);\n            }\n            else {\n                if (this.model.render_parents) {\n                    ref = tile_source.get_closest_parent_by_tile_xyz(x, y, z), px = ref[0], py = ref[1], pz = ref[2];\n                    parent_key = tile_source.tile_xyz_to_key(px, py, pz);\n                    parent_tile = tile_source.tiles[parent_key];\n                    if ((parent_tile != null) && parent_tile.loaded && indexOf.call(parents, parent_key) < 0) {\n                        parents.push(parent_key);\n                    }\n                    if (zooming_out) {\n                        children = tile_source.children_by_tile_xyz(x, y, z);\n                        for (j = 0, len1 = children.length; j < len1; j++) {\n                            c = children[j];\n                            cx = c[0], cy = c[1], cz = c[2], cbounds = c[3];\n                            child_key = tile_source.tile_xyz_to_key(cx, cy, cz);\n                            if (child_key in tile_source.tiles) {\n                                children.push(child_key);\n                            }\n                        }\n                    }\n                }\n            }\n            if (tile == null) {\n                need_load.push(t);\n            }\n        }\n        this._render_tiles(parents);\n        this._render_tiles(children);\n        this._render_tiles(cached);\n        for (k = 0, len2 = cached.length; k < len2; k++) {\n            t = cached[k];\n            tile_source.tiles[t].current = true;\n        }\n        if (this.render_timer != null) {\n            clearTimeout(this.render_timer);\n        }\n        return this.render_timer = setTimeout(((function (_this) {\n            return function () {\n                return _this._fetch_tiles(need_load);\n            };\n        })(this)), 65);\n    };\n    return TileRendererView;\n})(renderer_1.RendererView);\nexports.TileRenderer = (function (superClass) {\n    extend(TileRenderer, superClass);\n    function TileRenderer() {\n        return TileRenderer.__super__.constructor.apply(this, arguments);\n    }\n    TileRenderer.prototype.default_view = exports.TileRendererView;\n    TileRenderer.prototype.type = 'TileRenderer';\n    TileRenderer.define({\n        alpha: [p.Number, 1.0],\n        x_range_name: [p.String, \"default\"],\n        y_range_name: [p.String, \"default\"],\n        tile_source: [\n            p.Instance, function () {\n                return new wmts_tile_source_1.WMTSTileSource();\n            }\n        ],\n        render_parents: [p.Bool, true]\n    });\n    TileRenderer.override({\n        level: 'underlay'\n    });\n    return TileRenderer;\n})(renderer_1.Renderer);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar image_pool_1 = require(\"./image_pool\");\nvar tile_utils_1 = require(\"./tile_utils\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar model_1 = require(\"../../model\");\nexports.TileSource = (function (superClass) {\n    extend(TileSource, superClass);\n    TileSource.prototype.type = 'TileSource';\n    TileSource.define({\n        url: [p.String, ''],\n        tile_size: [p.Number, 256],\n        max_zoom: [p.Number, 30],\n        min_zoom: [p.Number, 0],\n        extra_url_vars: [p.Any, {}],\n        attribution: [p.String, ''],\n        x_origin_offset: [p.Number],\n        y_origin_offset: [p.Number],\n        initial_resolution: [p.Number]\n    });\n    TileSource.prototype.initialize = function (options) {\n        TileSource.__super__.initialize.call(this, options);\n        return this.normalize_case();\n    };\n    function TileSource(options) {\n        if (options == null) {\n            options = {};\n        }\n        TileSource.__super__.constructor.apply(this, arguments);\n        this.utils = new tile_utils_1.ProjectionUtils();\n        this.pool = new image_pool_1.ImagePool();\n        this.tiles = {};\n        this.normalize_case();\n    }\n    TileSource.prototype.string_lookup_replace = function (str, lookup) {\n        var key, result_str, value;\n        result_str = str;\n        for (key in lookup) {\n            value = lookup[key];\n            result_str = result_str.replace('{' + key + '}', value.toString());\n        }\n        return result_str;\n    };\n    TileSource.prototype.normalize_case = function () {\n        'Note: should probably be refactored into subclasses.';\n        var url;\n        url = this.url;\n        url = url.replace('{x}', '{X}');\n        url = url.replace('{y}', '{Y}');\n        url = url.replace('{z}', '{Z}');\n        url = url.replace('{q}', '{Q}');\n        url = url.replace('{xmin}', '{XMIN}');\n        url = url.replace('{ymin}', '{YMIN}');\n        url = url.replace('{xmax}', '{XMAX}');\n        url = url.replace('{ymax}', '{YMAX}');\n        return this.url = url;\n    };\n    TileSource.prototype.update = function () {\n        var key, ref, results, tile;\n        logging_1.logger.debug(\"TileSource: tile cache count: \" + (Object.keys(this.tiles).length));\n        ref = this.tiles;\n        results = [];\n        for (key in ref) {\n            tile = ref[key];\n            tile.current = false;\n            results.push(tile.retain = false);\n        }\n        return results;\n    };\n    TileSource.prototype.tile_xyz_to_key = function (x, y, z) {\n        var key;\n        key = x + \":\" + y + \":\" + z;\n        return key;\n    };\n    TileSource.prototype.key_to_tile_xyz = function (key) {\n        var c;\n        return (function () {\n            var i, len, ref, results;\n            ref = key.split(':');\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n                c = ref[i];\n                results.push(parseInt(c));\n            }\n            return results;\n        })();\n    };\n    TileSource.prototype.sort_tiles_from_center = function (tiles, tile_extent) {\n        var center_x, center_y, txmax, txmin, tymax, tymin;\n        txmin = tile_extent[0], tymin = tile_extent[1], txmax = tile_extent[2], tymax = tile_extent[3];\n        center_x = (txmax - txmin) / 2 + txmin;\n        center_y = (tymax - tymin) / 2 + tymin;\n        tiles.sort(function (a, b) {\n            var a_distance, b_distance;\n            a_distance = Math.sqrt(Math.pow(center_x - a[0], 2) + Math.pow(center_y - a[1], 2));\n            b_distance = Math.sqrt(Math.pow(center_x - b[0], 2) + Math.pow(center_y - b[1], 2));\n            return a_distance - b_distance;\n        });\n        return tiles;\n    };\n    TileSource.prototype.prune_tiles = function () {\n        var key, ref, ref1, results, tile;\n        ref = this.tiles;\n        for (key in ref) {\n            tile = ref[key];\n            tile.retain = tile.current || tile.tile_coords[2] < 3;\n            if (tile.current) {\n                this.retain_neighbors(tile);\n                this.retain_children(tile);\n                this.retain_parents(tile);\n            }\n        }\n        ref1 = this.tiles;\n        results = [];\n        for (key in ref1) {\n            tile = ref1[key];\n            if (!tile.retain) {\n                results.push(this.remove_tile(key));\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    TileSource.prototype.remove_tile = function (key) {\n        var tile;\n        tile = this.tiles[key];\n        if (tile != null) {\n            this.pool.push(tile.img);\n            return delete this.tiles[key];\n        }\n    };\n    TileSource.prototype.get_image_url = function (x, y, z) {\n        var image_url;\n        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n        return image_url.replace(\"{X}\", x).replace('{Y}', y).replace(\"{Z}\", z);\n    };\n    TileSource.prototype.retain_neighbors = function (reference_tile) {\n        throw new Error(\"Not Implemented\");\n    };\n    TileSource.prototype.retain_parents = function (reference_tile) {\n        throw new Error(\"Not Implemented\");\n    };\n    TileSource.prototype.retain_children = function (reference_tile) {\n        throw new Error(\"Not Implemented\");\n    };\n    TileSource.prototype.tile_xyz_to_quadkey = function (x, y, z) {\n        throw new Error(\"Not Implemented\");\n    };\n    TileSource.prototype.quadkey_to_tile_xyz = function (quadkey) {\n        throw new Error(\"Not Implemented\");\n    };\n    return TileSource;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar proj4_1 = require(\"core/util/proj4\");\nexports.ProjectionUtils = (function () {\n    function ProjectionUtils() {\n        this.origin_shift = 2 * Math.PI * 6378137 / 2.0;\n    }\n    ProjectionUtils.prototype.geographic_to_meters = function (xLon, yLat) {\n        return proj4_1.proj4(proj4_1.wgs84, proj4_1.mercator, [xLon, yLat]);\n    };\n    ProjectionUtils.prototype.meters_to_geographic = function (mx, my) {\n        return proj4_1.proj4(proj4_1.mercator, proj4_1.wgs84, [mx, my]);\n    };\n    ProjectionUtils.prototype.geographic_extent_to_meters = function (extent) {\n        var ref, ref1, xmax, xmin, ymax, ymin;\n        xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];\n        ref = this.geographic_to_meters(xmin, ymin), xmin = ref[0], ymin = ref[1];\n        ref1 = this.geographic_to_meters(xmax, ymax), xmax = ref1[0], ymax = ref1[1];\n        return [xmin, ymin, xmax, ymax];\n    };\n    ProjectionUtils.prototype.meters_extent_to_geographic = function (extent) {\n        var ref, ref1, xmax, xmin, ymax, ymin;\n        xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];\n        ref = this.meters_to_geographic(xmin, ymin), xmin = ref[0], ymin = ref[1];\n        ref1 = this.meters_to_geographic(xmax, ymax), xmax = ref1[0], ymax = ref1[1];\n        return [xmin, ymin, xmax, ymax];\n    };\n    return ProjectionUtils;\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar mercator_tile_source_1 = require(\"./mercator_tile_source\");\nexports.TMSTileSource = (function (superClass) {\n    extend(TMSTileSource, superClass);\n    function TMSTileSource() {\n        return TMSTileSource.__super__.constructor.apply(this, arguments);\n    }\n    TMSTileSource.prototype.type = 'TMSTileSource';\n    TMSTileSource.prototype.get_image_url = function (x, y, z) {\n        var image_url;\n        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n        return image_url.replace(\"{X}\", x).replace('{Y}', y).replace(\"{Z}\", z);\n    };\n    return TMSTileSource;\n})(mercator_tile_source_1.MercatorTileSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar mercator_tile_source_1 = require(\"./mercator_tile_source\");\nexports.WMTSTileSource = (function (superClass) {\n    extend(WMTSTileSource, superClass);\n    function WMTSTileSource() {\n        return WMTSTileSource.__super__.constructor.apply(this, arguments);\n    }\n    WMTSTileSource.prototype.type = 'WMTSTileSource';\n    WMTSTileSource.prototype.get_image_url = function (x, y, z) {\n        var image_url, ref;\n        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n        ref = this.tms_to_wmts(x, y, z), x = ref[0], y = ref[1], z = ref[2];\n        return image_url.replace(\"{X}\", x).replace('{Y}', y).replace(\"{Z}\", z);\n    };\n    return WMTSTileSource;\n})(mercator_tile_source_1.MercatorTileSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar button_tool_1 = require(\"../button_tool\");\nvar signaling_1 = require(\"core/signaling\");\nexports.ActionToolButtonView = (function (superClass) {\n    extend(ActionToolButtonView, superClass);\n    function ActionToolButtonView() {\n        return ActionToolButtonView.__super__.constructor.apply(this, arguments);\n    }\n    ActionToolButtonView.prototype._clicked = function () {\n        return this.model[\"do\"].emit();\n    };\n    return ActionToolButtonView;\n})(button_tool_1.ButtonToolButtonView);\nexports.ActionToolView = (function (superClass) {\n    extend(ActionToolView, superClass);\n    function ActionToolView() {\n        return ActionToolView.__super__.constructor.apply(this, arguments);\n    }\n    ActionToolView.prototype.initialize = function (options) {\n        ActionToolView.__super__.initialize.call(this, options);\n        return this.connect(this.model[\"do\"], function () {\n            return this.doit();\n        });\n    };\n    return ActionToolView;\n})(button_tool_1.ButtonToolView);\nexports.ActionTool = (function (superClass) {\n    extend(ActionTool, superClass);\n    function ActionTool() {\n        return ActionTool.__super__.constructor.apply(this, arguments);\n    }\n    ActionTool.prototype.initialize = function (attrs, options) {\n        ActionTool.__super__.initialize.call(this, attrs, options);\n        return this[\"do\"] = new signaling_1.Signal(this, \"do\");\n    };\n    return ActionTool;\n})(button_tool_1.ButtonTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar action_tool_1 = require(\"./action_tool\");\nvar p = require(\"core/properties\");\nexports.HelpToolView = (function (superClass) {\n    extend(HelpToolView, superClass);\n    function HelpToolView() {\n        return HelpToolView.__super__.constructor.apply(this, arguments);\n    }\n    HelpToolView.prototype.doit = function () {\n        return window.open(this.model.redirect);\n    };\n    return HelpToolView;\n})(action_tool_1.ActionToolView);\nexports.HelpTool = (function (superClass) {\n    extend(HelpTool, superClass);\n    function HelpTool() {\n        return HelpTool.__super__.constructor.apply(this, arguments);\n    }\n    HelpTool.prototype.default_view = exports.HelpToolView;\n    HelpTool.prototype.type = \"HelpTool\";\n    HelpTool.prototype.tool_name = \"Help\";\n    HelpTool.prototype.icon = \"bk-tool-icon-help\";\n    HelpTool.define({\n        help_tooltip: [p.String, 'Click the question mark to learn more about Bokeh plot tools.'],\n        redirect: [p.String, 'http://bokeh.pydata.org/en/latest/docs/user_guide/tools.html#built-in-tools']\n    });\n    HelpTool.getters({\n        tooltip: function () {\n            return this.help_tooltip;\n        }\n    });\n    return HelpTool;\n})(action_tool_1.ActionTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar action_tool_1 = require(\"./action_tool\");\nexports.RedoToolView = (function (superClass) {\n    extend(RedoToolView, superClass);\n    function RedoToolView() {\n        return RedoToolView.__super__.constructor.apply(this, arguments);\n    }\n    RedoToolView.prototype.initialize = function (options) {\n        RedoToolView.__super__.initialize.call(this, options);\n        return this.connect(this.plot_view.state_changed, (function (_this) {\n            return function () {\n                return _this.model.disabled = !_this.plot_view.can_redo();\n            };\n        })(this));\n    };\n    RedoToolView.prototype.doit = function () {\n        return this.plot_view.redo();\n    };\n    return RedoToolView;\n})(action_tool_1.ActionToolView);\nexports.RedoTool = (function (superClass) {\n    extend(RedoTool, superClass);\n    function RedoTool() {\n        return RedoTool.__super__.constructor.apply(this, arguments);\n    }\n    RedoTool.prototype.default_view = exports.RedoToolView;\n    RedoTool.prototype.type = \"RedoTool\";\n    RedoTool.prototype.tool_name = \"Redo\";\n    RedoTool.prototype.icon = \"bk-tool-icon-redo\";\n    RedoTool.override({\n        disabled: true\n    });\n    return RedoTool;\n})(action_tool_1.ActionTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar action_tool_1 = require(\"./action_tool\");\nvar p = require(\"core/properties\");\nexports.ResetToolView = (function (superClass) {\n    extend(ResetToolView, superClass);\n    function ResetToolView() {\n        return ResetToolView.__super__.constructor.apply(this, arguments);\n    }\n    ResetToolView.prototype.doit = function () {\n        this.plot_view.clear_state();\n        this.plot_view.reset_range();\n        this.plot_view.reset_selection();\n        if (this.model.reset_size) {\n            return this.plot_view.reset_dimensions();\n        }\n    };\n    return ResetToolView;\n})(action_tool_1.ActionToolView);\nexports.ResetTool = (function (superClass) {\n    extend(ResetTool, superClass);\n    function ResetTool() {\n        return ResetTool.__super__.constructor.apply(this, arguments);\n    }\n    ResetTool.prototype.default_view = exports.ResetToolView;\n    ResetTool.prototype.type = \"ResetTool\";\n    ResetTool.prototype.tool_name = \"Reset\";\n    ResetTool.prototype.icon = \"bk-tool-icon-reset\";\n    ResetTool.define({\n        reset_size: [p.Bool, true]\n    });\n    return ResetTool;\n})(action_tool_1.ActionTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar action_tool_1 = require(\"./action_tool\");\nexports.SaveToolView = (function (superClass) {\n    extend(SaveToolView, superClass);\n    function SaveToolView() {\n        return SaveToolView.__super__.constructor.apply(this, arguments);\n    }\n    SaveToolView.prototype.doit = function () {\n        return this.plot_view.save(\"bokeh_plot\");\n    };\n    return SaveToolView;\n})(action_tool_1.ActionToolView);\nexports.SaveTool = (function (superClass) {\n    extend(SaveTool, superClass);\n    function SaveTool() {\n        return SaveTool.__super__.constructor.apply(this, arguments);\n    }\n    SaveTool.prototype.default_view = exports.SaveToolView;\n    SaveTool.prototype.type = \"SaveTool\";\n    SaveTool.prototype.tool_name = \"Save\";\n    SaveTool.prototype.icon = \"bk-tool-icon-save\";\n    return SaveTool;\n})(action_tool_1.ActionTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar action_tool_1 = require(\"./action_tool\");\nexports.UndoToolView = (function (superClass) {\n    extend(UndoToolView, superClass);\n    function UndoToolView() {\n        return UndoToolView.__super__.constructor.apply(this, arguments);\n    }\n    UndoToolView.prototype.initialize = function (options) {\n        UndoToolView.__super__.initialize.call(this, options);\n        return this.connect(this.plot_view.state_changed, (function (_this) {\n            return function () {\n                return _this.model.disabled = !_this.plot_view.can_undo();\n            };\n        })(this));\n    };\n    UndoToolView.prototype.doit = function () {\n        return this.plot_view.undo();\n    };\n    return UndoToolView;\n})(action_tool_1.ActionToolView);\nexports.UndoTool = (function (superClass) {\n    extend(UndoTool, superClass);\n    function UndoTool() {\n        return UndoTool.__super__.constructor.apply(this, arguments);\n    }\n    UndoTool.prototype.default_view = exports.UndoToolView;\n    UndoTool.prototype.type = \"UndoTool\";\n    UndoTool.prototype.tool_name = \"Undo\";\n    UndoTool.prototype.icon = \"bk-tool-icon-undo\";\n    UndoTool.override({\n        disabled: true\n    });\n    return UndoTool;\n})(action_tool_1.ActionTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar action_tool_1 = require(\"./action_tool\");\nvar zoom_1 = require(\"core/util/zoom\");\nvar p = require(\"core/properties\");\nexports.ZoomInToolView = (function (superClass) {\n    extend(ZoomInToolView, superClass);\n    function ZoomInToolView() {\n        return ZoomInToolView.__super__.constructor.apply(this, arguments);\n    }\n    ZoomInToolView.prototype.doit = function () {\n        var dims, frame, h_axis, v_axis, zoom_info;\n        frame = this.plot_model.frame;\n        dims = this.model.dimensions;\n        h_axis = dims === 'width' || dims === 'both';\n        v_axis = dims === 'height' || dims === 'both';\n        zoom_info = zoom_1.scale_range(frame, this.model.factor, h_axis, v_axis);\n        this.plot_view.push_state('zoom_out', {\n            range: zoom_info\n        });\n        this.plot_view.update_range(zoom_info, false, true);\n        this.plot_view.interactive_timestamp = Date.now();\n        return null;\n    };\n    return ZoomInToolView;\n})(action_tool_1.ActionToolView);\nexports.ZoomInTool = (function (superClass) {\n    extend(ZoomInTool, superClass);\n    function ZoomInTool() {\n        return ZoomInTool.__super__.constructor.apply(this, arguments);\n    }\n    ZoomInTool.prototype.default_view = exports.ZoomInToolView;\n    ZoomInTool.prototype.type = \"ZoomInTool\";\n    ZoomInTool.prototype.tool_name = \"Zoom In\";\n    ZoomInTool.prototype.icon = \"bk-tool-icon-zoom-in\";\n    ZoomInTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\n        }\n    });\n    ZoomInTool.define({\n        factor: [p.Percent, 0.1],\n        dimensions: [p.Dimensions, \"both\"]\n    });\n    return ZoomInTool;\n})(action_tool_1.ActionTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar action_tool_1 = require(\"./action_tool\");\nvar zoom_1 = require(\"core/util/zoom\");\nvar p = require(\"core/properties\");\nexports.ZoomOutToolView = (function (superClass) {\n    extend(ZoomOutToolView, superClass);\n    function ZoomOutToolView() {\n        return ZoomOutToolView.__super__.constructor.apply(this, arguments);\n    }\n    ZoomOutToolView.prototype.doit = function () {\n        var dims, frame, h_axis, v_axis, zoom_info;\n        frame = this.plot_model.frame;\n        dims = this.model.dimensions;\n        h_axis = dims === 'width' || dims === 'both';\n        v_axis = dims === 'height' || dims === 'both';\n        zoom_info = zoom_1.scale_range(frame, -this.model.factor, h_axis, v_axis);\n        this.plot_view.push_state('zoom_out', {\n            range: zoom_info\n        });\n        this.plot_view.update_range(zoom_info, false, true);\n        this.plot_view.interactive_timestamp = Date.now();\n        return null;\n    };\n    return ZoomOutToolView;\n})(action_tool_1.ActionToolView);\nexports.ZoomOutTool = (function (superClass) {\n    extend(ZoomOutTool, superClass);\n    function ZoomOutTool() {\n        return ZoomOutTool.__super__.constructor.apply(this, arguments);\n    }\n    ZoomOutTool.prototype.default_view = exports.ZoomOutToolView;\n    ZoomOutTool.prototype.type = \"ZoomOutTool\";\n    ZoomOutTool.prototype.tool_name = \"Zoom Out\";\n    ZoomOutTool.prototype.icon = \"bk-tool-icon-zoom-out\";\n    ZoomOutTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\n        }\n    });\n    ZoomOutTool.define({\n        factor: [p.Percent, 0.1],\n        dimensions: [p.Dimensions, \"both\"]\n    });\n    return ZoomOutTool;\n})(action_tool_1.ActionTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar dom_view_1 = require(\"core/dom_view\");\nvar tool_1 = require(\"./tool\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nexports.ButtonToolButtonView = (function (superClass) {\n    extend(ButtonToolButtonView, superClass);\n    function ButtonToolButtonView() {\n        return ButtonToolButtonView.__super__.constructor.apply(this, arguments);\n    }\n    ButtonToolButtonView.prototype.className = \"bk-toolbar-button\";\n    ButtonToolButtonView.prototype.initialize = function (options) {\n        ButtonToolButtonView.__super__.initialize.call(this, options);\n        this.connect(this.model.change, (function (_this) {\n            return function () {\n                return _this.render();\n            };\n        })(this));\n        this.el.addEventListener(\"click\", (function (_this) {\n            return function (e) {\n                return _this._clicked(e);\n            };\n        })(this));\n        return this.render();\n    };\n    ButtonToolButtonView.prototype.render = function () {\n        var icon, tip;\n        dom_1.empty(this.el);\n        this.el.disabled = this.model.disabled;\n        icon = dom_1.div({\n            \"class\": ['bk-btn-icon', this.model.icon]\n        });\n        tip = dom_1.span({\n            \"class\": 'bk-tip'\n        }, this.model.tooltip);\n        this.el.appendChild(icon);\n        return this.el.appendChild(tip);\n    };\n    ButtonToolButtonView.prototype._clicked = function (e) { };\n    return ButtonToolButtonView;\n})(dom_view_1.DOMView);\nexports.ButtonToolView = (function (superClass) {\n    extend(ButtonToolView, superClass);\n    function ButtonToolView() {\n        return ButtonToolView.__super__.constructor.apply(this, arguments);\n    }\n    return ButtonToolView;\n})(tool_1.ToolView);\nexports.ButtonTool = (function (superClass) {\n    extend(ButtonTool, superClass);\n    function ButtonTool() {\n        return ButtonTool.__super__.constructor.apply(this, arguments);\n    }\n    ButtonTool.prototype.icon = null;\n    ButtonTool.getters({\n        tooltip: function () {\n            return this.tool_name;\n        }\n    });\n    ButtonTool.internal({\n        disabled: [p.Boolean, false]\n    });\n    return ButtonTool;\n})(tool_1.Tool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_BOX_OVERLAY, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar select_tool_1 = require(\"./select_tool\");\nvar box_annotation_1 = require(\"../../annotations/box_annotation\");\nvar p = require(\"core/properties\");\nexports.BoxSelectToolView = (function (superClass) {\n    extend(BoxSelectToolView, superClass);\n    function BoxSelectToolView() {\n        return BoxSelectToolView.__super__.constructor.apply(this, arguments);\n    }\n    BoxSelectToolView.prototype._pan_start = function (e) {\n        var canvas;\n        canvas = this.plot_view.canvas;\n        this._baseboint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];\n        return null;\n    };\n    BoxSelectToolView.prototype._pan = function (e) {\n        var append, canvas, curpoint, dims, frame, ref, ref1, vxlim, vylim;\n        canvas = this.plot_view.canvas;\n        curpoint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];\n        frame = this.plot_model.frame;\n        dims = this.model.dimensions;\n        ref = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vxlim = ref[0], vylim = ref[1];\n        this.model.overlay.update({\n            left: vxlim[0],\n            right: vxlim[1],\n            top: vylim[1],\n            bottom: vylim[0]\n        });\n        if (this.model.select_every_mousemove) {\n            append = (ref1 = e.srcEvent.shiftKey) != null ? ref1 : false;\n            this._select(vxlim, vylim, false, append);\n        }\n        return null;\n    };\n    BoxSelectToolView.prototype._pan_end = function (e) {\n        var append, canvas, curpoint, dims, frame, ref, ref1, vxlim, vylim;\n        canvas = this.plot_view.canvas;\n        curpoint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];\n        frame = this.plot_model.frame;\n        dims = this.model.dimensions;\n        ref = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vxlim = ref[0], vylim = ref[1];\n        append = (ref1 = e.srcEvent.shiftKey) != null ? ref1 : false;\n        this._select(vxlim, vylim, true, append);\n        this.model.overlay.update({\n            left: null,\n            right: null,\n            top: null,\n            bottom: null\n        });\n        this._baseboint = null;\n        this.plot_view.push_state('box_select', {\n            selection: this.plot_view.get_selection()\n        });\n        return null;\n    };\n    BoxSelectToolView.prototype._select = function (arg, arg1, final, append) {\n        var ds, geometry, r, renderers, renderers_by_source, sm, vx0, vx1, vy0, vy1;\n        vx0 = arg[0], vx1 = arg[1];\n        vy0 = arg1[0], vy1 = arg1[1];\n        if (append == null) {\n            append = false;\n        }\n        geometry = {\n            type: 'rect',\n            vx0: vx0,\n            vx1: vx1,\n            vy0: vy0,\n            vy1: vy1\n        };\n        renderers_by_source = this.model._computed_renderers_by_data_source();\n        for (ds in renderers_by_source) {\n            renderers = renderers_by_source[ds];\n            sm = renderers[0].data_source.selection_manager;\n            sm.select(this, (function () {\n                var i, len, results;\n                results = [];\n                for (i = 0, len = renderers.length; i < len; i++) {\n                    r = renderers[i];\n                    results.push(this.plot_view.renderer_views[r.id]);\n                }\n                return results;\n            }).call(this), geometry, final, append);\n        }\n        if (this.model.callback != null) {\n            this._emit_callback(geometry);\n        }\n        this._save_geometry(geometry, final, append);\n        return null;\n    };\n    BoxSelectToolView.prototype._emit_callback = function (geometry) {\n        var canvas, frame, r, xscale, yscale;\n        r = this.model.computed_renderers[0];\n        canvas = this.plot_model.canvas;\n        frame = this.plot_model.frame;\n        geometry['sx0'] = canvas.vx_to_sx(geometry.vx0);\n        geometry['sx1'] = canvas.vx_to_sx(geometry.vx1);\n        geometry['sy0'] = canvas.vy_to_sy(geometry.vy0);\n        geometry['sy1'] = canvas.vy_to_sy(geometry.vy1);\n        xscale = frame.xscales[r.x_range_name];\n        yscale = frame.yscales[r.y_range_name];\n        geometry['x0'] = xscale.invert(geometry.vx0);\n        geometry['x1'] = xscale.invert(geometry.vx1);\n        geometry['y0'] = yscale.invert(geometry.vy0);\n        geometry['y1'] = yscale.invert(geometry.vy1);\n        this.model.callback.execute(this.model, {\n            geometry: geometry\n        });\n    };\n    return BoxSelectToolView;\n})(select_tool_1.SelectToolView);\nDEFAULT_BOX_OVERLAY = function () {\n    return new box_annotation_1.BoxAnnotation({\n        level: \"overlay\",\n        render_mode: \"css\",\n        top_units: \"screen\",\n        left_units: \"screen\",\n        bottom_units: \"screen\",\n        right_units: \"screen\",\n        fill_color: {\n            value: \"lightgrey\"\n        },\n        fill_alpha: {\n            value: 0.5\n        },\n        line_color: {\n            value: \"black\"\n        },\n        line_alpha: {\n            value: 1.0\n        },\n        line_width: {\n            value: 2\n        },\n        line_dash: {\n            value: [4, 4]\n        }\n    });\n};\nexports.BoxSelectTool = (function (superClass) {\n    extend(BoxSelectTool, superClass);\n    function BoxSelectTool() {\n        return BoxSelectTool.__super__.constructor.apply(this, arguments);\n    }\n    BoxSelectTool.prototype.default_view = exports.BoxSelectToolView;\n    BoxSelectTool.prototype.type = \"BoxSelectTool\";\n    BoxSelectTool.prototype.tool_name = \"Box Select\";\n    BoxSelectTool.prototype.icon = \"bk-tool-icon-box-select\";\n    BoxSelectTool.prototype.event_type = \"pan\";\n    BoxSelectTool.prototype.default_order = 30;\n    BoxSelectTool.define({\n        dimensions: [p.Dimensions, \"both\"],\n        select_every_mousemove: [p.Bool, false],\n        callback: [p.Instance],\n        overlay: [p.Instance, DEFAULT_BOX_OVERLAY]\n    });\n    BoxSelectTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\n        }\n    });\n    return BoxSelectTool;\n})(select_tool_1.SelectTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_BOX_OVERLAY, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gesture_tool_1 = require(\"./gesture_tool\");\nvar box_annotation_1 = require(\"../../annotations/box_annotation\");\nvar p = require(\"core/properties\");\nexports.BoxZoomToolView = (function (superClass) {\n    extend(BoxZoomToolView, superClass);\n    function BoxZoomToolView() {\n        return BoxZoomToolView.__super__.constructor.apply(this, arguments);\n    }\n    BoxZoomToolView.prototype._match_aspect = function (basepoint, curpoint, frame) {\n        var a, bottom, h, hend, hstart, left, ref, ref1, right, top, va, vend, vh, vstart, vw, w, xmod, ymod;\n        hend = frame.h_range.end;\n        hstart = frame.h_range.start;\n        vend = frame.v_range.end;\n        vstart = frame.v_range.start;\n        w = hend - hstart;\n        h = vend - vstart;\n        a = w / h;\n        vw = Math.abs(basepoint[0] - curpoint[0]);\n        vh = Math.abs(basepoint[1] - curpoint[1]);\n        if (vh === 0) {\n            va = 0;\n        }\n        else {\n            va = vw / vh;\n        }\n        if (va >= a) {\n            ref = [1, va / a], xmod = ref[0], ymod = ref[1];\n        }\n        else {\n            ref1 = [a / va, 1], xmod = ref1[0], ymod = ref1[1];\n        }\n        if (basepoint[0] <= curpoint[0]) {\n            left = basepoint[0];\n            right = basepoint[0] + vw * xmod;\n            if (right > hend) {\n                right = hend;\n            }\n        }\n        else {\n            right = basepoint[0];\n            left = basepoint[0] - vw * xmod;\n            if (left < hstart) {\n                left = hstart;\n            }\n        }\n        vw = Math.abs(right - left);\n        if (basepoint[1] <= curpoint[1]) {\n            bottom = basepoint[1];\n            top = basepoint[1] + vw / a;\n            if (top > vend) {\n                top = vend;\n            }\n        }\n        else {\n            top = basepoint[1];\n            bottom = basepoint[1] - vw / a;\n            if (bottom < vstart) {\n                bottom = vstart;\n            }\n        }\n        vh = Math.abs(top - bottom);\n        if (basepoint[0] <= curpoint[0]) {\n            right = basepoint[0] + a * vh;\n        }\n        else {\n            left = basepoint[0] - a * vh;\n        }\n        return [[left, right], [bottom, top]];\n    };\n    BoxZoomToolView.prototype._pan_start = function (e) {\n        var canvas;\n        canvas = this.plot_view.canvas;\n        this._baseboint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];\n        return null;\n    };\n    BoxZoomToolView.prototype._pan = function (e) {\n        var canvas, curpoint, dims, frame, ref, ref1, vx, vy;\n        canvas = this.plot_view.canvas;\n        curpoint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];\n        frame = this.plot_model.frame;\n        dims = this.model.dimensions;\n        if (this.model.match_aspect && dims === 'both') {\n            ref = this._match_aspect(this._baseboint, curpoint, frame), vx = ref[0], vy = ref[1];\n        }\n        else {\n            ref1 = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vx = ref1[0], vy = ref1[1];\n        }\n        this.model.overlay.update({\n            left: vx[0],\n            right: vx[1],\n            top: vy[1],\n            bottom: vy[0]\n        });\n        return null;\n    };\n    BoxZoomToolView.prototype._pan_end = function (e) {\n        var canvas, curpoint, dims, frame, ref, ref1, vx, vy;\n        canvas = this.plot_view.canvas;\n        curpoint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];\n        frame = this.plot_model.frame;\n        dims = this.model.dimensions;\n        if (this.model.match_aspect && dims === 'both') {\n            ref = this._match_aspect(this._baseboint, curpoint, frame), vx = ref[0], vy = ref[1];\n        }\n        else {\n            ref1 = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vx = ref1[0], vy = ref1[1];\n        }\n        this._update(vx, vy);\n        this.model.overlay.update({\n            left: null,\n            right: null,\n            top: null,\n            bottom: null\n        });\n        this._baseboint = null;\n        return null;\n    };\n    BoxZoomToolView.prototype._update = function (vx, vy) {\n        var end, name, ref, ref1, ref2, ref3, scale, start, xrs, yrs, zoom_info;\n        if (Math.abs(vx[1] - vx[0]) <= 5 || Math.abs(vy[1] - vy[0]) <= 5) {\n            return;\n        }\n        xrs = {};\n        ref = this.plot_view.frame.xscales;\n        for (name in ref) {\n            scale = ref[name];\n            ref1 = scale.v_invert(vx, true), start = ref1[0], end = ref1[1];\n            xrs[name] = {\n                start: start,\n                end: end\n            };\n        }\n        yrs = {};\n        ref2 = this.plot_view.frame.yscales;\n        for (name in ref2) {\n            scale = ref2[name];\n            ref3 = scale.v_invert(vy, true), start = ref3[0], end = ref3[1];\n            yrs[name] = {\n                start: start,\n                end: end\n            };\n        }\n        zoom_info = {\n            xrs: xrs,\n            yrs: yrs\n        };\n        this.plot_view.push_state('box_zoom', {\n            range: zoom_info\n        });\n        return this.plot_view.update_range(zoom_info);\n    };\n    return BoxZoomToolView;\n})(gesture_tool_1.GestureToolView);\nDEFAULT_BOX_OVERLAY = function () {\n    return new box_annotation_1.BoxAnnotation({\n        level: \"overlay\",\n        render_mode: \"css\",\n        top_units: \"screen\",\n        left_units: \"screen\",\n        bottom_units: \"screen\",\n        right_units: \"screen\",\n        fill_color: {\n            value: \"lightgrey\"\n        },\n        fill_alpha: {\n            value: 0.5\n        },\n        line_color: {\n            value: \"black\"\n        },\n        line_alpha: {\n            value: 1.0\n        },\n        line_width: {\n            value: 2\n        },\n        line_dash: {\n            value: [4, 4]\n        }\n    });\n};\nexports.BoxZoomTool = (function (superClass) {\n    extend(BoxZoomTool, superClass);\n    function BoxZoomTool() {\n        return BoxZoomTool.__super__.constructor.apply(this, arguments);\n    }\n    BoxZoomTool.prototype.default_view = exports.BoxZoomToolView;\n    BoxZoomTool.prototype.type = \"BoxZoomTool\";\n    BoxZoomTool.prototype.tool_name = \"Box Zoom\";\n    BoxZoomTool.prototype.icon = \"bk-tool-icon-box-zoom\";\n    BoxZoomTool.prototype.event_type = \"pan\";\n    BoxZoomTool.prototype.default_order = 20;\n    BoxZoomTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\n        }\n    });\n    BoxZoomTool.define({\n        dimensions: [p.Dimensions, \"both\"],\n        overlay: [p.Instance, DEFAULT_BOX_OVERLAY],\n        match_aspect: [p.Bool, false]\n    });\n    return BoxZoomTool;\n})(gesture_tool_1.GestureTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar button_tool_1 = require(\"../button_tool\");\nexports.GestureToolView = (function (superClass) {\n    extend(GestureToolView, superClass);\n    function GestureToolView() {\n        return GestureToolView.__super__.constructor.apply(this, arguments);\n    }\n    return GestureToolView;\n})(button_tool_1.ButtonToolView);\nexports.GestureTool = (function (superClass) {\n    extend(GestureTool, superClass);\n    function GestureTool() {\n        return GestureTool.__super__.constructor.apply(this, arguments);\n    }\n    GestureTool.prototype.event_type = null;\n    GestureTool.prototype.default_order = null;\n    return GestureTool;\n})(button_tool_1.ButtonTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_POLY_OVERLAY, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar select_tool_1 = require(\"./select_tool\");\nvar poly_annotation_1 = require(\"../../annotations/poly_annotation\");\nvar p = require(\"core/properties\");\nexports.LassoSelectToolView = (function (superClass) {\n    extend(LassoSelectToolView, superClass);\n    function LassoSelectToolView() {\n        return LassoSelectToolView.__super__.constructor.apply(this, arguments);\n    }\n    LassoSelectToolView.prototype.initialize = function (options) {\n        LassoSelectToolView.__super__.initialize.call(this, options);\n        this.connect(this.model.properties.active.change, function () {\n            return this._active_change();\n        });\n        return this.data = null;\n    };\n    LassoSelectToolView.prototype._active_change = function () {\n        if (!this.model.active) {\n            return this._clear_overlay();\n        }\n    };\n    LassoSelectToolView.prototype._keyup = function (e) {\n        if (e.keyCode === 13) {\n            return this._clear_overlay();\n        }\n    };\n    LassoSelectToolView.prototype._pan_start = function (e) {\n        var canvas, vx, vy;\n        canvas = this.plot_view.canvas;\n        vx = canvas.sx_to_vx(e.bokeh.sx);\n        vy = canvas.sy_to_vy(e.bokeh.sy);\n        this.data = {\n            vx: [vx],\n            vy: [vy]\n        };\n        return null;\n    };\n    LassoSelectToolView.prototype._pan = function (e) {\n        var append, canvas, h_range, overlay, ref, v_range, vx, vy;\n        canvas = this.plot_view.canvas;\n        vx = canvas.sx_to_vx(e.bokeh.sx);\n        vy = canvas.sy_to_vy(e.bokeh.sy);\n        h_range = this.plot_model.frame.h_range;\n        v_range = this.plot_model.frame.v_range;\n        if (vx > h_range.end) {\n            vx = h_range.end;\n        }\n        if (vx < h_range.start) {\n            vx = h_range.start;\n        }\n        if (vy > v_range.end) {\n            vy = v_range.end;\n        }\n        if (vy < v_range.start) {\n            vy = v_range.start;\n        }\n        this.data.vx.push(vx);\n        this.data.vy.push(vy);\n        overlay = this.model.overlay;\n        overlay.update({\n            xs: this.data.vx,\n            ys: this.data.vy\n        });\n        if (this.model.select_every_mousemove) {\n            append = (ref = e.srcEvent.shiftKey) != null ? ref : false;\n            return this._select(this.data.vx, this.data.vy, false, append);\n        }\n    };\n    LassoSelectToolView.prototype._pan_end = function (e) {\n        var append, ref;\n        this._clear_overlay();\n        append = (ref = e.srcEvent.shiftKey) != null ? ref : false;\n        this._select(this.data.vx, this.data.vy, true, append);\n        return this.plot_view.push_state('lasso_select', {\n            selection: this.plot_view.get_selection()\n        });\n    };\n    LassoSelectToolView.prototype._clear_overlay = function () {\n        return this.model.overlay.update({\n            xs: [],\n            ys: []\n        });\n    };\n    LassoSelectToolView.prototype._select = function (vx, vy, final, append) {\n        var ds, geometry, r, renderers, renderers_by_source, sm;\n        geometry = {\n            type: 'poly',\n            vx: vx,\n            vy: vy\n        };\n        renderers_by_source = this.model._computed_renderers_by_data_source();\n        for (ds in renderers_by_source) {\n            renderers = renderers_by_source[ds];\n            sm = renderers[0].data_source.selection_manager;\n            sm.select(this, (function () {\n                var i, len, results;\n                results = [];\n                for (i = 0, len = renderers.length; i < len; i++) {\n                    r = renderers[i];\n                    results.push(this.plot_view.renderer_views[r.id]);\n                }\n                return results;\n            }).call(this), geometry, final, append);\n        }\n        if (this.model.callback != null) {\n            this._emit_callback(geometry);\n        }\n        this._save_geometry(geometry, final, append);\n        return null;\n    };\n    LassoSelectToolView.prototype._emit_callback = function (geometry) {\n        var canvas, frame, r, xscale, yscale;\n        r = this.model.computed_renderers[0];\n        canvas = this.plot_model.canvas;\n        frame = this.plot_model.frame;\n        geometry['sx'] = canvas.v_vx_to_sx(geometry.vx);\n        geometry['sy'] = canvas.v_vy_to_sy(geometry.vy);\n        xscale = frame.xscales[r.x_range_name];\n        yscale = frame.yscales[r.y_range_name];\n        geometry['x'] = xscale.v_invert(geometry.vx);\n        geometry['y'] = yscale.v_invert(geometry.vy);\n        this.model.callback.execute(this.model, {\n            geometry: geometry\n        });\n    };\n    return LassoSelectToolView;\n})(select_tool_1.SelectToolView);\nDEFAULT_POLY_OVERLAY = function () {\n    return new poly_annotation_1.PolyAnnotation({\n        level: \"overlay\",\n        xs_units: \"screen\",\n        ys_units: \"screen\",\n        fill_color: {\n            value: \"lightgrey\"\n        },\n        fill_alpha: {\n            value: 0.5\n        },\n        line_color: {\n            value: \"black\"\n        },\n        line_alpha: {\n            value: 1.0\n        },\n        line_width: {\n            value: 2\n        },\n        line_dash: {\n            value: [4, 4]\n        }\n    });\n};\nexports.LassoSelectTool = (function (superClass) {\n    extend(LassoSelectTool, superClass);\n    function LassoSelectTool() {\n        return LassoSelectTool.__super__.constructor.apply(this, arguments);\n    }\n    LassoSelectTool.prototype.default_view = exports.LassoSelectToolView;\n    LassoSelectTool.prototype.type = \"LassoSelectTool\";\n    LassoSelectTool.prototype.tool_name = \"Lasso Select\";\n    LassoSelectTool.prototype.icon = \"bk-tool-icon-lasso-select\";\n    LassoSelectTool.prototype.event_type = \"pan\";\n    LassoSelectTool.prototype.default_order = 12;\n    LassoSelectTool.define({\n        select_every_mousemove: [p.Bool, true],\n        callback: [p.Instance],\n        overlay: [p.Instance, DEFAULT_POLY_OVERLAY]\n    });\n    return LassoSelectTool;\n})(select_tool_1.SelectTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gesture_tool_1 = require(\"./gesture_tool\");\nvar p = require(\"core/properties\");\nexports.PanToolView = (function (superClass) {\n    extend(PanToolView, superClass);\n    function PanToolView() {\n        return PanToolView.__super__.constructor.apply(this, arguments);\n    }\n    PanToolView.prototype._pan_start = function (e) {\n        var canvas, frame, hr, vr, vx, vy;\n        this.last_dx = 0;\n        this.last_dy = 0;\n        canvas = this.plot_view.canvas;\n        frame = this.plot_view.frame;\n        vx = canvas.sx_to_vx(e.bokeh.sx);\n        vy = canvas.sy_to_vy(e.bokeh.sy);\n        if (!frame.contains(vx, vy)) {\n            hr = frame.h_range;\n            vr = frame.v_range;\n            if (vx < hr.start || vx > hr.end) {\n                this.v_axis_only = true;\n            }\n            if (vy < vr.start || vy > vr.end) {\n                this.h_axis_only = true;\n            }\n        }\n        return this.plot_view.interactive_timestamp = Date.now();\n    };\n    PanToolView.prototype._pan = function (e) {\n        this._update(e.deltaX, -e.deltaY);\n        return this.plot_view.interactive_timestamp = Date.now();\n    };\n    PanToolView.prototype._pan_end = function (e) {\n        this.h_axis_only = false;\n        this.v_axis_only = false;\n        if (this.pan_info != null) {\n            return this.plot_view.push_state('pan', {\n                range: this.pan_info\n            });\n        }\n    };\n    PanToolView.prototype._update = function (dx, dy) {\n        var dims, end, frame, hr, is_panning, name, new_dx, new_dy, ref, ref1, ref2, ref3, scale, sdx, sdy, start, sx0, sx1, sx_high, sx_low, sy0, sy1, sy_high, sy_low, vr, xrs, yrs;\n        frame = this.plot_view.frame;\n        new_dx = dx - this.last_dx;\n        new_dy = dy - this.last_dy;\n        hr = frame.h_range;\n        sx_low = hr.start - new_dx;\n        sx_high = hr.end - new_dx;\n        vr = frame.v_range;\n        sy_low = vr.start - new_dy;\n        sy_high = vr.end - new_dy;\n        dims = this.model.dimensions;\n        if ((dims === 'width' || dims === 'both') && !this.v_axis_only) {\n            sx0 = sx_low;\n            sx1 = sx_high;\n            sdx = -new_dx;\n        }\n        else {\n            sx0 = hr.start;\n            sx1 = hr.end;\n            sdx = 0;\n        }\n        if ((dims === 'height' || dims === 'both') && !this.h_axis_only) {\n            sy0 = sy_low;\n            sy1 = sy_high;\n            sdy = new_dy;\n        }\n        else {\n            sy0 = vr.start;\n            sy1 = vr.end;\n            sdy = 0;\n        }\n        this.last_dx = dx;\n        this.last_dy = dy;\n        xrs = {};\n        ref = frame.xscales;\n        for (name in ref) {\n            scale = ref[name];\n            ref1 = scale.v_invert([sx0, sx1], true), start = ref1[0], end = ref1[1];\n            xrs[name] = {\n                start: start,\n                end: end\n            };\n        }\n        yrs = {};\n        ref2 = frame.yscales;\n        for (name in ref2) {\n            scale = ref2[name];\n            ref3 = scale.v_invert([sy0, sy1], true), start = ref3[0], end = ref3[1];\n            yrs[name] = {\n                start: start,\n                end: end\n            };\n        }\n        this.pan_info = {\n            xrs: xrs,\n            yrs: yrs,\n            sdx: sdx,\n            sdy: sdy\n        };\n        this.plot_view.update_range(this.pan_info, is_panning = true);\n        return null;\n    };\n    return PanToolView;\n})(gesture_tool_1.GestureToolView);\nexports.PanTool = (function (superClass) {\n    extend(PanTool, superClass);\n    function PanTool() {\n        return PanTool.__super__.constructor.apply(this, arguments);\n    }\n    PanTool.prototype.default_view = exports.PanToolView;\n    PanTool.prototype.type = \"PanTool\";\n    PanTool.prototype.tool_name = \"Pan\";\n    PanTool.prototype.event_type = \"pan\";\n    PanTool.prototype.default_order = 10;\n    PanTool.define({\n        dimensions: [p.Dimensions, \"both\"]\n    });\n    PanTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(\"Pan\", this.dimensions);\n        },\n        icon: function () {\n            var suffix;\n            suffix = (function () {\n                switch (this.dimensions) {\n                    case \"both\":\n                        return \"pan\";\n                    case \"width\":\n                        return \"xpan\";\n                    case \"height\":\n                        return \"ypan\";\n                }\n            }).call(this);\n            return \"bk-tool-icon-\" + suffix;\n        }\n    });\n    return PanTool;\n})(gesture_tool_1.GestureTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_POLY_OVERLAY, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar select_tool_1 = require(\"./select_tool\");\nvar poly_annotation_1 = require(\"../../annotations/poly_annotation\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nexports.PolySelectToolView = (function (superClass) {\n    extend(PolySelectToolView, superClass);\n    function PolySelectToolView() {\n        return PolySelectToolView.__super__.constructor.apply(this, arguments);\n    }\n    PolySelectToolView.prototype.initialize = function (options) {\n        PolySelectToolView.__super__.initialize.call(this, options);\n        this.connect(this.model.properties.active.change, function () {\n            return this._active_change();\n        });\n        return this.data = {\n            vx: [],\n            vy: []\n        };\n    };\n    PolySelectToolView.prototype._active_change = function () {\n        if (!this.model.active) {\n            return this._clear_data();\n        }\n    };\n    PolySelectToolView.prototype._keyup = function (e) {\n        if (e.keyCode === 13) {\n            return this._clear_data();\n        }\n    };\n    PolySelectToolView.prototype._doubletap = function (e) {\n        var append, ref;\n        append = (ref = e.srcEvent.shiftKey) != null ? ref : false;\n        this._select(this.data.vx, this.data.vy, true, append);\n        return this._clear_data();\n    };\n    PolySelectToolView.prototype._clear_data = function () {\n        this.data = {\n            vx: [],\n            vy: []\n        };\n        return this.model.overlay.update({\n            xs: [],\n            ys: []\n        });\n    };\n    PolySelectToolView.prototype._tap = function (e) {\n        var canvas, vx, vy;\n        canvas = this.plot_view.canvas;\n        vx = canvas.sx_to_vx(e.bokeh.sx);\n        vy = canvas.sy_to_vy(e.bokeh.sy);\n        this.data.vx.push(vx);\n        this.data.vy.push(vy);\n        return this.model.overlay.update({\n            xs: array_1.copy(this.data.vx),\n            ys: array_1.copy(this.data.vy)\n        });\n    };\n    PolySelectToolView.prototype._select = function (vx, vy, final, append) {\n        var ds, geometry, r, renderers, renderers_by_source, sm;\n        geometry = {\n            type: 'poly',\n            vx: vx,\n            vy: vy\n        };\n        renderers_by_source = this.model._computed_renderers_by_data_source();\n        for (ds in renderers_by_source) {\n            renderers = renderers_by_source[ds];\n            sm = renderers[0].data_source.selection_manager;\n            sm.select(this, (function () {\n                var i, len, results;\n                results = [];\n                for (i = 0, len = renderers.length; i < len; i++) {\n                    r = renderers[i];\n                    results.push(this.plot_view.renderer_views[r.id]);\n                }\n                return results;\n            }).call(this), geometry, final, append);\n        }\n        this._save_geometry(geometry, final, append);\n        this.plot_view.push_state('poly_select', {\n            selection: this.plot_view.get_selection()\n        });\n        return null;\n    };\n    return PolySelectToolView;\n})(select_tool_1.SelectToolView);\nDEFAULT_POLY_OVERLAY = function () {\n    return new poly_annotation_1.PolyAnnotation({\n        level: \"overlay\",\n        xs_units: \"screen\",\n        ys_units: \"screen\",\n        fill_color: {\n            value: \"lightgrey\"\n        },\n        fill_alpha: {\n            value: 0.5\n        },\n        line_color: {\n            value: \"black\"\n        },\n        line_alpha: {\n            value: 1.0\n        },\n        line_width: {\n            value: 2\n        },\n        line_dash: {\n            value: [4, 4]\n        }\n    });\n};\nexports.PolySelectTool = (function (superClass) {\n    extend(PolySelectTool, superClass);\n    function PolySelectTool() {\n        return PolySelectTool.__super__.constructor.apply(this, arguments);\n    }\n    PolySelectTool.prototype.default_view = exports.PolySelectToolView;\n    PolySelectTool.prototype.type = \"PolySelectTool\";\n    PolySelectTool.prototype.tool_name = \"Poly Select\";\n    PolySelectTool.prototype.icon = \"bk-tool-icon-polygon-select\";\n    PolySelectTool.prototype.event_type = \"tap\";\n    PolySelectTool.prototype.default_order = 11;\n    PolySelectTool.define({\n        overlay: [p.Instance, DEFAULT_POLY_OVERLAY]\n    });\n    return PolySelectTool;\n})(select_tool_1.SelectTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gesture_tool_1 = require(\"./gesture_tool\");\nvar dom_1 = require(\"core/dom\");\nexports.ResizeToolView = (function (superClass) {\n    extend(ResizeToolView, superClass);\n    function ResizeToolView() {\n        return ResizeToolView.__super__.constructor.apply(this, arguments);\n    }\n    ResizeToolView.prototype.className = \"bk-resize-popup\";\n    ResizeToolView.prototype.initialize = function (options) {\n        var wrapper;\n        ResizeToolView.__super__.initialize.call(this, options);\n        this.overlay = dom_1.div();\n        wrapper = this.plot_view.canvas_view.el;\n        wrapper.appendChild(this.overlay);\n        dom_1.hide(this.overlay);\n        this.active = false;\n        return null;\n    };\n    ResizeToolView.prototype.activate = function () {\n        this.active = true;\n        this.render();\n        return null;\n    };\n    ResizeToolView.prototype.deactivate = function () {\n        this.active = false;\n        this.render();\n        return null;\n    };\n    ResizeToolView.prototype.render = function (ctx) {\n        var canvas, frame, left, top;\n        if (this.active) {\n            canvas = this.plot_view.canvas;\n            frame = this.plot_view.frame;\n            left = canvas.vx_to_sx(frame.h_range.end - 40);\n            top = canvas.vy_to_sy(frame.v_range.start + 40);\n            this.overlay.style.position = \"absolute\";\n            this.overlay.style.top = top + \"px\";\n            this.overlay.style.left = left + \"px\";\n            dom_1.show(this.overlay);\n        }\n        else {\n            dom_1.hide(this.overlay);\n        }\n        return this;\n    };\n    ResizeToolView.prototype._pan_start = function (e) {\n        var canvas;\n        canvas = this.plot_view.canvas;\n        this.ch = canvas._height.value;\n        this.cw = canvas._width.value;\n        this.plot_view.interactive_timestamp = Date.now();\n        return null;\n    };\n    ResizeToolView.prototype._pan = function (e) {\n        this._update(e.deltaX, e.deltaY);\n        this.plot_view.interactive_timestamp = Date.now();\n        return null;\n    };\n    ResizeToolView.prototype._pan_end = function (e) {\n        return this.plot_view.push_state(\"resize\", {\n            dimensions: {\n                width: this.plot_view.canvas._width.value,\n                height: this.plot_view.canvas._height.value\n            }\n        });\n    };\n    ResizeToolView.prototype._update = function (dx, dy) {\n        var new_height, new_width;\n        new_width = this.cw + dx;\n        new_height = this.ch + dy;\n        if (new_width < 100 || new_height < 100) {\n            return;\n        }\n        this.plot_view.update_dimensions(new_width, new_height);\n    };\n    return ResizeToolView;\n})(gesture_tool_1.GestureToolView);\nexports.ResizeTool = (function (superClass) {\n    extend(ResizeTool, superClass);\n    function ResizeTool() {\n        return ResizeTool.__super__.constructor.apply(this, arguments);\n    }\n    ResizeTool.prototype.default_view = exports.ResizeToolView;\n    ResizeTool.prototype.type = \"ResizeTool\";\n    ResizeTool.prototype.tool_name = \"Resize\";\n    ResizeTool.prototype.icon = \"bk-tool-icon-resize\";\n    ResizeTool.prototype.event_type = \"pan\";\n    ResizeTool.prototype.default_order = 40;\n    return ResizeTool;\n})(gesture_tool_1.GestureTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gesture_tool_1 = require(\"./gesture_tool\");\nvar glyph_renderer_1 = require(\"../../renderers/glyph_renderer\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nexports.SelectToolView = (function (superClass) {\n    extend(SelectToolView, superClass);\n    function SelectToolView() {\n        return SelectToolView.__super__.constructor.apply(this, arguments);\n    }\n    SelectToolView.prototype._keyup = function (e) {\n        var ds, j, len, r, ref, results, sm;\n        if (e.keyCode === 27) {\n            ref = this.model.computed_renderers;\n            results = [];\n            for (j = 0, len = ref.length; j < len; j++) {\n                r = ref[j];\n                ds = r.data_source;\n                sm = ds.selection_manager;\n                results.push(sm.clear());\n            }\n            return results;\n        }\n    };\n    SelectToolView.prototype._save_geometry = function (geometry, final, append) {\n        var g, geoms, i, j, ref, tool_events, xm, ym;\n        g = object_1.clone(geometry);\n        xm = this.plot_view.frame.xscales['default'];\n        ym = this.plot_view.frame.yscales['default'];\n        switch (g.type) {\n            case 'point':\n                g.x = xm.invert(g.vx);\n                g.y = ym.invert(g.vy);\n                break;\n            case 'rect':\n                g.x0 = xm.invert(g.vx0);\n                g.y0 = ym.invert(g.vy0);\n                g.x1 = xm.invert(g.vx1);\n                g.y1 = ym.invert(g.vy1);\n                break;\n            case 'poly':\n                g.x = new Array(g.vx.length);\n                g.y = new Array(g.vy.length);\n                for (i = j = 0, ref = g.vx.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    g.x[i] = xm.invert(g.vx[i]);\n                    g.y[i] = ym.invert(g.vy[i]);\n                }\n                break;\n            default:\n                logging_1.logger.debug(\"Unrecognized selection geometry type: '\" + g.type + \"'\");\n        }\n        if (final) {\n            tool_events = this.plot_model.plot.tool_events;\n            if (append) {\n                geoms = tool_events.geometries;\n                geoms.push(g);\n            }\n            else {\n                geoms = [g];\n            }\n            tool_events.geometries = geoms;\n        }\n        return null;\n    };\n    return SelectToolView;\n})(gesture_tool_1.GestureToolView);\nexports.SelectTool = (function (superClass) {\n    extend(SelectTool, superClass);\n    function SelectTool() {\n        return SelectTool.__super__.constructor.apply(this, arguments);\n    }\n    SelectTool.define({\n        renderers: [p.Array, []],\n        names: [p.Array, []]\n    });\n    SelectTool.internal({\n        multi_select_modifier: [p.String, \"shift\"]\n    });\n    SelectTool.prototype.connect_signals = function () {\n        SelectTool.__super__.connect_signals.call(this);\n        this.connect(this.properties.renderers.change, function () {\n            return this._computed_renderers = null;\n        });\n        this.connect(this.properties.names.change, function () {\n            return this._computed_renderers = null;\n        });\n        return this.connect(this.properties.plot.change, function () {\n            return this._computed_renderers = null;\n        });\n    };\n    SelectTool.prototype._compute_renderers = function () {\n        var all_renderers, names, r, renderers;\n        renderers = this.renderers;\n        names = this.names;\n        if (renderers.length === 0) {\n            all_renderers = this.plot.renderers;\n            renderers = (function () {\n                var j, len, results;\n                results = [];\n                for (j = 0, len = all_renderers.length; j < len; j++) {\n                    r = all_renderers[j];\n                    if (r instanceof glyph_renderer_1.GlyphRenderer) {\n                        results.push(r);\n                    }\n                }\n                return results;\n            })();\n        }\n        if (names.length > 0) {\n            renderers = (function () {\n                var j, len, results;\n                results = [];\n                for (j = 0, len = renderers.length; j < len; j++) {\n                    r = renderers[j];\n                    if (names.indexOf(r.name) >= 0) {\n                        results.push(r);\n                    }\n                }\n                return results;\n            })();\n        }\n        return renderers;\n    };\n    SelectTool.getters({\n        computed_renderers: function () {\n            if (this._computed_renderers == null) {\n                this._computed_renderers = this._compute_renderers();\n            }\n            return this._computed_renderers;\n        }\n    });\n    SelectTool.prototype._computed_renderers_by_data_source = function () {\n        var j, len, r, ref, renderers_by_source;\n        renderers_by_source = {};\n        ref = this.computed_renderers;\n        for (j = 0, len = ref.length; j < len; j++) {\n            r = ref[j];\n            if (!(r.data_source.id in renderers_by_source)) {\n                renderers_by_source[r.data_source.id] = [r];\n            }\n            else {\n                renderers_by_source[r.data_source.id] = renderers_by_source[r.data_source.id].concat([r]);\n            }\n        }\n        return renderers_by_source;\n    };\n    return SelectTool;\n})(gesture_tool_1.GestureTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar select_tool_1 = require(\"./select_tool\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.TapToolView = (function (superClass) {\n    extend(TapToolView, superClass);\n    function TapToolView() {\n        return TapToolView.__super__.constructor.apply(this, arguments);\n    }\n    TapToolView.prototype._tap = function (e) {\n        var append, canvas, ref, vx, vy;\n        canvas = this.plot_view.canvas;\n        vx = canvas.sx_to_vx(e.bokeh.sx);\n        vy = canvas.sy_to_vy(e.bokeh.sy);\n        append = (ref = e.srcEvent.shiftKey) != null ? ref : false;\n        return this._select(vx, vy, true, append);\n    };\n    TapToolView.prototype._select = function (vx, vy, final, append) {\n        var _, callback, cb_data, did_hit, ds, geometry, i, len, r, ref, renderers, renderers_by_source, sm, view;\n        geometry = {\n            type: 'point',\n            vx: vx,\n            vy: vy\n        };\n        callback = this.model.callback;\n        this._save_geometry(geometry, final, append);\n        cb_data = {\n            geometries: this.plot_model.plot.tool_events.geometries\n        };\n        if (this.model.behavior === \"select\") {\n            renderers_by_source = this.model._computed_renderers_by_data_source();\n            for (_ in renderers_by_source) {\n                renderers = renderers_by_source[_];\n                ds = renderers[0].data_source;\n                sm = ds.selection_manager;\n                did_hit = sm.select(this, (function () {\n                    var i, len, results;\n                    results = [];\n                    for (i = 0, len = renderers.length; i < len; i++) {\n                        r = renderers[i];\n                        results.push(this.plot_view.renderer_views[r.id]);\n                    }\n                    return results;\n                }).call(this), geometry, final, append);\n                if (did_hit && (callback != null)) {\n                    if (types_1.isFunction(callback)) {\n                        callback(ds, cb_data);\n                    }\n                    else {\n                        callback.execute(ds, cb_data);\n                    }\n                }\n            }\n            this.plot_view.push_state('tap', {\n                selection: this.plot_view.get_selection()\n            });\n        }\n        else {\n            ref = this.model.computed_renderers;\n            for (i = 0, len = ref.length; i < len; i++) {\n                r = ref[i];\n                ds = r.data_source;\n                sm = ds.selection_manager;\n                view = this.plot_view.renderer_views[r.id];\n                did_hit = sm.inspect(this, view, geometry, {\n                    geometry: geometry\n                });\n                if (did_hit && (callback != null)) {\n                    if (types_1.isFunction(callback)) {\n                        callback(ds, cb_data);\n                    }\n                    else {\n                        callback.execute(ds, cb_data);\n                    }\n                }\n            }\n        }\n        return null;\n    };\n    return TapToolView;\n})(select_tool_1.SelectToolView);\nexports.TapTool = (function (superClass) {\n    extend(TapTool, superClass);\n    function TapTool() {\n        return TapTool.__super__.constructor.apply(this, arguments);\n    }\n    TapTool.prototype.default_view = exports.TapToolView;\n    TapTool.prototype.type = \"TapTool\";\n    TapTool.prototype.tool_name = \"Tap\";\n    TapTool.prototype.icon = \"bk-tool-icon-tap-select\";\n    TapTool.prototype.event_type = \"tap\";\n    TapTool.prototype.default_order = 10;\n    TapTool.define({\n        behavior: [p.String, \"select\"],\n        callback: [p.Any]\n    });\n    return TapTool;\n})(select_tool_1.SelectTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gesture_tool_1 = require(\"./gesture_tool\");\nvar p = require(\"core/properties\");\nexports.WheelPanToolView = (function (superClass) {\n    extend(WheelPanToolView, superClass);\n    function WheelPanToolView() {\n        return WheelPanToolView.__super__.constructor.apply(this, arguments);\n    }\n    WheelPanToolView.prototype._scroll = function (e) {\n        var factor;\n        factor = this.model.speed * e.bokeh.delta;\n        if (factor > 0.9) {\n            factor = 0.9;\n        }\n        else if (factor < -0.9) {\n            factor = -0.9;\n        }\n        return this._update_ranges(factor);\n    };\n    WheelPanToolView.prototype._update_ranges = function (factor) {\n        var end, frame, hr, name, pan_info, ref, ref1, ref2, ref3, ref4, ref5, scale, start, sx0, sx1, sy0, sy1, vr, vx_high, vx_low, vx_range, vy_high, vy_low, vy_range, xrs, yrs;\n        frame = this.plot_model.frame;\n        hr = frame.h_range;\n        vr = frame.v_range;\n        ref = [hr.start, hr.end], vx_low = ref[0], vx_high = ref[1];\n        ref1 = [vr.start, vr.end], vy_low = ref1[0], vy_high = ref1[1];\n        switch (this.model.dimension) {\n            case \"height\":\n                vy_range = Math.abs(vy_high - vy_low);\n                sx0 = vx_low;\n                sx1 = vx_high;\n                sy0 = vy_low + vy_range * factor;\n                sy1 = vy_high + vy_range * factor;\n                break;\n            case \"width\":\n                vx_range = Math.abs(vx_high - vx_low);\n                sx0 = vx_low - vx_range * factor;\n                sx1 = vx_high - vx_range * factor;\n                sy0 = vy_low;\n                sy1 = vy_high;\n        }\n        xrs = {};\n        ref2 = frame.xscales;\n        for (name in ref2) {\n            scale = ref2[name];\n            ref3 = scale.v_invert([sx0, sx1], true), start = ref3[0], end = ref3[1];\n            xrs[name] = {\n                start: start,\n                end: end\n            };\n        }\n        yrs = {};\n        ref4 = frame.yscales;\n        for (name in ref4) {\n            scale = ref4[name];\n            ref5 = scale.v_invert([sy0, sy1], true), start = ref5[0], end = ref5[1];\n            yrs[name] = {\n                start: start,\n                end: end\n            };\n        }\n        pan_info = {\n            xrs: xrs,\n            yrs: yrs,\n            factor: factor\n        };\n        this.plot_view.push_state('wheel_pan', {\n            range: pan_info\n        });\n        this.plot_view.update_range(pan_info, false, true);\n        this.plot_view.interactive_timestamp = Date.now();\n        return null;\n    };\n    return WheelPanToolView;\n})(gesture_tool_1.GestureToolView);\nexports.WheelPanTool = (function (superClass) {\n    extend(WheelPanTool, superClass);\n    function WheelPanTool() {\n        return WheelPanTool.__super__.constructor.apply(this, arguments);\n    }\n    WheelPanTool.prototype.type = 'WheelPanTool';\n    WheelPanTool.prototype.default_view = exports.WheelPanToolView;\n    WheelPanTool.prototype.tool_name = \"Wheel Pan\";\n    WheelPanTool.prototype.icon = \"bk-tool-icon-wheel-pan\";\n    WheelPanTool.prototype.event_type = 'scroll';\n    WheelPanTool.prototype.default_order = 12;\n    WheelPanTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(this.tool_name, this.dimension);\n        }\n    });\n    WheelPanTool.define({\n        dimension: [p.Dimension, \"width\"]\n    });\n    WheelPanTool.internal({\n        speed: [p.Number, 1 / 1000]\n    });\n    return WheelPanTool;\n})(gesture_tool_1.GestureTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar document, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gesture_tool_1 = require(\"./gesture_tool\");\nvar zoom_1 = require(\"core/util/zoom\");\nvar p = require(\"core/properties\");\nif (typeof document === \"undefined\" || document === null) {\n    document = {};\n}\nexports.WheelZoomToolView = (function (superClass) {\n    extend(WheelZoomToolView, superClass);\n    function WheelZoomToolView() {\n        return WheelZoomToolView.__super__.constructor.apply(this, arguments);\n    }\n    WheelZoomToolView.prototype._pinch = function (e) {\n        var delta;\n        if (e.scale >= 1) {\n            delta = (e.scale - 1) * 20.0;\n        }\n        else {\n            delta = -20.0 / e.scale;\n        }\n        e.bokeh.delta = delta;\n        return this._scroll(e);\n    };\n    WheelZoomToolView.prototype._scroll = function (e) {\n        var dims, factor, frame, h_axis, hr, v_axis, vr, vx, vy, zoom_info;\n        frame = this.plot_model.frame;\n        hr = frame.h_range;\n        vr = frame.v_range;\n        vx = this.plot_view.canvas.sx_to_vx(e.bokeh.sx);\n        vy = this.plot_view.canvas.sy_to_vy(e.bokeh.sy);\n        dims = this.model.dimensions;\n        h_axis = (dims === 'width' || dims === 'both') && (hr.min < vx && vx < hr.max);\n        v_axis = (dims === 'height' || dims === 'both') && (vr.min < vy && vy < vr.max);\n        factor = this.model.speed * e.bokeh.delta;\n        zoom_info = zoom_1.scale_range(frame, factor, h_axis, v_axis, {\n            x: vx,\n            y: vy\n        });\n        this.plot_view.push_state('wheel_zoom', {\n            range: zoom_info\n        });\n        this.plot_view.update_range(zoom_info, false, true);\n        this.plot_view.interactive_timestamp = Date.now();\n        return null;\n    };\n    return WheelZoomToolView;\n})(gesture_tool_1.GestureToolView);\nexports.WheelZoomTool = (function (superClass) {\n    extend(WheelZoomTool, superClass);\n    function WheelZoomTool() {\n        return WheelZoomTool.__super__.constructor.apply(this, arguments);\n    }\n    WheelZoomTool.prototype.default_view = exports.WheelZoomToolView;\n    WheelZoomTool.prototype.type = \"WheelZoomTool\";\n    WheelZoomTool.prototype.tool_name = \"Wheel Zoom\";\n    WheelZoomTool.prototype.icon = \"bk-tool-icon-wheel-zoom\";\n    WheelZoomTool.prototype.event_type = ('ontouchstart' in window || navigator.maxTouchPoints > 0) ? 'pinch' : 'scroll';\n    WheelZoomTool.prototype.default_order = 10;\n    WheelZoomTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\n        }\n    });\n    WheelZoomTool.define({\n        dimensions: [p.Dimensions, \"both\"]\n    });\n    WheelZoomTool.internal({\n        speed: [p.Number, 1 / 600]\n    });\n    return WheelZoomTool;\n})(gesture_tool_1.GestureTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar action_tool_1 = require(\"./actions/action_tool\");\nexports.ActionTool = action_tool_1.ActionTool;\nvar help_tool_1 = require(\"./actions/help_tool\");\nexports.HelpTool = help_tool_1.HelpTool;\nvar redo_tool_1 = require(\"./actions/redo_tool\");\nexports.RedoTool = redo_tool_1.RedoTool;\nvar reset_tool_1 = require(\"./actions/reset_tool\");\nexports.ResetTool = reset_tool_1.ResetTool;\nvar save_tool_1 = require(\"./actions/save_tool\");\nexports.SaveTool = save_tool_1.SaveTool;\nvar undo_tool_1 = require(\"./actions/undo_tool\");\nexports.UndoTool = undo_tool_1.UndoTool;\nvar zoom_in_tool_1 = require(\"./actions/zoom_in_tool\");\nexports.ZoomInTool = zoom_in_tool_1.ZoomInTool;\nvar zoom_out_tool_1 = require(\"./actions/zoom_out_tool\");\nexports.ZoomOutTool = zoom_out_tool_1.ZoomOutTool;\nvar button_tool_1 = require(\"./button_tool\");\nexports.ButtonTool = button_tool_1.ButtonTool;\nvar box_select_tool_1 = require(\"./gestures/box_select_tool\");\nexports.BoxSelectTool = box_select_tool_1.BoxSelectTool;\nvar box_zoom_tool_1 = require(\"./gestures/box_zoom_tool\");\nexports.BoxZoomTool = box_zoom_tool_1.BoxZoomTool;\nvar gesture_tool_1 = require(\"./gestures/gesture_tool\");\nexports.GestureTool = gesture_tool_1.GestureTool;\nvar lasso_select_tool_1 = require(\"./gestures/lasso_select_tool\");\nexports.LassoSelectTool = lasso_select_tool_1.LassoSelectTool;\nvar pan_tool_1 = require(\"./gestures/pan_tool\");\nexports.PanTool = pan_tool_1.PanTool;\nvar poly_select_tool_1 = require(\"./gestures/poly_select_tool\");\nexports.PolySelectTool = poly_select_tool_1.PolySelectTool;\nvar resize_tool_1 = require(\"./gestures/resize_tool\");\nexports.ResizeTool = resize_tool_1.ResizeTool;\nvar select_tool_1 = require(\"./gestures/select_tool\");\nexports.SelectTool = select_tool_1.SelectTool;\nvar tap_tool_1 = require(\"./gestures/tap_tool\");\nexports.TapTool = tap_tool_1.TapTool;\nvar wheel_pan_tool_1 = require(\"./gestures/wheel_pan_tool\");\nexports.WheelPanTool = wheel_pan_tool_1.WheelPanTool;\nvar wheel_zoom_tool_1 = require(\"./gestures/wheel_zoom_tool\");\nexports.WheelZoomTool = wheel_zoom_tool_1.WheelZoomTool;\nvar crosshair_tool_1 = require(\"./inspectors/crosshair_tool\");\nexports.CrosshairTool = crosshair_tool_1.CrosshairTool;\nvar hover_tool_1 = require(\"./inspectors/hover_tool\");\nexports.HoverTool = hover_tool_1.HoverTool;\nvar inspect_tool_1 = require(\"./inspectors/inspect_tool\");\nexports.InspectTool = inspect_tool_1.InspectTool;\nvar tool_1 = require(\"./tool\");\nexports.Tool = tool_1.Tool;\nvar tool_events_1 = require(\"./tool_events\");\nexports.ToolEvents = tool_events_1.ToolEvents;\nvar tool_proxy_1 = require(\"./tool_proxy\");\nexports.ToolProxy = tool_proxy_1.ToolProxy;\nvar toolbar_1 = require(\"./toolbar\");\nexports.Toolbar = toolbar_1.Toolbar;\nvar toolbar_base_1 = require(\"./toolbar_base\");\nexports.ToolbarBase = toolbar_base_1.ToolbarBase;\nvar toolbar_box_1 = require(\"./toolbar_box\");\nexports.ToolbarBoxToolbar = toolbar_box_1.ToolbarBoxToolbar;\nvar toolbar_box_2 = require(\"./toolbar_box\");\nexports.ToolbarBox = toolbar_box_2.ToolbarBox;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar inspect_tool_1 = require(\"./inspect_tool\");\nvar span_1 = require(\"../../annotations/span\");\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nexports.CrosshairToolView = (function (superClass) {\n    extend(CrosshairToolView, superClass);\n    function CrosshairToolView() {\n        return CrosshairToolView.__super__.constructor.apply(this, arguments);\n    }\n    CrosshairToolView.prototype._move = function (e) {\n        var canvas, frame, vx, vy;\n        if (!this.model.active) {\n            return;\n        }\n        frame = this.plot_model.frame;\n        canvas = this.plot_model.canvas;\n        vx = canvas.sx_to_vx(e.bokeh.sx);\n        vy = canvas.sy_to_vy(e.bokeh.sy);\n        if (!frame.contains(vx, vy)) {\n            vx = vy = null;\n        }\n        return this._update_spans(vx, vy);\n    };\n    CrosshairToolView.prototype._move_exit = function (e) {\n        return this._update_spans(null, null);\n    };\n    CrosshairToolView.prototype._update_spans = function (x, y) {\n        var dims;\n        dims = this.model.dimensions;\n        if (dims === 'width' || dims === 'both') {\n            this.model.spans.width.computed_location = y;\n        }\n        if (dims === 'height' || dims === 'both') {\n            return this.model.spans.height.computed_location = x;\n        }\n    };\n    return CrosshairToolView;\n})(inspect_tool_1.InspectToolView);\nexports.CrosshairTool = (function (superClass) {\n    extend(CrosshairTool, superClass);\n    function CrosshairTool() {\n        return CrosshairTool.__super__.constructor.apply(this, arguments);\n    }\n    CrosshairTool.prototype.default_view = exports.CrosshairToolView;\n    CrosshairTool.prototype.type = \"CrosshairTool\";\n    CrosshairTool.prototype.tool_name = \"Crosshair\";\n    CrosshairTool.prototype.icon = \"bk-tool-icon-crosshair\";\n    CrosshairTool.define({\n        dimensions: [p.Dimensions, \"both\"],\n        line_color: [p.Color, 'black'],\n        line_width: [p.Number, 1],\n        line_alpha: [p.Number, 1.0]\n    });\n    CrosshairTool.internal({\n        location_units: [p.SpatialUnits, \"screen\"],\n        render_mode: [p.RenderMode, \"css\"],\n        spans: [p.Any]\n    });\n    CrosshairTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(\"Crosshair\", this.dimensions);\n        },\n        synthetic_renderers: function () {\n            return object_1.values(this.spans);\n        }\n    });\n    CrosshairTool.prototype.initialize = function (attrs, options) {\n        CrosshairTool.__super__.initialize.call(this, attrs, options);\n        return this.spans = {\n            width: new span_1.Span({\n                for_hover: true,\n                dimension: \"width\",\n                render_mode: this.render_mode,\n                location_units: this.location_units,\n                line_color: this.line_color,\n                line_width: this.line_width,\n                line_alpha: this.line_alpha\n            }),\n            height: new span_1.Span({\n                for_hover: true,\n                dimension: \"height\",\n                render_mode: this.render_mode,\n                location_units: this.location_units,\n                line_color: this.line_color,\n                line_width: this.line_width,\n                line_alpha: this.line_alpha\n            })\n        };\n    };\n    return CrosshairTool;\n})(inspect_tool_1.InspectTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _color_to_hex, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar inspect_tool_1 = require(\"./inspect_tool\");\nvar tooltip_1 = require(\"../../annotations/tooltip\");\nvar glyph_renderer_1 = require(\"../../renderers/glyph_renderer\");\nvar hittest = require(\"core/hittest\");\nvar templating_1 = require(\"core/util/templating\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nvar types_1 = require(\"core/util/types\");\nvar build_views_1 = require(\"core/build_views\");\n_color_to_hex = function (color) {\n    var blue, digits, green, red, rgb;\n    if (color.substr(0, 1) === '#') {\n        return color;\n    }\n    digits = /(.*?)rgb\\((\\d+), (\\d+), (\\d+)\\)/.exec(color);\n    red = parseInt(digits[2]);\n    green = parseInt(digits[3]);\n    blue = parseInt(digits[4]);\n    rgb = blue | (green << 8) | (red << 16);\n    return digits[1] + '#' + rgb.toString(16);\n};\nexports.HoverToolView = (function (superClass) {\n    extend(HoverToolView, superClass);\n    function HoverToolView() {\n        return HoverToolView.__super__.constructor.apply(this, arguments);\n    }\n    HoverToolView.prototype.initialize = function (options) {\n        HoverToolView.__super__.initialize.call(this, options);\n        return this.ttviews = {};\n    };\n    HoverToolView.prototype.remove = function () {\n        build_views_1.remove_views(this.ttviews);\n        return HoverToolView.__super__.remove.call(this);\n    };\n    HoverToolView.prototype.connect_signals = function () {\n        var k, len, r, ref;\n        HoverToolView.__super__.connect_signals.call(this);\n        ref = this.computed_renderers;\n        for (k = 0, len = ref.length; k < len; k++) {\n            r = ref[k];\n            this.connect(r.data_source.inspect, this._update);\n        }\n        this.connect(this.model.properties.renderers.change, function () {\n            return this._computed_renderers = this._ttmodels = null;\n        });\n        this.connect(this.model.properties.names.change, function () {\n            return this._computed_renderers = this._ttmodels = null;\n        });\n        this.connect(this.model.properties.plot.change, function () {\n            return this._computed_renderers = this._ttmodels = null;\n        });\n        return this.connect(this.model.properties.tooltips.change, function () {\n            return this._ttmodels = null;\n        });\n    };\n    HoverToolView.prototype._compute_renderers = function () {\n        var all_renderers, names, r, renderers;\n        renderers = this.model.renderers;\n        names = this.model.names;\n        if (renderers.length === 0) {\n            all_renderers = this.model.plot.renderers;\n            renderers = (function () {\n                var k, len, results;\n                results = [];\n                for (k = 0, len = all_renderers.length; k < len; k++) {\n                    r = all_renderers[k];\n                    if (r instanceof glyph_renderer_1.GlyphRenderer) {\n                        results.push(r);\n                    }\n                }\n                return results;\n            })();\n        }\n        if (names.length > 0) {\n            renderers = (function () {\n                var k, len, results;\n                results = [];\n                for (k = 0, len = renderers.length; k < len; k++) {\n                    r = renderers[k];\n                    if (names.indexOf(r.name) >= 0) {\n                        results.push(r);\n                    }\n                }\n                return results;\n            })();\n        }\n        return renderers;\n    };\n    HoverToolView.prototype._compute_ttmodels = function () {\n        var k, l, len, len1, new_views, r, ref, tooltip, tooltips, ttmodels, view;\n        ttmodels = {};\n        tooltips = this.model.tooltips;\n        if (tooltips != null) {\n            ref = this.computed_renderers;\n            for (k = 0, len = ref.length; k < len; k++) {\n                r = ref[k];\n                tooltip = new tooltip_1.Tooltip({\n                    custom: types_1.isString(tooltips) || types_1.isFunction(tooltips),\n                    attachment: this.model.attachment,\n                    show_arrow: this.model.show_arrow\n                });\n                ttmodels[r.id] = tooltip;\n            }\n        }\n        new_views = build_views_1.build_views(this.ttviews, object_1.values(ttmodels), {\n            parent: this,\n            plot_view: this.plot_view\n        });\n        for (l = 0, len1 = new_views.length; l < len1; l++) {\n            view = new_views[l];\n            view.connect_signals();\n        }\n        return ttmodels;\n    };\n    HoverToolView.getters({\n        computed_renderers: function () {\n            if (this._computed_renderers == null) {\n                this._computed_renderers = this._compute_renderers();\n            }\n            return this._computed_renderers;\n        },\n        ttmodels: function () {\n            if (this._ttmodels == null) {\n                this._ttmodels = this._compute_ttmodels();\n            }\n            return this._ttmodels;\n        }\n    });\n    HoverToolView.prototype._clear = function () {\n        var ref, results, rid, tt;\n        this._inspect(2e308, 2e308);\n        ref = this.ttmodels;\n        results = [];\n        for (rid in ref) {\n            tt = ref[rid];\n            results.push(tt.clear());\n        }\n        return results;\n    };\n    HoverToolView.prototype._move = function (e) {\n        var canvas, vx, vy;\n        if (!this.model.active) {\n            return;\n        }\n        canvas = this.plot_view.canvas;\n        vx = canvas.sx_to_vx(e.bokeh.sx);\n        vy = canvas.sy_to_vy(e.bokeh.sy);\n        if (!this.plot_view.frame.contains(vx, vy)) {\n            return this._clear();\n        }\n        else {\n            return this._inspect(vx, vy);\n        }\n    };\n    HoverToolView.prototype._move_exit = function () {\n        return this._clear();\n    };\n    HoverToolView.prototype._inspect = function (vx, vy, e) {\n        var geometry, hovered_indexes, hovered_renderers, k, len, r, ref, sm;\n        geometry = {\n            type: 'point',\n            vx: vx,\n            vy: vy\n        };\n        if (this.model.mode === 'mouse') {\n            geometry['type'] = 'point';\n        }\n        else {\n            geometry['type'] = 'span';\n            if (this.model.mode === 'vline') {\n                geometry.direction = 'h';\n            }\n            else {\n                geometry.direction = 'v';\n            }\n        }\n        hovered_indexes = [];\n        hovered_renderers = [];\n        ref = this.computed_renderers;\n        for (k = 0, len = ref.length; k < len; k++) {\n            r = ref[k];\n            sm = r.data_source.selection_manager;\n            sm.inspect(this, this.plot_view.renderer_views[r.id], geometry, {\n                \"geometry\": geometry\n            });\n        }\n        if (this.model.callback != null) {\n            this._emit_callback(geometry);\n        }\n    };\n    HoverToolView.prototype._update = function (arg) {\n        var canvas, d1x, d1y, d2x, d2y, data_x, data_y, dist1, dist2, ds, frame, geometry, i, ii, indices, j, jj, k, l, len, len1, pt, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, renderer, rx, ry, sdatax, sdatay, sx, sy, tool, tooltip, vars, vx, vy, x, xscale, y, yscale;\n        indices = arg[0], tool = arg[1], renderer = arg[2], ds = arg[3], (ref = arg[4], geometry = ref.geometry);\n        if (!this.model.active) {\n            return;\n        }\n        tooltip = (ref1 = this.ttmodels[renderer.model.id]) != null ? ref1 : null;\n        if (tooltip == null) {\n            return;\n        }\n        tooltip.clear();\n        if (indices['0d'].glyph === null && indices['1d'].indices.length === 0) {\n            return;\n        }\n        vx = geometry.vx;\n        vy = geometry.vy;\n        canvas = this.plot_model.canvas;\n        frame = this.plot_model.frame;\n        sx = canvas.vx_to_sx(vx);\n        sy = canvas.vy_to_sy(vy);\n        xscale = frame.xscales[renderer.model.x_range_name];\n        yscale = frame.yscales[renderer.model.y_range_name];\n        x = xscale.invert(vx);\n        y = yscale.invert(vy);\n        ref2 = indices['0d'].indices;\n        for (k = 0, len = ref2.length; k < len; k++) {\n            i = ref2[k];\n            data_x = renderer.glyph._x[i + 1];\n            data_y = renderer.glyph._y[i + 1];\n            ii = i;\n            switch (this.model.line_policy) {\n                case \"interp\":\n                    ref3 = renderer.glyph.get_interpolation_hit(i, geometry), data_x = ref3[0], data_y = ref3[1];\n                    rx = xscale.compute(data_x);\n                    ry = yscale.compute(data_y);\n                    break;\n                case \"prev\":\n                    rx = canvas.sx_to_vx(renderer.glyph.sx[i]);\n                    ry = canvas.sy_to_vy(renderer.glyph.sy[i]);\n                    break;\n                case \"next\":\n                    rx = canvas.sx_to_vx(renderer.glyph.sx[i + 1]);\n                    ry = canvas.sy_to_vy(renderer.glyph.sy[i + 1]);\n                    ii = i + 1;\n                    break;\n                case \"nearest\":\n                    d1x = renderer.glyph.sx[i];\n                    d1y = renderer.glyph.sy[i];\n                    dist1 = hittest.dist_2_pts(d1x, d1y, sx, sy);\n                    d2x = renderer.glyph.sx[i + 1];\n                    d2y = renderer.glyph.sy[i + 1];\n                    dist2 = hittest.dist_2_pts(d2x, d2y, sx, sy);\n                    if (dist1 < dist2) {\n                        ref4 = [d1x, d1y], sdatax = ref4[0], sdatay = ref4[1];\n                    }\n                    else {\n                        ref5 = [d2x, d2y], sdatax = ref5[0], sdatay = ref5[1];\n                        ii = i + 1;\n                    }\n                    data_x = renderer.glyph._x[i];\n                    data_y = renderer.glyph._y[i];\n                    rx = canvas.sx_to_vx(sdatax);\n                    ry = canvas.sy_to_vy(sdatay);\n                    break;\n                default:\n                    ref6 = [vx, vy], rx = ref6[0], ry = ref6[1];\n            }\n            vars = {\n                index: ii,\n                x: x,\n                y: y,\n                vx: vx,\n                vy: vy,\n                sx: sx,\n                sy: sy,\n                data_x: data_x,\n                data_y: data_y,\n                rx: rx,\n                ry: ry\n            };\n            tooltip.add(rx, ry, this._render_tooltips(ds, ii, vars));\n        }\n        ref7 = indices['1d'].indices;\n        for (l = 0, len1 = ref7.length; l < len1; l++) {\n            i = ref7[l];\n            if (!object_1.isEmpty(indices['2d'].indices)) {\n                ref8 = indices['2d'].indices;\n                for (i in ref8) {\n                    j = ref8[i][0];\n                    data_x = renderer.glyph._xs[i][j];\n                    data_y = renderer.glyph._ys[i][j];\n                    jj = j;\n                    switch (this.model.line_policy) {\n                        case \"interp\":\n                            ref9 = renderer.glyph.get_interpolation_hit(i, j, geometry), data_x = ref9[0], data_y = ref9[1];\n                            rx = xscale.compute(data_x);\n                            ry = yscale.compute(data_y);\n                            break;\n                        case \"prev\":\n                            rx = canvas.sx_to_vx(renderer.glyph.sxs[i][j]);\n                            ry = canvas.sy_to_vy(renderer.glyph.sys[i][j]);\n                            break;\n                        case \"next\":\n                            rx = canvas.sx_to_vx(renderer.glyph.sxs[i][j + 1]);\n                            ry = canvas.sy_to_vy(renderer.glyph.sys[i][j + 1]);\n                            jj = j + 1;\n                            break;\n                        case \"nearest\":\n                            d1x = renderer.glyph.sxs[i][j];\n                            d1y = renderer.glyph.sys[i][j];\n                            dist1 = hittest.dist_2_pts(d1x, d1y, sx, sy);\n                            d2x = renderer.glyph.sxs[i][j + 1];\n                            d2y = renderer.glyph.sys[i][j + 1];\n                            dist2 = hittest.dist_2_pts(d2x, d2y, sx, sy);\n                            if (dist1 < dist2) {\n                                ref10 = [d1x, d1y], sdatax = ref10[0], sdatay = ref10[1];\n                            }\n                            else {\n                                ref11 = [d2x, d2y], sdatax = ref11[0], sdatay = ref11[1];\n                                jj = j + 1;\n                            }\n                            data_x = renderer.glyph._xs[i][j];\n                            data_y = renderer.glyph._ys[i][j];\n                            rx = canvas.sx_to_vx(sdatax);\n                            ry = canvas.sy_to_vy(sdatay);\n                    }\n                    vars = {\n                        index: i,\n                        segment_index: jj,\n                        x: x,\n                        y: y,\n                        vx: vx,\n                        vy: vy,\n                        sx: sx,\n                        sy: sy,\n                        data_x: data_x,\n                        data_y: data_y\n                    };\n                    tooltip.add(rx, ry, this._render_tooltips(ds, i, vars));\n                }\n            }\n            else {\n                data_x = (ref12 = renderer.glyph._x) != null ? ref12[i] : void 0;\n                data_y = (ref13 = renderer.glyph._y) != null ? ref13[i] : void 0;\n                if (this.model.point_policy === 'snap_to_data') {\n                    pt = renderer.glyph.get_anchor_point(this.model.anchor, i, [sx, sy]);\n                    if (pt == null) {\n                        pt = renderer.glyph.get_anchor_point(\"center\", i, [sx, sy]);\n                    }\n                    rx = canvas.sx_to_vx(pt.x);\n                    ry = canvas.sy_to_vy(pt.y);\n                }\n                else {\n                    ref14 = [vx, vy], rx = ref14[0], ry = ref14[1];\n                }\n                vars = {\n                    index: i,\n                    x: x,\n                    y: y,\n                    vx: vx,\n                    vy: vy,\n                    sx: sx,\n                    sy: sy,\n                    data_x: data_x,\n                    data_y: data_y\n                };\n                tooltip.add(rx, ry, this._render_tooltips(ds, i, vars));\n            }\n        }\n        return null;\n    };\n    HoverToolView.prototype._emit_callback = function (geometry) {\n        var callback, canvas, data, frame, indices, obj, r, ref, xscale, yscale;\n        r = this.computed_renderers[0];\n        indices = this.plot_view.renderer_views[r.id].hit_test(geometry);\n        canvas = this.plot_model.canvas;\n        frame = this.plot_model.frame;\n        geometry['sx'] = canvas.vx_to_sx(geometry.vx);\n        geometry['sy'] = canvas.vy_to_sy(geometry.vy);\n        xscale = frame.xscales[r.x_range_name];\n        yscale = frame.yscales[r.y_range_name];\n        geometry['x'] = xscale.invert(geometry.vx);\n        geometry['y'] = yscale.invert(geometry.vy);\n        callback = this.model.callback;\n        ref = [\n            callback, {\n                index: indices,\n                geometry: geometry,\n                renderer: r\n            }\n        ], obj = ref[0], data = ref[1];\n        if (types_1.isFunction(callback)) {\n            callback(obj, data);\n        }\n        else {\n            callback.execute(obj, data);\n        }\n    };\n    HoverToolView.prototype._render_tooltips = function (ds, i, vars) {\n        var cell, colname, color, column, el, hex, k, label, len, match, opts, ref, ref1, row, rows, swatch, tooltips, value;\n        tooltips = this.model.tooltips;\n        if (types_1.isString(tooltips)) {\n            el = dom_1.div();\n            el.innerHTML = templating_1.replace_placeholders(tooltips, ds, i, this.model.formatters, vars);\n            return el;\n        }\n        else if (types_1.isFunction(tooltips)) {\n            return tooltips(ds, vars);\n        }\n        else {\n            rows = dom_1.div({\n                style: {\n                    display: \"table\",\n                    borderSpacing: \"2px\"\n                }\n            });\n            for (k = 0, len = tooltips.length; k < len; k++) {\n                ref = tooltips[k], label = ref[0], value = ref[1];\n                row = dom_1.div({\n                    style: {\n                        display: \"table-row\"\n                    }\n                });\n                rows.appendChild(row);\n                cell = dom_1.div({\n                    style: {\n                        display: \"table-cell\"\n                    },\n                    \"class\": 'bk-tooltip-row-label'\n                }, label + \": \");\n                row.appendChild(cell);\n                cell = dom_1.div({\n                    style: {\n                        display: \"table-cell\"\n                    },\n                    \"class\": 'bk-tooltip-row-value'\n                });\n                row.appendChild(cell);\n                if (value.indexOf(\"$color\") >= 0) {\n                    ref1 = value.match(/\\$color(\\[.*\\])?:(\\w*)/), match = ref1[0], opts = ref1[1], colname = ref1[2];\n                    column = ds.get_column(colname);\n                    if (column == null) {\n                        el = dom_1.span({}, colname + \" unknown\");\n                        cell.appendChild(el);\n                        continue;\n                    }\n                    hex = (opts != null ? opts.indexOf(\"hex\") : void 0) >= 0;\n                    swatch = (opts != null ? opts.indexOf(\"swatch\") : void 0) >= 0;\n                    color = column[i];\n                    if (color == null) {\n                        el = dom_1.span({}, \"(null)\");\n                        cell.appendChild(el);\n                        continue;\n                    }\n                    if (hex) {\n                        color = _color_to_hex(color);\n                    }\n                    el = dom_1.span({}, color);\n                    cell.appendChild(el);\n                    if (swatch) {\n                        el = dom_1.span({\n                            \"class\": 'bk-tooltip-color-block',\n                            style: {\n                                backgroundColor: color\n                            }\n                        }, \" \");\n                        cell.appendChild(el);\n                    }\n                }\n                else {\n                    value = value.replace(\"$~\", \"$data_\");\n                    el = dom_1.span();\n                    el.innerHTML = templating_1.replace_placeholders(value, ds, i, this.model.formatters, vars);\n                    cell.appendChild(el);\n                }\n            }\n            return rows;\n        }\n    };\n    return HoverToolView;\n})(inspect_tool_1.InspectToolView);\nexports.HoverTool = (function (superClass) {\n    extend(HoverTool, superClass);\n    function HoverTool() {\n        return HoverTool.__super__.constructor.apply(this, arguments);\n    }\n    HoverTool.prototype.default_view = exports.HoverToolView;\n    HoverTool.prototype.type = \"HoverTool\";\n    HoverTool.prototype.tool_name = \"Hover\";\n    HoverTool.prototype.icon = \"bk-tool-icon-hover\";\n    HoverTool.define({\n        tooltips: [p.Any, [[\"index\", \"$index\"], [\"data (x, y)\", \"($x, $y)\"], [\"canvas (x, y)\", \"($sx, $sy)\"]]],\n        formatters: [p.Any, {}],\n        renderers: [p.Array, []],\n        names: [p.Array, []],\n        mode: [p.String, 'mouse'],\n        point_policy: [p.String, 'snap_to_data'],\n        line_policy: [p.String, 'nearest'],\n        show_arrow: [p.Boolean, true],\n        anchor: [p.String, 'center'],\n        attachment: [p.String, 'horizontal'],\n        callback: [p.Any]\n    });\n    return HoverTool;\n})(inspect_tool_1.InspectTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar button_tool_1 = require(\"../button_tool\");\nexports.InspectToolView = (function (superClass) {\n    extend(InspectToolView, superClass);\n    function InspectToolView() {\n        return InspectToolView.__super__.constructor.apply(this, arguments);\n    }\n    return InspectToolView;\n})(button_tool_1.ButtonToolView);\nexports.InspectTool = (function (superClass) {\n    extend(InspectTool, superClass);\n    function InspectTool() {\n        return InspectTool.__super__.constructor.apply(this, arguments);\n    }\n    InspectTool.prototype.event_type = \"move\";\n    InspectTool.define({\n        toggleable: [p.Bool, true]\n    });\n    InspectTool.override({\n        active: true\n    });\n    return InspectTool;\n})(button_tool_1.ButtonTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar button_tool_1 = require(\"./button_tool\");\nexports.OnOffButtonView = (function (superClass) {\n    extend(OnOffButtonView, superClass);\n    function OnOffButtonView() {\n        return OnOffButtonView.__super__.constructor.apply(this, arguments);\n    }\n    OnOffButtonView.prototype.render = function () {\n        OnOffButtonView.__super__.render.call(this);\n        if (this.model.active) {\n            return this.el.classList.add('bk-active');\n        }\n        else {\n            return this.el.classList.remove('bk-active');\n        }\n    };\n    OnOffButtonView.prototype._clicked = function () {\n        var active;\n        active = this.model.active;\n        return this.model.active = !active;\n    };\n    return OnOffButtonView;\n})(button_tool_1.ButtonToolButtonView);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar view_1 = require(\"core/view\");\nvar array_1 = require(\"core/util/array\");\nvar model_1 = require(\"../../model\");\nexports.ToolView = (function (superClass) {\n    extend(ToolView, superClass);\n    function ToolView() {\n        return ToolView.__super__.constructor.apply(this, arguments);\n    }\n    ToolView.prototype.initialize = function (options) {\n        ToolView.__super__.initialize.call(this, options);\n        return this.plot_view = options.plot_view;\n    };\n    ToolView.getters({\n        plot_model: function () {\n            return this.plot_view.model;\n        }\n    });\n    ToolView.prototype.connect_signals = function () {\n        ToolView.__super__.connect_signals.call(this);\n        return this.connect(this.model.properties.active.change, (function (_this) {\n            return function () {\n                if (_this.model.active) {\n                    return _this.activate();\n                }\n                else {\n                    return _this.deactivate();\n                }\n            };\n        })(this));\n    };\n    ToolView.prototype.activate = function () { };\n    ToolView.prototype.deactivate = function () { };\n    return ToolView;\n})(view_1.View);\nexports.Tool = (function (superClass) {\n    extend(Tool, superClass);\n    function Tool() {\n        return Tool.__super__.constructor.apply(this, arguments);\n    }\n    Tool.getters({\n        synthetic_renderers: function () {\n            return [];\n        }\n    });\n    Tool.define({\n        plot: [p.Instance]\n    });\n    Tool.internal({\n        active: [p.Boolean, false]\n    });\n    Tool.prototype._get_dim_tooltip = function (name, dims) {\n        switch (dims) {\n            case 'width':\n                return name + \" (x-axis)\";\n            case 'height':\n                return name + \" (y-axis)\";\n            case 'both':\n                return name;\n        }\n    };\n    Tool.prototype._get_dim_limits = function (arg, arg1, frame, dims) {\n        var hr, vr, vx0, vx1, vxlim, vy0, vy1, vylim;\n        vx0 = arg[0], vy0 = arg[1];\n        vx1 = arg1[0], vy1 = arg1[1];\n        hr = frame.h_range;\n        if (dims === 'width' || dims === 'both') {\n            vxlim = [array_1.min([vx0, vx1]), array_1.max([vx0, vx1])];\n            vxlim = [array_1.max([vxlim[0], hr.min]), array_1.min([vxlim[1], hr.max])];\n        }\n        else {\n            vxlim = [hr.min, hr.max];\n        }\n        vr = frame.v_range;\n        if (dims === 'height' || dims === 'both') {\n            vylim = [array_1.min([vy0, vy1]), array_1.max([vy0, vy1])];\n            vylim = [array_1.max([vylim[0], vr.min]), array_1.min([vylim[1], vr.max])];\n        }\n        else {\n            vylim = [vr.min, vr.max];\n        }\n        return [vxlim, vylim];\n    };\n    return Tool;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nvar p = require(\"core/properties\");\nexports.ToolEvents = (function (superClass) {\n    extend(ToolEvents, superClass);\n    function ToolEvents() {\n        return ToolEvents.__super__.constructor.apply(this, arguments);\n    }\n    ToolEvents.prototype.type = 'ToolEvents';\n    ToolEvents.define({\n        geometries: [p.Array, []]\n    });\n    return ToolEvents;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar signaling_1 = require(\"core/signaling\");\nvar model_1 = require(\"../../model\");\nexports.ToolProxy = (function (superClass) {\n    extend(ToolProxy, superClass);\n    function ToolProxy() {\n        return ToolProxy.__super__.constructor.apply(this, arguments);\n    }\n    ToolProxy.prototype.initialize = function (options) {\n        ToolProxy.__super__.initialize.call(this, options);\n        this[\"do\"] = new signaling_1.Signal(this, \"do\");\n        this.connect(this[\"do\"], function () {\n            return this.doit();\n        });\n        return this.connect(this.properties.active.change, function () {\n            return this.set_active();\n        });\n    };\n    ToolProxy.prototype.doit = function () {\n        var i, len, ref, tool;\n        ref = this.tools;\n        for (i = 0, len = ref.length; i < len; i++) {\n            tool = ref[i];\n            tool[\"do\"].emit();\n        }\n        return null;\n    };\n    ToolProxy.prototype.set_active = function () {\n        var i, len, ref, tool;\n        ref = this.tools;\n        for (i = 0, len = ref.length; i < len; i++) {\n            tool = ref[i];\n            tool.active = this.active;\n        }\n        return null;\n    };\n    ToolProxy.define({\n        tools: [p.Array, []],\n        active: [p.Bool, false],\n        tooltip: [p.String],\n        tool_name: [p.String],\n        disabled: [p.Bool, false],\n        event_type: [p.String],\n        icon: [p.String]\n    });\n    ToolProxy.prototype._clicked = function () {\n        var active;\n        active = this.model.active;\n        return this.model.active = !active;\n    };\n    return ToolProxy;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nvar action_tool_1 = require(\"./actions/action_tool\");\nvar help_tool_1 = require(\"./actions/help_tool\");\nvar gesture_tool_1 = require(\"./gestures/gesture_tool\");\nvar inspect_tool_1 = require(\"./inspectors/inspect_tool\");\nvar toolbar_base_1 = require(\"./toolbar_base\");\nexports.Toolbar = (function (superClass) {\n    extend(Toolbar, superClass);\n    function Toolbar() {\n        return Toolbar.__super__.constructor.apply(this, arguments);\n    }\n    Toolbar.prototype.type = 'Toolbar';\n    Toolbar.prototype.default_view = toolbar_base_1.ToolbarBaseView;\n    Toolbar.prototype.initialize = function (attrs, options) {\n        Toolbar.__super__.initialize.call(this, attrs, options);\n        this.connect(this.properties.tools.change, function () {\n            return this._init_tools();\n        });\n        return this._init_tools();\n    };\n    Toolbar.prototype._init_tools = function () {\n        var et, i, len, ref, results, tool, tools;\n        ref = this.tools;\n        for (i = 0, len = ref.length; i < len; i++) {\n            tool = ref[i];\n            if (tool instanceof inspect_tool_1.InspectTool) {\n                if (!array_1.any(this.inspectors, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    this.inspectors = this.inspectors.concat([tool]);\n                }\n            }\n            else if (tool instanceof help_tool_1.HelpTool) {\n                if (!array_1.any(this.help, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    this.help = this.help.concat([tool]);\n                }\n            }\n            else if (tool instanceof action_tool_1.ActionTool) {\n                if (!array_1.any(this.actions, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    this.actions = this.actions.concat([tool]);\n                }\n            }\n            else if (tool instanceof gesture_tool_1.GestureTool) {\n                et = tool.event_type;\n                if (!(et in this.gestures)) {\n                    logger.warn(\"Toolbar: unknown event type '\" + et + \"' for tool: \" + tool.type + \" (\" + tool.id + \")\");\n                    continue;\n                }\n                if (!array_1.any(this.gestures[et].tools, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    this.gestures[et].tools = this.gestures[et].tools.concat([tool]);\n                }\n                this.connect(tool.properties.active.change, this._active_change.bind(null, tool));\n            }\n        }\n        if (this.active_inspect === 'auto') {\n        }\n        else if (this.active_inspect instanceof inspect_tool_1.InspectTool) {\n            this.inspectors.map((function (_this) {\n                return function (inspector) {\n                    if (inspector !== _this.active_inspect) {\n                        return inspector.active = false;\n                    }\n                };\n            })(this));\n        }\n        else if (this.active_inspect instanceof Array) {\n            this.inspectors.map((function (_this) {\n                return function (inspector) {\n                    if (indexOf.call(_this.active_inspect, inspector) < 0) {\n                        return inspector.active = false;\n                    }\n                };\n            })(this));\n        }\n        else if (this.active_inspect === null) {\n            this.inspectors.map(function (inspector) {\n                return inspector.active = false;\n            });\n        }\n        results = [];\n        for (et in this.gestures) {\n            tools = this.gestures[et].tools;\n            if (tools.length === 0) {\n                continue;\n            }\n            this.gestures[et].tools = array_1.sortBy(tools, function (tool) {\n                return tool.default_order;\n            });\n            if (et === 'tap') {\n                if (this.active_tap === null) {\n                    continue;\n                }\n                if (this.active_tap === 'auto') {\n                    this.gestures[et].tools[0].active = true;\n                }\n                else {\n                    this.active_tap.active = true;\n                }\n            }\n            if (et === 'pan') {\n                if (this.active_drag === null) {\n                    continue;\n                }\n                if (this.active_drag === 'auto') {\n                    this.gestures[et].tools[0].active = true;\n                }\n                else {\n                    this.active_drag.active = true;\n                }\n            }\n            if (et === 'pinch' || et === 'scroll') {\n                if (this.active_scroll === null || this.active_scroll === 'auto') {\n                    continue;\n                }\n                results.push(this.active_scroll.active = true);\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    Toolbar.define({\n        active_drag: [p.Any, 'auto'],\n        active_inspect: [p.Any, 'auto'],\n        active_scroll: [p.Any, 'auto'],\n        active_tap: [p.Any, 'auto']\n    });\n    return Toolbar;\n})(toolbar_base_1.ToolbarBase);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; };\nvar logging_1 = require(\"core/logging\");\nvar solver_1 = require(\"core/layout/solver\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nvar layout_dom_1 = require(\"../layouts/layout_dom\");\nvar action_tool_1 = require(\"./actions/action_tool\");\nvar on_off_button_1 = require(\"./on_off_button\");\nvar toolbar_template_1 = require(\"./toolbar_template\");\nexports.ToolbarBaseView = (function (superClass) {\n    extend(ToolbarBaseView, superClass);\n    function ToolbarBaseView() {\n        return ToolbarBaseView.__super__.constructor.apply(this, arguments);\n    }\n    ToolbarBaseView.prototype.className = \"bk-toolbar-wrapper\";\n    ToolbarBaseView.prototype.template = toolbar_template_1.default;\n    ToolbarBaseView.prototype.render = function () {\n        var buttons, et, gestures, i, j, k, l, len, len1, len2, len3, obj, ref, ref1, ref2, ref3;\n        dom_1.empty(this.el);\n        if (this.model.sizing_mode !== 'fixed') {\n            this.el.style.left = this.model._dom_left.value + \"px\";\n            this.el.style.top = this.model._dom_top.value + \"px\";\n            this.el.style.width = this.model._width.value + \"px\";\n            this.el.style.height = this.model._height.value + \"px\";\n        }\n        this.el.appendChild(this.template({\n            logo: this.model.logo,\n            location: this.model.toolbar_location,\n            sticky: this.model.toolbar_sticky ? 'sticky' : 'not-sticky'\n        }));\n        buttons = this.el.querySelector(\".bk-button-bar-list[type='inspectors']\");\n        ref = this.model.inspectors;\n        for (i = 0, len = ref.length; i < len; i++) {\n            obj = ref[i];\n            if (obj.toggleable) {\n                buttons.appendChild(new on_off_button_1.OnOffButtonView({\n                    model: obj,\n                    parent: this\n                }).el);\n            }\n        }\n        buttons = this.el.querySelector(\".bk-button-bar-list[type='help']\");\n        ref1 = this.model.help;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n            obj = ref1[j];\n            buttons.appendChild(new action_tool_1.ActionToolButtonView({\n                model: obj,\n                parent: this\n            }).el);\n        }\n        buttons = this.el.querySelector(\".bk-button-bar-list[type='actions']\");\n        ref2 = this.model.actions;\n        for (k = 0, len2 = ref2.length; k < len2; k++) {\n            obj = ref2[k];\n            buttons.appendChild(new action_tool_1.ActionToolButtonView({\n                model: obj,\n                parent: this\n            }).el);\n        }\n        gestures = this.model.gestures;\n        for (et in gestures) {\n            buttons = this.el.querySelector(\".bk-button-bar-list[type='\" + et + \"']\");\n            ref3 = gestures[et].tools;\n            for (l = 0, len3 = ref3.length; l < len3; l++) {\n                obj = ref3[l];\n                buttons.appendChild(new on_off_button_1.OnOffButtonView({\n                    model: obj,\n                    parent: this\n                }).el);\n            }\n        }\n        return this;\n    };\n    return ToolbarBaseView;\n})(layout_dom_1.LayoutDOMView);\nexports.ToolbarBase = (function (superClass) {\n    extend(ToolbarBase, superClass);\n    function ToolbarBase() {\n        this._active_change = bind(this._active_change, this);\n        return ToolbarBase.__super__.constructor.apply(this, arguments);\n    }\n    ToolbarBase.prototype.type = 'ToolbarBase';\n    ToolbarBase.prototype.default_view = exports.ToolbarBaseView;\n    ToolbarBase.prototype.initialize = function (attrs, options) {\n        ToolbarBase.__super__.initialize.call(this, attrs, options);\n        this._set_sizeable();\n        return this.connect(this.properties.toolbar_location.change, (function (_this) {\n            return function () {\n                return _this._set_sizeable();\n            };\n        })(this));\n    };\n    ToolbarBase.prototype._set_sizeable = function () {\n        var horizontal, ref;\n        horizontal = (ref = this.toolbar_location) === 'left' || ref === 'right';\n        return this._sizeable = !horizontal ? this._height : this._width;\n    };\n    ToolbarBase.prototype._active_change = function (tool) {\n        var currently_active_tool, event_type;\n        event_type = tool.event_type;\n        if (tool.active) {\n            currently_active_tool = this.gestures[event_type].active;\n            if (currently_active_tool != null) {\n                logging_1.logger.debug(\"Toolbar: deactivating tool: \" + currently_active_tool.type + \" (\" + currently_active_tool.id + \") for event type '\" + event_type + \"'\");\n                currently_active_tool.active = false;\n            }\n            this.gestures[event_type].active = tool;\n            logging_1.logger.debug(\"Toolbar: activating tool: \" + tool.type + \" (\" + tool.id + \") for event type '\" + event_type + \"'\");\n        }\n        else {\n            this.gestures[event_type].active = null;\n        }\n        return null;\n    };\n    ToolbarBase.prototype.get_constraints = function () {\n        return ToolbarBase.__super__.get_constraints.call(this).concat([solver_1.EQ(this._sizeable, -30)]);\n    };\n    ToolbarBase.define({\n        tools: [p.Array, []],\n        logo: [p.String, 'normal']\n    });\n    ToolbarBase.internal({\n        gestures: [\n            p.Any, function () {\n                return {\n                    pan: {\n                        tools: [],\n                        active: null\n                    },\n                    tap: {\n                        tools: [],\n                        active: null\n                    },\n                    doubletap: {\n                        tools: [],\n                        active: null\n                    },\n                    scroll: {\n                        tools: [],\n                        active: null\n                    },\n                    pinch: {\n                        tools: [],\n                        active: null\n                    },\n                    press: {\n                        tools: [],\n                        active: null\n                    },\n                    rotate: {\n                        tools: [],\n                        active: null\n                    }\n                };\n            }\n        ],\n        actions: [p.Array, []],\n        inspectors: [p.Array, []],\n        help: [p.Array, []],\n        toolbar_location: [p.Location, 'right'],\n        toolbar_sticky: [p.Bool]\n    });\n    ToolbarBase.override({\n        sizing_mode: null\n    });\n    return ToolbarBase;\n})(layout_dom_1.LayoutDOM);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nvar action_tool_1 = require(\"./actions/action_tool\");\nvar help_tool_1 = require(\"./actions/help_tool\");\nvar gesture_tool_1 = require(\"./gestures/gesture_tool\");\nvar inspect_tool_1 = require(\"./inspectors/inspect_tool\");\nvar toolbar_base_1 = require(\"./toolbar_base\");\nvar tool_proxy_1 = require(\"./tool_proxy\");\nvar box_1 = require(\"../layouts/box\");\nexports.ToolbarBoxToolbar = (function (superClass) {\n    extend(ToolbarBoxToolbar, superClass);\n    function ToolbarBoxToolbar() {\n        return ToolbarBoxToolbar.__super__.constructor.apply(this, arguments);\n    }\n    ToolbarBoxToolbar.prototype.type = 'ToolbarBoxToolbar';\n    ToolbarBoxToolbar.prototype.default_view = toolbar_base_1.ToolbarBaseView;\n    ToolbarBoxToolbar.prototype.initialize = function (options) {\n        ToolbarBoxToolbar.__super__.initialize.call(this, options);\n        this._init_tools();\n        if (this.merge_tools === true) {\n            return this._merge_tools();\n        }\n    };\n    ToolbarBoxToolbar.define({\n        merge_tools: [p.Bool, true]\n    });\n    ToolbarBoxToolbar.prototype._init_tools = function () {\n        var et, i, len, ref, results, tool;\n        ref = this.tools;\n        results = [];\n        for (i = 0, len = ref.length; i < len; i++) {\n            tool = ref[i];\n            if (tool instanceof inspect_tool_1.InspectTool) {\n                if (!array_1.any(this.inspectors, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    results.push(this.inspectors = this.inspectors.concat([tool]));\n                }\n                else {\n                    results.push(void 0);\n                }\n            }\n            else if (tool instanceof help_tool_1.HelpTool) {\n                if (!array_1.any(this.help, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    results.push(this.help = this.help.concat([tool]));\n                }\n                else {\n                    results.push(void 0);\n                }\n            }\n            else if (tool instanceof action_tool_1.ActionTool) {\n                if (!array_1.any(this.actions, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    results.push(this.actions = this.actions.concat([tool]));\n                }\n                else {\n                    results.push(void 0);\n                }\n            }\n            else if (tool instanceof gesture_tool_1.GestureTool) {\n                et = tool.event_type;\n                if (!array_1.any(this.gestures[et].tools, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    results.push(this.gestures[et].tools = this.gestures[et].tools.concat([tool]));\n                }\n                else {\n                    results.push(void 0);\n                }\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    ToolbarBoxToolbar.prototype._merge_tools = function () {\n        var actions, active, et, event_type, gestures, helptool, i, info, inspectors, j, k, l, len, len1, len2, len3, make_proxy, new_help_tools, new_help_urls, proxy, ref, ref1, ref2, ref3, ref4, ref5, ref6, results, tool, tool_type, tools;\n        inspectors = {};\n        actions = {};\n        gestures = {};\n        new_help_tools = [];\n        new_help_urls = [];\n        ref = this.help;\n        for (i = 0, len = ref.length; i < len; i++) {\n            helptool = ref[i];\n            if (ref1 = helptool.redirect, indexOf.call(new_help_urls, ref1) < 0) {\n                new_help_tools.push(helptool);\n                new_help_urls.push(helptool.redirect);\n            }\n        }\n        this.help = new_help_tools;\n        ref2 = this.gestures;\n        for (event_type in ref2) {\n            info = ref2[event_type];\n            if (!(event_type in gestures)) {\n                gestures[event_type] = {};\n            }\n            ref3 = info.tools;\n            for (j = 0, len1 = ref3.length; j < len1; j++) {\n                tool = ref3[j];\n                if (!(tool.type in gestures[event_type])) {\n                    gestures[event_type][tool.type] = [];\n                }\n                gestures[event_type][tool.type].push(tool);\n            }\n        }\n        ref4 = this.inspectors;\n        for (k = 0, len2 = ref4.length; k < len2; k++) {\n            tool = ref4[k];\n            if (!(tool.type in inspectors)) {\n                inspectors[tool.type] = [];\n            }\n            inspectors[tool.type].push(tool);\n        }\n        ref5 = this.actions;\n        for (l = 0, len3 = ref5.length; l < len3; l++) {\n            tool = ref5[l];\n            if (!(tool.type in actions)) {\n                actions[tool.type] = [];\n            }\n            actions[tool.type].push(tool);\n        }\n        make_proxy = function (tools, active) {\n            if (active == null) {\n                active = false;\n            }\n            return new tool_proxy_1.ToolProxy({\n                tools: tools,\n                event_type: tools[0].event_type,\n                tooltip: tools[0].tool_name,\n                tool_name: tools[0].tool_name,\n                icon: tools[0].icon,\n                active: active\n            });\n        };\n        for (event_type in gestures) {\n            this.gestures[event_type].tools = [];\n            ref6 = gestures[event_type];\n            for (tool_type in ref6) {\n                tools = ref6[tool_type];\n                if (tools.length > 0) {\n                    proxy = make_proxy(tools);\n                    this.gestures[event_type].tools.push(proxy);\n                    this.connect(proxy.properties.active.change, this._active_change.bind(null, proxy));\n                }\n            }\n        }\n        this.actions = [];\n        for (tool_type in actions) {\n            tools = actions[tool_type];\n            if (tools.length > 0) {\n                this.actions.push(make_proxy(tools));\n            }\n        }\n        this.inspectors = [];\n        for (tool_type in inspectors) {\n            tools = inspectors[tool_type];\n            if (tools.length > 0) {\n                this.inspectors.push(make_proxy(tools, active = true));\n            }\n        }\n        results = [];\n        for (et in this.gestures) {\n            tools = this.gestures[et].tools;\n            if (tools.length === 0) {\n                continue;\n            }\n            this.gestures[et].tools = array_1.sortBy(tools, function (tool) {\n                return tool.default_order;\n            });\n            if (et !== 'pinch' && et !== 'scroll') {\n                results.push(this.gestures[et].tools[0].active = true);\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    return ToolbarBoxToolbar;\n})(toolbar_base_1.ToolbarBase);\nexports.ToolbarBoxView = (function (superClass) {\n    extend(ToolbarBoxView, superClass);\n    function ToolbarBoxView() {\n        return ToolbarBoxView.__super__.constructor.apply(this, arguments);\n    }\n    ToolbarBoxView.prototype.className = 'bk-toolbar-box';\n    ToolbarBoxView.prototype.get_width = function () {\n        if (this.model._horizontal === true) {\n            return 30;\n        }\n        else {\n            return null;\n        }\n    };\n    ToolbarBoxView.prototype.get_height = function () {\n        return 30;\n    };\n    return ToolbarBoxView;\n})(box_1.BoxView);\nexports.ToolbarBox = (function (superClass) {\n    extend(ToolbarBox, superClass);\n    function ToolbarBox() {\n        return ToolbarBox.__super__.constructor.apply(this, arguments);\n    }\n    ToolbarBox.prototype.type = 'ToolbarBox';\n    ToolbarBox.prototype.default_view = exports.ToolbarBoxView;\n    ToolbarBox.prototype.initialize = function (options) {\n        var ref;\n        ToolbarBox.__super__.initialize.call(this, options);\n        this._toolbar = new exports.ToolbarBoxToolbar(options);\n        this._horizontal = (ref = this.toolbar_location) === 'left' || ref === 'right';\n        return this._sizeable = !this._horizontal ? this._height : this._width;\n    };\n    ToolbarBox.prototype._doc_attached = function () {\n        this._toolbar.attach_document(this.document);\n        return ToolbarBox.__super__._doc_attached.call(this);\n    };\n    ToolbarBox.prototype.get_layoutable_children = function () {\n        return [this._toolbar];\n    };\n    ToolbarBox.define({\n        toolbar_location: [p.Location, \"right\"],\n        merge_tools: [p.Bool, true],\n        tools: [p.Any, []],\n        logo: [p.String, \"normal\"]\n    });\n    return ToolbarBox;\n})(box_1.Box);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOM = require(\"core/dom\");\nexports.default = function (props) {\n    var logo;\n    if (props.logo != null) {\n        var cls = props.logo === \"grey\" ? \"bk-grey\" : null;\n        logo = DOM.createElement(\"a\", { href: \"http://bokeh.pydata.org/\", target: \"_blank\", class: [\"bk-logo\", \"bk-logo-small\", cls] });\n    }\n    return (DOM.createElement(\"div\", { class: [\"bk-toolbar-\" + props.location, \"bk-toolbar-\" + props.sticky] },\n        logo,\n        DOM.createElement(\"div\", { class: 'bk-button-bar' },\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"pan\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"scroll\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"pinch\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"tap\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"press\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"rotate\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"actions\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"inspectors\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"help\" }))));\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, slice = [].slice;\nvar transform_1 = require(\"./transform\");\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nexports.CustomJSTransform = (function (superClass) {\n    extend(CustomJSTransform, superClass);\n    function CustomJSTransform() {\n        return CustomJSTransform.__super__.constructor.apply(this, arguments);\n    }\n    CustomJSTransform.prototype.type = 'CustomJSTransform';\n    CustomJSTransform.define({\n        args: [p.Any, {}],\n        func: [p.String, \"\"],\n        v_func: [p.String, \"\"]\n    });\n    CustomJSTransform.getters({\n        values: function () {\n            return this._make_values();\n        },\n        scalar_transform: function () {\n            return this._make_transform(\"x\", this.func);\n        },\n        vector_transform: function () {\n            return this._make_transform(\"xs\", this.v_func);\n        }\n    });\n    CustomJSTransform.prototype.compute = function (x) {\n        return this.scalar_transform.apply(this, slice.call(this.values).concat([x], [require], [exports]));\n    };\n    CustomJSTransform.prototype.v_compute = function (xs) {\n        return this.vector_transform.apply(this, slice.call(this.values).concat([xs], [require], [exports]));\n    };\n    CustomJSTransform.prototype._make_transform = function (val, fn) {\n        return (function (func, args, ctor) {\n            ctor.prototype = func.prototype;\n            var child = new ctor, result = func.apply(child, args);\n            return Object(result) === result ? result : child;\n        })(Function, slice.call(Object.keys(this.args)).concat([val], [\"require\"], [\"exports\"], [fn]), function () { });\n    };\n    CustomJSTransform.prototype._make_values = function () {\n        return object_1.values(this.args);\n    };\n    return CustomJSTransform;\n})(transform_1.Transform);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar customjs_transform_1 = require(\"./customjs_transform\");\nexports.CustomJSTransform = customjs_transform_1.CustomJSTransform;\nvar interpolator_1 = require(\"./interpolator\");\nexports.Interpolator = interpolator_1.Interpolator;\nvar jitter_1 = require(\"./jitter\");\nexports.Jitter = jitter_1.Jitter;\nvar linear_interpolator_1 = require(\"./linear_interpolator\");\nexports.LinearInterpolator = linear_interpolator_1.LinearInterpolator;\nvar step_interpolator_1 = require(\"./step_interpolator\");\nexports.StepInterpolator = step_interpolator_1.StepInterpolator;\nvar transform_1 = require(\"./transform\");\nexports.Transform = transform_1.Transform;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar transform_1 = require(\"./transform\");\nvar p = require(\"core/properties\");\nexports.Interpolator = (function (superClass) {\n    extend(Interpolator, superClass);\n    function Interpolator() {\n        return Interpolator.__super__.constructor.apply(this, arguments);\n    }\n    Interpolator.prototype.initialize = function (attrs, options) {\n        Interpolator.__super__.initialize.call(this, attrs, options);\n        this._x_sorted = [];\n        this._y_sorted = [];\n        this._sorted_dirty = true;\n        return this.connect(this.change, function () {\n            return this._sorted_dirty = true;\n        });\n    };\n    Interpolator.define({\n        x: [p.Any],\n        y: [p.Any],\n        data: [p.Any],\n        clip: [p.Bool, true]\n    });\n    Interpolator.prototype.sort = function (descending) {\n        var column_names, data, i, j, k, list, ref, ref1, ref2, tsx, tsy;\n        if (descending == null) {\n            descending = false;\n        }\n        if (typeof this.x !== typeof this.y) {\n            throw new Error('The parameters for x and y must be of the same type, either both strings which define a column in the data source or both arrays of the same length');\n            return;\n        }\n        else {\n            if (typeof this.x === 'string' && this.data === null) {\n                throw new Error('If the x and y parameters are not specified as an array, the data parameter is reqired.');\n                return;\n            }\n        }\n        if (this._sorted_dirty === false) {\n            return;\n        }\n        tsx = [];\n        tsy = [];\n        if (typeof this.x === 'string') {\n            data = this.data;\n            column_names = data.columns();\n            if (ref = this.x, indexOf.call(column_names, ref) < 0) {\n                throw new Error('The x parameter does not correspond to a valid column name defined in the data parameter');\n            }\n            if (ref1 = this.y, indexOf.call(column_names, ref1) < 0) {\n                throw new Error('The x parameter does not correspond to a valid column name defined in the data parameter');\n            }\n            tsx = data.get_column(this.x);\n            tsy = data.get_column(this.y);\n        }\n        else {\n            tsx = this.x;\n            tsy = this.y;\n        }\n        if (tsx.length !== tsy.length) {\n            throw new Error('The length for x and y do not match');\n        }\n        if (tsx.length < 2) {\n            throw new Error('x and y must have at least two elements to support interpolation');\n        }\n        list = [];\n        for (j in tsx) {\n            list.push({\n                'x': tsx[j],\n                'y': tsy[j]\n            });\n        }\n        if (descending === true) {\n            list.sort(function (a, b) {\n                var ref2, ref3;\n                return (ref2 = a.x < b.x) != null ? ref2 : -{\n                    1: (ref3 = a.x === b.x) != null ? ref3 : {\n                        0: 1\n                    }\n                };\n            });\n        }\n        else {\n            list.sort(function (a, b) {\n                var ref2, ref3;\n                return (ref2 = a.x > b.x) != null ? ref2 : -{\n                    1: (ref3 = a.x === b.x) != null ? ref3 : {\n                        0: 1\n                    }\n                };\n            });\n        }\n        for (k = i = 0, ref2 = list.length; 0 <= ref2 ? i < ref2 : i > ref2; k = 0 <= ref2 ? ++i : --i) {\n            this._x_sorted[k] = list[k].x;\n            this._y_sorted[k] = list[k].y;\n        }\n        return this._sorted_dirty = false;\n    };\n    return Interpolator;\n})(transform_1.Transform);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar transform_1 = require(\"./transform\");\nvar p = require(\"core/properties\");\nvar bokeh_math = require(\"core/util/math\");\nexports.Jitter = (function (superClass) {\n    extend(Jitter, superClass);\n    function Jitter() {\n        return Jitter.__super__.constructor.apply(this, arguments);\n    }\n    Jitter.define({\n        mean: [p.Number, 0],\n        width: [p.Number, 1],\n        distribution: [p.Distribution, 'uniform']\n    });\n    Jitter.prototype.compute = function (x) {\n        if (this.distribution === 'uniform') {\n            return x + this.mean + ((bokeh_math.random() - 0.5) * this.width);\n        }\n        if (this.distribution === 'normal') {\n            return x + bokeh_math.rnorm(this.mean, this.width);\n        }\n    };\n    Jitter.prototype.v_compute = function (xs) {\n        var i, idx, len, result, x;\n        result = new Float64Array(xs.length);\n        for (idx = i = 0, len = xs.length; i < len; idx = ++i) {\n            x = xs[idx];\n            result[idx] = this.compute(x);\n        }\n        return result;\n    };\n    return Jitter;\n})(transform_1.Transform);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar array_1 = require(\"core/util/array\");\nvar interpolator_1 = require(\"./interpolator\");\nexports.LinearInterpolator = (function (superClass) {\n    extend(LinearInterpolator, superClass);\n    function LinearInterpolator() {\n        return LinearInterpolator.__super__.constructor.apply(this, arguments);\n    }\n    LinearInterpolator.prototype.compute = function (x) {\n        var descending, ind, ret, x1, x2, y1, y2;\n        this.sort(descending = false);\n        if (this.clip === true) {\n            if (x < this._x_sorted[0] || x > this._x_sorted[this._x_sorted.length - 1]) {\n                return null;\n            }\n        }\n        else {\n            if (x < this._x_sorted[0]) {\n                return this._y_sorted[0];\n            }\n            if (x > this._x_sorted[this._x_sorted.length - 1]) {\n                return this._y_sorted[this._y_sorted.length - 1];\n            }\n        }\n        if (x === this._x_sorted[0]) {\n            return this._y_sorted[0];\n        }\n        ind = array_1.findLastIndex(this._x_sorted, function (num) {\n            return num < x;\n        });\n        x1 = this._x_sorted[ind];\n        x2 = this._x_sorted[ind + 1];\n        y1 = this._y_sorted[ind];\n        y2 = this._y_sorted[ind + 1];\n        ret = y1 + (((x - x1) / (x2 - x1)) * (y2 - y1));\n        return ret;\n    };\n    LinearInterpolator.prototype.v_compute = function (xs) {\n        var i, idx, len, result, x;\n        result = new Float64Array(xs.length);\n        for (idx = i = 0, len = xs.length; i < len; idx = ++i) {\n            x = xs[idx];\n            result[idx] = this.compute(x);\n        }\n        return result;\n    };\n    return LinearInterpolator;\n})(interpolator_1.Interpolator);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar interpolator_1 = require(\"./interpolator\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nexports.StepInterpolator = (function (superClass) {\n    extend(StepInterpolator, superClass);\n    function StepInterpolator() {\n        return StepInterpolator.__super__.constructor.apply(this, arguments);\n    }\n    StepInterpolator.define({\n        mode: [p.TransformStepMode, \"after\"]\n    });\n    StepInterpolator.prototype.compute = function (x) {\n        var descending, diffs, ind, mdiff, ret, tx;\n        this.sort(descending = false);\n        if (this.clip === true) {\n            if (x < this._x_sorted[0] || x > this._x_sorted[this._x_sorted.length - 1]) {\n                return null;\n            }\n        }\n        else {\n            if (x < this._x_sorted[0]) {\n                return this._y_sorted[0];\n            }\n            if (x > this._x_sorted[this._x_sorted.length - 1]) {\n                return this._y_sorted[this._y_sorted.length - 1];\n            }\n        }\n        ind = -1;\n        if (this.mode === \"after\") {\n            ind = array_1.findLastIndex(this._x_sorted, function (num) {\n                return x >= num;\n            });\n        }\n        if (this.mode === \"before\") {\n            ind = array_1.findIndex(this._x_sorted, function (num) {\n                return x <= num;\n            });\n        }\n        if (this.mode === \"center\") {\n            diffs = (function () {\n                var i, len, ref, results;\n                ref = this._x_sorted;\n                results = [];\n                for (i = 0, len = ref.length; i < len; i++) {\n                    tx = ref[i];\n                    results.push(Math.abs(tx - x));\n                }\n                return results;\n            }).call(this);\n            mdiff = array_1.min(diffs);\n            ind = array_1.findIndex(diffs, function (num) {\n                return mdiff === num;\n            });\n        }\n        if (ind !== -1) {\n            ret = this._y_sorted[ind];\n        }\n        else {\n            ret = null;\n        }\n        return ret;\n    };\n    StepInterpolator.prototype.v_compute = function (xs) {\n        var i, idx, len, result, x;\n        result = new Float64Array(xs.length);\n        for (idx = i = 0, len = xs.length; i < len; idx = ++i) {\n            x = xs[idx];\n            result[idx] = this.compute(x);\n        }\n        return result;\n    };\n    return StepInterpolator;\n})(interpolator_1.Interpolator);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nexports.Transform = (function (superClass) {\n    extend(Transform, superClass);\n    function Transform() {\n        return Transform.__super__.constructor.apply(this, arguments);\n    }\n    return Transform;\n})(model_1.Model);\n","\"use strict\";\nif (typeof WeakMap !== \"function\") {\n    require(\"es6-weak-map/implement\");\n}\nif (typeof Set !== \"function\") {\n    require(\"es6-set/implement\");\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _burst_into_flames;\n_burst_into_flames = function (error) {\n    var body, box, button, message, ref, title;\n    box = document.createElement(\"div\");\n    box.style[\"background-color\"] = \"#f2dede\";\n    box.style[\"border\"] = \"1px solid #a94442\";\n    box.style[\"border-radius\"] = \"4px\";\n    box.style[\"display\"] = \"inline-block\";\n    box.style[\"font-family\"] = \"sans-serif\";\n    box.style[\"margin-top\"] = \"5px\";\n    box.style[\"min-width\"] = \"200px\";\n    box.style[\"padding\"] = \"5px 5px 5px 10px\";\n    button = document.createElement(\"span\");\n    button.style[\"background-color\"] = \"#a94442\";\n    button.style[\"border-radius\"] = \"0px 4px 0px 0px\";\n    button.style[\"color\"] = \"white\";\n    button.style[\"cursor\"] = \"pointer\";\n    button.style[\"float\"] = \"right\";\n    button.style[\"font-size\"] = \"0.8em\";\n    button.style[\"margin\"] = \"-6px -6px 0px 0px\";\n    button.style[\"padding\"] = \"2px 5px 4px 5px\";\n    button.title = \"close\";\n    button.setAttribute(\"aria-label\", \"close\");\n    button.appendChild(document.createTextNode(\"x\"));\n    button.addEventListener(\"click\", function () {\n        return body.removeChild(box);\n    });\n    title = document.createElement(\"h3\");\n    title.style[\"color\"] = \"#a94442\";\n    title.style[\"margin\"] = \"8px 0px 0px 0px\";\n    title.style[\"padding\"] = \"0px\";\n    title.appendChild(document.createTextNode(\"Bokeh Error\"));\n    message = document.createElement(\"pre\");\n    message.style[\"white-space\"] = \"unset\";\n    message.style[\"overflow-x\"] = \"auto\";\n    message.appendChild(document.createTextNode((ref = error.message) != null ? ref : error));\n    box.appendChild(button);\n    box.appendChild(title);\n    box.appendChild(message);\n    body = document.getElementsByTagName(\"body\")[0];\n    return body.insertBefore(box, body.firstChild);\n};\nexports.safely = function (fn, silent) {\n    var error;\n    if (silent == null) {\n        silent = false;\n    }\n    try {\n        return fn();\n    }\n    catch (error1) {\n        error = error1;\n        _burst_into_flames(error);\n        if (!silent) {\n            throw error;\n        }\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.version = '0.12.6';\n","/*!!\n *  Canvas 2 Svg v1.0.21\n *  A low level canvas to SVG converter. Uses a mock canvas context to build an SVG document.\n *\n *  Licensed under the MIT license:\n *  http://www.opensource.org/licenses/mit-license.php\n *\n *  Author:\n *  Kerry Liu\n *\n *  Copyright (c) 2014 Gliffy Inc.\n */\n\n;(function () {\n    \"use strict\";\n\n    var STYLES, ctx, CanvasGradient, CanvasPattern, namedEntities;\n\n    //helper function to format a string\n    function format(str, args) {\n        var keys = Object.keys(args), i;\n        for (i=0; i<keys.length; i++) {\n            str = str.replace(new RegExp(\"\\\\{\" + keys[i] + \"\\\\}\", \"gi\"), args[keys[i]]);\n        }\n        return str;\n    }\n\n    //helper function that generates a random string\n    function randomString(holder) {\n        var chars, randomstring, i;\n        if (!holder) {\n            throw new Error(\"cannot create a random attribute name for an undefined object\");\n        }\n        chars = \"ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\";\n        randomstring = \"\";\n        do {\n            randomstring = \"\";\n            for (i = 0; i < 12; i++) {\n                randomstring += chars[Math.floor(Math.random() * chars.length)];\n            }\n        } while (holder[randomstring]);\n        return randomstring;\n    }\n\n    //helper function to map named to numbered entities\n    function createNamedToNumberedLookup(items, radix) {\n        var i, entity, lookup = {}, base10, base16;\n        items = items.split(',');\n        radix = radix || 10;\n        // Map from named to numbered entities.\n        for (i = 0; i < items.length; i += 2) {\n            entity = '&' + items[i + 1] + ';';\n            base10 = parseInt(items[i], radix);\n            lookup[entity] = '&#'+base10+';';\n        }\n        //FF and IE need to create a regex from hex values ie &nbsp; == \\xa0\n        lookup[\"\\\\xa0\"] = '&#160;';\n        return lookup;\n    }\n\n    //helper function to map canvas-textAlign to svg-textAnchor\n    function getTextAnchor(textAlign) {\n        //TODO: support rtl languages\n        var mapping = {\"left\":\"start\", \"right\":\"end\", \"center\":\"middle\", \"start\":\"start\", \"end\":\"end\"};\n        return mapping[textAlign] || mapping.start;\n    }\n\n    //helper function to map canvas-textBaseline to svg-dominantBaseline\n    function getDominantBaseline(textBaseline) {\n        //INFO: not supported in all browsers\n        var mapping = {\"alphabetic\": \"alphabetic\", \"hanging\": \"hanging\", \"top\":\"text-before-edge\", \"bottom\":\"text-after-edge\", \"middle\":\"central\"};\n        return mapping[textBaseline] || mapping.alphabetic;\n    }\n\n    // Unpack entities lookup where the numbers are in radix 32 to reduce the size\n    // entity mapping courtesy of tinymce\n    namedEntities = createNamedToNumberedLookup(\n        '50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' +\n            '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' +\n            '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' +\n            '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' +\n            '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' +\n            '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' +\n            '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' +\n            '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' +\n            '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' +\n            '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' +\n            'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' +\n            'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' +\n            't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' +\n            'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' +\n            'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' +\n            '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' +\n            '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' +\n            '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' +\n            '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' +\n            '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' +\n            'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' +\n            'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' +\n            'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' +\n            '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' +\n            '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\n\n\n    //Some basic mappings for attributes and default values.\n    STYLES = {\n        \"strokeStyle\":{\n            svgAttr : \"stroke\", //corresponding svg attribute\n            canvas : \"#000000\", //canvas default\n            svg : \"none\",       //svg default\n            apply : \"stroke\"    //apply on stroke() or fill()\n        },\n        \"fillStyle\":{\n            svgAttr : \"fill\",\n            canvas : \"#000000\",\n            svg : null, //svg default is black, but we need to special case this to handle canvas stroke without fill\n            apply : \"fill\"\n        },\n        \"lineCap\":{\n            svgAttr : \"stroke-linecap\",\n            canvas : \"butt\",\n            svg : \"butt\",\n            apply : \"stroke\"\n        },\n        \"lineJoin\":{\n            svgAttr : \"stroke-linejoin\",\n            canvas : \"miter\",\n            svg : \"miter\",\n            apply : \"stroke\"\n        },\n        \"miterLimit\":{\n            svgAttr : \"stroke-miterlimit\",\n            canvas : 10,\n            svg : 4,\n            apply : \"stroke\"\n        },\n        \"lineWidth\":{\n            svgAttr : \"stroke-width\",\n            canvas : 1,\n            svg : 1,\n            apply : \"stroke\"\n        },\n        \"globalAlpha\": {\n            svgAttr : \"opacity\",\n            canvas : 1,\n            svg : 1,\n            apply :  \"fill stroke\"\n        },\n        \"font\":{\n            //font converts to multiple svg attributes, there is custom logic for this\n            canvas : \"10px sans-serif\"\n        },\n        \"shadowColor\":{\n            canvas : \"#000000\"\n        },\n        \"shadowOffsetX\":{\n            canvas : 0\n        },\n        \"shadowOffsetY\":{\n            canvas : 0\n        },\n        \"shadowBlur\":{\n            canvas : 0\n        },\n        \"textAlign\":{\n            canvas : \"start\"\n        },\n        \"textBaseline\":{\n            canvas : \"alphabetic\"\n        },\n        \"lineDash\" : {\n            svgAttr : \"stroke-dasharray\",\n            canvas : [],\n            svg : null,\n            apply : \"stroke\"\n        }\n    };\n\n    /**\n     *\n     * @param gradientNode - reference to the gradient\n     * @constructor\n     */\n    CanvasGradient = function (gradientNode, ctx) {\n        this.__root = gradientNode;\n        this.__ctx = ctx;\n    };\n\n    /**\n     * Adds a color stop to the gradient root\n     */\n    CanvasGradient.prototype.addColorStop = function (offset, color) {\n        var stop = this.__ctx.__createElement(\"stop\"), regex, matches;\n        stop.setAttribute(\"offset\", offset);\n        if (color.indexOf(\"rgba\") !== -1) {\n            //separate alpha value, since webkit can't handle it\n            regex = /rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?\\.?\\d*)\\s*\\)/gi;\n            matches = regex.exec(color);\n            stop.setAttribute(\"stop-color\", format(\"rgb({r},{g},{b})\", {r:matches[1], g:matches[2], b:matches[3]}));\n            stop.setAttribute(\"stop-opacity\", matches[4]);\n        } else {\n            stop.setAttribute(\"stop-color\", color);\n        }\n        this.__root.appendChild(stop);\n    };\n\n    CanvasPattern = function (pattern, ctx) {\n        this.__root = pattern;\n        this.__ctx = ctx;\n    };\n\n    /**\n     * The mock canvas context\n     * @param o - options include:\n     * ctx - existing Context2D to wrap around\n     * width - width of your canvas (defaults to 500)\n     * height - height of your canvas (defaults to 500)\n     * enableMirroring - enables canvas mirroring (get image data) (defaults to false)\n     * document - the document object (defaults to the current document)\n     */\n    ctx = function (o) {\n        var defaultOptions = { width:500, height:500, enableMirroring : false}, options;\n\n        //keep support for this way of calling C2S: new C2S(width,height)\n        if (arguments.length > 1) {\n            options = defaultOptions;\n            options.width = arguments[0];\n            options.height = arguments[1];\n        } else if ( !o ) {\n            options = defaultOptions;\n        } else {\n            options = o;\n        }\n\n        if (!(this instanceof ctx)) {\n            //did someone call this without new?\n            return new ctx(options);\n        }\n\n        //setup options\n        this.width = options.width || defaultOptions.width;\n        this.height = options.height || defaultOptions.height;\n        this.enableMirroring = options.enableMirroring !== undefined ? options.enableMirroring : defaultOptions.enableMirroring;\n\n        this.canvas = this;   ///point back to this instance!\n        this.__document = options.document || document;\n\n        // allow passing in an existing context to wrap around\n        // if a context is passed in, we know a canvas already exist\n        if (options.ctx) {\n            this.__ctx = options.ctx;\n        } else {\n            this.__canvas = this.__document.createElement(\"canvas\");\n            this.__ctx = this.__canvas.getContext(\"2d\");\n        }\n\n        this.__setDefaultStyles();\n        this.__stack = [this.__getStyleState()];\n        this.__groupStack = [];\n\n        //the root svg element\n        this.__root = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n        this.__root.setAttribute(\"version\", 1.1);\n        this.__root.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n        this.__root.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n        this.__root.setAttribute(\"width\", this.width);\n        this.__root.setAttribute(\"height\", this.height);\n\n        //make sure we don't generate the same ids in defs\n        this.__ids = {};\n\n        //defs tag\n        this.__defs = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"defs\");\n        this.__root.appendChild(this.__defs);\n\n        //also add a group child. the svg element can't use the transform attribute\n        this.__currentElement = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n        this.__root.appendChild(this.__currentElement);\n    };\n\n\n    /**\n     * Creates the specified svg element\n     * @private\n     */\n    ctx.prototype.__createElement = function (elementName, properties, resetFill) {\n        if (typeof properties === \"undefined\") {\n            properties = {};\n        }\n\n        var element = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", elementName),\n            keys = Object.keys(properties), i, key;\n        if (resetFill) {\n            //if fill or stroke is not specified, the svg element should not display. By default SVG's fill is black.\n            element.setAttribute(\"fill\", \"none\");\n            element.setAttribute(\"stroke\", \"none\");\n        }\n        for (i=0; i<keys.length; i++) {\n            key = keys[i];\n            element.setAttribute(key, properties[key]);\n        }\n        return element;\n    };\n\n    /**\n     * Applies default canvas styles to the context\n     * @private\n     */\n    ctx.prototype.__setDefaultStyles = function () {\n        //default 2d canvas context properties see:http://www.w3.org/TR/2dcontext/\n        var keys = Object.keys(STYLES), i, key;\n        for (i=0; i<keys.length; i++) {\n            key = keys[i];\n            this[key] = STYLES[key].canvas;\n        }\n    };\n\n    /**\n     * Applies styles on restore\n     * @param styleState\n     * @private\n     */\n    ctx.prototype.__applyStyleState = function (styleState) {\n        var keys = Object.keys(styleState), i, key;\n        for (i=0; i<keys.length; i++) {\n            key = keys[i];\n            this[key] = styleState[key];\n        }\n    };\n\n    /**\n     * Gets the current style state\n     * @return {Object}\n     * @private\n     */\n    ctx.prototype.__getStyleState = function () {\n        var i, styleState = {}, keys = Object.keys(STYLES), key;\n        for (i=0; i<keys.length; i++) {\n            key = keys[i];\n            styleState[key] = this[key];\n        }\n        return styleState;\n    };\n\n    /**\n     * Apples the current styles to the current SVG element. On \"ctx.fill\" or \"ctx.stroke\"\n     * @param type\n     * @private\n     */\n    ctx.prototype.__applyStyleToCurrentElement = function (type) {\n    \tvar currentElement = this.__currentElement;\n    \tvar currentStyleGroup = this.__currentElementsToStyle;\n    \tif (currentStyleGroup) {\n    \t\tcurrentElement.setAttribute(type, \"\");\n    \t\tcurrentElement = currentStyleGroup.element;\n    \t\tcurrentStyleGroup.children.forEach(function (node) {\n    \t\t\tnode.setAttribute(type, \"\");\n    \t\t})\n    \t}\n\n        var keys = Object.keys(STYLES), i, style, value, id, regex, matches;\n        for (i = 0; i < keys.length; i++) {\n            style = STYLES[keys[i]];\n            value = this[keys[i]];\n            if (style.apply) {\n                //is this a gradient or pattern?\n                if (value instanceof CanvasPattern) {\n                    //pattern\n                    if (value.__ctx) {\n                        //copy over defs\n                        while(value.__ctx.__defs.childNodes.length) {\n                            id = value.__ctx.__defs.childNodes[0].getAttribute(\"id\");\n                            this.__ids[id] = id;\n                            this.__defs.appendChild(value.__ctx.__defs.childNodes[0]);\n                        }\n                    }\n                    currentElement.setAttribute(style.apply, format(\"url(#{id})\", {id:value.__root.getAttribute(\"id\")}));\n                }\n                else if (value instanceof CanvasGradient) {\n                    //gradient\n                    currentElement.setAttribute(style.apply, format(\"url(#{id})\", {id:value.__root.getAttribute(\"id\")}));\n                } else if (style.apply.indexOf(type)!==-1 && style.svg !== value) {\n                    if ((style.svgAttr === \"stroke\" || style.svgAttr === \"fill\") && value.indexOf(\"rgba\") !== -1) {\n                        //separate alpha value, since illustrator can't handle it\n                        regex = /rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?\\.?\\d*)\\s*\\)/gi;\n                        matches = regex.exec(value);\n                        currentElement.setAttribute(style.svgAttr, format(\"rgb({r},{g},{b})\", {r:matches[1], g:matches[2], b:matches[3]}));\n                        //should take globalAlpha here\n                        var opacity = matches[4];\n                        var globalAlpha = this.globalAlpha;\n                        if (globalAlpha != null) {\n                            opacity *= globalAlpha;\n                        }\n                        currentElement.setAttribute(style.svgAttr+\"-opacity\", opacity);\n                    } else {\n                        var attr = style.svgAttr;\n                        if (keys[i] === 'globalAlpha') {\n                            attr = type+'-'+style.svgAttr;\n                            if (currentElement.getAttribute(attr)) {\n                                 //fill-opacity or stroke-opacity has already been set by stroke or fill.\n                                continue;\n                            }\n                        }\n                        //otherwise only update attribute if right type, and not svg default\n                        currentElement.setAttribute(attr, value);\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Will return the closest group or svg node. May return the current element.\n     * @private\n     */\n    ctx.prototype.__closestGroupOrSvg = function (node) {\n        node = node || this.__currentElement;\n        if (node.nodeName === \"g\" || node.nodeName === \"svg\") {\n            return node;\n        } else {\n            return this.__closestGroupOrSvg(node.parentNode);\n        }\n    };\n\n    /**\n     * Returns the serialized value of the svg so far\n     * @param fixNamedEntities - Standalone SVG doesn't support named entities, which document.createTextNode encodes.\n     *                           If true, we attempt to find all named entities and encode it as a numeric entity.\n     * @return serialized svg\n     */\n    ctx.prototype.getSerializedSvg = function (fixNamedEntities) {\n        var serialized = new XMLSerializer().serializeToString(this.__root),\n            keys, i, key, value, regexp, xmlns;\n\n        //IE search for a duplicate xmnls because they didn't implement setAttributeNS correctly\n        xmlns = /xmlns=\"http:\\/\\/www\\.w3\\.org\\/2000\\/svg\".+xmlns=\"http:\\/\\/www\\.w3\\.org\\/2000\\/svg/gi;\n        if (xmlns.test(serialized)) {\n            serialized = serialized.replace('xmlns=\"http://www.w3.org/2000/svg','xmlns:xlink=\"http://www.w3.org/1999/xlink');\n        }\n\n        if (fixNamedEntities) {\n            keys = Object.keys(namedEntities);\n            //loop over each named entity and replace with the proper equivalent.\n            for (i=0; i<keys.length; i++) {\n                key = keys[i];\n                value = namedEntities[key];\n                regexp = new RegExp(key, \"gi\");\n                if (regexp.test(serialized)) {\n                    serialized = serialized.replace(regexp, value);\n                }\n            }\n        }\n\n        return serialized;\n    };\n\n\n    /**\n     * Returns the root svg\n     * @return\n     */\n    ctx.prototype.getSvg = function () {\n        return this.__root;\n    };\n    /**\n     * Will generate a group tag.\n     */\n    ctx.prototype.save = function () {\n        var group = this.__createElement(\"g\");\n        var parent = this.__closestGroupOrSvg();\n        this.__groupStack.push(parent);\n        parent.appendChild(group);\n        this.__currentElement = group;\n        this.__stack.push(this.__getStyleState());\n    };\n    /**\n     * Sets current element to parent, or just root if already root\n     */\n    ctx.prototype.restore = function () {\n        this.__currentElement = this.__groupStack.pop();\n        this.__currentElementsToStyle = null;\n        //Clearing canvas will make the poped group invalid, currentElement is set to the root group node.\n        if (!this.__currentElement) {\n            this.__currentElement = this.__root.childNodes[1];\n        }\n        var state = this.__stack.pop();\n        this.__applyStyleState(state);\n    };\n\n    /**\n     * Helper method to add transform\n     * @private\n     */\n    ctx.prototype.__addTransform = function (t) {\n        //if the current element has siblings, add another group\n        var parent = this.__closestGroupOrSvg();\n        if (parent.childNodes.length > 0) {\n        \tif (this.__currentElement.nodeName === \"path\") {\n        \t\tif (!this.__currentElementsToStyle) this.__currentElementsToStyle = {element: parent, children: []};\n        \t\tthis.__currentElementsToStyle.children.push(this.__currentElement)\n        \t\tthis.__applyCurrentDefaultPath();\n        \t}\n\n            var group = this.__createElement(\"g\");\n            parent.appendChild(group);\n            this.__currentElement = group;\n        }\n\n        var transform = this.__currentElement.getAttribute(\"transform\");\n        if (transform) {\n            transform += \" \";\n        } else {\n            transform = \"\";\n        }\n        transform += t;\n        this.__currentElement.setAttribute(\"transform\", transform);\n    };\n\n    /**\n     *  scales the current element\n     */\n    ctx.prototype.scale = function (x, y) {\n        if (y === undefined) {\n            y = x;\n        }\n        this.__addTransform(format(\"scale({x},{y})\", {x:x, y:y}));\n    };\n\n    /**\n     * rotates the current element\n     */\n    ctx.prototype.rotate = function (angle) {\n        var degrees = (angle * 180 / Math.PI);\n        this.__addTransform(format(\"rotate({angle},{cx},{cy})\", {angle:degrees, cx:0, cy:0}));\n    };\n\n    /**\n     * translates the current element\n     */\n    ctx.prototype.translate = function (x, y) {\n        this.__addTransform(format(\"translate({x},{y})\", {x:x,y:y}));\n    };\n\n    /**\n     * applies a transform to the current element\n     */\n    ctx.prototype.transform = function (a, b, c, d, e, f) {\n        this.__addTransform(format(\"matrix({a},{b},{c},{d},{e},{f})\", {a:a, b:b, c:c, d:d, e:e, f:f}));\n    };\n\n    /**\n     * Create a new Path Element\n     */\n    ctx.prototype.beginPath = function () {\n        var path, parent;\n\n        // Note that there is only one current default path, it is not part of the drawing state.\n        // See also: https://html.spec.whatwg.org/multipage/scripting.html#current-default-path\n        this.__currentDefaultPath = \"\";\n        this.__currentPosition = {};\n\n        path = this.__createElement(\"path\", {}, true);\n        parent = this.__closestGroupOrSvg();\n        parent.appendChild(path);\n        this.__currentElement = path;\n    };\n\n    /**\n     * Helper function to apply currentDefaultPath to current path element\n     * @private\n     */\n    ctx.prototype.__applyCurrentDefaultPath = function () {\n    \tvar currentElement = this.__currentElement;\n        if (currentElement.nodeName === \"path\") {\n\t\t\tcurrentElement.setAttribute(\"d\", this.__currentDefaultPath);\n        } else {\n\t\t\tconsole.error(\"Attempted to apply path command to node\", currentElement.nodeName);\n        }\n    };\n\n    /**\n     * Helper function to add path command\n     * @private\n     */\n    ctx.prototype.__addPathCommand = function (command) {\n        this.__currentDefaultPath += \" \";\n        this.__currentDefaultPath += command;\n    };\n\n    /**\n     * Adds the move command to the current path element,\n     * if the currentPathElement is not empty create a new path element\n     */\n    ctx.prototype.moveTo = function (x,y) {\n        if (this.__currentElement.nodeName !== \"path\") {\n            this.beginPath();\n        }\n\n        // creates a new subpath with the given point\n        this.__currentPosition = {x: x, y: y};\n        this.__addPathCommand(format(\"M {x} {y}\", {x:x, y:y}));\n    };\n\n    /**\n     * Closes the current path\n     */\n    ctx.prototype.closePath = function () {\n        if (this.__currentDefaultPath) {\n            this.__addPathCommand(\"Z\");\n        }\n    };\n\n    /**\n     * Adds a line to command\n     */\n    ctx.prototype.lineTo = function (x, y) {\n        this.__currentPosition = {x: x, y: y};\n        if (this.__currentDefaultPath.indexOf('M') > -1) {\n            this.__addPathCommand(format(\"L {x} {y}\", {x:x, y:y}));\n        } else {\n            this.__addPathCommand(format(\"M {x} {y}\", {x:x, y:y}));\n        }\n    };\n\n    /**\n     * Add a bezier command\n     */\n    ctx.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n        this.__currentPosition = {x: x, y: y};\n        this.__addPathCommand(format(\"C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}\",\n            {cp1x:cp1x, cp1y:cp1y, cp2x:cp2x, cp2y:cp2y, x:x, y:y}));\n    };\n\n    /**\n     * Adds a quadratic curve to command\n     */\n    ctx.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {\n        this.__currentPosition = {x: x, y: y};\n        this.__addPathCommand(format(\"Q {cpx} {cpy} {x} {y}\", {cpx:cpx, cpy:cpy, x:x, y:y}));\n    };\n\n\n    /**\n     * Return a new normalized vector of given vector\n     */\n    var normalize = function (vector) {\n        var len = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);\n        return [vector[0] / len, vector[1] / len];\n    };\n\n    /**\n     * Adds the arcTo to the current path\n     *\n     * @see http://www.w3.org/TR/2015/WD-2dcontext-20150514/#dom-context-2d-arcto\n     */\n    ctx.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n        // Let the point (x0, y0) be the last point in the subpath.\n        var x0 = this.__currentPosition && this.__currentPosition.x;\n        var y0 = this.__currentPosition && this.__currentPosition.y;\n\n        // First ensure there is a subpath for (x1, y1).\n        if (typeof x0 == \"undefined\" || typeof y0 == \"undefined\") {\n            return;\n        }\n\n        // Negative values for radius must cause the implementation to throw an IndexSizeError exception.\n        if (radius < 0) {\n            throw new Error(\"IndexSizeError: The radius provided (\" + radius + \") is negative.\");\n        }\n\n        // If the point (x0, y0) is equal to the point (x1, y1),\n        // or if the point (x1, y1) is equal to the point (x2, y2),\n        // or if the radius radius is zero,\n        // then the method must add the point (x1, y1) to the subpath,\n        // and connect that point to the previous point (x0, y0) by a straight line.\n        if (((x0 === x1) && (y0 === y1))\n            || ((x1 === x2) && (y1 === y2))\n            || (radius === 0)) {\n            this.lineTo(x1, y1);\n            return;\n        }\n\n        // Otherwise, if the points (x0, y0), (x1, y1), and (x2, y2) all lie on a single straight line,\n        // then the method must add the point (x1, y1) to the subpath,\n        // and connect that point to the previous point (x0, y0) by a straight line.\n        var unit_vec_p1_p0 = normalize([x0 - x1, y0 - y1]);\n        var unit_vec_p1_p2 = normalize([x2 - x1, y2 - y1]);\n        if (unit_vec_p1_p0[0] * unit_vec_p1_p2[1] === unit_vec_p1_p0[1] * unit_vec_p1_p2[0]) {\n            this.lineTo(x1, y1);\n            return;\n        }\n\n        // Otherwise, let The Arc be the shortest arc given by circumference of the circle that has radius radius,\n        // and that has one point tangent to the half-infinite line that crosses the point (x0, y0) and ends at the point (x1, y1),\n        // and that has a different point tangent to the half-infinite line that ends at the point (x1, y1), and crosses the point (x2, y2).\n        // The points at which this circle touches these two lines are called the start and end tangent points respectively.\n\n        // note that both vectors are unit vectors, so the length is 1\n        var cos = (unit_vec_p1_p0[0] * unit_vec_p1_p2[0] + unit_vec_p1_p0[1] * unit_vec_p1_p2[1]);\n        var theta = Math.acos(Math.abs(cos));\n\n        // Calculate origin\n        var unit_vec_p1_origin = normalize([\n            unit_vec_p1_p0[0] + unit_vec_p1_p2[0],\n            unit_vec_p1_p0[1] + unit_vec_p1_p2[1]\n        ]);\n        var len_p1_origin = radius / Math.sin(theta / 2);\n        var x = x1 + len_p1_origin * unit_vec_p1_origin[0];\n        var y = y1 + len_p1_origin * unit_vec_p1_origin[1];\n\n        // Calculate start angle and end angle\n        // rotate 90deg clockwise (note that y axis points to its down)\n        var unit_vec_origin_start_tangent = [\n            -unit_vec_p1_p0[1],\n            unit_vec_p1_p0[0]\n        ];\n        // rotate 90deg counter clockwise (note that y axis points to its down)\n        var unit_vec_origin_end_tangent = [\n            unit_vec_p1_p2[1],\n            -unit_vec_p1_p2[0]\n        ];\n        var getAngle = function (vector) {\n            // get angle (clockwise) between vector and (1, 0)\n            var x = vector[0];\n            var y = vector[1];\n            if (y >= 0) { // note that y axis points to its down\n                return Math.acos(x);\n            } else {\n                return -Math.acos(x);\n            }\n        };\n        var startAngle = getAngle(unit_vec_origin_start_tangent);\n        var endAngle = getAngle(unit_vec_origin_end_tangent);\n\n        // Connect the point (x0, y0) to the start tangent point by a straight line\n        this.lineTo(x + unit_vec_origin_start_tangent[0] * radius,\n                    y + unit_vec_origin_start_tangent[1] * radius);\n\n        // Connect the start tangent point to the end tangent point by arc\n        // and adding the end tangent point to the subpath.\n        this.arc(x, y, radius, startAngle, endAngle);\n    };\n\n    /**\n     * Sets the stroke property on the current element\n     */\n    ctx.prototype.stroke = function () {\n        if (this.__currentElement.nodeName === \"path\") {\n            this.__currentElement.setAttribute(\"paint-order\", \"fill stroke markers\");\n        }\n        this.__applyCurrentDefaultPath();\n        this.__applyStyleToCurrentElement(\"stroke\");\n    };\n\n    /**\n     * Sets fill properties on the current element\n     */\n    ctx.prototype.fill = function () {\n        if (this.__currentElement.nodeName === \"path\") {\n            this.__currentElement.setAttribute(\"paint-order\", \"stroke fill markers\");\n        }\n        this.__applyCurrentDefaultPath();\n        this.__applyStyleToCurrentElement(\"fill\");\n    };\n\n    /**\n     *  Adds a rectangle to the path.\n     */\n    ctx.prototype.rect = function (x, y, width, height) {\n        if (this.__currentElement.nodeName !== \"path\") {\n            this.beginPath();\n        }\n        this.moveTo(x, y);\n        this.lineTo(x+width, y);\n        this.lineTo(x+width, y+height);\n        this.lineTo(x, y+height);\n        this.lineTo(x, y);\n        this.closePath();\n    };\n\n\n    /**\n     * adds a rectangle element\n     */\n    ctx.prototype.fillRect = function (x, y, width, height) {\n        var rect, parent;\n        rect = this.__createElement(\"rect\", {\n            x : x,\n            y : y,\n            width : width,\n            height : height\n        }, true);\n        parent = this.__closestGroupOrSvg();\n        parent.appendChild(rect);\n        this.__currentElement = rect;\n        this.__applyStyleToCurrentElement(\"fill\");\n    };\n\n    /**\n     * Draws a rectangle with no fill\n     * @param x\n     * @param y\n     * @param width\n     * @param height\n     */\n    ctx.prototype.strokeRect = function (x, y, width, height) {\n        var rect, parent;\n        rect = this.__createElement(\"rect\", {\n            x : x,\n            y : y,\n            width : width,\n            height : height\n        }, true);\n        parent = this.__closestGroupOrSvg();\n        parent.appendChild(rect);\n        this.__currentElement = rect;\n        this.__applyStyleToCurrentElement(\"stroke\");\n    };\n\n\n    /**\n     * Clear entire canvas:\n     * 1. save current transforms\n     * 2. remove all the childNodes of the root g element\n     */\n    ctx.prototype.__clearCanvas = function () {\n        var current = this.__closestGroupOrSvg(),\n            transform = current.getAttribute(\"transform\");\n        var rootGroup = this.__root.childNodes[1];\n        var childNodes = rootGroup.childNodes;\n        for (var i = childNodes.length - 1; i >= 0; i--) {\n            if (childNodes[i]) {\n                rootGroup.removeChild(childNodes[i]);\n            }\n        }\n        this.__currentElement = rootGroup;\n        //reset __groupStack as all the child group nodes are all removed.\n        this.__groupStack = [];\n        if (transform) {\n            this.__addTransform(transform);\n        }\n    };\n\n    /**\n     * \"Clears\" a canvas by just drawing a white rectangle in the current group.\n     */\n    ctx.prototype.clearRect = function (x, y, width, height) {\n        //clear entire canvas\n        if (x === 0 && y === 0 && width === this.width && height === this.height) {\n            this.__clearCanvas();\n            return;\n        }\n        var rect, parent = this.__closestGroupOrSvg();\n        rect = this.__createElement(\"rect\", {\n            x : x,\n            y : y,\n            width : width,\n            height : height,\n            fill : \"#FFFFFF\"\n        }, true);\n        parent.appendChild(rect);\n    };\n\n    /**\n     * Adds a linear gradient to a defs tag.\n     * Returns a canvas gradient object that has a reference to it's parent def\n     */\n    ctx.prototype.createLinearGradient = function (x1, y1, x2, y2) {\n        var grad = this.__createElement(\"linearGradient\", {\n            id : randomString(this.__ids),\n            x1 : x1+\"px\",\n            x2 : x2+\"px\",\n            y1 : y1+\"px\",\n            y2 : y2+\"px\",\n            \"gradientUnits\" : \"userSpaceOnUse\"\n        }, false);\n        this.__defs.appendChild(grad);\n        return new CanvasGradient(grad, this);\n    };\n\n    /**\n     * Adds a radial gradient to a defs tag.\n     * Returns a canvas gradient object that has a reference to it's parent def\n     */\n    ctx.prototype.createRadialGradient = function (x0, y0, r0, x1, y1, r1) {\n        var grad = this.__createElement(\"radialGradient\", {\n            id : randomString(this.__ids),\n            cx : x1+\"px\",\n            cy : y1+\"px\",\n            r  : r1+\"px\",\n            fx : x0+\"px\",\n            fy : y0+\"px\",\n            \"gradientUnits\" : \"userSpaceOnUse\"\n        }, false);\n        this.__defs.appendChild(grad);\n        return new CanvasGradient(grad, this);\n\n    };\n\n    /**\n     * Parses the font string and returns svg mapping\n     * @private\n     */\n    ctx.prototype.__parseFont = function () {\n        var regex = /^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))(?:\\s*\\/\\s*(normal|[.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])))?\\s*([-,\\'\\\"\\sa-z0-9]+?)\\s*$/i;\n        var fontPart = regex.exec( this.font );\n        var data = {\n            style : fontPart[1] || 'normal',\n            size : fontPart[4] || '10px',\n            family : fontPart[6] || 'sans-serif',\n            weight: fontPart[3] || 'normal',\n            decoration : fontPart[2] || 'normal',\n            href : null\n        };\n\n        //canvas doesn't support underline natively, but we can pass this attribute\n        if (this.__fontUnderline === \"underline\") {\n            data.decoration = \"underline\";\n        }\n\n        //canvas also doesn't support linking, but we can pass this as well\n        if (this.__fontHref) {\n            data.href = this.__fontHref;\n        }\n\n        return data;\n    };\n\n    /**\n     * Helper to link text fragments\n     * @param font\n     * @param element\n     * @return {*}\n     * @private\n     */\n    ctx.prototype.__wrapTextLink = function (font, element) {\n        if (font.href) {\n            var a = this.__createElement(\"a\");\n            a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", font.href);\n            a.appendChild(element);\n            return a;\n        }\n        return element;\n    };\n\n    /**\n     * Fills or strokes text\n     * @param text\n     * @param x\n     * @param y\n     * @param action - stroke or fill\n     * @private\n     */\n    ctx.prototype.__applyText = function (text, x, y, action) {\n        var font = this.__parseFont(),\n            parent = this.__closestGroupOrSvg(),\n            textElement = this.__createElement(\"text\", {\n                \"font-family\" : font.family,\n                \"font-size\" : font.size,\n                \"font-style\" : font.style,\n                \"font-weight\" : font.weight,\n                \"text-decoration\" : font.decoration,\n                \"x\" : x,\n                \"y\" : y,\n                \"text-anchor\": getTextAnchor(this.textAlign),\n                \"dominant-baseline\": getDominantBaseline(this.textBaseline)\n            }, true);\n\n        textElement.appendChild(this.__document.createTextNode(text));\n        this.__currentElement = textElement;\n        this.__applyStyleToCurrentElement(action);\n        parent.appendChild(this.__wrapTextLink(font,textElement));\n    };\n\n    /**\n     * Creates a text element\n     * @param text\n     * @param x\n     * @param y\n     */\n    ctx.prototype.fillText = function (text, x, y) {\n        this.__applyText(text, x, y, \"fill\");\n    };\n\n    /**\n     * Strokes text\n     * @param text\n     * @param x\n     * @param y\n     */\n    ctx.prototype.strokeText = function (text, x, y) {\n        this.__applyText(text, x, y, \"stroke\");\n    };\n\n    /**\n     * No need to implement this for svg.\n     * @param text\n     * @return {TextMetrics}\n     */\n    ctx.prototype.measureText = function (text) {\n        this.__ctx.font = this.font;\n        return this.__ctx.measureText(text);\n    };\n\n    /**\n     *  Arc command!\n     */\n    ctx.prototype.arc = function (x, y, radius, startAngle, endAngle, counterClockwise) {\n        // in canvas no circle is drawn if no angle is provided.\n        if (startAngle === endAngle) {\n            return;\n        }\n        startAngle = startAngle % (2*Math.PI);\n        endAngle = endAngle % (2*Math.PI);\n        if (startAngle === endAngle) {\n            //circle time! subtract some of the angle so svg is happy (svg elliptical arc can't draw a full circle)\n            endAngle = ((endAngle + (2*Math.PI)) - 0.001 * (counterClockwise ? -1 : 1)) % (2*Math.PI);\n        }\n        var endX = x+radius*Math.cos(endAngle),\n            endY = y+radius*Math.sin(endAngle),\n            startX = x+radius*Math.cos(startAngle),\n            startY = y+radius*Math.sin(startAngle),\n            sweepFlag = counterClockwise ? 0 : 1,\n            largeArcFlag = 0,\n            diff = endAngle - startAngle;\n\n        // https://github.com/gliffy/canvas2svg/issues/4\n        if (diff < 0) {\n            diff += 2*Math.PI;\n        }\n\n        if (counterClockwise) {\n            largeArcFlag = diff > Math.PI ? 0 : 1;\n        } else {\n            largeArcFlag = diff > Math.PI ? 1 : 0;\n        }\n\n        this.lineTo(startX, startY);\n        this.__addPathCommand(format(\"A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}\",\n            {rx:radius, ry:radius, xAxisRotation:0, largeArcFlag:largeArcFlag, sweepFlag:sweepFlag, endX:endX, endY:endY}));\n\n        this.__currentPosition = {x: endX, y: endY};\n    };\n\n    /**\n     * Generates a ClipPath from the clip command.\n     */\n    ctx.prototype.clip = function () {\n        var group = this.__closestGroupOrSvg(),\n            clipPath = this.__createElement(\"clipPath\"),\n            id =  randomString(this.__ids),\n            newGroup = this.__createElement(\"g\");\n\n        this.__applyCurrentDefaultPath();\n        group.removeChild(this.__currentElement);\n        clipPath.setAttribute(\"id\", id);\n        clipPath.appendChild(this.__currentElement);\n\n        this.__defs.appendChild(clipPath);\n\n        //set the clip path to this group\n        group.setAttribute(\"clip-path\", format(\"url(#{id})\", {id:id}));\n\n        //clip paths can be scaled and transformed, we need to add another wrapper group to avoid later transformations\n        // to this path\n        group.appendChild(newGroup);\n\n        this.__currentElement = newGroup;\n\n    };\n\n    /**\n     * Draws a canvas, image or mock context to this canvas.\n     * Note that all svg dom manipulation uses node.childNodes rather than node.children for IE support.\n     * http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage\n     */\n    ctx.prototype.drawImage = function () {\n        //convert arguments to a real array\n        var args = Array.prototype.slice.call(arguments),\n            image=args[0],\n            dx, dy, dw, dh, sx=0, sy=0, sw, sh, parent, svg, defs, group,\n            currentElement, svgImage, canvas, context, id;\n\n        if (args.length === 3) {\n            dx = args[1];\n            dy = args[2];\n            sw = image.width;\n            sh = image.height;\n            dw = sw;\n            dh = sh;\n        } else if (args.length === 5) {\n            dx = args[1];\n            dy = args[2];\n            dw = args[3];\n            dh = args[4];\n            sw = image.width;\n            sh = image.height;\n        } else if (args.length === 9) {\n            sx = args[1];\n            sy = args[2];\n            sw = args[3];\n            sh = args[4];\n            dx = args[5];\n            dy = args[6];\n            dw = args[7];\n            dh = args[8];\n        } else {\n            throw new Error(\"Inavlid number of arguments passed to drawImage: \" + arguments.length);\n        }\n\n        parent = this.__closestGroupOrSvg();\n        currentElement = this.__currentElement;\n        var translateDirective = \"translate(\" + dx + \", \" + dy + \")\";\n        if (image instanceof ctx) {\n            //canvas2svg mock canvas context. In the future we may want to clone nodes instead.\n            //also I'm currently ignoring dw, dh, sw, sh, sx, sy for a mock context.\n            svg = image.getSvg().cloneNode(true);\n            if (svg.childNodes && svg.childNodes.length > 1) {\n                defs = svg.childNodes[0];\n                while(defs.childNodes.length) {\n                    id = defs.childNodes[0].getAttribute(\"id\");\n                    this.__ids[id] = id;\n                    this.__defs.appendChild(defs.childNodes[0]);\n                }\n                group = svg.childNodes[1];\n                if (group) {\n                    //save original transform\n                    var originTransform = group.getAttribute(\"transform\");\n                    var transformDirective;\n                    if (originTransform) {\n                        transformDirective = originTransform+\" \"+translateDirective;\n                    } else {\n                        transformDirective = translateDirective;\n                    }\n                    group.setAttribute(\"transform\", transformDirective);\n                    parent.appendChild(group);\n                }\n            }\n        } else if (image.nodeName === \"IMG\") {\n            svgImage = this.__createElement(\"image\");\n            svgImage.setAttribute(\"width\", dw);\n            svgImage.setAttribute(\"height\", dh);\n            svgImage.setAttribute(\"preserveAspectRatio\", \"none\");\n\n            if (sx || sy || sw !== image.width || sh !== image.height) {\n                //crop the image using a temporary canvas\n                canvas = this.__document.createElement(\"canvas\");\n                canvas.width = dw;\n                canvas.height = dh;\n                context = canvas.getContext(\"2d\");\n                context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);\n                image = canvas;\n            }\n            svgImage.setAttribute(\"transform\", translateDirective);\n            svgImage.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\",\n                image.nodeName === \"CANVAS\" ? image.toDataURL() : image.getAttribute(\"src\"));\n            parent.appendChild(svgImage);\n        } else if (image.nodeName === \"CANVAS\") {\n            svgImage = this.__createElement(\"image\");\n            svgImage.setAttribute(\"width\", dw);\n            svgImage.setAttribute(\"height\", dh);\n            svgImage.setAttribute(\"preserveAspectRatio\", \"none\");\n\n            // draw canvas onto temporary canvas so that smoothing can be handled\n            canvas = this.__document.createElement(\"canvas\");\n            canvas.width = dw;\n            canvas.height = dh;\n            context = canvas.getContext(\"2d\");\n            context.imageSmoothingEnabled = false;\n            context.mozImageSmoothingEnabled = false;\n            context.oImageSmoothingEnabled = false;\n            context.webkitImageSmoothingEnabled = false;\n            context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);\n            image = canvas;\n\n            svgImage.setAttribute(\"transform\", translateDirective);\n            svgImage.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", image.toDataURL());\n            parent.appendChild(svgImage);\n        }\n    };\n\n    /**\n     * Generates a pattern tag\n     */\n    ctx.prototype.createPattern = function (image, repetition) {\n        var pattern = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"pattern\"), id = randomString(this.__ids),\n            img;\n        pattern.setAttribute(\"id\", id);\n        pattern.setAttribute(\"width\", image.width);\n        pattern.setAttribute(\"height\", image.height);\n        if (image.nodeName === \"CANVAS\" || image.nodeName === \"IMG\") {\n            img = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"image\");\n            img.setAttribute(\"width\", image.width);\n            img.setAttribute(\"height\", image.height);\n            img.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\",\n                image.nodeName === \"CANVAS\" ? image.toDataURL() : image.getAttribute(\"src\"));\n            pattern.appendChild(img);\n            this.__defs.appendChild(pattern);\n        } else if (image instanceof ctx) {\n            pattern.appendChild(image.__root.childNodes[1]);\n            this.__defs.appendChild(pattern);\n        }\n        return new CanvasPattern(pattern, this);\n    };\n\n    ctx.prototype.setLineDash = function (dashArray) {\n        if (dashArray && dashArray.length > 0) {\n            this.lineDash = dashArray.join(\",\");\n        } else {\n            this.lineDash = null;\n        }\n    };\n\n    /**\n     * Not yet implemented\n     */\n    ctx.prototype.drawFocusRing = function () {};\n    ctx.prototype.createImageData = function () {};\n    ctx.prototype.getImageData = function () {};\n    ctx.prototype.putImageData = function () {};\n    ctx.prototype.globalCompositeOperation = function () {};\n    ctx.prototype.setTransform = function () {};\n\n    //add options for alternative namespace\n    if (typeof window === \"object\") {\n        window.C2S = ctx;\n    }\n\n    // CommonJS/Browserify\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        module.exports = ctx;\n    }\n\n}());\n","'use strict';\n\nvar copy             = require('es5-ext/object/copy')\n  , normalizeOptions = require('es5-ext/object/normalize-options')\n  , ensureCallable   = require('es5-ext/object/valid-callable')\n  , map              = require('es5-ext/object/map')\n  , callable         = require('es5-ext/object/valid-callable')\n  , validValue       = require('es5-ext/object/valid-value')\n\n  , bind = Function.prototype.bind, defineProperty = Object.defineProperty\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , define;\n\ndefine = function (name, desc, options) {\n\tvar value = validValue(desc) && callable(desc.value), dgs;\n\tdgs = copy(desc);\n\tdelete dgs.writable;\n\tdelete dgs.value;\n\tdgs.get = function () {\n\t\tif (!options.overwriteDefinition && hasOwnProperty.call(this, name)) return value;\n\t\tdesc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);\n\t\tdefineProperty(this, name, desc);\n\t\treturn this[name];\n\t};\n\treturn dgs;\n};\n\nmodule.exports = function (props/*, options*/) {\n\tvar options = normalizeOptions(arguments[1]);\n\tif (options.resolveContext != null) ensureCallable(options.resolveContext);\n\treturn map(props, function (desc, name) { return define(name, desc, options); });\n};\n","'use strict';\n\nvar assign        = require('es5-ext/object/assign')\n  , normalizeOpts = require('es5-ext/object/normalize-options')\n  , isCallable    = require('es5-ext/object/is-callable')\n  , contains      = require('es5-ext/string/#/contains')\n\n  , d;\n\nd = module.exports = function (dscr, value/*, options*/) {\n\tvar c, e, w, options, desc;\n\tif ((arguments.length < 2) || (typeof dscr !== 'string')) {\n\t\toptions = value;\n\t\tvalue = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[2];\n\t}\n\tif (dscr == null) {\n\t\tc = w = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t\tw = contains.call(dscr, 'w');\n\t}\n\n\tdesc = { value: value, configurable: c, enumerable: e, writable: w };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\nd.gs = function (dscr, get, set/*, options*/) {\n\tvar c, e, options, desc;\n\tif (typeof dscr !== 'string') {\n\t\toptions = set;\n\t\tset = get;\n\t\tget = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[3];\n\t}\n\tif (get == null) {\n\t\tget = undefined;\n\t} else if (!isCallable(get)) {\n\t\toptions = get;\n\t\tget = set = undefined;\n\t} else if (set == null) {\n\t\tset = undefined;\n\t} else if (!isCallable(set)) {\n\t\toptions = set;\n\t\tset = undefined;\n\t}\n\tif (dscr == null) {\n\t\tc = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t}\n\n\tdesc = { get: get, set: set, configurable: c, enumerable: e };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n","// Inspired by Google Closure:\n// http://closure-library.googlecode.com/svn/docs/\n// closure_goog_array_array.js.html#goog.array.clear\n\n'use strict';\n\nvar value = require('../../object/valid-value');\n\nmodule.exports = function () {\n\tvalue(this).length = 0;\n\treturn this;\n};\n","'use strict';\n\nvar toPosInt = require('../../number/to-pos-integer')\n  , value    = require('../../object/valid-value')\n\n  , indexOf = Array.prototype.indexOf\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , abs = Math.abs, floor = Math.floor;\n\nmodule.exports = function (searchElement/*, fromIndex*/) {\n\tvar i, l, fromIndex, val;\n\tif (searchElement === searchElement) { //jslint: ignore\n\t\treturn indexOf.apply(this, arguments);\n\t}\n\n\tl = toPosInt(value(this).length);\n\tfromIndex = arguments[1];\n\tif (isNaN(fromIndex)) fromIndex = 0;\n\telse if (fromIndex >= 0) fromIndex = floor(fromIndex);\n\telse fromIndex = toPosInt(this.length) - floor(abs(fromIndex));\n\n\tfor (i = fromIndex; i < l; ++i) {\n\t\tif (hasOwnProperty.call(this, i)) {\n\t\t\tval = this[i];\n\t\t\tif (val !== val) return i; //jslint: ignore\n\t\t}\n\t}\n\treturn -1;\n};\n","'use strict';\n\nmodule.exports = require('./is-implemented')()\n\t? Array.from\n\t: require('./shim');\n","'use strict';\n\nmodule.exports = function () {\n\tvar from = Array.from, arr, result;\n\tif (typeof from !== 'function') return false;\n\tarr = ['raz', 'dwa'];\n\tresult = from(arr);\n\treturn Boolean(result && (result !== arr) && (result[1] === 'dwa'));\n};\n","'use strict';\n\nvar iteratorSymbol = require('es6-symbol').iterator\n  , isArguments    = require('../../function/is-arguments')\n  , isFunction     = require('../../function/is-function')\n  , toPosInt       = require('../../number/to-pos-integer')\n  , callable       = require('../../object/valid-callable')\n  , validValue     = require('../../object/valid-value')\n  , isString       = require('../../string/is-string')\n\n  , isArray = Array.isArray, call = Function.prototype.call\n  , desc = { configurable: true, enumerable: true, writable: true, value: null }\n  , defineProperty = Object.defineProperty;\n\nmodule.exports = function (arrayLike/*, mapFn, thisArg*/) {\n\tvar mapFn = arguments[1], thisArg = arguments[2], Constructor, i, j, arr, l, code, iterator\n\t  , result, getIterator, value;\n\n\tarrayLike = Object(validValue(arrayLike));\n\n\tif (mapFn != null) callable(mapFn);\n\tif (!this || (this === Array) || !isFunction(this)) {\n\t\t// Result: Plain array\n\t\tif (!mapFn) {\n\t\t\tif (isArguments(arrayLike)) {\n\t\t\t\t// Source: Arguments\n\t\t\t\tl = arrayLike.length;\n\t\t\t\tif (l !== 1) return Array.apply(null, arrayLike);\n\t\t\t\tarr = new Array(1);\n\t\t\t\tarr[0] = arrayLike[0];\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t\tif (isArray(arrayLike)) {\n\t\t\t\t// Source: Array\n\t\t\t\tarr = new Array(l = arrayLike.length);\n\t\t\t\tfor (i = 0; i < l; ++i) arr[i] = arrayLike[i];\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t}\n\t\tarr = [];\n\t} else {\n\t\t// Result: Non plain array\n\t\tConstructor = this;\n\t}\n\n\tif (!isArray(arrayLike)) {\n\t\tif ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {\n\t\t\t// Source: Iterator\n\t\t\titerator = callable(getIterator).call(arrayLike);\n\t\t\tif (Constructor) arr = new Constructor();\n\t\t\tresult = iterator.next();\n\t\t\ti = 0;\n\t\t\twhile (!result.done) {\n\t\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;\n\t\t\t\tif (!Constructor) {\n\t\t\t\t\tarr[i] = value;\n\t\t\t\t} else {\n\t\t\t\t\tdesc.value = value;\n\t\t\t\t\tdefineProperty(arr, i, desc);\n\t\t\t\t}\n\t\t\t\tresult = iterator.next();\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tl = i;\n\t\t} else if (isString(arrayLike)) {\n\t\t\t// Source: String\n\t\t\tl = arrayLike.length;\n\t\t\tif (Constructor) arr = new Constructor();\n\t\t\tfor (i = 0, j = 0; i < l; ++i) {\n\t\t\t\tvalue = arrayLike[i];\n\t\t\t\tif ((i + 1) < l) {\n\t\t\t\t\tcode = value.charCodeAt(0);\n\t\t\t\t\tif ((code >= 0xD800) && (code <= 0xDBFF)) value += arrayLike[++i];\n\t\t\t\t}\n\t\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, value, j) : value;\n\t\t\t\tif (!Constructor) {\n\t\t\t\t\tarr[j] = value;\n\t\t\t\t} else {\n\t\t\t\t\tdesc.value = value;\n\t\t\t\t\tdefineProperty(arr, j, desc);\n\t\t\t\t}\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tl = j;\n\t\t}\n\t}\n\tif (l === undefined) {\n\t\t// Source: array or array-like\n\t\tl = toPosInt(arrayLike.length);\n\t\tif (Constructor) arr = new Constructor(l);\n\t\tfor (i = 0; i < l; ++i) {\n\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];\n\t\t\tif (!Constructor) {\n\t\t\t\tarr[i] = value;\n\t\t\t} else {\n\t\t\t\tdesc.value = value;\n\t\t\t\tdefineProperty(arr, i, desc);\n\t\t\t}\n\t\t}\n\t}\n\tif (Constructor) {\n\t\tdesc.value = null;\n\t\tarr.length = l;\n\t}\n\treturn arr;\n};\n","'use strict';\n\nvar toString = Object.prototype.toString\n\n  , id = toString.call((function () { return arguments; }()));\n\nmodule.exports = function (x) { return (toString.call(x) === id); };\n","'use strict';\n\nvar toString = Object.prototype.toString\n\n  , id = toString.call(require('./noop'));\n\nmodule.exports = function (f) {\n\treturn (typeof f === \"function\") && (toString.call(f) === id);\n};\n","'use strict';\n\nmodule.exports = function () {};\n","'use strict';\n\nmodule.exports = new Function(\"return this\")();\n","'use strict';\n\nmodule.exports = require('./is-implemented')()\n\t? Math.sign\n\t: require('./shim');\n","'use strict';\n\nmodule.exports = function () {\n\tvar sign = Math.sign;\n\tif (typeof sign !== 'function') return false;\n\treturn ((sign(10) === 1) && (sign(-20) === -1));\n};\n","'use strict';\n\nmodule.exports = function (value) {\n\tvalue = Number(value);\n\tif (isNaN(value) || (value === 0)) return value;\n\treturn (value > 0) ? 1 : -1;\n};\n","'use strict';\n\nvar sign = require('../math/sign')\n\n  , abs = Math.abs, floor = Math.floor;\n\nmodule.exports = function (value) {\n\tif (isNaN(value)) return 0;\n\tvalue = Number(value);\n\tif ((value === 0) || !isFinite(value)) return value;\n\treturn sign(value) * floor(abs(value));\n};\n","'use strict';\n\nvar toInteger = require('./to-integer')\n\n  , max = Math.max;\n\nmodule.exports = function (value) { return max(0, toInteger(value)); };\n","// Internal method, used by iteration functions.\n// Calls a function for each key-value pair found in object\n// Optionally takes compareFn to iterate object in specific order\n\n'use strict';\n\nvar callable = require('./valid-callable')\n  , value    = require('./valid-value')\n\n  , bind = Function.prototype.bind, call = Function.prototype.call, keys = Object.keys\n  , propertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nmodule.exports = function (method, defVal) {\n\treturn function (obj, cb/*, thisArg, compareFn*/) {\n\t\tvar list, thisArg = arguments[2], compareFn = arguments[3];\n\t\tobj = Object(value(obj));\n\t\tcallable(cb);\n\n\t\tlist = keys(obj);\n\t\tif (compareFn) {\n\t\t\tlist.sort((typeof compareFn === 'function') ? bind.call(compareFn, obj) : undefined);\n\t\t}\n\t\tif (typeof method !== 'function') method = list[method];\n\t\treturn call.call(method, list, function (key, index) {\n\t\t\tif (!propertyIsEnumerable.call(obj, key)) return defVal;\n\t\t\treturn call.call(cb, thisArg, obj[key], key, obj, index);\n\t\t});\n\t};\n};\n","'use strict';\n\nmodule.exports = require('./is-implemented')()\n\t? Object.assign\n\t: require('./shim');\n","'use strict';\n\nmodule.exports = function () {\n\tvar assign = Object.assign, obj;\n\tif (typeof assign !== 'function') return false;\n\tobj = { foo: 'raz' };\n\tassign(obj, { bar: 'dwa' }, { trzy: 'trzy' });\n\treturn (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';\n};\n","'use strict';\n\nvar keys  = require('../keys')\n  , value = require('../valid-value')\n\n  , max = Math.max;\n\nmodule.exports = function (dest, src/*, srcn*/) {\n\tvar error, i, l = max(arguments.length, 2), assign;\n\tdest = Object(value(dest));\n\tassign = function (key) {\n\t\ttry { dest[key] = src[key]; } catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t};\n\tfor (i = 1; i < l; ++i) {\n\t\tsrc = arguments[i];\n\t\tkeys(src).forEach(assign);\n\t}\n\tif (error !== undefined) throw error;\n\treturn dest;\n};\n","'use strict';\n\nvar aFrom  = require('../array/from')\n  , assign = require('./assign')\n  , value  = require('./valid-value');\n\nmodule.exports = function (obj/*, propertyNames, options*/) {\n\tvar copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);\n\tif (copy !== obj && !propertyNames) return copy;\n\tvar result = {};\n\tif (propertyNames) {\n\t\taFrom(propertyNames, function (propertyName) {\n\t\t\tif (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];\n\t\t});\n\t} else {\n\t\tassign(result, obj);\n\t}\n\treturn result;\n};\n","// Workaround for http://code.google.com/p/v8/issues/detail?id=2804\n\n'use strict';\n\nvar create = Object.create, shim;\n\nif (!require('./set-prototype-of/is-implemented')()) {\n\tshim = require('./set-prototype-of/shim');\n}\n\nmodule.exports = (function () {\n\tvar nullObject, props, desc;\n\tif (!shim) return create;\n\tif (shim.level !== 1) return create;\n\n\tnullObject = {};\n\tprops = {};\n\tdesc = { configurable: false, enumerable: false, writable: true,\n\t\tvalue: undefined };\n\tObject.getOwnPropertyNames(Object.prototype).forEach(function (name) {\n\t\tif (name === '__proto__') {\n\t\t\tprops[name] = { configurable: true, enumerable: false, writable: true,\n\t\t\t\tvalue: undefined };\n\t\t\treturn;\n\t\t}\n\t\tprops[name] = desc;\n\t});\n\tObject.defineProperties(nullObject, props);\n\n\tObject.defineProperty(shim, 'nullPolyfill', { configurable: false,\n\t\tenumerable: false, writable: false, value: nullObject });\n\n\treturn function (prototype, props) {\n\t\treturn create((prototype === null) ? nullObject : prototype, props);\n\t};\n}());\n","'use strict';\n\nmodule.exports = require('./_iterate')('forEach');\n","// Deprecated\n\n'use strict';\n\nmodule.exports = function (obj) { return typeof obj === 'function'; };\n","'use strict';\n\nvar map = { 'function': true, object: true };\n\nmodule.exports = function (x) {\n\treturn ((x != null) && map[typeof x]) || false;\n};\n","'use strict';\n\nmodule.exports = require('./is-implemented')()\n\t? Object.keys\n\t: require('./shim');\n","'use strict';\n\nmodule.exports = function () {\n\ttry {\n\t\tObject.keys('primitive');\n\t\treturn true;\n\t} catch (e) { return false; }\n};\n","'use strict';\n\nvar keys = Object.keys;\n\nmodule.exports = function (object) {\n\treturn keys(object == null ? object : Object(object));\n};\n","'use strict';\n\nvar callable = require('./valid-callable')\n  , forEach  = require('./for-each')\n\n  , call = Function.prototype.call;\n\nmodule.exports = function (obj, cb/*, thisArg*/) {\n\tvar o = {}, thisArg = arguments[2];\n\tcallable(cb);\n\tforEach(obj, function (value, key, obj, index) {\n\t\to[key] = call.call(cb, thisArg, value, key, obj, index);\n\t});\n\treturn o;\n};\n","'use strict';\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\nvar process = function (src, obj) {\n\tvar key;\n\tfor (key in src) obj[key] = src[key];\n};\n\nmodule.exports = function (options/*, options*/) {\n\tvar result = create(null);\n\tforEach.call(arguments, function (options) {\n\t\tif (options == null) return;\n\t\tprocess(Object(options), result);\n\t});\n\treturn result;\n};\n","'use strict';\n\nmodule.exports = require('./is-implemented')()\n\t? Object.setPrototypeOf\n\t: require('./shim');\n","'use strict';\n\nvar create = Object.create, getPrototypeOf = Object.getPrototypeOf\n  , x = {};\n\nmodule.exports = function (/*customCreate*/) {\n\tvar setPrototypeOf = Object.setPrototypeOf\n\t  , customCreate = arguments[0] || create;\n\tif (typeof setPrototypeOf !== 'function') return false;\n\treturn getPrototypeOf(setPrototypeOf(customCreate(null), x)) === x;\n};\n","// Big thanks to @WebReflection for sorting this out\n// https://gist.github.com/WebReflection/5593554\n\n'use strict';\n\nvar isObject      = require('../is-object')\n  , value         = require('../valid-value')\n\n  , isPrototypeOf = Object.prototype.isPrototypeOf\n  , defineProperty = Object.defineProperty\n  , nullDesc = { configurable: true, enumerable: false, writable: true,\n\t\tvalue: undefined }\n  , validate;\n\nvalidate = function (obj, prototype) {\n\tvalue(obj);\n\tif ((prototype === null) || isObject(prototype)) return obj;\n\tthrow new TypeError('Prototype must be null or an object');\n};\n\nmodule.exports = (function (status) {\n\tvar fn, set;\n\tif (!status) return null;\n\tif (status.level === 2) {\n\t\tif (status.set) {\n\t\t\tset = status.set;\n\t\t\tfn = function (obj, prototype) {\n\t\t\t\tset.call(validate(obj, prototype), prototype);\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t} else {\n\t\t\tfn = function (obj, prototype) {\n\t\t\t\tvalidate(obj, prototype).__proto__ = prototype;\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t}\n\t} else {\n\t\tfn = function self(obj, prototype) {\n\t\t\tvar isNullBase;\n\t\t\tvalidate(obj, prototype);\n\t\t\tisNullBase = isPrototypeOf.call(self.nullPolyfill, obj);\n\t\t\tif (isNullBase) delete self.nullPolyfill.__proto__;\n\t\t\tif (prototype === null) prototype = self.nullPolyfill;\n\t\t\tobj.__proto__ = prototype;\n\t\t\tif (isNullBase) defineProperty(self.nullPolyfill, '__proto__', nullDesc);\n\t\t\treturn obj;\n\t\t};\n\t}\n\treturn Object.defineProperty(fn, 'level', { configurable: false,\n\t\tenumerable: false, writable: false, value: status.level });\n}((function () {\n\tvar x = Object.create(null), y = {}, set\n\t  , desc = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');\n\n\tif (desc) {\n\t\ttry {\n\t\t\tset = desc.set; // Opera crashes at this point\n\t\t\tset.call(x, y);\n\t\t} catch (ignore) { }\n\t\tif (Object.getPrototypeOf(x) === y) return { set: set, level: 2 };\n\t}\n\n\tx.__proto__ = y;\n\tif (Object.getPrototypeOf(x) === y) return { level: 2 };\n\n\tx = {};\n\tx.__proto__ = y;\n\tif (Object.getPrototypeOf(x) === y) return { level: 1 };\n\n\treturn false;\n}())));\n\nrequire('../create');\n","'use strict';\n\nmodule.exports = function (fn) {\n\tif (typeof fn !== 'function') throw new TypeError(fn + \" is not a function\");\n\treturn fn;\n};\n","'use strict';\n\nvar isObject = require('./is-object');\n\nmodule.exports = function (value) {\n\tif (!isObject(value)) throw new TypeError(value + \" is not an Object\");\n\treturn value;\n};\n","'use strict';\n\nmodule.exports = function (value) {\n\tif (value == null) throw new TypeError(\"Cannot use null or undefined\");\n\treturn value;\n};\n","'use strict';\n\nmodule.exports = require('./is-implemented')()\n\t? String.prototype.contains\n\t: require('./shim');\n","'use strict';\n\nvar str = 'razdwatrzy';\n\nmodule.exports = function () {\n\tif (typeof str.contains !== 'function') return false;\n\treturn ((str.contains('dwa') === true) && (str.contains('foo') === false));\n};\n","'use strict';\n\nvar indexOf = String.prototype.indexOf;\n\nmodule.exports = function (searchString/*, position*/) {\n\treturn indexOf.call(this, searchString, arguments[1]) > -1;\n};\n","'use strict';\n\nvar toString = Object.prototype.toString\n\n  , id = toString.call('');\n\nmodule.exports = function (x) {\n\treturn (typeof x === 'string') || (x && (typeof x === 'object') &&\n\t\t((x instanceof String) || (toString.call(x) === id))) || false;\n};\n","'use strict';\n\nvar generated = Object.create(null)\n\n  , random = Math.random;\n\nmodule.exports = function () {\n\tvar str;\n\tdo { str = random().toString(36).slice(2); } while (generated[str]);\n\treturn str;\n};\n","'use strict';\n\nvar setPrototypeOf = require('es5-ext/object/set-prototype-of')\n  , contains       = require('es5-ext/string/#/contains')\n  , d              = require('d')\n  , Iterator       = require('./')\n\n  , defineProperty = Object.defineProperty\n  , ArrayIterator;\n\nArrayIterator = module.exports = function (arr, kind) {\n\tif (!(this instanceof ArrayIterator)) return new ArrayIterator(arr, kind);\n\tIterator.call(this, arr);\n\tif (!kind) kind = 'value';\n\telse if (contains.call(kind, 'key+value')) kind = 'key+value';\n\telse if (contains.call(kind, 'key')) kind = 'key';\n\telse kind = 'value';\n\tdefineProperty(this, '__kind__', d('', kind));\n};\nif (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);\n\nArrayIterator.prototype = Object.create(Iterator.prototype, {\n\tconstructor: d(ArrayIterator),\n\t_resolve: d(function (i) {\n\t\tif (this.__kind__ === 'value') return this.__list__[i];\n\t\tif (this.__kind__ === 'key+value') return [i, this.__list__[i]];\n\t\treturn i;\n\t}),\n\ttoString: d(function () { return '[object Array Iterator]'; })\n});\n","'use strict';\n\nvar isArguments = require('es5-ext/function/is-arguments')\n  , callable    = require('es5-ext/object/valid-callable')\n  , isString    = require('es5-ext/string/is-string')\n  , get         = require('./get')\n\n  , isArray = Array.isArray, call = Function.prototype.call\n  , some = Array.prototype.some;\n\nmodule.exports = function (iterable, cb/*, thisArg*/) {\n\tvar mode, thisArg = arguments[2], result, doBreak, broken, i, l, char, code;\n\tif (isArray(iterable) || isArguments(iterable)) mode = 'array';\n\telse if (isString(iterable)) mode = 'string';\n\telse iterable = get(iterable);\n\n\tcallable(cb);\n\tdoBreak = function () { broken = true; };\n\tif (mode === 'array') {\n\t\tsome.call(iterable, function (value) {\n\t\t\tcall.call(cb, thisArg, value, doBreak);\n\t\t\tif (broken) return true;\n\t\t});\n\t\treturn;\n\t}\n\tif (mode === 'string') {\n\t\tl = iterable.length;\n\t\tfor (i = 0; i < l; ++i) {\n\t\t\tchar = iterable[i];\n\t\t\tif ((i + 1) < l) {\n\t\t\t\tcode = char.charCodeAt(0);\n\t\t\t\tif ((code >= 0xD800) && (code <= 0xDBFF)) char += iterable[++i];\n\t\t\t}\n\t\t\tcall.call(cb, thisArg, char, doBreak);\n\t\t\tif (broken) break;\n\t\t}\n\t\treturn;\n\t}\n\tresult = iterable.next();\n\n\twhile (!result.done) {\n\t\tcall.call(cb, thisArg, result.value, doBreak);\n\t\tif (broken) return;\n\t\tresult = iterable.next();\n\t}\n};\n","'use strict';\n\nvar isArguments    = require('es5-ext/function/is-arguments')\n  , isString       = require('es5-ext/string/is-string')\n  , ArrayIterator  = require('./array')\n  , StringIterator = require('./string')\n  , iterable       = require('./valid-iterable')\n  , iteratorSymbol = require('es6-symbol').iterator;\n\nmodule.exports = function (obj) {\n\tif (typeof iterable(obj)[iteratorSymbol] === 'function') return obj[iteratorSymbol]();\n\tif (isArguments(obj)) return new ArrayIterator(obj);\n\tif (isString(obj)) return new StringIterator(obj);\n\treturn new ArrayIterator(obj);\n};\n","'use strict';\n\nvar clear    = require('es5-ext/array/#/clear')\n  , assign   = require('es5-ext/object/assign')\n  , callable = require('es5-ext/object/valid-callable')\n  , value    = require('es5-ext/object/valid-value')\n  , d        = require('d')\n  , autoBind = require('d/auto-bind')\n  , Symbol   = require('es6-symbol')\n\n  , defineProperty = Object.defineProperty\n  , defineProperties = Object.defineProperties\n  , Iterator;\n\nmodule.exports = Iterator = function (list, context) {\n\tif (!(this instanceof Iterator)) return new Iterator(list, context);\n\tdefineProperties(this, {\n\t\t__list__: d('w', value(list)),\n\t\t__context__: d('w', context),\n\t\t__nextIndex__: d('w', 0)\n\t});\n\tif (!context) return;\n\tcallable(context.on);\n\tcontext.on('_add', this._onAdd);\n\tcontext.on('_delete', this._onDelete);\n\tcontext.on('_clear', this._onClear);\n};\n\ndefineProperties(Iterator.prototype, assign({\n\tconstructor: d(Iterator),\n\t_next: d(function () {\n\t\tvar i;\n\t\tif (!this.__list__) return;\n\t\tif (this.__redo__) {\n\t\t\ti = this.__redo__.shift();\n\t\t\tif (i !== undefined) return i;\n\t\t}\n\t\tif (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;\n\t\tthis._unBind();\n\t}),\n\tnext: d(function () { return this._createResult(this._next()); }),\n\t_createResult: d(function (i) {\n\t\tif (i === undefined) return { done: true, value: undefined };\n\t\treturn { done: false, value: this._resolve(i) };\n\t}),\n\t_resolve: d(function (i) { return this.__list__[i]; }),\n\t_unBind: d(function () {\n\t\tthis.__list__ = null;\n\t\tdelete this.__redo__;\n\t\tif (!this.__context__) return;\n\t\tthis.__context__.off('_add', this._onAdd);\n\t\tthis.__context__.off('_delete', this._onDelete);\n\t\tthis.__context__.off('_clear', this._onClear);\n\t\tthis.__context__ = null;\n\t}),\n\ttoString: d(function () { return '[object Iterator]'; })\n}, autoBind({\n\t_onAdd: d(function (index) {\n\t\tif (index >= this.__nextIndex__) return;\n\t\t++this.__nextIndex__;\n\t\tif (!this.__redo__) {\n\t\t\tdefineProperty(this, '__redo__', d('c', [index]));\n\t\t\treturn;\n\t\t}\n\t\tthis.__redo__.forEach(function (redo, i) {\n\t\t\tif (redo >= index) this.__redo__[i] = ++redo;\n\t\t}, this);\n\t\tthis.__redo__.push(index);\n\t}),\n\t_onDelete: d(function (index) {\n\t\tvar i;\n\t\tif (index >= this.__nextIndex__) return;\n\t\t--this.__nextIndex__;\n\t\tif (!this.__redo__) return;\n\t\ti = this.__redo__.indexOf(index);\n\t\tif (i !== -1) this.__redo__.splice(i, 1);\n\t\tthis.__redo__.forEach(function (redo, i) {\n\t\t\tif (redo > index) this.__redo__[i] = --redo;\n\t\t}, this);\n\t}),\n\t_onClear: d(function () {\n\t\tif (this.__redo__) clear.call(this.__redo__);\n\t\tthis.__nextIndex__ = 0;\n\t})\n})));\n\ndefineProperty(Iterator.prototype, Symbol.iterator, d(function () {\n\treturn this;\n}));\ndefineProperty(Iterator.prototype, Symbol.toStringTag, d('', 'Iterator'));\n","'use strict';\n\nvar isArguments    = require('es5-ext/function/is-arguments')\n  , isString       = require('es5-ext/string/is-string')\n  , iteratorSymbol = require('es6-symbol').iterator\n\n  , isArray = Array.isArray;\n\nmodule.exports = function (value) {\n\tif (value == null) return false;\n\tif (isArray(value)) return true;\n\tif (isString(value)) return true;\n\tif (isArguments(value)) return true;\n\treturn (typeof value[iteratorSymbol] === 'function');\n};\n","// Thanks @mathiasbynens\n// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols\n\n'use strict';\n\nvar setPrototypeOf = require('es5-ext/object/set-prototype-of')\n  , d              = require('d')\n  , Iterator       = require('./')\n\n  , defineProperty = Object.defineProperty\n  , StringIterator;\n\nStringIterator = module.exports = function (str) {\n\tif (!(this instanceof StringIterator)) return new StringIterator(str);\n\tstr = String(str);\n\tIterator.call(this, str);\n\tdefineProperty(this, '__length__', d('', str.length));\n\n};\nif (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);\n\nStringIterator.prototype = Object.create(Iterator.prototype, {\n\tconstructor: d(StringIterator),\n\t_next: d(function () {\n\t\tif (!this.__list__) return;\n\t\tif (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;\n\t\tthis._unBind();\n\t}),\n\t_resolve: d(function (i) {\n\t\tvar char = this.__list__[i], code;\n\t\tif (this.__nextIndex__ === this.__length__) return char;\n\t\tcode = char.charCodeAt(0);\n\t\tif ((code >= 0xD800) && (code <= 0xDBFF)) return char + this.__list__[this.__nextIndex__++];\n\t\treturn char;\n\t}),\n\ttoString: d(function () { return '[object String Iterator]'; })\n});\n","'use strict';\n\nvar isIterable = require('./is-iterable');\n\nmodule.exports = function (value) {\n\tif (!isIterable(value)) throw new TypeError(value + \" is not iterable\");\n\treturn value;\n};\n","/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   3.0.2\n */\n\n(function() {\n    \"use strict\";\n    function lib$es6$promise$utils$$objectOrFunction(x) {\n      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n    }\n\n    function lib$es6$promise$utils$$isFunction(x) {\n      return typeof x === 'function';\n    }\n\n    function lib$es6$promise$utils$$isMaybeThenable(x) {\n      return typeof x === 'object' && x !== null;\n    }\n\n    var lib$es6$promise$utils$$_isArray;\n    if (!Array.isArray) {\n      lib$es6$promise$utils$$_isArray = function (x) {\n        return Object.prototype.toString.call(x) === '[object Array]';\n      };\n    } else {\n      lib$es6$promise$utils$$_isArray = Array.isArray;\n    }\n\n    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n    var lib$es6$promise$asap$$len = 0;\n    var lib$es6$promise$asap$$toString = {}.toString;\n    var lib$es6$promise$asap$$vertxNext;\n    var lib$es6$promise$asap$$customSchedulerFn;\n\n    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n      lib$es6$promise$asap$$len += 2;\n      if (lib$es6$promise$asap$$len === 2) {\n        // If len is 2, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        if (lib$es6$promise$asap$$customSchedulerFn) {\n          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n        } else {\n          lib$es6$promise$asap$$scheduleFlush();\n        }\n      }\n    }\n\n    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n    }\n\n    function lib$es6$promise$asap$$setAsap(asapFn) {\n      lib$es6$promise$asap$$asap = asapFn;\n    }\n\n    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n    // test for web worker but not in IE10\n    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n      typeof importScripts !== 'undefined' &&\n      typeof MessageChannel !== 'undefined';\n\n    // node\n    function lib$es6$promise$asap$$useNextTick() {\n      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n      // see https://github.com/cujojs/when/issues/410 for details\n      return function() {\n        process.nextTick(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    // vertx\n    function lib$es6$promise$asap$$useVertxTimer() {\n      return function() {\n        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    function lib$es6$promise$asap$$useMutationObserver() {\n      var iterations = 0;\n      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    // web worker\n    function lib$es6$promise$asap$$useMessageChannel() {\n      var channel = new MessageChannel();\n      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n      return function () {\n        channel.port2.postMessage(0);\n      };\n    }\n\n    function lib$es6$promise$asap$$useSetTimeout() {\n      return function() {\n        setTimeout(lib$es6$promise$asap$$flush, 1);\n      };\n    }\n\n    var lib$es6$promise$asap$$queue = new Array(1000);\n    function lib$es6$promise$asap$$flush() {\n      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n        var callback = lib$es6$promise$asap$$queue[i];\n        var arg = lib$es6$promise$asap$$queue[i+1];\n\n        callback(arg);\n\n        lib$es6$promise$asap$$queue[i] = undefined;\n        lib$es6$promise$asap$$queue[i+1] = undefined;\n      }\n\n      lib$es6$promise$asap$$len = 0;\n    }\n\n    function lib$es6$promise$asap$$attemptVertx() {\n      try {\n        var r = require;\n        var vertx = r('vertx');\n        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n        return lib$es6$promise$asap$$useVertxTimer();\n      } catch(e) {\n        return lib$es6$promise$asap$$useSetTimeout();\n      }\n    }\n\n    var lib$es6$promise$asap$$scheduleFlush;\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (lib$es6$promise$asap$$isNode) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n    } else if (lib$es6$promise$asap$$isWorker) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n    } else {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n    }\n\n    function lib$es6$promise$$internal$$noop() {}\n\n    var lib$es6$promise$$internal$$PENDING   = void 0;\n    var lib$es6$promise$$internal$$FULFILLED = 1;\n    var lib$es6$promise$$internal$$REJECTED  = 2;\n\n    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$selfFulfillment() {\n      return new TypeError(\"You cannot resolve a promise with itself\");\n    }\n\n    function lib$es6$promise$$internal$$cannotReturnOwn() {\n      return new TypeError('A promises callback cannot return that same promise.');\n    }\n\n    function lib$es6$promise$$internal$$getThen(promise) {\n      try {\n        return promise.then;\n      } catch(error) {\n        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n      try {\n        then.call(value, fulfillmentHandler, rejectionHandler);\n      } catch(e) {\n        return e;\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n       lib$es6$promise$asap$$asap(function(promise) {\n        var sealed = false;\n        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n          if (sealed) { return; }\n          sealed = true;\n          if (thenable !== value) {\n            lib$es6$promise$$internal$$resolve(promise, value);\n          } else {\n            lib$es6$promise$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          if (sealed) { return; }\n          sealed = true;\n\n          lib$es6$promise$$internal$$reject(promise, reason);\n        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n        if (!sealed && error) {\n          sealed = true;\n          lib$es6$promise$$internal$$reject(promise, error);\n        }\n      }, promise);\n    }\n\n    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, thenable._result);\n      } else {\n        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n      if (maybeThenable.constructor === promise.constructor) {\n        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n      } else {\n        var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n\n        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n        } else if (then === undefined) {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        } else if (lib$es6$promise$utils$$isFunction(then)) {\n          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n        } else {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        }\n      }\n    }\n\n    function lib$es6$promise$$internal$$resolve(promise, value) {\n      if (promise === value) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n      } else {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publishRejection(promise) {\n      if (promise._onerror) {\n        promise._onerror(promise._result);\n      }\n\n      lib$es6$promise$$internal$$publish(promise);\n    }\n\n    function lib$es6$promise$$internal$$fulfill(promise, value) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\n      promise._result = value;\n      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\n      if (promise._subscribers.length !== 0) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n      }\n    }\n\n    function lib$es6$promise$$internal$$reject(promise, reason) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n      promise._state = lib$es6$promise$$internal$$REJECTED;\n      promise._result = reason;\n\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n    }\n\n    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      parent._onerror = null;\n\n      subscribers[length] = child;\n      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\n      if (length === 0 && parent._state) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publish(promise) {\n      var subscribers = promise._subscribers;\n      var settled = promise._state;\n\n      if (subscribers.length === 0) { return; }\n\n      var child, callback, detail = promise._result;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        if (child) {\n          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n        } else {\n          callback(detail);\n        }\n      }\n\n      promise._subscribers.length = 0;\n    }\n\n    function lib$es6$promise$$internal$$ErrorObject() {\n      this.error = null;\n    }\n\n    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n      try {\n        return callback(detail);\n      } catch(e) {\n        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\n        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n          failed = true;\n          error = value.error;\n          value = null;\n        } else {\n          succeeded = true;\n        }\n\n        if (promise === value) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n          return;\n        }\n\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n        // noop\n      } else if (hasCallback && succeeded) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      } else if (failed) {\n        lib$es6$promise$$internal$$reject(promise, error);\n      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n      try {\n        resolver(function resolvePromise(value){\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function rejectPromise(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      } catch(e) {\n        lib$es6$promise$$internal$$reject(promise, e);\n      }\n    }\n\n    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n      var enumerator = this;\n\n      enumerator._instanceConstructor = Constructor;\n      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (enumerator._validateInput(input)) {\n        enumerator._input     = input;\n        enumerator.length     = input.length;\n        enumerator._remaining = input.length;\n\n        enumerator._init();\n\n        if (enumerator.length === 0) {\n          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n        } else {\n          enumerator.length = enumerator.length || 0;\n          enumerator._enumerate();\n          if (enumerator._remaining === 0) {\n            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n          }\n        }\n      } else {\n        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n      }\n    }\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {\n      return lib$es6$promise$utils$$isArray(input);\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n      return new Error('Array Methods must be provided an Array');\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {\n      this._result = new Array(this.length);\n    };\n\n    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n      var enumerator = this;\n\n      var length  = enumerator.length;\n      var promise = enumerator.promise;\n      var input   = enumerator._input;\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        enumerator._eachEntry(input[i], i);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n      var enumerator = this;\n      var c = enumerator._instanceConstructor;\n\n      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n          entry._onerror = null;\n          enumerator._settledAt(entry._state, i, entry._result);\n        } else {\n          enumerator._willSettleAt(c.resolve(entry), i);\n        }\n      } else {\n        enumerator._remaining--;\n        enumerator._result[i] = entry;\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n      var enumerator = this;\n      var promise = enumerator.promise;\n\n      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n        enumerator._remaining--;\n\n        if (state === lib$es6$promise$$internal$$REJECTED) {\n          lib$es6$promise$$internal$$reject(promise, value);\n        } else {\n          enumerator._result[i] = value;\n        }\n      }\n\n      if (enumerator._remaining === 0) {\n        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n      var enumerator = this;\n\n      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n      }, function(reason) {\n        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n      });\n    };\n    function lib$es6$promise$promise$all$$all(entries) {\n      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n    }\n    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n    function lib$es6$promise$promise$race$$race(entries) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (!lib$es6$promise$utils$$isArray(entries)) {\n        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n        return promise;\n      }\n\n      var length = entries.length;\n\n      function onFulfillment(value) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      }\n\n      function onRejection(reason) {\n        lib$es6$promise$$internal$$reject(promise, reason);\n      }\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n      }\n\n      return promise;\n    }\n    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n    function lib$es6$promise$promise$resolve$$resolve(object) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (object && typeof object === 'object' && object.constructor === Constructor) {\n        return object;\n      }\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$resolve(promise, object);\n      return promise;\n    }\n    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n    function lib$es6$promise$promise$reject$$reject(reason) {\n      /*jshint validthis:true */\n      var Constructor = this;\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$reject(promise, reason);\n      return promise;\n    }\n    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\n    var lib$es6$promise$promise$$counter = 0;\n\n    function lib$es6$promise$promise$$needsResolver() {\n      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n    }\n\n    function lib$es6$promise$promise$$needsNew() {\n      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n    }\n\n    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n    /**\n      Promise objects represent the eventual result of an asynchronous operation. The\n      primary way of interacting with a promise is through its `then` method, which\n      registers callbacks to receive either a promise's eventual value or the reason\n      why the promise cannot be fulfilled.\n\n      Terminology\n      -----------\n\n      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n      - `thenable` is an object or function that defines a `then` method.\n      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n      - `exception` is a value that is thrown using the throw statement.\n      - `reason` is a value that indicates why a promise was rejected.\n      - `settled` the final resting state of a promise, fulfilled or rejected.\n\n      A promise can be in one of three states: pending, fulfilled, or rejected.\n\n      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n      state.  Promises that are rejected have a rejection reason and are in the\n      rejected state.  A fulfillment value is never a thenable.\n\n      Promises can also be said to *resolve* a value.  If this value is also a\n      promise, then the original promise's settled state will match the value's\n      settled state.  So a promise that *resolves* a promise that rejects will\n      itself reject, and a promise that *resolves* a promise that fulfills will\n      itself fulfill.\n\n\n      Basic Usage:\n      ------------\n\n      ```js\n      var promise = new Promise(function(resolve, reject) {\n        // on success\n        resolve(value);\n\n        // on failure\n        reject(reason);\n      });\n\n      promise.then(function(value) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Advanced Usage:\n      ---------------\n\n      Promises shine when abstracting away asynchronous interactions such as\n      `XMLHttpRequest`s.\n\n      ```js\n      function getJSON(url) {\n        return new Promise(function(resolve, reject){\n          var xhr = new XMLHttpRequest();\n\n          xhr.open('GET', url);\n          xhr.onreadystatechange = handler;\n          xhr.responseType = 'json';\n          xhr.setRequestHeader('Accept', 'application/json');\n          xhr.send();\n\n          function handler() {\n            if (this.readyState === this.DONE) {\n              if (this.status === 200) {\n                resolve(this.response);\n              } else {\n                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n              }\n            }\n          };\n        });\n      }\n\n      getJSON('/posts.json').then(function(json) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Unlike callbacks, promises are great composable primitives.\n\n      ```js\n      Promise.all([\n        getJSON('/posts'),\n        getJSON('/comments')\n      ]).then(function(values){\n        values[0] // => postsJSON\n        values[1] // => commentsJSON\n\n        return values;\n      });\n      ```\n\n      @class Promise\n      @param {function} resolver\n      Useful for tooling.\n      @constructor\n    */\n    function lib$es6$promise$promise$$Promise(resolver) {\n      this._id = lib$es6$promise$promise$$counter++;\n      this._state = undefined;\n      this._result = undefined;\n      this._subscribers = [];\n\n      if (lib$es6$promise$$internal$$noop !== resolver) {\n        if (!lib$es6$promise$utils$$isFunction(resolver)) {\n          lib$es6$promise$promise$$needsResolver();\n        }\n\n        if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n          lib$es6$promise$promise$$needsNew();\n        }\n\n        lib$es6$promise$$internal$$initializePromise(this, resolver);\n      }\n    }\n\n    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\n    lib$es6$promise$promise$$Promise.prototype = {\n      constructor: lib$es6$promise$promise$$Promise,\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n\n      ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n\n      Chaining\n      --------\n\n      The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n\n      ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n\n      findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n      ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n\n      Assimilation\n      ------------\n\n      Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n\n      If the assimliated promise rejects, then the downstream promise will also reject.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n\n      Simple Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var result;\n\n      try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n\n      Advanced Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var author, books;\n\n      try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n\n      function foundBooks(books) {\n\n      }\n\n      function failure(reason) {\n\n      }\n\n      findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      Useful for tooling.\n      @return {Promise}\n    */\n      then: function(onFulfillment, onRejection) {\n        var parent = this;\n        var state = parent._state;\n\n        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n          return this;\n        }\n\n        var child = new this.constructor(lib$es6$promise$$internal$$noop);\n        var result = parent._result;\n\n        if (state) {\n          var callback = arguments[state - 1];\n          lib$es6$promise$asap$$asap(function(){\n            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n          });\n        } else {\n          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n        }\n\n        return child;\n      },\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n\n      ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n\n      // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n\n      // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method catch\n      @param {Function} onRejection\n      Useful for tooling.\n      @return {Promise}\n    */\n      'catch': function(onRejection) {\n        return this.then(null, onRejection);\n      }\n    };\n    function lib$es6$promise$polyfill$$polyfill() {\n      var local;\n\n      if (typeof global !== 'undefined') {\n          local = global;\n      } else if (typeof self !== 'undefined') {\n          local = self;\n      } else {\n          try {\n              local = Function('return this')();\n          } catch (e) {\n              throw new Error('polyfill failed because global object is unavailable in this environment');\n          }\n      }\n\n      var P = local.Promise;\n\n      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n        return;\n      }\n\n      local.Promise = lib$es6$promise$promise$$default;\n    }\n    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\n    var lib$es6$promise$umd$$ES6Promise = {\n      'Promise': lib$es6$promise$promise$$default,\n      'polyfill': lib$es6$promise$polyfill$$default\n    };\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define(function() { return lib$es6$promise$umd$$ES6Promise; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n    } else if (typeof this !== 'undefined') {\n      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n    }\n\n    lib$es6$promise$polyfill$$default();\n}).call(this);\n\n","'use strict';\n\nif (!require('./is-implemented')()) {\n\tObject.defineProperty(require('es5-ext/global'), 'Set',\n\t\t{ value: require('./polyfill'), configurable: true, enumerable: false,\n\t\t\twritable: true });\n}\n","'use strict';\n\nmodule.exports = function () {\n\tvar set, iterator, result;\n\tif (typeof Set !== 'function') return false;\n\tset = new Set(['raz', 'dwa', 'trzy']);\n\tif (String(set) !== '[object Set]') return false;\n\tif (set.size !== 3) return false;\n\tif (typeof set.add !== 'function') return false;\n\tif (typeof set.clear !== 'function') return false;\n\tif (typeof set.delete !== 'function') return false;\n\tif (typeof set.entries !== 'function') return false;\n\tif (typeof set.forEach !== 'function') return false;\n\tif (typeof set.has !== 'function') return false;\n\tif (typeof set.keys !== 'function') return false;\n\tif (typeof set.values !== 'function') return false;\n\n\titerator = set.values();\n\tresult = iterator.next();\n\tif (result.done !== false) return false;\n\tif (result.value !== 'raz') return false;\n\n\treturn true;\n};\n","// Exports true if environment provides native `Set` implementation,\n// whatever that is.\n\n'use strict';\n\nmodule.exports = (function () {\n\tif (typeof Set === 'undefined') return false;\n\treturn (Object.prototype.toString.call(Set.prototype) === '[object Set]');\n}());\n","'use strict';\n\nvar setPrototypeOf    = require('es5-ext/object/set-prototype-of')\n  , contains          = require('es5-ext/string/#/contains')\n  , d                 = require('d')\n  , Iterator          = require('es6-iterator')\n  , toStringTagSymbol = require('es6-symbol').toStringTag\n\n  , defineProperty = Object.defineProperty\n  , SetIterator;\n\nSetIterator = module.exports = function (set, kind) {\n\tif (!(this instanceof SetIterator)) return new SetIterator(set, kind);\n\tIterator.call(this, set.__setData__, set);\n\tif (!kind) kind = 'value';\n\telse if (contains.call(kind, 'key+value')) kind = 'key+value';\n\telse kind = 'value';\n\tdefineProperty(this, '__kind__', d('', kind));\n};\nif (setPrototypeOf) setPrototypeOf(SetIterator, Iterator);\n\nSetIterator.prototype = Object.create(Iterator.prototype, {\n\tconstructor: d(SetIterator),\n\t_resolve: d(function (i) {\n\t\tif (this.__kind__ === 'value') return this.__list__[i];\n\t\treturn [this.__list__[i], this.__list__[i]];\n\t}),\n\ttoString: d(function () { return '[object Set Iterator]'; })\n});\ndefineProperty(SetIterator.prototype, toStringTagSymbol, d('c', 'Set Iterator'));\n","'use strict';\n\nvar clear          = require('es5-ext/array/#/clear')\n  , eIndexOf       = require('es5-ext/array/#/e-index-of')\n  , setPrototypeOf = require('es5-ext/object/set-prototype-of')\n  , callable       = require('es5-ext/object/valid-callable')\n  , d              = require('d')\n  , ee             = require('event-emitter')\n  , Symbol         = require('es6-symbol')\n  , iterator       = require('es6-iterator/valid-iterable')\n  , forOf          = require('es6-iterator/for-of')\n  , Iterator       = require('./lib/iterator')\n  , isNative       = require('./is-native-implemented')\n\n  , call = Function.prototype.call\n  , defineProperty = Object.defineProperty, getPrototypeOf = Object.getPrototypeOf\n  , SetPoly, getValues, NativeSet;\n\nif (isNative) NativeSet = Set;\n\nmodule.exports = SetPoly = function Set(/*iterable*/) {\n\tvar iterable = arguments[0], self;\n\tif (!(this instanceof SetPoly)) throw new TypeError('Constructor requires \\'new\\'');\n\tif (isNative && setPrototypeOf) self = setPrototypeOf(new NativeSet(), getPrototypeOf(this));\n\telse self = this;\n\tif (iterable != null) iterator(iterable);\n\tdefineProperty(self, '__setData__', d('c', []));\n\tif (!iterable) return self;\n\tforOf(iterable, function (value) {\n\t\tif (eIndexOf.call(this, value) !== -1) return;\n\t\tthis.push(value);\n\t}, self.__setData__);\n\treturn self;\n};\n\nif (isNative) {\n\tif (setPrototypeOf) setPrototypeOf(SetPoly, NativeSet);\n\tSetPoly.prototype = Object.create(NativeSet.prototype, { constructor: d(SetPoly) });\n}\n\nee(Object.defineProperties(SetPoly.prototype, {\n\tadd: d(function (value) {\n\t\tif (this.has(value)) return this;\n\t\tthis.emit('_add', this.__setData__.push(value) - 1, value);\n\t\treturn this;\n\t}),\n\tclear: d(function () {\n\t\tif (!this.__setData__.length) return;\n\t\tclear.call(this.__setData__);\n\t\tthis.emit('_clear');\n\t}),\n\tdelete: d(function (value) {\n\t\tvar index = eIndexOf.call(this.__setData__, value);\n\t\tif (index === -1) return false;\n\t\tthis.__setData__.splice(index, 1);\n\t\tthis.emit('_delete', index, value);\n\t\treturn true;\n\t}),\n\tentries: d(function () { return new Iterator(this, 'key+value'); }),\n\tforEach: d(function (cb/*, thisArg*/) {\n\t\tvar thisArg = arguments[1], iterator, result, value;\n\t\tcallable(cb);\n\t\titerator = this.values();\n\t\tresult = iterator._next();\n\t\twhile (result !== undefined) {\n\t\t\tvalue = iterator._resolve(result);\n\t\t\tcall.call(cb, thisArg, value, value, this);\n\t\t\tresult = iterator._next();\n\t\t}\n\t}),\n\thas: d(function (value) {\n\t\treturn (eIndexOf.call(this.__setData__, value) !== -1);\n\t}),\n\tkeys: d(getValues = function () { return this.values(); }),\n\tsize: d.gs(function () { return this.__setData__.length; }),\n\tvalues: d(function () { return new Iterator(this); }),\n\ttoString: d(function () { return '[object Set]'; })\n}));\ndefineProperty(SetPoly.prototype, Symbol.iterator, d(getValues));\ndefineProperty(SetPoly.prototype, Symbol.toStringTag, d('c', 'Set'));\n","'use strict';\n\nmodule.exports = require('./is-implemented')() ? Symbol : require('./polyfill');\n","'use strict';\n\nvar validTypes = { object: true, symbol: true };\n\nmodule.exports = function () {\n\tvar symbol;\n\tif (typeof Symbol !== 'function') return false;\n\tsymbol = Symbol('test symbol');\n\ttry { String(symbol); } catch (e) { return false; }\n\n\t// Return 'true' also for polyfills\n\tif (!validTypes[typeof Symbol.iterator]) return false;\n\tif (!validTypes[typeof Symbol.toPrimitive]) return false;\n\tif (!validTypes[typeof Symbol.toStringTag]) return false;\n\n\treturn true;\n};\n","'use strict';\n\nmodule.exports = function (x) {\n\tif (!x) return false;\n\tif (typeof x === 'symbol') return true;\n\tif (!x.constructor) return false;\n\tif (x.constructor.name !== 'Symbol') return false;\n\treturn (x[x.constructor.toStringTag] === 'Symbol');\n};\n","// ES2015 Symbol polyfill for environments that do not (or partially) support it\n\n'use strict';\n\nvar d              = require('d')\n  , validateSymbol = require('./validate-symbol')\n\n  , create = Object.create, defineProperties = Object.defineProperties\n  , defineProperty = Object.defineProperty, objPrototype = Object.prototype\n  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null)\n  , isNativeSafe;\n\nif (typeof Symbol === 'function') {\n\tNativeSymbol = Symbol;\n\ttry {\n\t\tString(NativeSymbol());\n\t\tisNativeSafe = true;\n\t} catch (ignore) {}\n}\n\nvar generateName = (function () {\n\tvar created = create(null);\n\treturn function (desc) {\n\t\tvar postfix = 0, name, ie11BugWorkaround;\n\t\twhile (created[desc + (postfix || '')]) ++postfix;\n\t\tdesc += (postfix || '');\n\t\tcreated[desc] = true;\n\t\tname = '@@' + desc;\n\t\tdefineProperty(objPrototype, name, d.gs(null, function (value) {\n\t\t\t// For IE11 issue see:\n\t\t\t// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/\n\t\t\t//    ie11-broken-getters-on-dom-objects\n\t\t\t// https://github.com/medikoo/es6-symbol/issues/12\n\t\t\tif (ie11BugWorkaround) return;\n\t\t\tie11BugWorkaround = true;\n\t\t\tdefineProperty(this, name, d(value));\n\t\t\tie11BugWorkaround = false;\n\t\t}));\n\t\treturn name;\n\t};\n}());\n\n// Internal constructor (not one exposed) for creating Symbol instances.\n// This one is used to ensure that `someSymbol instanceof Symbol` always return false\nHiddenSymbol = function Symbol(description) {\n\tif (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');\n\treturn SymbolPolyfill(description);\n};\n\n// Exposed `Symbol` constructor\n// (returns instances of HiddenSymbol)\nmodule.exports = SymbolPolyfill = function Symbol(description) {\n\tvar symbol;\n\tif (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');\n\tif (isNativeSafe) return NativeSymbol(description);\n\tsymbol = create(HiddenSymbol.prototype);\n\tdescription = (description === undefined ? '' : String(description));\n\treturn defineProperties(symbol, {\n\t\t__description__: d('', description),\n\t\t__name__: d('', generateName(description))\n\t});\n};\ndefineProperties(SymbolPolyfill, {\n\tfor: d(function (key) {\n\t\tif (globalSymbols[key]) return globalSymbols[key];\n\t\treturn (globalSymbols[key] = SymbolPolyfill(String(key)));\n\t}),\n\tkeyFor: d(function (s) {\n\t\tvar key;\n\t\tvalidateSymbol(s);\n\t\tfor (key in globalSymbols) if (globalSymbols[key] === s) return key;\n\t}),\n\n\t// To ensure proper interoperability with other native functions (e.g. Array.from)\n\t// fallback to eventual native implementation of given symbol\n\thasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),\n\tisConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||\n\t\tSymbolPolyfill('isConcatSpreadable')),\n\titerator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),\n\tmatch: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),\n\treplace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),\n\tsearch: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),\n\tspecies: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),\n\tsplit: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),\n\ttoPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),\n\ttoStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),\n\tunscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))\n});\n\n// Internal tweaks for real symbol producer\ndefineProperties(HiddenSymbol.prototype, {\n\tconstructor: d(SymbolPolyfill),\n\ttoString: d('', function () { return this.__name__; })\n});\n\n// Proper implementation of methods exposed on Symbol.prototype\n// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\ndefineProperties(SymbolPolyfill.prototype, {\n\ttoString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),\n\tvalueOf: d(function () { return validateSymbol(this); })\n});\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {\n\tvar symbol = validateSymbol(this);\n\tif (typeof symbol === 'symbol') return symbol;\n\treturn symbol.toString();\n}));\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));\n\n// Proper implementaton of toPrimitive and toStringTag for returned symbol instances\ndefineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,\n\td('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));\n\n// Note: It's important to define `toPrimitive` as last one, as some implementations\n// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n// And that may invoke error in definition flow:\n// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\ndefineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,\n\td('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));\n","'use strict';\n\nvar isSymbol = require('./is-symbol');\n\nmodule.exports = function (value) {\n\tif (!isSymbol(value)) throw new TypeError(value + \" is not a symbol\");\n\treturn value;\n};\n","'use strict';\n\nif (!require('./is-implemented')()) {\n\tObject.defineProperty(require('es5-ext/global'), 'WeakMap',\n\t\t{ value: require('./polyfill'), configurable: true, enumerable: false,\n\t\t\twritable: true });\n}\n","'use strict';\n\nmodule.exports = function () {\n\tvar weakMap, x;\n\tif (typeof WeakMap !== 'function') return false;\n\ttry {\n\t\t// WebKit doesn't support arguments and crashes\n\t\tweakMap = new WeakMap([[x = {}, 'one'], [{}, 'two'], [{}, 'three']]);\n\t} catch (e) {\n\t\treturn false;\n\t}\n\tif (String(weakMap) !== '[object WeakMap]') return false;\n\tif (typeof weakMap.set !== 'function') return false;\n\tif (weakMap.set({}, 1) !== weakMap) return false;\n\tif (typeof weakMap.delete !== 'function') return false;\n\tif (typeof weakMap.has !== 'function') return false;\n\tif (weakMap.get(x) !== 'one') return false;\n\n\treturn true;\n};\n","// Exports true if environment provides native `WeakMap` implementation, whatever that is.\n\n'use strict';\n\nmodule.exports = (function () {\n\tif (typeof WeakMap !== 'function') return false;\n\treturn (Object.prototype.toString.call(new WeakMap()) === '[object WeakMap]');\n}());\n","'use strict';\n\nvar setPrototypeOf    = require('es5-ext/object/set-prototype-of')\n  , object            = require('es5-ext/object/valid-object')\n  , value             = require('es5-ext/object/valid-value')\n  , randomUniq        = require('es5-ext/string/random-uniq')\n  , d                 = require('d')\n  , getIterator       = require('es6-iterator/get')\n  , forOf             = require('es6-iterator/for-of')\n  , toStringTagSymbol = require('es6-symbol').toStringTag\n  , isNative          = require('./is-native-implemented')\n\n  , isArray = Array.isArray, defineProperty = Object.defineProperty\n  , hasOwnProperty = Object.prototype.hasOwnProperty, getPrototypeOf = Object.getPrototypeOf\n  , WeakMapPoly;\n\nmodule.exports = WeakMapPoly = function (/*iterable*/) {\n\tvar iterable = arguments[0], self;\n\tif (!(this instanceof WeakMapPoly)) throw new TypeError('Constructor requires \\'new\\'');\n\tif (isNative && setPrototypeOf && (WeakMap !== WeakMapPoly)) {\n\t\tself = setPrototypeOf(new WeakMap(), getPrototypeOf(this));\n\t} else {\n\t\tself = this;\n\t}\n\tif (iterable != null) {\n\t\tif (!isArray(iterable)) iterable = getIterator(iterable);\n\t}\n\tdefineProperty(self, '__weakMapData__', d('c', '$weakMap$' + randomUniq()));\n\tif (!iterable) return self;\n\tforOf(iterable, function (val) {\n\t\tvalue(val);\n\t\tself.set(val[0], val[1]);\n\t});\n\treturn self;\n};\n\nif (isNative) {\n\tif (setPrototypeOf) setPrototypeOf(WeakMapPoly, WeakMap);\n\tWeakMapPoly.prototype = Object.create(WeakMap.prototype, {\n\t\tconstructor: d(WeakMapPoly)\n\t});\n}\n\nObject.defineProperties(WeakMapPoly.prototype, {\n\tdelete: d(function (key) {\n\t\tif (hasOwnProperty.call(object(key), this.__weakMapData__)) {\n\t\t\tdelete key[this.__weakMapData__];\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}),\n\tget: d(function (key) {\n\t\tif (hasOwnProperty.call(object(key), this.__weakMapData__)) {\n\t\t\treturn key[this.__weakMapData__];\n\t\t}\n\t}),\n\thas: d(function (key) {\n\t\treturn hasOwnProperty.call(object(key), this.__weakMapData__);\n\t}),\n\tset: d(function (key, value) {\n\t\tdefineProperty(object(key), this.__weakMapData__, d('c', value));\n\t\treturn this;\n\t}),\n\ttoString: d(function () { return '[object WeakMap]'; })\n});\ndefineProperty(WeakMapPoly.prototype, toStringTagSymbol, d('c', 'WeakMap'));\n","'use strict';\n\nvar d        = require('d')\n  , callable = require('es5-ext/object/valid-callable')\n\n  , apply = Function.prototype.apply, call = Function.prototype.call\n  , create = Object.create, defineProperty = Object.defineProperty\n  , defineProperties = Object.defineProperties\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , descriptor = { configurable: true, enumerable: false, writable: true }\n\n  , on, once, off, emit, methods, descriptors, base;\n\non = function (type, listener) {\n\tvar data;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) {\n\t\tdata = descriptor.value = create(null);\n\t\tdefineProperty(this, '__ee__', descriptor);\n\t\tdescriptor.value = null;\n\t} else {\n\t\tdata = this.__ee__;\n\t}\n\tif (!data[type]) data[type] = listener;\n\telse if (typeof data[type] === 'object') data[type].push(listener);\n\telse data[type] = [data[type], listener];\n\n\treturn this;\n};\n\nonce = function (type, listener) {\n\tvar once, self;\n\n\tcallable(listener);\n\tself = this;\n\ton.call(this, type, once = function () {\n\t\toff.call(self, type, once);\n\t\tapply.call(listener, this, arguments);\n\t});\n\n\tonce.__eeOnceListener__ = listener;\n\treturn this;\n};\n\noff = function (type, listener) {\n\tvar data, listeners, candidate, i;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return this;\n\tdata = this.__ee__;\n\tif (!data[type]) return this;\n\tlisteners = data[type];\n\n\tif (typeof listeners === 'object') {\n\t\tfor (i = 0; (candidate = listeners[i]); ++i) {\n\t\t\tif ((candidate === listener) ||\n\t\t\t\t\t(candidate.__eeOnceListener__ === listener)) {\n\t\t\t\tif (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n\t\t\t\telse listeners.splice(i, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ((listeners === listener) ||\n\t\t\t\t(listeners.__eeOnceListener__ === listener)) {\n\t\t\tdelete data[type];\n\t\t}\n\t}\n\n\treturn this;\n};\n\nemit = function (type) {\n\tvar i, l, listener, listeners, args;\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return;\n\tlisteners = this.__ee__[type];\n\tif (!listeners) return;\n\n\tif (typeof listeners === 'object') {\n\t\tl = arguments.length;\n\t\targs = new Array(l - 1);\n\t\tfor (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\n\t\tlisteners = listeners.slice();\n\t\tfor (i = 0; (listener = listeners[i]); ++i) {\n\t\t\tapply.call(listener, this, args);\n\t\t}\n\t} else {\n\t\tswitch (arguments.length) {\n\t\tcase 1:\n\t\t\tcall.call(listeners, this);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcall.call(listeners, this, arguments[1]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcall.call(listeners, this, arguments[1], arguments[2]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tl = arguments.length;\n\t\t\targs = new Array(l - 1);\n\t\t\tfor (i = 1; i < l; ++i) {\n\t\t\t\targs[i - 1] = arguments[i];\n\t\t\t}\n\t\t\tapply.call(listeners, this, args);\n\t\t}\n\t}\n};\n\nmethods = {\n\ton: on,\n\tonce: once,\n\toff: off,\n\temit: emit\n};\n\ndescriptors = {\n\ton: d(on),\n\tonce: d(once),\n\toff: d(off),\n\temit: d(emit)\n};\n\nbase = defineProperties({}, descriptors);\n\nmodule.exports = exports = function (o) {\n\treturn (o == null) ? create(base) : defineProperties(Object(o), descriptors);\n};\nexports.methods = methods;\n","/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (typeof define === 'function' && define.amd) {\n    define(function() {\n        return Hammer;\n    });\n} else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n} else {\n    window[exportName] = Hammer;\n}\n\n})(window, document, 'Hammer');\n","\"use strict\";\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar strength_1 = require(\"./strength\");\n/**\n * An enum defining the linear constraint operators.\n */\nvar Operator;\n(function (Operator) {\n    Operator[Operator[\"Le\"] = 0] = \"Le\";\n    Operator[Operator[\"Ge\"] = 1] = \"Ge\";\n    Operator[Operator[\"Eq\"] = 2] = \"Eq\"; // ==\n})(Operator = exports.Operator || (exports.Operator = {}));\n/**\n * A linear constraint equation.\n *\n * A constraint equation is composed of an expression, an operator,\n * and a strength. The RHS of the equation is implicitly zero.\n *\n * @class\n */\nvar Constraint = (function () {\n    /**\n     * Construct a new Constraint.\n     *\n     * @param expression The constraint expression.\n     * @param operator The equation operator.\n     * @param strength The strength of the constraint.\n     */\n    function Constraint(expression, operator, strength) {\n        if (strength === void 0) { strength = strength_1.Strength.required; }\n        this._id = CnId++;\n        this._operator = operator;\n        this._expression = expression;\n        this._strength = strength_1.Strength.clip(strength);\n    }\n    /**\n     * A static constraint comparison function.\n     */\n    Constraint.Compare = function (a, b) {\n        return a.id - b.id;\n    };\n    Object.defineProperty(Constraint.prototype, \"id\", {\n        /**\n         * Returns the unique id number of the constraint.\n         */\n        get: function () {\n            return this._id;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Constraint.prototype, \"expression\", {\n        /**\n         * Returns the expression of the constraint.\n         */\n        get: function () {\n            return this._expression;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Constraint.prototype, \"op\", {\n        /**\n         * Returns the relational operator of the constraint.\n         */\n        get: function () {\n            return this._operator;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Constraint.prototype, \"strength\", {\n        /**\n         * Returns the strength of the constraint.\n         */\n        get: function () {\n            return this._strength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Constraint;\n}());\nexports.Constraint = Constraint;\n/**\n * The internal constraint id counter.\n */\nvar CnId = 0;\n","\"use strict\";\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsu_1 = require(\"./tsu\");\nvar variable_1 = require(\"./variable\");\nvar maptype_1 = require(\"./maptype\");\n/**\n * An expression of variable terms and a constant.\n *\n * @class\n */\nvar Expression = (function () {\n    function Expression() {\n        var parsed = parseArgs(arguments);\n        this._terms = parsed.terms;\n        this._constant = parsed.constant;\n    }\n    Object.defineProperty(Expression.prototype, \"terms\", {\n        /**\n         * Returns the mapping of terms in the expression.\n         *\n         * This *must* be treated as const.\n         */\n        get: function () {\n            return this._terms;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Expression.prototype, \"constant\", {\n        /**\n         * Returns the constant of the expression.\n         */\n        get: function () {\n            return this._constant;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Expression.prototype, \"value\", {\n        /**\n         * Returns the computed value of the expression.\n         */\n        get: function () {\n            var result = this._constant;\n            tsu_1.forEach(this._terms, function (pair) {\n                result += pair.first.value * pair.second;\n            });\n            return result;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Expression;\n}());\nexports.Expression = Expression;\n/**\n * An internal argument parsing function.\n */\nfunction parseArgs(args) {\n    var constant = 0.0;\n    var factory = function () { return 0.0; };\n    var terms = maptype_1.createMap(variable_1.Variable.Compare);\n    for (var i = 0, n = args.length; i < n; ++i) {\n        var item = args[i];\n        if (typeof item === \"number\") {\n            constant += item;\n        }\n        else if (item instanceof variable_1.Variable) {\n            terms.setDefault(item, factory).second += 1.0;\n        }\n        else if (item instanceof Array) {\n            if (item.length !== 2) {\n                throw new Error(\"array must have length 2\");\n            }\n            var value = item[0];\n            var variable = item[1];\n            if (typeof value !== \"number\") {\n                throw new Error(\"array item 0 must be a number\");\n            }\n            if (!(variable instanceof variable_1.Variable)) {\n                throw new Error(\"array item 1 must be a variable\");\n            }\n            terms.setDefault(variable, factory).second += value;\n        }\n        else {\n            throw new Error(\"invalid Expression argument: \" + JSON.stringify(item));\n        }\n    }\n    return { terms: terms, constant: constant };\n}\n","\"use strict\";\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./variable\"));\n__export(require(\"./expression\"));\n__export(require(\"./constraint\"));\n__export(require(\"./strength\"));\n__export(require(\"./solver\"));\n","\"use strict\";\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsu_1 = require(\"./tsu\");\nfunction createMap(compare) {\n    return new tsu_1.AssociativeArray(compare);\n}\nexports.createMap = createMap;\n","\"use strict\";\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar variable_1 = require(\"./variable\");\nvar expression_1 = require(\"./expression\");\nvar constraint_1 = require(\"./constraint\");\nvar strength_1 = require(\"./strength\");\nvar maptype_1 = require(\"./maptype\");\n/**\n * The constraint solver class.\n *\n * @class\n */\nvar Solver = (function () {\n    /**\n     * Construct a new Solver.\n     */\n    function Solver() {\n        this._cnMap = createCnMap();\n        this._rowMap = createRowMap();\n        this._varMap = createVarMap();\n        this._editMap = createEditMap();\n        this._infeasibleRows = [];\n        this._objective = new Row();\n        this._artificial = null;\n        this._idTick = 0;\n    }\n    /**\n     * Add a constraint to the solver.\n     */\n    Solver.prototype.addConstraint = function (constraint) {\n        var cnPair = this._cnMap.find(constraint);\n        if (cnPair !== undefined) {\n            throw new Error(\"duplicate constraint\");\n        }\n        // Creating a row causes symbols to be reserved for the variables\n        // in the constraint. If this method exits with an exception,\n        // then its possible those variables will linger in the var map.\n        // Since its likely that those variables will be used in other\n        // constraints and since exceptional conditions are uncommon,\n        // i'm not too worried about aggressive cleanup of the var map.\n        var data = this._createRow(constraint);\n        var row = data.row;\n        var tag = data.tag;\n        var subject = this._chooseSubject(row, tag);\n        // If chooseSubject couldnt find a valid entering symbol, one\n        // last option is available if the entire row is composed of\n        // dummy variables. If the constant of the row is zero, then\n        // this represents redundant constraints and the new dummy\n        // marker can enter the basis. If the constant is non-zero,\n        // then it represents an unsatisfiable constraint.\n        if (subject.type() === SymbolType.Invalid && row.allDummies()) {\n            if (!nearZero(row.constant())) {\n                var names = [];\n                for (var _i = 0, _a = constraint.expression.terms._array; _i < _a.length; _i++) {\n                    var item = _a[_i];\n                    names.push(item.first.name);\n                }\n                var op = ['LE', 'GE', 'EQ'][constraint.op];\n                throw new Error(\"unsatisfiable constraint [\" + names.join(\",\") + \"] operator: \" + op);\n            }\n            else {\n                subject = tag.marker;\n            }\n        }\n        // If an entering symbol still isn't found, then the row must\n        // be added using an artificial variable. If that fails, then\n        // the row represents an unsatisfiable constraint.\n        if (subject.type() === SymbolType.Invalid) {\n            if (!this._addWithArtificialVariable(row)) {\n                throw new Error(\"unsatisfiable constraint\");\n            }\n        }\n        else {\n            row.solveFor(subject);\n            this._substitute(subject, row);\n            this._rowMap.insert(subject, row);\n        }\n        this._cnMap.insert(constraint, tag);\n        // Optimizing after each constraint is added performs less\n        // aggregate work due to a smaller average system size. It\n        // also ensures the solver remains in a consistent state.\n        this._optimize(this._objective);\n    };\n    /**\n     * Remove a constraint from the solver.\n     */\n    Solver.prototype.removeConstraint = function (constraint, silent) {\n        if (silent === void 0) { silent = false; }\n        var cnPair = this._cnMap.erase(constraint);\n        if (cnPair === undefined) {\n            if (silent)\n                return;\n            else\n                throw new Error(\"unknown constraint\");\n        }\n        // Remove the error effects from the objective function\n        // *before* pivoting, or substitutions into the objective\n        // will lead to incorrect solver results.\n        this._removeConstraintEffects(constraint, cnPair.second);\n        // If the marker is basic, simply drop the row. Otherwise,\n        // pivot the marker into the basis and then drop the row.\n        var marker = cnPair.second.marker;\n        var rowPair = this._rowMap.erase(marker);\n        if (rowPair === undefined) {\n            var leaving = this._getMarkerLeavingSymbol(marker);\n            if (leaving.type() === SymbolType.Invalid) {\n                throw new Error(\"failed to find leaving row\");\n            }\n            rowPair = this._rowMap.erase(leaving);\n            rowPair.second.solveForEx(leaving, marker);\n            this._substitute(marker, rowPair.second);\n        }\n        // Optimizing after each constraint is removed ensures that the\n        // solver remains consistent. It makes the solver api easier to\n        // use at a small tradeoff for speed.\n        this._optimize(this._objective);\n    };\n    /**\n     * Test whether the solver contains the constraint.\n     */\n    Solver.prototype.hasConstraint = function (constraint) {\n        return this._cnMap.contains(constraint);\n    };\n    /**\n     * Add an edit variable to the solver.\n     */\n    Solver.prototype.addEditVariable = function (variable, strength) {\n        var editPair = this._editMap.find(variable);\n        if (editPair !== undefined) {\n            throw new Error(\"duplicate edit variable: \" + variable.name);\n        }\n        strength = strength_1.Strength.clip(strength);\n        if (strength === strength_1.Strength.required) {\n            throw new Error(\"bad required strength\");\n        }\n        var expr = new expression_1.Expression(variable);\n        var cn = new constraint_1.Constraint(expr, constraint_1.Operator.Eq, strength);\n        this.addConstraint(cn);\n        var tag = this._cnMap.find(cn).second;\n        var info = { tag: tag, constraint: cn, constant: 0.0 };\n        this._editMap.insert(variable, info);\n    };\n    /**\n     * Remove an edit variable from the solver.\n     */\n    Solver.prototype.removeEditVariable = function (variable, silent) {\n        if (silent === void 0) { silent = false; }\n        var editPair = this._editMap.erase(variable);\n        if (editPair === undefined) {\n            if (silent)\n                return;\n            else\n                throw new Error(\"unknown edit variable: \" + variable.name);\n        }\n        this.removeConstraint(editPair.second.constraint, silent);\n    };\n    /**\n     * Test whether the solver contains the edit variable.\n     */\n    Solver.prototype.hasEditVariable = function (variable) {\n        return this._editMap.contains(variable);\n    };\n    /**\n     * Suggest the value of an edit variable.\n     */\n    Solver.prototype.suggestValue = function (variable, value) {\n        var editPair = this._editMap.find(variable);\n        if (editPair === undefined) {\n            throw new Error(\"unknown edit variable: \" + variable.name);\n        }\n        var rows = this._rowMap;\n        var info = editPair.second;\n        var delta = value - info.constant;\n        info.constant = value;\n        // Check first if the positive error variable is basic.\n        var marker = info.tag.marker;\n        var rowPair = rows.find(marker);\n        if (rowPair !== undefined) {\n            if (rowPair.second.add(-delta) < 0.0) {\n                this._infeasibleRows.push(marker);\n            }\n            this._dualOptimize();\n            return;\n        }\n        // Check next if the negative error variable is basic.\n        var other = info.tag.other;\n        rowPair = rows.find(other);\n        if (rowPair !== undefined) {\n            if (rowPair.second.add(delta) < 0.0) {\n                this._infeasibleRows.push(other);\n            }\n            this._dualOptimize();\n            return;\n        }\n        // Otherwise update each row where the error variables exist.\n        for (var i = 0, n = rows.size(); i < n; ++i) {\n            var rowPair_1 = rows.itemAt(i);\n            var row = rowPair_1.second;\n            var coeff = row.coefficientFor(marker);\n            if (coeff !== 0.0 && row.add(delta * coeff) < 0.0 &&\n                rowPair_1.first.type() !== SymbolType.External) {\n                this._infeasibleRows.push(rowPair_1.first);\n            }\n        }\n        this._dualOptimize();\n    };\n    /**\n     * Update the values of the variables.\n     */\n    Solver.prototype.updateVariables = function () {\n        var vars = this._varMap;\n        var rows = this._rowMap;\n        for (var i = 0, n = vars.size(); i < n; ++i) {\n            var pair = vars.itemAt(i);\n            var rowPair = rows.find(pair.second);\n            if (rowPair !== undefined) {\n                pair.first.setValue(rowPair.second.constant());\n            }\n            else {\n                pair.first.setValue(0.0);\n            }\n        }\n    };\n    Object.defineProperty(Solver.prototype, \"numConstraints\", {\n        get: function () {\n            return this._cnMap.size();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Solver.prototype, \"numEditVariables\", {\n        get: function () {\n            return this._editMap.size();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get the symbol for the given variable.\n     *\n     * If a symbol does not exist for the variable, one will be created.\n     */\n    Solver.prototype._getVarSymbol = function (variable) {\n        var _this = this;\n        var factory = function () { return _this._makeSymbol(SymbolType.External); };\n        return this._varMap.setDefault(variable, factory).second;\n    };\n    /**\n     * Create a new Row object for the given constraint.\n     *\n     * The terms in the constraint will be converted to cells in the row.\n     * Any term in the constraint with a coefficient of zero is ignored.\n     * This method uses the `_getVarSymbol` method to get the symbol for\n     * the variables added to the row. If the symbol for a given cell\n     * variable is basic, the cell variable will be substituted with the\n     * basic row.\n     *\n     * The necessary slack and error variables will be added to the row.\n     * If the constant for the row is negative, the sign for the row\n     * will be inverted so the constant becomes positive.\n     *\n     * Returns the created Row and the tag for tracking the constraint.\n     */\n    Solver.prototype._createRow = function (constraint) {\n        var expr = constraint.expression;\n        var row = new Row(expr.constant);\n        // Substitute the current basic variables into the row.\n        var terms = expr.terms;\n        for (var i = 0, n = terms.size(); i < n; ++i) {\n            var termPair = terms.itemAt(i);\n            if (!nearZero(termPair.second)) {\n                var symbol = this._getVarSymbol(termPair.first);\n                var basicPair = this._rowMap.find(symbol);\n                if (basicPair !== undefined) {\n                    row.insertRow(basicPair.second, termPair.second);\n                }\n                else {\n                    row.insertSymbol(symbol, termPair.second);\n                }\n            }\n        }\n        // Add the necessary slack, error, and dummy variables.\n        var objective = this._objective;\n        var strength = constraint.strength;\n        var tag = { marker: INVALID_SYMBOL, other: INVALID_SYMBOL };\n        switch (constraint.op) {\n            case constraint_1.Operator.Le:\n            case constraint_1.Operator.Ge:\n                {\n                    var coeff = constraint.op === constraint_1.Operator.Le ? 1.0 : -1.0;\n                    var slack = this._makeSymbol(SymbolType.Slack);\n                    tag.marker = slack;\n                    row.insertSymbol(slack, coeff);\n                    if (strength < strength_1.Strength.required) {\n                        var error = this._makeSymbol(SymbolType.Error);\n                        tag.other = error;\n                        row.insertSymbol(error, -coeff);\n                        objective.insertSymbol(error, strength);\n                    }\n                    break;\n                }\n            case constraint_1.Operator.Eq:\n                {\n                    if (strength < strength_1.Strength.required) {\n                        var errplus = this._makeSymbol(SymbolType.Error);\n                        var errminus = this._makeSymbol(SymbolType.Error);\n                        tag.marker = errplus;\n                        tag.other = errminus;\n                        row.insertSymbol(errplus, -1.0); // v = eplus - eminus\n                        row.insertSymbol(errminus, 1.0); // v - eplus + eminus = 0\n                        objective.insertSymbol(errplus, strength);\n                        objective.insertSymbol(errminus, strength);\n                    }\n                    else {\n                        var dummy = this._makeSymbol(SymbolType.Dummy);\n                        tag.marker = dummy;\n                        row.insertSymbol(dummy);\n                    }\n                    break;\n                }\n        }\n        // Ensure the row has a positive constant.\n        if (row.constant() < 0.0) {\n            row.reverseSign();\n        }\n        return { row: row, tag: tag };\n    };\n    /**\n     * Choose the subject for solving for the row.\n     *\n     * This method will choose the best subject for using as the solve\n     * target for the row. An invalid symbol will be returned if there\n     * is no valid target.\n     *\n     * The symbols are chosen according to the following precedence:\n     *\n     * 1) The first symbol representing an external variable.\n     * 2) A negative slack or error tag variable.\n     *\n     * If a subject cannot be found, an invalid symbol will be returned.\n     */\n    Solver.prototype._chooseSubject = function (row, tag) {\n        var cells = row.cells();\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            if (pair.first.type() === SymbolType.External) {\n                return pair.first;\n            }\n        }\n        var type = tag.marker.type();\n        if (type === SymbolType.Slack || type === SymbolType.Error) {\n            if (row.coefficientFor(tag.marker) < 0.0) {\n                return tag.marker;\n            }\n        }\n        type = tag.other.type();\n        if (type === SymbolType.Slack || type === SymbolType.Error) {\n            if (row.coefficientFor(tag.other) < 0.0) {\n                return tag.other;\n            }\n        }\n        return INVALID_SYMBOL;\n    };\n    /**\n     * Add the row to the tableau using an artificial variable.\n     *\n     * This will return false if the constraint cannot be satisfied.\n     */\n    Solver.prototype._addWithArtificialVariable = function (row) {\n        // Create and add the artificial variable to the tableau.\n        var art = this._makeSymbol(SymbolType.Slack);\n        this._rowMap.insert(art, row.copy());\n        this._artificial = row.copy();\n        // Optimize the artificial objective. This is successful\n        // only if the artificial objective is optimized to zero.\n        this._optimize(this._artificial);\n        var success = nearZero(this._artificial.constant());\n        this._artificial = null;\n        // If the artificial variable is basic, pivot the row so that\n        // it becomes non-basic. If the row is constant, exit early.\n        var pair = this._rowMap.erase(art);\n        if (pair !== undefined) {\n            var basicRow = pair.second;\n            if (basicRow.isConstant()) {\n                return success;\n            }\n            var entering = this._anyPivotableSymbol(basicRow);\n            if (entering.type() === SymbolType.Invalid) {\n                return false; // unsatisfiable (will this ever happen?)\n            }\n            basicRow.solveForEx(art, entering);\n            this._substitute(entering, basicRow);\n            this._rowMap.insert(entering, basicRow);\n        }\n        // Remove the artificial variable from the tableau.\n        var rows = this._rowMap;\n        for (var i = 0, n = rows.size(); i < n; ++i) {\n            rows.itemAt(i).second.removeSymbol(art);\n        }\n        this._objective.removeSymbol(art);\n        return success;\n    };\n    /**\n     * Substitute the parametric symbol with the given row.\n     *\n     * This method will substitute all instances of the parametric symbol\n     * in the tableau and the objective function with the given row.\n     */\n    Solver.prototype._substitute = function (symbol, row) {\n        var rows = this._rowMap;\n        for (var i = 0, n = rows.size(); i < n; ++i) {\n            var pair = rows.itemAt(i);\n            pair.second.substitute(symbol, row);\n            if (pair.second.constant() < 0.0 &&\n                pair.first.type() !== SymbolType.External) {\n                this._infeasibleRows.push(pair.first);\n            }\n        }\n        this._objective.substitute(symbol, row);\n        if (this._artificial) {\n            this._artificial.substitute(symbol, row);\n        }\n    };\n    /**\n     * Optimize the system for the given objective function.\n     *\n     * This method performs iterations of Phase 2 of the simplex method\n     * until the objective function reaches a minimum.\n     */\n    Solver.prototype._optimize = function (objective) {\n        while (true) {\n            var entering = this._getEnteringSymbol(objective);\n            if (entering.type() === SymbolType.Invalid) {\n                return;\n            }\n            var leaving = this._getLeavingSymbol(entering);\n            if (leaving.type() === SymbolType.Invalid) {\n                throw new Error(\"the objective is unbounded\");\n            }\n            // pivot the entering symbol into the basis\n            var row = this._rowMap.erase(leaving).second;\n            row.solveForEx(leaving, entering);\n            this._substitute(entering, row);\n            this._rowMap.insert(entering, row);\n        }\n    };\n    /**\n     * Optimize the system using the dual of the simplex method.\n     *\n     * The current state of the system should be such that the objective\n     * function is optimal, but not feasible. This method will perform\n     * an iteration of the dual simplex method to make the solution both\n     * optimal and feasible.\n     */\n    Solver.prototype._dualOptimize = function () {\n        var rows = this._rowMap;\n        var infeasible = this._infeasibleRows;\n        while (infeasible.length !== 0) {\n            var leaving = infeasible.pop();\n            var pair = rows.find(leaving);\n            if (pair !== undefined && pair.second.constant() < 0.0) {\n                var entering = this._getDualEnteringSymbol(pair.second);\n                if (entering.type() === SymbolType.Invalid) {\n                    throw new Error(\"dual optimize failed\");\n                }\n                // pivot the entering symbol into the basis\n                var row = pair.second;\n                rows.erase(leaving);\n                row.solveForEx(leaving, entering);\n                this._substitute(entering, row);\n                rows.insert(entering, row);\n            }\n        }\n    };\n    /**\n     * Compute the entering variable for a pivot operation.\n     *\n     * This method will return first symbol in the objective function which\n     * is non-dummy and has a coefficient less than zero. If no symbol meets\n     * the criteria, it means the objective function is at a minimum, and an\n     * invalid symbol is returned.\n     */\n    Solver.prototype._getEnteringSymbol = function (objective) {\n        var cells = objective.cells();\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            var symbol = pair.first;\n            if (pair.second < 0.0 && symbol.type() !== SymbolType.Dummy) {\n                return symbol;\n            }\n        }\n        return INVALID_SYMBOL;\n    };\n    /**\n     * Compute the entering symbol for the dual optimize operation.\n     *\n     * This method will return the symbol in the row which has a positive\n     * coefficient and yields the minimum ratio for its respective symbol\n     * in the objective function. The provided row *must* be infeasible.\n     * If no symbol is found which meats the criteria, an invalid symbol\n     * is returned.\n     */\n    Solver.prototype._getDualEnteringSymbol = function (row) {\n        var ratio = Number.MAX_VALUE;\n        var entering = INVALID_SYMBOL;\n        var cells = row.cells();\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            var symbol = pair.first;\n            var c = pair.second;\n            if (c > 0.0 && symbol.type() !== SymbolType.Dummy) {\n                var coeff = this._objective.coefficientFor(symbol);\n                var r = coeff / c;\n                if (r < ratio) {\n                    ratio = r;\n                    entering = symbol;\n                }\n            }\n        }\n        return entering;\n    };\n    /**\n     * Compute the symbol for pivot exit row.\n     *\n     * This method will return the symbol for the exit row in the row\n     * map. If no appropriate exit symbol is found, an invalid symbol\n     * will be returned. This indicates that the objective function is\n     * unbounded.\n     */\n    Solver.prototype._getLeavingSymbol = function (entering) {\n        var ratio = Number.MAX_VALUE;\n        var found = INVALID_SYMBOL;\n        var rows = this._rowMap;\n        for (var i = 0, n = rows.size(); i < n; ++i) {\n            var pair = rows.itemAt(i);\n            var symbol = pair.first;\n            if (symbol.type() !== SymbolType.External) {\n                var row = pair.second;\n                var temp = row.coefficientFor(entering);\n                if (temp < 0.0) {\n                    var temp_ratio = -row.constant() / temp;\n                    if (temp_ratio < ratio) {\n                        ratio = temp_ratio;\n                        found = symbol;\n                    }\n                }\n            }\n        }\n        return found;\n    };\n    /**\n     * Compute the leaving symbol for a marker variable.\n     *\n     * This method will return a symbol corresponding to a basic row\n     * which holds the given marker variable. The row will be chosen\n     * according to the following precedence:\n     *\n     * 1) The row with a restricted basic varible and a negative coefficient\n     *    for the marker with the smallest ratio of -constant / coefficient.\n     *\n     * 2) The row with a restricted basic variable and the smallest ratio\n     *    of constant / coefficient.\n     *\n     * 3) The last unrestricted row which contains the marker.\n     *\n     * If the marker does not exist in any row, an invalid symbol will be\n     * returned. This indicates an internal solver error since the marker\n     * *should* exist somewhere in the tableau.\n     */\n    Solver.prototype._getMarkerLeavingSymbol = function (marker) {\n        var dmax = Number.MAX_VALUE;\n        var r1 = dmax;\n        var r2 = dmax;\n        var invalid = INVALID_SYMBOL;\n        var first = invalid;\n        var second = invalid;\n        var third = invalid;\n        var rows = this._rowMap;\n        for (var i = 0, n = rows.size(); i < n; ++i) {\n            var pair = rows.itemAt(i);\n            var row = pair.second;\n            var c = row.coefficientFor(marker);\n            if (c === 0.0) {\n                continue;\n            }\n            var symbol = pair.first;\n            if (symbol.type() === SymbolType.External) {\n                third = symbol;\n            }\n            else if (c < 0.0) {\n                var r = -row.constant() / c;\n                if (r < r1) {\n                    r1 = r;\n                    first = symbol;\n                }\n            }\n            else {\n                var r = row.constant() / c;\n                if (r < r2) {\n                    r2 = r;\n                    second = symbol;\n                }\n            }\n        }\n        if (first !== invalid) {\n            return first;\n        }\n        if (second !== invalid) {\n            return second;\n        }\n        return third;\n    };\n    /**\n     * Remove the effects of a constraint on the objective function.\n     */\n    Solver.prototype._removeConstraintEffects = function (cn, tag) {\n        if (tag.marker.type() === SymbolType.Error) {\n            this._removeMarkerEffects(tag.marker, cn.strength);\n        }\n        if (tag.other.type() === SymbolType.Error) {\n            this._removeMarkerEffects(tag.other, cn.strength);\n        }\n    };\n    /**\n     * Remove the effects of an error marker on the objective function.\n     */\n    Solver.prototype._removeMarkerEffects = function (marker, strength) {\n        var pair = this._rowMap.find(marker);\n        if (pair !== undefined) {\n            this._objective.insertRow(pair.second, -strength);\n        }\n        else {\n            this._objective.insertSymbol(marker, -strength);\n        }\n    };\n    /**\n     * Get the first Slack or Error symbol in the row.\n     *\n     * If no such symbol is present, an invalid symbol will be returned.\n     */\n    Solver.prototype._anyPivotableSymbol = function (row) {\n        var cells = row.cells();\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            var type = pair.first.type();\n            if (type === SymbolType.Slack || type === SymbolType.Error) {\n                return pair.first;\n            }\n        }\n        return INVALID_SYMBOL;\n    };\n    /**\n     * Returns a new Symbol of the given type.\n     */\n    Solver.prototype._makeSymbol = function (type) {\n        return new Symbol(type, this._idTick++);\n    };\n    return Solver;\n}());\nexports.Solver = Solver;\n/**\n * Test whether a value is approximately zero.\n */\nfunction nearZero(value) {\n    var eps = 1.0e-8;\n    return value < 0.0 ? -value < eps : value < eps;\n}\n/**\n * An internal function for creating a constraint map.\n */\nfunction createCnMap() {\n    return maptype_1.createMap(constraint_1.Constraint.Compare);\n}\n/**\n * An internal function for creating a row map.\n */\nfunction createRowMap() {\n    return maptype_1.createMap(Symbol.Compare);\n}\n/**\n * An internal function for creating a variable map.\n */\nfunction createVarMap() {\n    return maptype_1.createMap(variable_1.Variable.Compare);\n}\n/**\n * An internal function for creating an edit map.\n */\nfunction createEditMap() {\n    return maptype_1.createMap(variable_1.Variable.Compare);\n}\n/**\n * An enum defining the available symbol types.\n */\nvar SymbolType;\n(function (SymbolType) {\n    SymbolType[SymbolType[\"Invalid\"] = 0] = \"Invalid\";\n    SymbolType[SymbolType[\"External\"] = 1] = \"External\";\n    SymbolType[SymbolType[\"Slack\"] = 2] = \"Slack\";\n    SymbolType[SymbolType[\"Error\"] = 3] = \"Error\";\n    SymbolType[SymbolType[\"Dummy\"] = 4] = \"Dummy\";\n})(SymbolType || (SymbolType = {}));\n/**\n * An internal class representing a symbol in the solver.\n */\nvar Symbol = (function () {\n    /**\n     * Construct a new Symbol\n     *\n     * @param [type] The type of the symbol.\n     * @param [id] The unique id number of the symbol.\n     */\n    function Symbol(type, id) {\n        this._id = id;\n        this._type = type;\n    }\n    /**\n     * The static Symbol comparison function.\n     */\n    Symbol.Compare = function (a, b) {\n        return a.id() - b.id();\n    };\n    /**\n     * Returns the unique id number of the symbol.\n     */\n    Symbol.prototype.id = function () {\n        return this._id;\n    };\n    /**\n     * Returns the type of the symbol.\n     */\n    Symbol.prototype.type = function () {\n        return this._type;\n    };\n    return Symbol;\n}());\n/**\n * A static invalid symbol\n */\nvar INVALID_SYMBOL = new Symbol(SymbolType.Invalid, -1);\n/**\n * An internal row class used by the solver.\n */\nvar Row = (function () {\n    /**\n     * Construct a new Row.\n     */\n    function Row(constant) {\n        if (constant === void 0) { constant = 0.0; }\n        this._cellMap = maptype_1.createMap(Symbol.Compare);\n        this._constant = constant;\n    }\n    /**\n     * Returns the mapping of symbols to coefficients.\n     */\n    Row.prototype.cells = function () {\n        return this._cellMap;\n    };\n    /**\n     * Returns the constant for the row.\n     */\n    Row.prototype.constant = function () {\n        return this._constant;\n    };\n    /**\n     * Returns true if the row is a constant value.\n     */\n    Row.prototype.isConstant = function () {\n        return this._cellMap.empty();\n    };\n    /**\n     * Returns true if the Row has all dummy symbols.\n     */\n    Row.prototype.allDummies = function () {\n        var cells = this._cellMap;\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            if (pair.first.type() !== SymbolType.Dummy) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Create a copy of the row.\n     */\n    Row.prototype.copy = function () {\n        var theCopy = new Row(this._constant);\n        theCopy._cellMap = this._cellMap.copy();\n        return theCopy;\n    };\n    /**\n     * Add a constant value to the row constant.\n     *\n     * Returns the new value of the constant.\n     */\n    Row.prototype.add = function (value) {\n        return this._constant += value;\n    };\n    /**\n     * Insert the symbol into the row with the given coefficient.\n     *\n     * If the symbol already exists in the row, the coefficient\n     * will be added to the existing coefficient. If the resulting\n     * coefficient is zero, the symbol will be removed from the row.\n     */\n    Row.prototype.insertSymbol = function (symbol, coefficient) {\n        if (coefficient === void 0) { coefficient = 1.0; }\n        var pair = this._cellMap.setDefault(symbol, function () { return 0.0; });\n        if (nearZero(pair.second += coefficient)) {\n            this._cellMap.erase(symbol);\n        }\n    };\n    /**\n     * Insert a row into this row with a given coefficient.\n     *\n     * The constant and the cells of the other row will be\n     * multiplied by the coefficient and added to this row. Any\n     * cell with a resulting coefficient of zero will be removed\n     * from the row.\n     */\n    Row.prototype.insertRow = function (other, coefficient) {\n        if (coefficient === void 0) { coefficient = 1.0; }\n        this._constant += other._constant * coefficient;\n        var cells = other._cellMap;\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            this.insertSymbol(pair.first, pair.second * coefficient);\n        }\n    };\n    /**\n     * Remove a symbol from the row.\n     */\n    Row.prototype.removeSymbol = function (symbol) {\n        this._cellMap.erase(symbol);\n    };\n    /**\n     * Reverse the sign of the constant and cells in the row.\n     */\n    Row.prototype.reverseSign = function () {\n        this._constant = -this._constant;\n        var cells = this._cellMap;\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            pair.second = -pair.second;\n        }\n    };\n    /**\n     * Solve the row for the given symbol.\n     *\n     * This method assumes the row is of the form\n     * a * x + b * y + c = 0 and (assuming solve for x) will modify\n     * the row to represent the right hand side of\n     * x = -b/a * y - c / a. The target symbol will be removed from\n     * the row, and the constant and other cells will be multiplied\n     * by the negative inverse of the target coefficient.\n     *\n     * The given symbol *must* exist in the row.\n     */\n    Row.prototype.solveFor = function (symbol) {\n        var cells = this._cellMap;\n        var pair = cells.erase(symbol);\n        var coeff = -1.0 / pair.second;\n        this._constant *= coeff;\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            cells.itemAt(i).second *= coeff;\n        }\n    };\n    /**\n     * Solve the row for the given symbols.\n     *\n     * This method assumes the row is of the form\n     * x = b * y + c and will solve the row such that\n     * y = x / b - c / b. The rhs symbol will be removed from the\n     * row, the lhs added, and the result divided by the negative\n     * inverse of the rhs coefficient.\n     *\n     * The lhs symbol *must not* exist in the row, and the rhs\n     * symbol must* exist in the row.\n     */\n    Row.prototype.solveForEx = function (lhs, rhs) {\n        this.insertSymbol(lhs, -1.0);\n        this.solveFor(rhs);\n    };\n    /**\n     * Returns the coefficient for the given symbol.\n     */\n    Row.prototype.coefficientFor = function (symbol) {\n        var pair = this._cellMap.find(symbol);\n        return pair !== undefined ? pair.second : 0.0;\n    };\n    /**\n     * Substitute a symbol with the data from another row.\n     *\n     * Given a row of the form a * x + b and a substitution of the\n     * form x = 3 * y + c the row will be updated to reflect the\n     * expression 3 * a * y + a * c + b.\n     *\n     * If the symbol does not exist in the row, this is a no-op.\n     */\n    Row.prototype.substitute = function (symbol, row) {\n        var pair = this._cellMap.erase(symbol);\n        if (pair !== undefined) {\n            this.insertRow(row, pair.second);\n        }\n    };\n    return Row;\n}());\n","\"use strict\";\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Strength;\n(function (Strength) {\n    /**\n     * Create a new symbolic strength.\n     */\n    function create(a, b, c, w) {\n        if (w === void 0) { w = 1.0; }\n        var result = 0.0;\n        result += Math.max(0.0, Math.min(1000.0, a * w)) * 1000000.0;\n        result += Math.max(0.0, Math.min(1000.0, b * w)) * 1000.0;\n        result += Math.max(0.0, Math.min(1000.0, c * w));\n        return result;\n    }\n    Strength.create = create;\n    /**\n     * The 'required' symbolic strength.\n     */\n    Strength.required = create(1000.0, 1000.0, 1000.0);\n    /**\n     * The 'strong' symbolic strength.\n     */\n    Strength.strong = create(1.0, 0.0, 0.0);\n    /**\n     * The 'medium' symbolic strength.\n     */\n    Strength.medium = create(0.0, 1.0, 0.0);\n    /**\n     * The 'weak' symbolic strength.\n     */\n    Strength.weak = create(0.0, 0.0, 1.0);\n    /**\n     * Clip a symbolic strength to the allowed min and max.\n     */\n    function clip(value) {\n        return Math.max(0.0, Math.min(Strength.required, value));\n    }\n    Strength.clip = clip;\n})(Strength = exports.Strength || (exports.Strength = {}));\n","\"use strict\";\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar iterator_1 = require(\"./iterator\");\n/**\n* Perform a lower bound search on a sorted array.\n*\n* @param array The array of sorted items to search.\n* @param value The value to located in the array.\n* @param compare The value comparison function.\n* @returns The index of the first element in the array which\n*          compares greater than or equal to the given value.\n*/\nfunction lowerBound(array, value, compare) {\n    var begin = 0;\n    var n = array.length;\n    var half;\n    var middle;\n    while (n > 0) {\n        half = n >> 1;\n        middle = begin + half;\n        if (compare(array[middle], value) < 0) {\n            begin = middle + 1;\n            n -= half + 1;\n        }\n        else {\n            n = half;\n        }\n    }\n    return begin;\n}\nexports.lowerBound = lowerBound;\n/**\n* Perform a binary search on a sorted array.\n*\n* @param array The array of sorted items to search.\n* @param value The value to located in the array.\n* @param compare The value comparison function.\n* @returns The index of the found item, or -1.\n*/\nfunction binarySearch(array, value, compare) {\n    var index = lowerBound(array, value, compare);\n    if (index === array.length) {\n        return -1;\n    }\n    var item = array[index];\n    if (compare(item, value) !== 0) {\n        return -1;\n    }\n    return index;\n}\nexports.binarySearch = binarySearch;\n/**\n* Perform a binary find on a sorted array.\n*\n* @param array The array of sorted items to search.\n* @param value The value to located in the array.\n* @param compare The value comparison function.\n* @returns The found item in the array, or undefined.\n*/\nfunction binaryFind(array, value, compare) {\n    var index = lowerBound(array, value, compare);\n    if (index === array.length) {\n        return undefined;\n    }\n    var item = array[index];\n    if (compare(item, value) !== 0) {\n        return undefined;\n    }\n    return item;\n}\nexports.binaryFind = binaryFind;\nfunction asSet(items, compare) {\n    var array = iterator_1.asArray(items);\n    var n = array.length;\n    if (n <= 1) {\n        return array;\n    }\n    array.sort(compare);\n    var result = [array[0]];\n    for (var i = 1, j = 0; i < n; ++i) {\n        var item = array[i];\n        if (compare(result[j], item) !== 0) {\n            result.push(item);\n            ++j;\n        }\n    }\n    return result;\n}\nexports.asSet = asSet;\n/**\n* Test whether a two sorted arrays sets are disjoint.\n*\n* @param first The first sorted array set.\n* @param second The second sorted array set.\n* @param compare The value comparison function.\n* @returns true if the sets are disjoint, false otherwise.\n*/\nfunction setIsDisjoint(first, second, compare) {\n    var i = 0, j = 0;\n    var len1 = first.length;\n    var len2 = second.length;\n    while (i < len1 && j < len2) {\n        var v = compare(first[i], second[j]);\n        if (v < 0) {\n            ++i;\n        }\n        else if (v > 0) {\n            ++j;\n        }\n        else {\n            return false;\n        }\n    }\n    return true;\n}\nexports.setIsDisjoint = setIsDisjoint;\n/**\n* Test whether one sorted array set is the subset of another.\n*\n* @param first The potential subset.\n* @param second The potential superset.\n* @param compare The value comparison function.\n* @returns true if the first set is a subset of the second.\n*/\nfunction setIsSubset(first, second, compare) {\n    var len1 = first.length;\n    var len2 = second.length;\n    if (len1 > len2) {\n        return false;\n    }\n    var i = 0, j = 0;\n    while (i < len1 && j < len2) {\n        var v = compare(first[i], second[j]);\n        if (v < 0) {\n            return false;\n        }\n        else if (v > 0) {\n            ++j;\n        }\n        else {\n            ++i;\n            ++j;\n        }\n    }\n    if (i < len1) {\n        return false;\n    }\n    return true;\n}\nexports.setIsSubset = setIsSubset;\n/**\n* Create the set union of two sorted set arrays.\nvar j = 0;\n*\n* @param first The first sorted array set.\n* @param second The second sorted array set.\n* @param compare The value comparison function.\n* @returns The set union of the two arrays.\n*/\nfunction setUnion(first, second, compare) {\n    var i = 0, j = 0;\n    var len1 = first.length;\n    var len2 = second.length;\n    var merged = [];\n    while (i < len1 && j < len2) {\n        var a = first[i];\n        var b = second[j];\n        var v = compare(a, b);\n        if (v < 0) {\n            merged.push(a);\n            ++i;\n        }\n        else if (v > 0) {\n            merged.push(b);\n            ++j;\n        }\n        else {\n            merged.push(a);\n            ++i;\n            ++j;\n        }\n    }\n    while (i < len1) {\n        merged.push(first[i]);\n        ++i;\n    }\n    while (j < len2) {\n        merged.push(second[j]);\n        ++j;\n    }\n    return merged;\n}\nexports.setUnion = setUnion;\n/**\n* Create a set intersection of two sorted set arrays.\n*\n* @param first The first sorted array set.\n* @param second The second sorted array set.\n* @param compare The value comparison function.\n* @returns The set intersection of the two arrays.\n*/\nfunction setIntersection(first, second, compare) {\n    var i = 0, j = 0;\n    var len1 = first.length;\n    var len2 = second.length;\n    var merged = [];\n    while (i < len1 && j < len2) {\n        var a = first[i];\n        var b = second[j];\n        var v = compare(a, b);\n        if (v < 0) {\n            ++i;\n        }\n        else if (v > 0) {\n            ++j;\n        }\n        else {\n            merged.push(a);\n            ++i;\n            ++j;\n        }\n    }\n    return merged;\n}\nexports.setIntersection = setIntersection;\n/**\n* Create a set difference of two sorted set arrays.\n*\n* @param first The first sorted array set.\n* @param second The second sorted array set.\n* @param compare The value comparison function.\n* @returns The set difference of the two arrays.\n*/\nfunction setDifference(first, second, compare) {\n    var i = 0, j = 0;\n    var len1 = first.length;\n    var len2 = second.length;\n    var merged = [];\n    while (i < len1 && j < len2) {\n        var a = first[i];\n        var b = second[j];\n        var v = compare(a, b);\n        if (v < 0) {\n            merged.push(a);\n            ++i;\n        }\n        else if (v > 0) {\n            ++j;\n        }\n        else {\n            ++i;\n            ++j;\n        }\n    }\n    while (i < len1) {\n        merged.push(first[i]);\n        ++i;\n    }\n    return merged;\n}\nexports.setDifference = setDifference;\n/**\n* Create a set symmetric difference of two sorted set arrays.\n*\n* @param first The first sorted array set.\n* @param second The second sorted array set.\n* @param compare The value comparison function.\n* @returns The set symmetric difference of the two arrays.\n*/\nfunction setSymmetricDifference(first, second, compare) {\n    var i = 0, j = 0;\n    var len1 = first.length;\n    var len2 = second.length;\n    var merged = [];\n    while (i < len1 && j < len2) {\n        var a = first[i];\n        var b = second[j];\n        var v = compare(a, b);\n        if (v < 0) {\n            merged.push(a);\n            ++i;\n        }\n        else if (v > 0) {\n            merged.push(b);\n            ++j;\n        }\n        else {\n            ++i;\n            ++j;\n        }\n    }\n    while (i < len1) {\n        merged.push(first[i]);\n        ++i;\n    }\n    while (j < len2) {\n        merged.push(second[j]);\n        ++j;\n    }\n    return merged;\n}\nexports.setSymmetricDifference = setSymmetricDifference;\n","\"use strict\";\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar iterator_1 = require(\"./iterator\");\n/**\n* A base class for implementing array-based data structures.\n*\n* @class\n*/\nvar ArrayBase = (function () {\n    function ArrayBase() {\n        /*\n        * The internal data array.\n        *\n        * @protected\n        */\n        this._array = [];\n    }\n    /**\n    * Returns the number of items in the array.\n    */\n    ArrayBase.prototype.size = function () {\n        return this._array.length;\n    };\n    /**\n    * Returns true if the array is empty.\n    */\n    ArrayBase.prototype.empty = function () {\n        return this._array.length === 0;\n    };\n    /**\n    * Returns the item at the given array index.\n    *\n    * @param index The integer index of the desired item.\n    */\n    ArrayBase.prototype.itemAt = function (index) {\n        return this._array[index];\n    };\n    /**\n    * Removes and returns the item at the given index.\n    *\n    * @param index The integer index of the desired item.\n    */\n    ArrayBase.prototype.takeAt = function (index) {\n        return this._array.splice(index, 1)[0];\n    };\n    /**\n    * Clear the internal contents of array.\n    */\n    ArrayBase.prototype.clear = function () {\n        this._array = [];\n    };\n    /**\n    * Swap this array's contents with another array.\n    *\n    * @param other The array base to use for the swap.\n    */\n    ArrayBase.prototype.swap = function (other) {\n        var array = this._array;\n        this._array = other._array;\n        other._array = array;\n    };\n    /**\n    * Returns an iterator over the array of items.\n    */\n    ArrayBase.prototype.__iter__ = function () {\n        return iterator_1.iter(this._array);\n    };\n    /**\n    * Returns a reverse iterator over the array of items.\n    */\n    ArrayBase.prototype.__reversed__ = function () {\n        return iterator_1.reversed(this._array);\n    };\n    return ArrayBase;\n}());\nexports.ArrayBase = ArrayBase;\n","\"use strict\";\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pair_1 = require(\"./pair\");\nvar array_base_1 = require(\"./array_base\");\nvar algorithm_1 = require(\"./algorithm\");\nvar iterator_1 = require(\"./iterator\");\n/**\n* A mapping container build on a sorted array.\n*\n* @class\n*/\nvar AssociativeArray = (function (_super) {\n    __extends(AssociativeArray, _super);\n    /**\n    * Construct a new AssociativeArray.\n    *\n    * @param compare The key comparison function.\n    */\n    function AssociativeArray(compare) {\n        var _this = _super.call(this) || this;\n        _this._compare = compare;\n        _this._wrapped = wrapCompare(compare);\n        return _this;\n    }\n    /**\n    * Returns the key comparison function used by this array.\n    */\n    AssociativeArray.prototype.comparitor = function () {\n        return this._compare;\n    };\n    /**\n    * Return the array index of the given key, or -1.\n    *\n    * @param key The key to locate in the array.\n    */\n    AssociativeArray.prototype.indexOf = function (key) {\n        return algorithm_1.binarySearch(this._array, key, this._wrapped);\n    };\n    /**\n    * Returns true if the key is in the array, false otherwise.\n    *\n    * @param key The key to locate in the array.\n    */\n    AssociativeArray.prototype.contains = function (key) {\n        return algorithm_1.binarySearch(this._array, key, this._wrapped) >= 0;\n    };\n    /**\n    * Returns the pair associated with the given key, or undefined.\n    *\n    * @param key The key to locate in the array.\n    */\n    AssociativeArray.prototype.find = function (key) {\n        return algorithm_1.binaryFind(this._array, key, this._wrapped);\n    };\n    /**\n    * Returns the pair associated with the key if it exists.\n    *\n    * If the key does not exist, a new pair will be created and\n    * inserted using the value created by the given factory.\n    *\n    * @param key The key to locate in the array.\n    * @param factory The function which creates the default value.\n    */\n    AssociativeArray.prototype.setDefault = function (key, factory) {\n        var array = this._array;\n        var index = algorithm_1.lowerBound(array, key, this._wrapped);\n        if (index === array.length) {\n            var pair = new pair_1.Pair(key, factory());\n            array.push(pair);\n            return pair;\n        }\n        var currPair = array[index];\n        if (this._compare(currPair.first, key) !== 0) {\n            var pair = new pair_1.Pair(key, factory());\n            array.splice(index, 0, pair);\n            return pair;\n        }\n        return currPair;\n    };\n    /**\n    * Insert the pair into the array and return the pair.\n    *\n    * This will overwrite any existing entry in the array.\n    *\n    * @param key The key portion of the pair.\n    * @param value The value portion of the pair.\n    */\n    AssociativeArray.prototype.insert = function (key, value) {\n        var array = this._array;\n        var index = algorithm_1.lowerBound(array, key, this._wrapped);\n        if (index === array.length) {\n            var pair = new pair_1.Pair(key, value);\n            array.push(pair);\n            return pair;\n        }\n        var currPair = array[index];\n        if (this._compare(currPair.first, key) !== 0) {\n            var pair = new pair_1.Pair(key, value);\n            array.splice(index, 0, pair);\n            return pair;\n        }\n        currPair.second = value;\n        return currPair;\n    };\n    AssociativeArray.prototype.update = function (object) {\n        var _this = this;\n        if (object instanceof AssociativeArray) {\n            this._array = merge(this._array, object._array, this._compare);\n        }\n        else {\n            iterator_1.forEach(object, function (pair) {\n                _this.insert(pair.first, pair.second);\n            });\n        }\n    };\n    /**\n    * Removes and returns the pair for the given key, or undefined.\n    *\n    * @param key The key to remove from the map.\n    */\n    AssociativeArray.prototype.erase = function (key) {\n        var array = this._array;\n        var index = algorithm_1.binarySearch(array, key, this._wrapped);\n        if (index < 0) {\n            return undefined;\n        }\n        return array.splice(index, 1)[0];\n    };\n    /**\n    * Create a copy of this associative array.\n    */\n    AssociativeArray.prototype.copy = function () {\n        var theCopy = new AssociativeArray(this._compare);\n        var copyArray = theCopy._array;\n        var thisArray = this._array;\n        for (var i = 0, n = thisArray.length; i < n; ++i) {\n            copyArray.push(thisArray[i].copy());\n        }\n        return theCopy;\n    };\n    return AssociativeArray;\n}(array_base_1.ArrayBase));\nexports.AssociativeArray = AssociativeArray;\n/**\n* An internal which wraps a comparison key function.\n*/\nfunction wrapCompare(cmp) {\n    return function (pair, value) {\n        return cmp(pair.first, value);\n    };\n}\n/**\n* An internal function which merges two ordered pair arrays.\n*/\nfunction merge(first, second, compare) {\n    var i = 0, j = 0;\n    var len1 = first.length;\n    var len2 = second.length;\n    var merged = [];\n    while (i < len1 && j < len2) {\n        var a = first[i];\n        var b = second[j];\n        var v = compare(a.first, b.first);\n        if (v < 0) {\n            merged.push(a.copy());\n            ++i;\n        }\n        else if (v > 0) {\n            merged.push(b.copy());\n            ++j;\n        }\n        else {\n            merged.push(b.copy());\n            ++i;\n            ++j;\n        }\n    }\n    while (i < len1) {\n        merged.push(first[i].copy());\n        ++i;\n    }\n    while (j < len2) {\n        merged.push(second[j].copy());\n        ++j;\n    }\n    return merged;\n}\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./algorithm\"));\n__export(require(\"./array_base\"));\n__export(require(\"./associative_array\"));\n__export(require(\"./iterator\"));\n__export(require(\"./pair\"));\n","\"use strict\";\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n* An iterator for an array of items.\n*/\nvar ArrayIterator = (function () {\n    /*\n    * Construct a new ArrayIterator.\n    *\n    * @param array The array of items to iterate.\n    * @param [index] The index at which to start iteration.\n    */\n    function ArrayIterator(array, index) {\n        if (typeof index === \"undefined\") {\n            index = 0;\n        }\n        this._array = array;\n        this._index = Math.max(0, Math.min(index, array.length));\n    }\n    /**\n    * Returns the next item from the iterator or undefined.\n    */\n    ArrayIterator.prototype.__next__ = function () {\n        return this._array[this._index++];\n    };\n    /**\n    * Returns this same iterator.\n    */\n    ArrayIterator.prototype.__iter__ = function () {\n        return this;\n    };\n    return ArrayIterator;\n}());\nexports.ArrayIterator = ArrayIterator;\n/**\n* A reverse iterator for an array of items.\n*/\nvar ReverseArrayIterator = (function () {\n    /**\n    * Construct a new ReverseArrayIterator.\n    *\n    * @param array The array of items to iterate.\n    * @param [index] The index at which to start iteration.\n    */\n    function ReverseArrayIterator(array, index) {\n        if (typeof index === \"undefined\") {\n            index = array.length;\n        }\n        this._array = array;\n        this._index = Math.max(0, Math.min(index, array.length));\n    }\n    /**\n    * Returns the next item from the iterator or undefined.\n    */\n    ReverseArrayIterator.prototype.__next__ = function () {\n        return this._array[--this._index];\n    };\n    /**\n    * Returns this same iterator.\n    */\n    ReverseArrayIterator.prototype.__iter__ = function () {\n        return this;\n    };\n    return ReverseArrayIterator;\n}());\nexports.ReverseArrayIterator = ReverseArrayIterator;\nfunction iter(object) {\n    if (object instanceof Array) {\n        return new ArrayIterator(object);\n    }\n    return object.__iter__();\n}\nexports.iter = iter;\nfunction reversed(object) {\n    if (object instanceof Array) {\n        return new ReverseArrayIterator(object);\n    }\n    return object.__reversed__();\n}\nexports.reversed = reversed;\n/**\n* Returns the next value from an iterator, or undefined.\n*/\nfunction next(iterator) {\n    return iterator.__next__();\n}\nexports.next = next;\nfunction asArray(object) {\n    if (object instanceof Array) {\n        return object.slice();\n    }\n    var value;\n    var array = [];\n    var it = object.__iter__();\n    while ((value = it.__next__()) !== undefined) {\n        array.push(value);\n    }\n    return array;\n}\nexports.asArray = asArray;\nfunction forEach(object, callback) {\n    if (object instanceof Array) {\n        for (var i = 0, n = object.length; i < n; ++i) {\n            if (callback(object[i]) === false) {\n                return;\n            }\n        }\n    }\n    else {\n        var value;\n        var it = object.__iter__();\n        while ((value = it.__next__()) !== undefined) {\n            if (callback(value) === false) {\n                return;\n            }\n        }\n    }\n}\nexports.forEach = forEach;\nfunction map(object, callback) {\n    var result = [];\n    if (object instanceof Array) {\n        for (var i = 0, n = object.length; i < n; ++i) {\n            result.push(callback(object[i]));\n        }\n    }\n    else {\n        var value;\n        var it = object.__iter__();\n        while ((value = it.__next__()) !== undefined) {\n            result.push(callback(value));\n        }\n    }\n    return result;\n}\nexports.map = map;\nfunction filter(object, callback) {\n    var value;\n    var result = [];\n    if (object instanceof Array) {\n        for (var i = 0, n = object.length; i < n; ++i) {\n            value = object[i];\n            if (callback(value)) {\n                result.push(value);\n            }\n        }\n    }\n    else {\n        var it = object.__iter__();\n        while ((value = it.__next__()) !== undefined) {\n            if (callback(value)) {\n                result.push(value);\n            }\n        }\n    }\n    return result;\n}\nexports.filter = filter;\n","\"use strict\";\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n* A class which defines a generic pair object.\n*/\nvar Pair = (function () {\n    /**\n    * Construct a new Pair object.\n    *\n    * @param first The first item of the pair.\n    * @param second The second item of the pair.\n    */\n    function Pair(first, second) {\n        this.first = first;\n        this.second = second;\n    }\n    /**\n    * Create a copy of the pair.\n    */\n    Pair.prototype.copy = function () {\n        return new Pair(this.first, this.second);\n    };\n    return Pair;\n}());\nexports.Pair = Pair;\n","\"use strict\";\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The primary user constraint variable.\n *\n * @class\n */\nvar Variable = (function () {\n    /**\n     * Construct a new Variable\n     *\n     * @param [name] The name to associated with the variable.\n     */\n    function Variable(name) {\n        if (name === void 0) { name = \"\"; }\n        this._value = 0.0;\n        this._context = null;\n        this._id = VarId++;\n        this._name = name;\n    }\n    /**\n     * A static variable comparison function.\n     */\n    Variable.Compare = function (a, b) {\n        return a.id - b.id;\n    };\n    Object.defineProperty(Variable.prototype, \"id\", {\n        /**\n         * Returns the unique id number of the variable.\n         */\n        get: function () {\n            return this._id;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Variable.prototype, \"name\", {\n        /**\n         * Returns the name of the variable.\n         */\n        get: function () {\n            return this._name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Set the name of the variable.\n     */\n    Variable.prototype.setName = function (name) {\n        this._name = name;\n    };\n    Object.defineProperty(Variable.prototype, \"context\", {\n        /**\n         * Returns the user context object of the variable.\n         */\n        get: function () {\n            return this._context;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Set the user context object of the variable.\n     */\n    Variable.prototype.setContext = function (context) {\n        this._context = context;\n    };\n    Object.defineProperty(Variable.prototype, \"value\", {\n        /**\n         * Returns the value of the variable.\n         */\n        get: function () {\n            return this._value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Set the value of the variable.\n     */\n    Variable.prototype.setValue = function (value) {\n        this._value = value;\n    };\n    return Variable;\n}());\nexports.Variable = Variable;\n/**\n * The internal variable id counter.\n */\nvar VarId = 0;\n","/*!\n * numbro.js\n * version : 1.6.2\n * author : Fretagsplatsen AB\n * license : MIT\n * http://www.foretagsplatsen.se\n */\n\n    /************************************\n        Constants\n    ************************************/\n\n    var numbro,\n        VERSION = '1.6.2',\n    // internal storage for culture config files\n        cultures = {},\n    // Todo: Remove in 2.0.0\n        languages = cultures,\n        currentCulture = 'en-US',\n        zeroFormat = null,\n        defaultFormat = '0,0',\n        defaultCurrencyFormat = '0$',\n        // check for nodeJS\n        hasModule = (typeof module !== 'undefined' && module.exports),\n    // default culture\n        enUS = {\n            delimiters: {\n                thousands: ',',\n                decimal: '.'\n            },\n            abbreviations: {\n                thousand: 'k',\n                million: 'm',\n                billion: 'b',\n                trillion: 't'\n            },\n            ordinal: function(number) {\n                var b = number % 10;\n                return (~~(number % 100 / 10) === 1) ? 'th' :\n                    (b === 1) ? 'st' :\n                        (b === 2) ? 'nd' :\n                            (b === 3) ? 'rd' : 'th';\n            },\n            currency: {\n                symbol: '$',\n                position: 'prefix'\n            },\n            defaults: {\n                currencyFormat: ',0000 a'\n            },\n            formats: {\n                fourDigits: '0000 a',\n                fullWithTwoDecimals: '$ ,0.00',\n                fullWithTwoDecimalsNoCurrency: ',0.00'\n            }\n        };\n\n    /************************************\n        Constructors\n    ************************************/\n\n\n    // Numbro prototype object\n    function Numbro(number) {\n        this._value = number;\n    }\n\n    function zeroes(count) {\n        var i, ret = '';\n\n        for (i = 0; i < count; i++) {\n            ret += '0';\n        }\n\n        return ret;\n    }\n    /**\n     * Implementation of toFixed() for numbers with exponent > 21\n     *\n     *\n     */\n    function toFixedLarge(value, precision) {\n        var mantissa,\n            beforeDec,\n            afterDec,\n            exponent,\n            str;\n\n        str = value.toString();\n\n        mantissa = str.split('e')[0];\n        exponent  = str.split('e')[1];\n\n        beforeDec = mantissa.split('.')[0];\n        afterDec = mantissa.split('.')[1] || '';\n\n        str = beforeDec + afterDec + zeroes(exponent - afterDec.length);\n        if (precision > 0) {\n            str += '.' + zeroes(precision);\n        }\n\n        return str;\n    }\n\n    /**\n     * Implementation of toFixed() that treats floats more like decimals\n     *\n     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\n     * problems for accounting- and finance-related software.\n     */\n    function toFixed(value, precision, roundingFunction, optionals) {\n        var power = Math.pow(10, precision),\n            optionalsRegExp,\n            output;\n\n        if (value.toFixed(0).search('e') > -1) {\n            // Above 1e21, toFixed returns scientific notation, which\n            // is useless and unexpected\n            output = toFixedLarge(value, precision);\n        }\n        else {\n            //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);\n            // Multiply up by precision, round accurately, then divide and use native toFixed():\n            output = (roundingFunction(value * power) / power).toFixed(precision);\n        }\n\n        if (optionals) {\n            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');\n            output = output.replace(optionalsRegExp, '');\n        }\n\n        return output;\n    }\n\n    /************************************\n        Formatting\n    ************************************/\n\n    // determine what type of formatting we need to do\n    function formatNumbro(value, format, roundingFunction) {\n        var output;\n        // TODO: do something with `language`\n\n        // figure out what kind of format we are dealing with\n        if (format.indexOf('$') > -1) { // currency!!!!!\n            output = formatCurrency(value, format, roundingFunction);\n        } else if (format.indexOf('%') > -1) { // percentage\n            output = formatPercentage(value, format, roundingFunction);\n        } else if (format.indexOf(':') > -1) { // time\n            output = formatTime(value);\n        } else { // plain ol' numbers or bytes\n            output = formatNumber(value, format, roundingFunction);\n        }\n\n        // return string\n        return output;\n    }\n\n    function formatCurrency(value, originalFormat, roundingFunction) {\n        var format = originalFormat,\n            symbolIndex = format.indexOf('$'),\n            openParenIndex = format.indexOf('('),\n            plusSignIndex = format.indexOf('+'),\n            minusSignIndex = format.indexOf('-'),\n            space = '',\n            decimalSeparator = '',\n            spliceIndex,\n            output;\n\n        if(format.indexOf('$') === -1){\n            // Use defaults instead of the format provided\n            if (cultures[currentCulture].currency.position === 'infix') {\n                decimalSeparator = cultures[currentCulture].currency.symbol;\n                if (cultures[currentCulture].currency.spaceSeparated) {\n                    decimalSeparator = ' ' + decimalSeparator + ' ';\n                }\n            } else if (cultures[currentCulture].currency.spaceSeparated) {\n                space = ' ';\n            }\n        } else {\n            // check for space before or after currency\n            if (format.indexOf(' $') > -1) {\n                space = ' ';\n                format = format.replace(' $', '');\n            } else if (format.indexOf('$ ') > -1) {\n                space = ' ';\n                format = format.replace('$ ', '');\n            } else {\n                format = format.replace('$', '');\n            }\n        }\n\n        // Format The Number\n        output = formatNumber(value, format, roundingFunction, decimalSeparator);\n\n        if (originalFormat.indexOf('$') === -1) {\n            // Use defaults instead of the format provided\n            switch (cultures[currentCulture].currency.position) {\n                case 'postfix':\n                    if (output.indexOf(')') > -1) {\n                        output = output.split('');\n                        output.splice(-1, 0, space + cultures[currentCulture].currency.symbol);\n                        output = output.join('');\n                    } else {\n                        output = output + space + cultures[currentCulture].currency.symbol;\n                    }\n                    break;\n                case 'infix':\n                    break;\n                case 'prefix':\n                    if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {\n                        output = output.split('');\n                        spliceIndex = Math.max(openParenIndex, minusSignIndex) + 1;\n\n                        output.splice(spliceIndex, 0, cultures[currentCulture].currency.symbol + space);\n                        output = output.join('');\n                    } else {\n                        output = cultures[currentCulture].currency.symbol + space + output;\n                    }\n                    break;\n                default:\n                    throw Error('Currency position should be among [\"prefix\", \"infix\", \"postfix\"]');\n            }\n        } else {\n            // position the symbol\n            if (symbolIndex <= 1) {\n                if (output.indexOf('(') > -1 || output.indexOf('+') > -1 || output.indexOf('-') > -1) {\n                    output = output.split('');\n                    spliceIndex = 1;\n                    if (symbolIndex < openParenIndex || symbolIndex < plusSignIndex || symbolIndex < minusSignIndex) {\n                        // the symbol appears before the \"(\", \"+\" or \"-\"\n                        spliceIndex = 0;\n                    }\n                    output.splice(spliceIndex, 0, cultures[currentCulture].currency.symbol + space);\n                    output = output.join('');\n                } else {\n                    output = cultures[currentCulture].currency.symbol + space + output;\n                }\n            } else {\n                if (output.indexOf(')') > -1) {\n                    output = output.split('');\n                    output.splice(-1, 0, space + cultures[currentCulture].currency.symbol);\n                    output = output.join('');\n                } else {\n                    output = output + space + cultures[currentCulture].currency.symbol;\n                }\n            }\n        }\n\n        return output;\n    }\n\n    function formatPercentage(value, format, roundingFunction) {\n        var space = '',\n            output;\n        value = value * 100;\n\n        // check for space before %\n        if (format.indexOf(' %') > -1) {\n            space = ' ';\n            format = format.replace(' %', '');\n        } else {\n            format = format.replace('%', '');\n        }\n\n        output = formatNumber(value, format, roundingFunction);\n\n        if (output.indexOf(')') > -1) {\n            output = output.split('');\n            output.splice(-1, 0, space + '%');\n            output = output.join('');\n        } else {\n            output = output + space + '%';\n        }\n\n        return output;\n    }\n\n    function formatTime(value) {\n        var hours = Math.floor(value / 60 / 60),\n            minutes = Math.floor((value - (hours * 60 * 60)) / 60),\n            seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));\n        return hours + ':' +\n            ((minutes < 10) ? '0' + minutes : minutes) + ':' +\n            ((seconds < 10) ? '0' + seconds : seconds);\n    }\n\n    function formatNumber (value, format, roundingFunction, sep) {\n        var negP = false,\n            signed = false,\n            optDec = false,\n            abbr = '',\n            i,\n            abbrK = false, // force abbreviation to thousands\n            abbrM = false, // force abbreviation to millions\n            abbrB = false, // force abbreviation to billions\n            abbrT = false, // force abbreviation to trillions\n            abbrForce = false, // force abbreviation\n            bytes = '',\n            ord = '',\n            abs = Math.abs(value),\n            binarySuffixes = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'],\n            decimalSuffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],\n            min,\n            max,\n            power,\n            totalLength,\n            length,\n            minimumPrecision,\n            pow,\n            w,\n            intPrecision,\n            precision,\n            prefix,\n            postfix,\n            thousands,\n            d = '',\n            forcedNeg = false,\n            neg = false,\n            indexOpenP,\n            size,\n            indexMinus,\n            paren = '',\n            minlen;\n\n        // check if number is zero and a custom zero format has been set\n        if (value === 0 && zeroFormat !== null) {\n            return zeroFormat;\n        }\n\n        if (!isFinite(value)) {\n            return '' + value;\n        }\n\n        if (format.indexOf('{') === 0) {\n            var end = format.indexOf('}');\n            if (end === -1) {\n                throw Error('Format should also contain a \"}\"');\n            }\n            prefix = format.slice(1, end);\n            format = format.slice(end + 1);\n        } else {\n            prefix = '';\n        }\n\n        if (format.indexOf('}') === format.length - 1) {\n            var start = format.indexOf('{');\n            if (start === -1) {\n                throw Error('Format should also contain a \"{\"');\n            }\n            postfix = format.slice(start + 1, -1);\n            format = format.slice(0, start + 1);\n        } else {\n            postfix = '';\n        }\n\n        // check for min length\n        var info;\n        if (format.indexOf('.') === -1) {\n            info = format.match(/([0-9]+).*/);\n        } else {\n            info = format.match(/([0-9]+)\\..*/);\n        }\n        minlen = info === null ? -1 : info[1].length;\n\n        // see if we should use parentheses for negative number or if we should prefix with a sign\n        // if both are present we default to parentheses\n        if (format.indexOf('-') !== -1) {\n            forcedNeg = true;\n        }\n        if (format.indexOf('(') > -1) {\n            negP = true;\n            format = format.slice(1, -1);\n        } else if (format.indexOf('+') > -1) {\n            signed = true;\n            format = format.replace(/\\+/g, '');\n        }\n\n        // see if abbreviation is wanted\n        if (format.indexOf('a') > -1) {\n            intPrecision = format.split('.')[0].match(/[0-9]+/g) || ['0'];\n            intPrecision = parseInt(intPrecision[0], 10);\n\n            // check if abbreviation is specified\n            abbrK = format.indexOf('aK') >= 0;\n            abbrM = format.indexOf('aM') >= 0;\n            abbrB = format.indexOf('aB') >= 0;\n            abbrT = format.indexOf('aT') >= 0;\n            abbrForce = abbrK || abbrM || abbrB || abbrT;\n\n            // check for space before abbreviation\n            if (format.indexOf(' a') > -1) {\n                abbr = ' ';\n                format = format.replace(' a', '');\n            } else {\n                format = format.replace('a', '');\n            }\n\n            totalLength = Math.floor(Math.log(abs) / Math.LN10) + 1;\n\n            minimumPrecision = totalLength % 3;\n            minimumPrecision = minimumPrecision === 0 ? 3 : minimumPrecision;\n\n            if (intPrecision && abs !== 0) {\n\n                length = Math.floor(Math.log(abs) / Math.LN10) + 1 - intPrecision;\n\n                pow = 3 * ~~((Math.min(intPrecision, totalLength) - minimumPrecision) / 3);\n\n                abs = abs / Math.pow(10, pow);\n\n                if (format.indexOf('.') === -1 && intPrecision > 3) {\n                    format += '[.]';\n\n                    size = length === 0 ? 0 : 3 * ~~(length / 3) - length;\n                    size = size < 0 ? size + 3 : size;\n\n                    for (i = 0; i < size; i++) {\n                        format += '0';\n                    }\n                }\n            }\n\n            if (Math.floor(Math.log(Math.abs(value)) / Math.LN10) + 1 !== intPrecision) {\n                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {\n                    // trillion\n                    abbr = abbr + cultures[currentCulture].abbreviations.trillion;\n                    value = value / Math.pow(10, 12);\n                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {\n                    // billion\n                    abbr = abbr + cultures[currentCulture].abbreviations.billion;\n                    value = value / Math.pow(10, 9);\n                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {\n                    // million\n                    abbr = abbr + cultures[currentCulture].abbreviations.million;\n                    value = value / Math.pow(10, 6);\n                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {\n                    // thousand\n                    abbr = abbr + cultures[currentCulture].abbreviations.thousand;\n                    value = value / Math.pow(10, 3);\n                }\n            }\n        }\n\n        // see if we are formatting binary bytes\n        if (format.indexOf('b') > -1) {\n            // check for space before\n            if (format.indexOf(' b') > -1) {\n                bytes = ' ';\n                format = format.replace(' b', '');\n            } else {\n                format = format.replace('b', '');\n            }\n\n            for (power = 0; power <= binarySuffixes.length; power++) {\n                min = Math.pow(1024, power);\n                max = Math.pow(1024, power + 1);\n\n                if (value >= min && value < max) {\n                    bytes = bytes + binarySuffixes[power];\n                    if (min > 0) {\n                        value = value / min;\n                    }\n                    break;\n                }\n            }\n        }\n\n        // see if we are formatting decimal bytes\n        if (format.indexOf('d') > -1) {\n            // check for space before\n            if (format.indexOf(' d') > -1) {\n                bytes = ' ';\n                format = format.replace(' d', '');\n            } else {\n                format = format.replace('d', '');\n            }\n\n            for (power = 0; power <= decimalSuffixes.length; power++) {\n                min = Math.pow(1000, power);\n                max = Math.pow(1000, power + 1);\n\n                if (value >= min && value < max) {\n                    bytes = bytes + decimalSuffixes[power];\n                    if (min > 0) {\n                        value = value / min;\n                    }\n                    break;\n                }\n            }\n        }\n\n        // see if ordinal is wanted\n        if (format.indexOf('o') > -1) {\n            // check for space before\n            if (format.indexOf(' o') > -1) {\n                ord = ' ';\n                format = format.replace(' o', '');\n            } else {\n                format = format.replace('o', '');\n            }\n\n            if (cultures[currentCulture].ordinal) {\n                ord = ord + cultures[currentCulture].ordinal(value);\n            }\n        }\n\n        if (format.indexOf('[.]') > -1) {\n            optDec = true;\n            format = format.replace('[.]', '.');\n        }\n\n        w = value.toString().split('.')[0];\n        precision = format.split('.')[1];\n        thousands = format.indexOf(',');\n\n        if (precision) {\n            if (precision.indexOf('*') !== -1) {\n                d = toFixed(value, value.toString().split('.')[1].length, roundingFunction);\n            } else {\n                if (precision.indexOf('[') > -1) {\n                    precision = precision.replace(']', '');\n                    precision = precision.split('[');\n                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction,\n                        precision[1].length);\n                } else {\n                    d = toFixed(value, precision.length, roundingFunction);\n                }\n            }\n\n            w = d.split('.')[0];\n\n            if (d.split('.')[1].length) {\n                var p = sep ? abbr + sep : cultures[currentCulture].delimiters.decimal;\n                d = p + d.split('.')[1];\n            } else {\n                d = '';\n            }\n\n            if (optDec && Number(d.slice(1)) === 0) {\n                d = '';\n            }\n        } else {\n            w = toFixed(value, null, roundingFunction);\n        }\n\n        // format number\n        if (w.indexOf('-') > -1) {\n            w = w.slice(1);\n            neg = true;\n        }\n\n        if (w.length < minlen) {\n            w = new Array(minlen - w.length + 1).join('0') + w;\n        }\n\n        if (thousands > -1) {\n            w = w.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' +\n                cultures[currentCulture].delimiters.thousands);\n        }\n\n        if (format.indexOf('.') === 0) {\n            w = '';\n        }\n\n        indexOpenP = format.indexOf('(');\n        indexMinus = format.indexOf('-');\n\n        if (indexOpenP < indexMinus) {\n            paren = ((negP && neg) ? '(' : '') + (((forcedNeg && neg) || (!negP && neg)) ? '-' : '');\n        } else {\n            paren = (((forcedNeg && neg) || (!negP && neg)) ? '-' : '') + ((negP && neg) ? '(' : '');\n        }\n\n        return prefix +\n            paren + ((!neg && signed && value !== 0) ? '+' : '') +\n            w + d +\n            ((ord) ? ord : '') +\n            ((abbr && !sep) ? abbr : '') +\n            ((bytes) ? bytes : '') +\n            ((negP && neg) ? ')' : '') +\n            postfix;\n    }\n\n    /************************************\n        Top Level Functions\n    ************************************/\n\n    numbro = function(input) {\n        if (numbro.isNumbro(input)) {\n            input = input.value();\n        } else if (input === 0 || typeof input === 'undefined') {\n            input = 0;\n        } else if (!Number(input)) {\n            input = numbro.fn.unformat(input);\n        }\n\n        return new Numbro(Number(input));\n    };\n\n    // version number\n    numbro.version = VERSION;\n\n    // compare numbro object\n    numbro.isNumbro = function(obj) {\n        return obj instanceof Numbro;\n    };\n\n    /**\n     * This function allow the user to set a new language with a fallback if\n     * the language does not exist. If no fallback language is provided,\n     * it fallbacks to english.\n     *\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n     * `setCulture` should be used instead.\n     */\n    numbro.setLanguage = function(newLanguage, fallbackLanguage) {\n        console.warn('`setLanguage` is deprecated since version 1.6.0. Use `setCulture` instead');\n        var key = newLanguage,\n            prefix = newLanguage.split('-')[0],\n            matchingLanguage = null;\n        if (!languages[key]) {\n            Object.keys(languages).forEach(function(language) {\n                if (!matchingLanguage && language.split('-')[0] === prefix) {\n                    matchingLanguage = language;\n                }\n            });\n            key = matchingLanguage || fallbackLanguage || 'en-US';\n        }\n        chooseCulture(key);\n    };\n\n    /**\n     * This function allow the user to set a new culture with a fallback if\n     * the culture does not exist. If no fallback culture is provided,\n     * it fallbacks to \"en-US\".\n     */\n    numbro.setCulture = function(newCulture, fallbackCulture) {\n        var key = newCulture,\n            suffix = newCulture.split('-')[1],\n            matchingCulture = null;\n        if (!cultures[key]) {\n            if (suffix) {\n                Object.keys(cultures).forEach(function(language) {\n                    if (!matchingCulture && language.split('-')[1] === suffix) {\n                        matchingCulture = language;\n                    }\n                });\n            }\n\n            key = matchingCulture || fallbackCulture || 'en-US';\n        }\n        chooseCulture(key);\n    };\n\n    /**\n     * This function will load languages and then set the global language.  If\n     * no arguments are passed in, it will simply return the current global\n     * language key.\n     *\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n     * `culture` should be used instead.\n     */\n    numbro.language = function(key, values) {\n        console.warn('`language` is deprecated since version 1.6.0. Use `culture` instead');\n\n        if (!key) {\n            return currentCulture;\n        }\n\n        if (key && !values) {\n            if (!languages[key]) {\n                throw new Error('Unknown language : ' + key);\n            }\n            chooseCulture(key);\n        }\n\n        if (values || !languages[key]) {\n            setCulture(key, values);\n        }\n\n        return numbro;\n    };\n\n    /**\n     * This function will load cultures and then set the global culture.  If\n     * no arguments are passed in, it will simply return the current global\n     * culture code.\n     */\n    numbro.culture = function(code, values) {\n        if (!code) {\n            return currentCulture;\n        }\n\n        if (code && !values) {\n            if (!cultures[code]) {\n                throw new Error('Unknown culture : ' + code);\n            }\n            chooseCulture(code);\n        }\n\n        if (values || !cultures[code]) {\n            setCulture(code, values);\n        }\n\n        return numbro;\n    };\n\n    /**\n     * This function provides access to the loaded language data.  If\n     * no arguments are passed in, it will simply return the current\n     * global language object.\n     *\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n     * `culture` should be used instead.\n     */\n    numbro.languageData = function(key) {\n        console.warn('`languageData` is deprecated since version 1.6.0. Use `cultureData` instead');\n\n        if (!key) {\n            return languages[currentCulture];\n        }\n\n        if (!languages[key]) {\n            throw new Error('Unknown language : ' + key);\n        }\n\n        return languages[key];\n    };\n\n    /**\n     * This function provides access to the loaded culture data.  If\n     * no arguments are passed in, it will simply return the current\n     * global culture object.\n     */\n    numbro.cultureData = function(code) {\n        if (!code) {\n            return cultures[currentCulture];\n        }\n\n        if (!cultures[code]) {\n            throw new Error('Unknown culture : ' + code);\n        }\n\n        return cultures[code];\n    };\n\n    numbro.culture('en-US', enUS);\n\n    /**\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n     * `cultures` should be used instead.\n     */\n    numbro.languages = function() {\n        console.warn('`languages` is deprecated since version 1.6.0. Use `cultures` instead');\n\n        return languages;\n    };\n\n    numbro.cultures = function() {\n        return cultures;\n    };\n\n    numbro.zeroFormat = function(format) {\n        zeroFormat = typeof(format) === 'string' ? format : null;\n    };\n\n    numbro.defaultFormat = function(format) {\n        defaultFormat = typeof(format) === 'string' ? format : '0.0';\n    };\n\n    numbro.defaultCurrencyFormat = function (format) {\n        defaultCurrencyFormat = typeof(format) === 'string' ? format : '0$';\n    };\n\n    numbro.validate = function(val, culture) {\n\n        var _decimalSep,\n            _thousandSep,\n            _currSymbol,\n            _valArray,\n            _abbrObj,\n            _thousandRegEx,\n            cultureData,\n            temp;\n\n        //coerce val to string\n        if (typeof val !== 'string') {\n            val += '';\n            if (console.warn) {\n                console.warn('Numbro.js: Value is not string. It has been co-erced to: ', val);\n            }\n        }\n\n        //trim whitespaces from either sides\n        val = val.trim();\n\n        //if val is just digits return true\n        if ( !! val.match(/^\\d+$/)) {\n            return true;\n        }\n\n        //if val is empty return false\n        if (val === '') {\n            return false;\n        }\n\n        //get the decimal and thousands separator from numbro.cultureData\n        try {\n            //check if the culture is understood by numbro. if not, default it to current culture\n            cultureData = numbro.cultureData(culture);\n        } catch (e) {\n            cultureData = numbro.cultureData(numbro.culture());\n        }\n\n        //setup the delimiters and currency symbol based on culture\n        _currSymbol = cultureData.currency.symbol;\n        _abbrObj = cultureData.abbreviations;\n        _decimalSep = cultureData.delimiters.decimal;\n        if (cultureData.delimiters.thousands === '.') {\n            _thousandSep = '\\\\.';\n        } else {\n            _thousandSep = cultureData.delimiters.thousands;\n        }\n\n        // validating currency symbol\n        temp = val.match(/^[^\\d]+/);\n        if (temp !== null) {\n            val = val.substr(1);\n            if (temp[0] !== _currSymbol) {\n                return false;\n            }\n        }\n\n        //validating abbreviation symbol\n        temp = val.match(/[^\\d]+$/);\n        if (temp !== null) {\n            val = val.slice(0, -1);\n            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million &&\n                    temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {\n                return false;\n            }\n        }\n\n        _thousandRegEx = new RegExp(_thousandSep + '{2}');\n\n        if (!val.match(/[^\\d.,]/g)) {\n            _valArray = val.split(_decimalSep);\n            if (_valArray.length > 2) {\n                return false;\n            } else {\n                if (_valArray.length < 2) {\n                    return ( !! _valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx));\n                } else {\n                    if (_valArray[0].length === 1) {\n                        return ( !! _valArray[0].match(/^\\d+$/) &&\n                            !_valArray[0].match(_thousandRegEx) &&\n                            !! _valArray[1].match(/^\\d+$/));\n                    } else {\n                        return ( !! _valArray[0].match(/^\\d+.*\\d$/) &&\n                            !_valArray[0].match(_thousandRegEx) &&\n                            !! _valArray[1].match(/^\\d+$/));\n                    }\n                }\n            }\n        }\n\n        return false;\n    };\n\n    /************************************\n        Helpers\n    ************************************/\n\n    function setCulture(code, values) {\n        cultures[code] = values;\n    }\n\n    function chooseCulture(code) {\n        currentCulture = code;\n        var defaults = cultures[code].defaults;\n        if (defaults && defaults.format) {\n            numbro.defaultFormat(defaults.format);\n        }\n        if (defaults && defaults.currencyFormat) {\n            numbro.defaultCurrencyFormat(defaults.currencyFormat);\n        }\n    }\n\n    function format(input, formatString, language, roundingFunction) {\n        if (language != null && language !== numbro.culture()) {\n            numbro.setCulture(language);\n        }\n        return formatNumbro(\n            Number(input),\n            formatString != null     ? formatString : defaultFormat,\n            roundingFunction == null ? Math.round   : roundingFunction);\n    }\n\n    module.exports = {\"format\": format};\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var parseCode = require('./parseCode');\nvar extend = require('./extend');\nvar projections = require('./projections');\nvar deriveConstants = require('./deriveConstants');\nvar Datum = require('./constants/Datum');\nvar datum = require('./datum');\n\n\nfunction Projection(srsCode,callback) {\n  if (!(this instanceof Projection)) {\n    return new Projection(srsCode);\n  }\n  callback = callback || function(error){\n    if(error){\n      throw error;\n    }\n  };\n  var json = parseCode(srsCode);\n  if(typeof json !== 'object'){\n    callback(srsCode);\n    return;\n  }\n  var ourProj = Projection.projections.get(json.projName);\n  if(!ourProj){\n    callback(srsCode);\n    return;\n  }\n  if (json.datumCode && json.datumCode !== 'none') {\n    var datumDef = Datum[json.datumCode];\n    if (datumDef) {\n      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;\n      json.ellps = datumDef.ellipse;\n      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;\n    }\n  }\n  json.k0 = json.k0 || 1.0;\n  json.axis = json.axis || 'enu';\n\n  var sphere = deriveConstants.sphere(json.a, json.b, json.rf, json.ellps, json.sphere);\n  var ecc = deriveConstants.eccentricity(sphere.a, sphere.b, sphere.rf, json.R_A);\n  var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere.a, sphere.b, ecc.es, ecc.ep2);\n\n  extend(this, json); // transfer everything over from the projection because we don't know what we'll need\n  extend(this, ourProj); // transfer all the methods from the projection\n\n  // copy the 4 things over we calulated in deriveConstants.sphere\n  this.a = sphere.a;\n  this.b = sphere.b;\n  this.rf = sphere.rf;\n  this.sphere = sphere.sphere;\n\n  // copy the 3 things we calculated in deriveConstants.eccentricity\n  this.es = ecc.es;\n  this.e = ecc.e;\n  this.ep2 = ecc.ep2;\n\n  // add in the datum object\n  this.datum = datumObj;\n\n  // init the projection\n  this.init();\n\n  // legecy callback from back in the day when it went to spatialreference.org\n  callback(null, this);\n\n}\nProjection.projections = projections;\nProjection.projections.start();\nmodule.exports = Projection;\n","module.exports = function(crs, denorm, point) {\n  var xin = point.x,\n    yin = point.y,\n    zin = point.z || 0.0;\n  var v, t, i;\n  var out = {};\n  for (i = 0; i < 3; i++) {\n    if (denorm && i === 2 && point.z === undefined) {\n      continue;\n    }\n    if (i === 0) {\n      v = xin;\n      t = 'x';\n    }\n    else if (i === 1) {\n      v = yin;\n      t = 'y';\n    }\n    else {\n      v = zin;\n      t = 'z';\n    }\n    switch (crs.axis[i]) {\n    case 'e':\n      out[t] = v;\n      break;\n    case 'w':\n      out[t] = -v;\n      break;\n    case 'n':\n      out[t] = v;\n      break;\n    case 's':\n      out[t] = -v;\n      break;\n    case 'u':\n      if (point[t] !== undefined) {\n        out.z = v;\n      }\n      break;\n    case 'd':\n      if (point[t] !== undefined) {\n        out.z = -v;\n      }\n      break;\n    default:\n      //console.log(\"ERROR: unknow axis (\"+crs.axis[i]+\") - check definition of \"+crs.projName);\n      return null;\n    }\n  }\n  return out;\n};\n","var TWO_PI = Math.PI * 2;\n// SPI is slightly greater than Math.PI, so values that exceed the -180..180\n// degree range by a tiny amount don't get wrapped. This prevents points that\n// have drifted from their original location along the 180th meridian (due to\n// floating point error) from changing their sign.\nvar SPI = 3.14159265359;\nvar sign = require('./sign');\n\nmodule.exports = function(x) {\n  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));\n};","module.exports = function(eccent, sinphi, cosphi) {\n  var con = eccent * sinphi;\n  return cosphi / (Math.sqrt(1 - con * con));\n};","var HALF_PI = Math.PI/2;\nmodule.exports = function(eccent, ts) {\n  var eccnth = 0.5 * eccent;\n  var con, dphi;\n  var phi = HALF_PI - 2 * Math.atan(ts);\n  for (var i = 0; i <= 15; i++) {\n    con = eccent * Math.sin(phi);\n    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n  //console.log(\"phi2z has NoConvergence\");\n  return -9999;\n};","module.exports = function(x) {\n  return x<0 ? -1 : 1;\n};","module.exports = function (array){\n  var out = {\n    x: array[0],\n    y: array[1]\n  };\n  if (array.length>2) {\n    out.z = array[2];\n  }\n  if (array.length>3) {\n    out.m = array[3];\n  }\n  return out;\n};","var HALF_PI = Math.PI/2;\n\nmodule.exports = function(eccent, phi, sinphi) {\n  var con = eccent * sinphi;\n  var com = 0.5 * eccent;\n  con = Math.pow(((1 - con) / (1 + con)), com);\n  return (Math.tan(0.5 * (HALF_PI - phi)) / con);\n};","exports.wgs84 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"WGS84\",\n  datumName: \"WGS84\"\n};\nexports.ch1903 = {\n  towgs84: \"674.374,15.056,405.346\",\n  ellipse: \"bessel\",\n  datumName: \"swiss\"\n};\nexports.ggrs87 = {\n  towgs84: \"-199.87,74.79,246.62\",\n  ellipse: \"GRS80\",\n  datumName: \"Greek_Geodetic_Reference_System_1987\"\n};\nexports.nad83 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"GRS80\",\n  datumName: \"North_American_Datum_1983\"\n};\nexports.nad27 = {\n  nadgrids: \"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat\",\n  ellipse: \"clrk66\",\n  datumName: \"North_American_Datum_1927\"\n};\nexports.potsdam = {\n  towgs84: \"606.0,23.0,413.0\",\n  ellipse: \"bessel\",\n  datumName: \"Potsdam Rauenberg 1950 DHDN\"\n};\nexports.carthage = {\n  towgs84: \"-263.0,6.0,431.0\",\n  ellipse: \"clark80\",\n  datumName: \"Carthage 1934 Tunisia\"\n};\nexports.hermannskogel = {\n  towgs84: \"653.0,-212.0,449.0\",\n  ellipse: \"bessel\",\n  datumName: \"Hermannskogel\"\n};\nexports.ire65 = {\n  towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n  ellipse: \"mod_airy\",\n  datumName: \"Ireland 1965\"\n};\nexports.rassadiran = {\n  towgs84: \"-133.63,-157.5,-158.62\",\n  ellipse: \"intl\",\n  datumName: \"Rassadiran\"\n};\nexports.nzgd49 = {\n  towgs84: \"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993\",\n  ellipse: \"intl\",\n  datumName: \"New Zealand Geodetic Datum 1949\"\n};\nexports.osgb36 = {\n  towgs84: \"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894\",\n  ellipse: \"airy\",\n  datumName: \"Airy 1830\"\n};\nexports.s_jtsk = {\n  towgs84: \"589,76,480\",\n  ellipse: 'bessel',\n  datumName: 'S-JTSK (Ferro)'\n};\nexports.beduaram = {\n  towgs84: '-106,-87,188',\n  ellipse: 'clrk80',\n  datumName: 'Beduaram'\n};\nexports.gunung_segara = {\n  towgs84: '-403,684,41',\n  ellipse: 'bessel',\n  datumName: 'Gunung Segara Jakarta'\n};\nexports.rnb72 = {\n  towgs84: \"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1\",\n  ellipse: \"intl\",\n  datumName: \"Reseau National Belge 1972\"\n};","exports.MERIT = {\n  a: 6378137.0,\n  rf: 298.257,\n  ellipseName: \"MERIT 1983\"\n};\nexports.SGS85 = {\n  a: 6378136.0,\n  rf: 298.257,\n  ellipseName: \"Soviet Geodetic System 85\"\n};\nexports.GRS80 = {\n  a: 6378137.0,\n  rf: 298.257222101,\n  ellipseName: \"GRS 1980(IUGG, 1980)\"\n};\nexports.IAU76 = {\n  a: 6378140.0,\n  rf: 298.257,\n  ellipseName: \"IAU 1976\"\n};\nexports.airy = {\n  a: 6377563.396,\n  b: 6356256.910,\n  ellipseName: \"Airy 1830\"\n};\nexports.APL4 = {\n  a: 6378137,\n  rf: 298.25,\n  ellipseName: \"Appl. Physics. 1965\"\n};\nexports.NWL9D = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: \"Naval Weapons Lab., 1965\"\n};\nexports.mod_airy = {\n  a: 6377340.189,\n  b: 6356034.446,\n  ellipseName: \"Modified Airy\"\n};\nexports.andrae = {\n  a: 6377104.43,\n  rf: 300.0,\n  ellipseName: \"Andrae 1876 (Den., Iclnd.)\"\n};\nexports.aust_SA = {\n  a: 6378160.0,\n  rf: 298.25,\n  ellipseName: \"Australian Natl & S. Amer. 1969\"\n};\nexports.GRS67 = {\n  a: 6378160.0,\n  rf: 298.2471674270,\n  ellipseName: \"GRS 67(IUGG 1967)\"\n};\nexports.bessel = {\n  a: 6377397.155,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841\"\n};\nexports.bess_nam = {\n  a: 6377483.865,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841 (Namibia)\"\n};\nexports.clrk66 = {\n  a: 6378206.4,\n  b: 6356583.8,\n  ellipseName: \"Clarke 1866\"\n};\nexports.clrk80 = {\n  a: 6378249.145,\n  rf: 293.4663,\n  ellipseName: \"Clarke 1880 mod.\"\n};\nexports.clrk58 = {\n  a: 6378293.645208759,\n  rf: 294.2606763692654,\n  ellipseName: \"Clarke 1858\"\n};\nexports.CPM = {\n  a: 6375738.7,\n  rf: 334.29,\n  ellipseName: \"Comm. des Poids et Mesures 1799\"\n};\nexports.delmbr = {\n  a: 6376428.0,\n  rf: 311.5,\n  ellipseName: \"Delambre 1810 (Belgium)\"\n};\nexports.engelis = {\n  a: 6378136.05,\n  rf: 298.2566,\n  ellipseName: \"Engelis 1985\"\n};\nexports.evrst30 = {\n  a: 6377276.345,\n  rf: 300.8017,\n  ellipseName: \"Everest 1830\"\n};\nexports.evrst48 = {\n  a: 6377304.063,\n  rf: 300.8017,\n  ellipseName: \"Everest 1948\"\n};\nexports.evrst56 = {\n  a: 6377301.243,\n  rf: 300.8017,\n  ellipseName: \"Everest 1956\"\n};\nexports.evrst69 = {\n  a: 6377295.664,\n  rf: 300.8017,\n  ellipseName: \"Everest 1969\"\n};\nexports.evrstSS = {\n  a: 6377298.556,\n  rf: 300.8017,\n  ellipseName: \"Everest (Sabah & Sarawak)\"\n};\nexports.fschr60 = {\n  a: 6378166.0,\n  rf: 298.3,\n  ellipseName: \"Fischer (Mercury Datum) 1960\"\n};\nexports.fschr60m = {\n  a: 6378155.0,\n  rf: 298.3,\n  ellipseName: \"Fischer 1960\"\n};\nexports.fschr68 = {\n  a: 6378150.0,\n  rf: 298.3,\n  ellipseName: \"Fischer 1968\"\n};\nexports.helmert = {\n  a: 6378200.0,\n  rf: 298.3,\n  ellipseName: \"Helmert 1906\"\n};\nexports.hough = {\n  a: 6378270.0,\n  rf: 297.0,\n  ellipseName: \"Hough\"\n};\nexports.intl = {\n  a: 6378388.0,\n  rf: 297.0,\n  ellipseName: \"International 1909 (Hayford)\"\n};\nexports.kaula = {\n  a: 6378163.0,\n  rf: 298.24,\n  ellipseName: \"Kaula 1961\"\n};\nexports.lerch = {\n  a: 6378139.0,\n  rf: 298.257,\n  ellipseName: \"Lerch 1979\"\n};\nexports.mprts = {\n  a: 6397300.0,\n  rf: 191.0,\n  ellipseName: \"Maupertius 1738\"\n};\nexports.new_intl = {\n  a: 6378157.5,\n  b: 6356772.2,\n  ellipseName: \"New International 1967\"\n};\nexports.plessis = {\n  a: 6376523.0,\n  rf: 6355863.0,\n  ellipseName: \"Plessis 1817 (France)\"\n};\nexports.krass = {\n  a: 6378245.0,\n  rf: 298.3,\n  ellipseName: \"Krassovsky, 1942\"\n};\nexports.SEasia = {\n  a: 6378155.0,\n  b: 6356773.3205,\n  ellipseName: \"Southeast Asia\"\n};\nexports.walbeck = {\n  a: 6376896.0,\n  b: 6355834.8467,\n  ellipseName: \"Walbeck\"\n};\nexports.WGS60 = {\n  a: 6378165.0,\n  rf: 298.3,\n  ellipseName: \"WGS 60\"\n};\nexports.WGS66 = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: \"WGS 66\"\n};\nexports.WGS7 = {\n  a: 6378135.0,\n  rf: 298.26,\n  ellipseName: \"WGS 72\"\n};\nexports.WGS84 = {\n  a: 6378137.0,\n  rf: 298.257223563,\n  ellipseName: \"WGS 84\"\n};\nexports.sphere = {\n  a: 6370997.0,\n  b: 6370997.0,\n  ellipseName: \"Normal Sphere (r=6370997)\"\n};","exports.greenwich = 0.0; //\"0dE\",\nexports.lisbon = -9.131906111111; //\"9d07'54.862\\\"W\",\nexports.paris = 2.337229166667; //\"2d20'14.025\\\"E\",\nexports.bogota = -74.080916666667; //\"74d04'51.3\\\"W\",\nexports.madrid = -3.687938888889; //\"3d41'16.58\\\"W\",\nexports.rome = 12.452333333333; //\"12d27'8.4\\\"E\",\nexports.bern = 7.439583333333; //\"7d26'22.5\\\"E\",\nexports.jakarta = 106.807719444444; //\"106d48'27.79\\\"E\",\nexports.ferro = -17.666666666667; //\"17d40'W\",\nexports.brussels = 4.367975; //\"4d22'4.71\\\"E\",\nexports.stockholm = 18.058277777778; //\"18d3'29.8\\\"E\",\nexports.athens = 23.7163375; //\"23d42'58.815\\\"E\",\nexports.oslo = 10.722916666667; //\"10d43'22.5\\\"E\"","exports.ft = {to_meter: 0.3048};\nexports['us-ft'] = {to_meter: 1200 / 3937};\n","var proj = require('./Proj');\nvar transform = require('./transform');\nvar wgs84 = proj('WGS84');\n\nfunction transformer(from, to, coords) {\n  var transformedArray;\n  if (Array.isArray(coords)) {\n    transformedArray = transform(from, to, coords);\n    if (coords.length === 3) {\n      return [transformedArray.x, transformedArray.y, transformedArray.z];\n    }\n    else {\n      return [transformedArray.x, transformedArray.y];\n    }\n  }\n  else {\n    return transform(from, to, coords);\n  }\n}\n\nfunction checkProj(item) {\n  if (item instanceof proj) {\n    return item;\n  }\n  if (item.oProj) {\n    return item.oProj;\n  }\n  return proj(item);\n}\nfunction proj4(fromProj, toProj, coord) {\n  fromProj = checkProj(fromProj);\n  var single = false;\n  var obj;\n  if (typeof toProj === 'undefined') {\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  }\n  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {\n    coord = toProj;\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  }\n  toProj = checkProj(toProj);\n  if (coord) {\n    return transformer(fromProj, toProj, coord);\n  }\n  else {\n    obj = {\n      forward: function(coords) {\n        return transformer(fromProj, toProj, coords);\n      },\n      inverse: function(coords) {\n        return transformer(toProj, fromProj, coords);\n      }\n    };\n    if (single) {\n      obj.oProj = toProj;\n    }\n    return obj;\n  }\n}\nmodule.exports = proj4;","var PJD_3PARAM = 1;\nvar PJD_7PARAM = 2;\nvar PJD_WGS84 = 4; // WGS84 or equivalent\nvar PJD_NODATUM = 5; // WGS84 or equivalent\nvar SEC_TO_RAD = 4.84813681109535993589914102357e-6;\n\nfunction datum(datumCode, datum_params, a, b, es, ep2) {\n  var out = {};\n  out.datum_type = PJD_WGS84; //default setting\n  if (datumCode && datumCode === 'none') {\n    out.datum_type = PJD_NODATUM;\n  }\n\n  if (datum_params) {\n    out.datum_params = datum_params.map(parseFloat);\n    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {\n      out.datum_type = PJD_3PARAM;\n    }\n    if (out.datum_params.length > 3) {\n      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {\n        out.datum_type = PJD_7PARAM;\n        out.datum_params[3] *= SEC_TO_RAD;\n        out.datum_params[4] *= SEC_TO_RAD;\n        out.datum_params[5] *= SEC_TO_RAD;\n        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;\n      }\n    }\n  }\n\n\n  out.a = a; //datum object also uses these values\n  out.b = b;\n  out.es = es;\n  out.ep2 = ep2;\n  return out;\n}\n\nmodule.exports = datum;\n","'use strict';\nvar PJD_3PARAM = 1;\nvar PJD_7PARAM = 2;\nvar HALF_PI = Math.PI/2;\n\nexports.compareDatums = function(source, dest) {\n  if (source.datum_type !== dest.datum_type) {\n    return false; // false, datums are not equal\n  } else if (source.a !== dest.a || Math.abs(this.es - dest.es) > 0.000000000050) {\n    // the tolerence for es is to ensure that GRS80 and WGS84\n    // are considered identical\n    return false;\n  } else if (source.datum_type === PJD_3PARAM) {\n    return (this.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);\n  } else if (source.datum_type === PJD_7PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);\n  } else {\n    return true; // datums are equal\n  }\n}; // cs_compare_datums()\n\n/*\n * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n * according to the current ellipsoid parameters.\n *\n *    Latitude  : Geodetic latitude in radians                     (input)\n *    Longitude : Geodetic longitude in radians                    (input)\n *    Height    : Geodetic height, in meters                       (input)\n *    X         : Calculated Geocentric X coordinate, in meters    (output)\n *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n *\n */\nexports.geodeticToGeocentric = function(p, es, a) {\n  var Longitude = p.x;\n  var Latitude = p.y;\n  var Height = p.z ? p.z : 0; //Z value not always supplied\n\n  var Rn; /*  Earth radius at location  */\n  var Sin_Lat; /*  Math.sin(Latitude)  */\n  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */\n  var Cos_Lat; /*  Math.cos(Latitude)  */\n\n  /*\n   ** Don't blow up if Latitude is just a little out of the value\n   ** range as it may just be a rounding issue.  Also removed longitude\n   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n   */\n  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n    Latitude = -HALF_PI;\n  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n    Latitude = HALF_PI;\n  } else if ((Latitude < -HALF_PI) || (Latitude > HALF_PI)) {\n    /* Latitude out of range */\n    //..reportError('geocent:lat out of range:' + Latitude);\n    return null;\n  }\n\n  if (Longitude > Math.PI) {\n    Longitude -= (2 * Math.PI);\n  }\n  Sin_Lat = Math.sin(Latitude);\n  Cos_Lat = Math.cos(Latitude);\n  Sin2_Lat = Sin_Lat * Sin_Lat;\n  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));\n  return {\n    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\n    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\n    z: ((Rn * (1 - es)) + Height) * Sin_Lat\n  };\n}; // cs_geodetic_to_geocentric()\n\n\nexports.geocentricToGeodetic = function(p, es, a, b) {\n  /* local defintions and variables */\n  /* end-criterium of loop, accuracy of sin(Latitude) */\n  var genau = 1e-12;\n  var genau2 = (genau * genau);\n  var maxiter = 30;\n\n  var P; /* distance between semi-minor axis and location */\n  var RR; /* distance between center and location */\n  var CT; /* sin of geocentric latitude */\n  var ST; /* cos of geocentric latitude */\n  var RX;\n  var RK;\n  var RN; /* Earth radius at location */\n  var CPHI0; /* cos of start or old geodetic latitude in iterations */\n  var SPHI0; /* sin of start or old geodetic latitude in iterations */\n  var CPHI; /* cos of searched geodetic latitude */\n  var SPHI; /* sin of searched geodetic latitude */\n  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */\n\n  var X = p.x;\n  var Y = p.y;\n  var Z = p.z ? p.z : 0.0; //Z value not always supplied\n  var Longitude;\n  var Latitude;\n  var Height;\n\n  P = Math.sqrt(X * X + Y * Y);\n  RR = Math.sqrt(X * X + Y * Y + Z * Z);\n\n  /*      special cases for latitude and longitude */\n  if (P / a < genau) {\n\n    /*  special case, if P=0. (X=0., Y=0.) */\n    Longitude = 0.0;\n\n    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n    if (RR / a < genau) {\n      Latitude = HALF_PI;\n      Height = -b;\n      return {\n        x: p.x,\n        y: p.y,\n        z: p.z\n      };\n    }\n  } else {\n    /*  ellipsoidal (geodetic) longitude\n     *  interval: -PI < Longitude <= +PI */\n    Longitude = Math.atan2(Y, X);\n  }\n\n  /* --------------------------------------------------------------\n   * Following iterative algorithm was developped by\n   * \"Institut for Erdmessung\", University of Hannover, July 1988.\n   * Internet: www.ife.uni-hannover.de\n   * Iterative computation of CPHI,SPHI and Height.\n   * Iteration of CPHI and SPHI to 10**-12 radian resp.\n   * 2*10**-7 arcsec.\n   * --------------------------------------------------------------\n   */\n  CT = Z / RR;\n  ST = P / RR;\n  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);\n  CPHI0 = ST * (1.0 - es) * RX;\n  SPHI0 = CT * RX;\n  iter = 0;\n\n  /* loop to find sin(Latitude) resp. Latitude\n   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n  do {\n    iter++;\n    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);\n\n    /*  ellipsoidal (geodetic) height */\n    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);\n\n    RK = es * RN / (RN + Height);\n    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n    CPHI = ST * (1.0 - RK) * RX;\n    SPHI = CT * RX;\n    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n    CPHI0 = CPHI;\n    SPHI0 = SPHI;\n  }\n  while (SDPHI * SDPHI > genau2 && iter < maxiter);\n\n  /*      ellipsoidal (geodetic) latitude */\n  Latitude = Math.atan(SPHI / Math.abs(CPHI));\n  return {\n    x: Longitude,\n    y: Latitude,\n    z: Height\n  };\n}; // cs_geocentric_to_geodetic()\n\n\n/****************************************************************/\n// pj_geocentic_to_wgs84( p )\n//  p = point to transform in geocentric coordinates (x,y,z)\n\n\n/** point object, nothing fancy, just allows values to be\n    passed back and forth by reference rather than by value.\n    Other point classes may be used as long as they have\n    x and y properties, which will get modified in the transform method.\n*/\nexports.geocentricToWgs84 = function(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x + datum_params[0],\n      y: p.y + datum_params[1],\n      z: p.z + datum_params[2],\n    };\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,\n      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,\n      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF\n    };\n  }\n}; // cs_geocentric_to_wgs84\n\n/****************************************************************/\n// pj_geocentic_from_wgs84()\n//  coordinate system definition,\n//  point to transform in geocentric coordinates (x,y,z)\nexports.geocentricFromWgs84 = function(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x - datum_params[0],\n      y: p.y - datum_params[1],\n      z: p.z - datum_params[2],\n    };\n\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    var x_tmp = (p.x - Dx_BF) / M_BF;\n    var y_tmp = (p.y - Dy_BF) / M_BF;\n    var z_tmp = (p.z - Dz_BF) / M_BF;\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n\n    return {\n      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\n      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\n      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\n    };\n  } //cs_geocentric_from_wgs84()\n};\n","var PJD_3PARAM = 1;\nvar PJD_7PARAM = 2;\nvar PJD_NODATUM = 5; // WGS84 or equivalent\nvar datum = require('./datumUtils');\nfunction checkParams(type) {\n  return (type === PJD_3PARAM || type === PJD_7PARAM);\n}\nmodule.exports = function(source, dest, point) {\n  // Short cut if the datums are identical.\n  if (datum.compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n\n  // Do we need to go through geocentric coordinates?\n  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = datum.geodeticToGeocentric(point, source.es, source.a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = datum.geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = datum.geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  return datum.geocentricToGeodetic(point, dest.es, dest.a, dest.b);\n\n};\n","var globals = require('./global');\nvar parseProj = require('./projString');\nvar wkt = require('./wkt');\n\nfunction defs(name) {\n  /*global console*/\n  var that = this;\n  if (arguments.length === 2) {\n    var def = arguments[1];\n    if (typeof def === 'string') {\n      if (def.charAt(0) === '+') {\n        defs[name] = parseProj(arguments[1]);\n      }\n      else {\n        defs[name] = wkt(arguments[1]);\n      }\n    } else {\n      defs[name] = def;\n    }\n  }\n  else if (arguments.length === 1) {\n    if (Array.isArray(name)) {\n      return name.map(function(v) {\n        if (Array.isArray(v)) {\n          defs.apply(that, v);\n        }\n        else {\n          defs(v);\n        }\n      });\n    }\n    else if (typeof name === 'string') {\n      if (name in defs) {\n        return defs[name];\n      }\n    }\n    else if ('EPSG' in name) {\n      defs['EPSG:' + name.EPSG] = name;\n    }\n    else if ('ESRI' in name) {\n      defs['ESRI:' + name.ESRI] = name;\n    }\n    else if ('IAU2000' in name) {\n      defs['IAU2000:' + name.IAU2000] = name;\n    }\n    else {\n      console.log(name);\n    }\n    return;\n  }\n\n\n}\nglobals(defs);\nmodule.exports = defs;\n","// ellipoid pj_set_ell.c\nvar SIXTH = 0.1666666666666666667;\n/* 1/6 */\nvar RA4 = 0.04722222222222222222;\n/* 17/360 */\nvar RA6 = 0.02215608465608465608;\nvar EPSLN = 1.0e-10;\nvar Ellipsoid = require('./constants/Ellipsoid');\n\nexports.eccentricity = function(a, b, rf, R_A) {\n  var a2 = a * a; // used in geocentric\n  var b2 = b * b; // used in geocentric\n  var es = (a2 - b2) / a2; // e ^ 2\n  var e = 0;\n  if (R_A) {\n    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));\n    a2 = a * a;\n    es = 0;\n  } else {\n    e = Math.sqrt(es); // eccentricity\n  }\n  var ep2 = (a2 - b2) / b2; // used in geocentric\n  return {\n    es: es,\n    e: e,\n    ep2: ep2\n  };\n};\nexports.sphere = function (a, b, rf, ellps, sphere) {\n  if (!a) { // do we have an ellipsoid?\n    var ellipse = Ellipsoid[ellps];\n    if (!ellipse) {\n      ellipse = Ellipsoid.WGS84;\n    }\n    a = ellipse.a;\n    b = ellipse.b;\n    rf = ellipse.rf;\n  }\n\n  if (rf && !b) {\n    b = (1.0 - 1.0 / rf) * a;\n  }\n  if (rf === 0 || Math.abs(a - b) < EPSLN) {\n    sphere = true;\n    b = a;\n  }\n  return {\n    a: a,\n    b: b,\n    rf: rf,\n    sphere: sphere\n  };\n};\n","module.exports = function(destination, source) {\n  destination = destination || {};\n  var value, property;\n  if (!source) {\n    return destination;\n  }\n  for (property in source) {\n    value = source[property];\n    if (value !== undefined) {\n      destination[property] = value;\n    }\n  }\n  return destination;\n};\n","module.exports = function(defs) {\n  defs('EPSG:4326', \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\");\n  defs('EPSG:4269', \"+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees\");\n  defs('EPSG:3857', \"+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs\");\n\n  defs.WGS84 = defs['EPSG:4326'];\n  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857\n  defs.GOOGLE = defs['EPSG:3857'];\n  defs['EPSG:900913'] = defs['EPSG:3857'];\n  defs['EPSG:102113'] = defs['EPSG:3857'];\n};\n","var defs = require('./defs');\nvar wkt = require('./wkt');\nvar projStr = require('./projString');\nfunction testObj(code){\n  return typeof code === 'string';\n}\nfunction testDef(code){\n  return code in defs;\n}\nvar codeWords = ['GEOGCS','GEOCCS','PROJCS','LOCAL_CS'];\n\nfunction testWKT(code){\n  return codeWords.some(function (word) {\n    return code.indexOf(word) > -1;\n  });\n}\nfunction testProj(code){\n  return code[0] === '+';\n}\nfunction parse(code){\n  if (testObj(code)) {\n    //check to see if this is a WKT string\n    if (testDef(code)) {\n      return defs[code];\n    }\n    if (testWKT(code)) {\n      return wkt(code);\n    }\n    if (testProj(code)) {\n      return projStr(code);\n    }\n  }else{\n    return code;\n  }\n}\n\nmodule.exports = parse;\n","var D2R = 0.01745329251994329577;\nvar PrimeMeridian = require('./constants/PrimeMeridian');\nvar units = require('./constants/units');\n\nmodule.exports = function(defData) {\n  var self = {};\n  var paramObj = defData.split('+').map(function(v) {\n    return v.trim();\n  }).filter(function(a) {\n    return a;\n  }).reduce(function(p, a) {\n    var split = a.split('=');\n    split.push(true);\n    p[split[0].toLowerCase()] = split[1];\n    return p;\n  }, {});\n  var paramName, paramVal, paramOutname;\n  var params = {\n    proj: 'projName',\n    datum: 'datumCode',\n    rf: function(v) {\n      self.rf = parseFloat(v);\n    },\n    lat_0: function(v) {\n      self.lat0 = v * D2R;\n    },\n    lat_1: function(v) {\n      self.lat1 = v * D2R;\n    },\n    lat_2: function(v) {\n      self.lat2 = v * D2R;\n    },\n    lat_ts: function(v) {\n      self.lat_ts = v * D2R;\n    },\n    lon_0: function(v) {\n      self.long0 = v * D2R;\n    },\n    lon_1: function(v) {\n      self.long1 = v * D2R;\n    },\n    lon_2: function(v) {\n      self.long2 = v * D2R;\n    },\n    alpha: function(v) {\n      self.alpha = parseFloat(v) * D2R;\n    },\n    lonc: function(v) {\n      self.longc = v * D2R;\n    },\n    x_0: function(v) {\n      self.x0 = parseFloat(v);\n    },\n    y_0: function(v) {\n      self.y0 = parseFloat(v);\n    },\n    k_0: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    k: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    a: function(v) {\n      self.a = parseFloat(v);\n    },\n    b: function(v) {\n      self.b = parseFloat(v);\n    },\n    r_a: function() {\n      self.R_A = true;\n    },\n    zone: function(v) {\n      self.zone = parseInt(v, 10);\n    },\n    south: function() {\n      self.utmSouth = true;\n    },\n    towgs84: function(v) {\n      self.datum_params = v.split(\",\").map(function(a) {\n        return parseFloat(a);\n      });\n    },\n    to_meter: function(v) {\n      self.to_meter = parseFloat(v);\n    },\n    units: function(v) {\n      self.units = v;\n      if (units[v]) {\n        self.to_meter = units[v].to_meter;\n      }\n    },\n    from_greenwich: function(v) {\n      self.from_greenwich = v * D2R;\n    },\n    pm: function(v) {\n      self.from_greenwich = (PrimeMeridian[v] ? PrimeMeridian[v] : parseFloat(v)) * D2R;\n    },\n    nadgrids: function(v) {\n      if (v === '@null') {\n        self.datumCode = 'none';\n      }\n      else {\n        self.nadgrids = v;\n      }\n    },\n    axis: function(v) {\n      var legalAxis = \"ewnsud\";\n      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {\n        self.axis = v;\n      }\n    }\n  };\n  for (paramName in paramObj) {\n    paramVal = paramObj[paramName];\n    if (paramName in params) {\n      paramOutname = params[paramName];\n      if (typeof paramOutname === 'function') {\n        paramOutname(paramVal);\n      }\n      else {\n        self[paramOutname] = paramVal;\n      }\n    }\n    else {\n      self[paramName] = paramVal;\n    }\n  }\n  if(typeof self.datumCode === 'string' && self.datumCode !== \"WGS84\"){\n    self.datumCode = self.datumCode.toLowerCase();\n  }\n  return self;\n};\n","var projs = [\n  require('./projections/merc'),\n  require('./projections/longlat')\n];\nvar names = {};\nvar projStore = [];\n\nfunction add(proj, i) {\n  var len = projStore.length;\n  if (!proj.names) {\n    console.log(i);\n    return true;\n  }\n  projStore[len] = proj;\n  proj.names.forEach(function(n) {\n    names[n.toLowerCase()] = len;\n  });\n  return this;\n}\n\nexports.add = add;\n\nexports.get = function(name) {\n  if (!name) {\n    return false;\n  }\n  var n = name.toLowerCase();\n  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {\n    return projStore[names[n]];\n  }\n};\nexports.start = function() {\n  projs.forEach(add);\n};\n","exports.init = function() {\n  //no-op for longlat\n};\n\nfunction identity(pt) {\n  return pt;\n}\nexports.forward = identity;\nexports.inverse = identity;\nexports.names = [\"longlat\", \"identity\"];\n","var msfnz = require('../common/msfnz');\nvar HALF_PI = Math.PI/2;\nvar EPSLN = 1.0e-10;\nvar R2D = 57.29577951308232088;\nvar adjust_lon = require('../common/adjust_lon');\nvar FORTPI = Math.PI/4;\nvar tsfnz = require('../common/tsfnz');\nvar phi2z = require('../common/phi2z');\nexports.init = function() {\n  var con = this.b / this.a;\n  this.es = 1 - con * con;\n  if(!('x0' in this)){\n    this.x0 = 0;\n  }\n  if(!('y0' in this)){\n    this.y0 = 0;\n  }\n  this.e = Math.sqrt(this.es);\n  if (this.lat_ts) {\n    if (this.sphere) {\n      this.k0 = Math.cos(this.lat_ts);\n    }\n    else {\n      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n    }\n  }\n  else {\n    if (!this.k0) {\n      if (this.k) {\n        this.k0 = this.k;\n      }\n      else {\n        this.k0 = 1;\n      }\n    }\n  }\n};\n\n/* Mercator forward equations--mapping lat,long to x,y\n  --------------------------------------------------*/\n\nexports.forward = function(p) {\n  var lon = p.x;\n  var lat = p.y;\n  // convert to radians\n  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {\n    return null;\n  }\n\n  var x, y;\n  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n    return null;\n  }\n  else {\n    if (this.sphere) {\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));\n    }\n    else {\n      var sinphi = Math.sin(lat);\n      var ts = tsfnz(this.e, lat, sinphi);\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 - this.a * this.k0 * Math.log(ts);\n    }\n    p.x = x;\n    p.y = y;\n    return p;\n  }\n};\n\n\n/* Mercator inverse equations--mapping x,y to lat/long\n  --------------------------------------------------*/\nexports.inverse = function(p) {\n\n  var x = p.x - this.x0;\n  var y = p.y - this.y0;\n  var lon, lat;\n\n  if (this.sphere) {\n    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));\n  }\n  else {\n    var ts = Math.exp(-y / (this.a * this.k0));\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  lon = adjust_lon(this.long0 + x / (this.a * this.k0));\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n};\n\nexports.names = [\"Mercator\", \"Popular Visualisation Pseudo Mercator\", \"Mercator_1SP\", \"Mercator_Auxiliary_Sphere\", \"merc\"];\n","var D2R = 0.01745329251994329577;\nvar R2D = 57.29577951308232088;\nvar PJD_3PARAM = 1;\nvar PJD_7PARAM = 2;\nvar datum_transform = require('./datum_transform');\nvar adjust_axis = require('./adjust_axis');\nvar proj = require('./Proj');\nvar toPoint = require('./common/toPoint');\nfunction checkNotWGS(source, dest) {\n  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');\n}\nmodule.exports = function transform(source, dest, point) {\n  var wgs84;\n  if (Array.isArray(point)) {\n    point = toPoint(point);\n  }\n\n  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs84 = new proj('WGS84');\n    point = transform(source, wgs84, point);\n    source = wgs84;\n  }\n  // DGR, 2010/11/12\n  if (source.axis !== 'enu') {\n    point = adjust_axis(source, false, point);\n  }\n  // Transform source points to long/lat, if they aren't already.\n  if (source.projName === 'longlat') {\n    point = {\n      x: point.x * D2R,\n      y: point.y * D2R\n    };\n  }\n  else {\n    if (source.to_meter) {\n      point = {\n        x: point.x * source.to_meter,\n        y: point.y * source.to_meter\n      };\n    }\n    point = source.inverse(point); // Convert Cartesian to longlat\n  }\n  // Adjust for the prime meridian if necessary\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  }\n\n  // Convert datums if needed, and if possible.\n  point = datum_transform(source.datum, dest.datum, point);\n\n  // Adjust for the prime meridian if necessary\n  if (dest.from_greenwich) {\n    point = {\n      x: point.x - dest.grom_greenwich,\n      y: point.y\n    };\n  }\n\n  if (dest.projName === 'longlat') {\n    // convert radians to decimal degrees\n    point = {\n      x: point.x * R2D,\n      y: point.y * R2D\n    };\n  } else { // else project\n    point = dest.forward(point);\n    if (dest.to_meter) {\n      point = {\n        x: point.x / dest.to_meter,\n        y: point.y / dest.to_meter\n      };\n    }\n  }\n\n  // DGR, 2010/11/12\n  if (dest.axis !== 'enu') {\n    return adjust_axis(dest, true, point);\n  }\n\n  return point;\n};\n","var D2R = 0.01745329251994329577;\nvar extend = require('./extend');\n\nfunction mapit(obj, key, v) {\n  obj[key] = v.map(function(aa) {\n    var o = {};\n    sExpr(aa, o);\n    return o;\n  }).reduce(function(a, b) {\n    return extend(a, b);\n  }, {});\n}\n\nfunction sExpr(v, obj) {\n  var key;\n  if (!Array.isArray(v)) {\n    obj[v] = true;\n    return;\n  }\n  else {\n    key = v.shift();\n    if (key === 'PARAMETER') {\n      key = v.shift();\n    }\n    if (v.length === 1) {\n      if (Array.isArray(v[0])) {\n        obj[key] = {};\n        sExpr(v[0], obj[key]);\n      }\n      else {\n        obj[key] = v[0];\n      }\n    }\n    else if (!v.length) {\n      obj[key] = true;\n    }\n    else if (key === 'TOWGS84') {\n      obj[key] = v;\n    }\n    else {\n      obj[key] = {};\n      if (['UNIT', 'PRIMEM', 'VERT_DATUM'].indexOf(key) > -1) {\n        obj[key] = {\n          name: v[0].toLowerCase(),\n          convert: v[1]\n        };\n        if (v.length === 3) {\n          obj[key].auth = v[2];\n        }\n      }\n      else if (key === 'SPHEROID') {\n        obj[key] = {\n          name: v[0],\n          a: v[1],\n          rf: v[2]\n        };\n        if (v.length === 4) {\n          obj[key].auth = v[3];\n        }\n      }\n      else if (['GEOGCS', 'GEOCCS', 'DATUM', 'VERT_CS', 'COMPD_CS', 'LOCAL_CS', 'FITTED_CS', 'LOCAL_DATUM'].indexOf(key) > -1) {\n        v[0] = ['name', v[0]];\n        mapit(obj, key, v);\n      }\n      else if (v.every(function(aa) {\n        return Array.isArray(aa);\n      })) {\n        mapit(obj, key, v);\n      }\n      else {\n        sExpr(v, obj[key]);\n      }\n    }\n  }\n}\n\nfunction rename(obj, params) {\n  var outName = params[0];\n  var inName = params[1];\n  if (!(outName in obj) && (inName in obj)) {\n    obj[outName] = obj[inName];\n    if (params.length === 3) {\n      obj[outName] = params[2](obj[outName]);\n    }\n  }\n}\n\nfunction d2r(input) {\n  return input * D2R;\n}\n\nfunction cleanWKT(wkt) {\n  if (wkt.type === 'GEOGCS') {\n    wkt.projName = 'longlat';\n  }\n  else if (wkt.type === 'LOCAL_CS') {\n    wkt.projName = 'identity';\n    wkt.local = true;\n  }\n  else {\n    if (typeof wkt.PROJECTION === \"object\") {\n      wkt.projName = Object.keys(wkt.PROJECTION)[0];\n    }\n    else {\n      wkt.projName = wkt.PROJECTION;\n    }\n  }\n  if (wkt.UNIT) {\n    wkt.units = wkt.UNIT.name.toLowerCase();\n    if (wkt.units === 'metre') {\n      wkt.units = 'meter';\n    }\n    if (wkt.UNIT.convert) {\n      if (wkt.type === 'GEOGCS') {\n        if (wkt.DATUM && wkt.DATUM.SPHEROID) {\n          wkt.to_meter = parseFloat(wkt.UNIT.convert, 10)*wkt.DATUM.SPHEROID.a;\n        }\n      } else {\n        wkt.to_meter = parseFloat(wkt.UNIT.convert, 10);\n      }\n    }\n  }\n\n  if (wkt.GEOGCS) {\n    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){\n    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;\n    //}\n    if (wkt.GEOGCS.DATUM) {\n      wkt.datumCode = wkt.GEOGCS.DATUM.name.toLowerCase();\n    }\n    else {\n      wkt.datumCode = wkt.GEOGCS.name.toLowerCase();\n    }\n    if (wkt.datumCode.slice(0, 2) === 'd_') {\n      wkt.datumCode = wkt.datumCode.slice(2);\n    }\n    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {\n      wkt.datumCode = 'nzgd49';\n    }\n    if (wkt.datumCode === \"wgs_1984\") {\n      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {\n        wkt.sphere = true;\n      }\n      wkt.datumCode = 'wgs84';\n    }\n    if (wkt.datumCode.slice(-6) === '_ferro') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 6);\n    }\n    if (wkt.datumCode.slice(-8) === '_jakarta') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 8);\n    }\n    if (~wkt.datumCode.indexOf('belge')) {\n      wkt.datumCode = \"rnb72\";\n    }\n    if (wkt.GEOGCS.DATUM && wkt.GEOGCS.DATUM.SPHEROID) {\n      wkt.ellps = wkt.GEOGCS.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\\_18/, 'clrk');\n      if (wkt.ellps.toLowerCase().slice(0, 13) === \"international\") {\n        wkt.ellps = 'intl';\n      }\n\n      wkt.a = wkt.GEOGCS.DATUM.SPHEROID.a;\n      wkt.rf = parseFloat(wkt.GEOGCS.DATUM.SPHEROID.rf, 10);\n    }\n    if (~wkt.datumCode.indexOf('osgb_1936')) {\n      wkt.datumCode = \"osgb36\";\n    }\n  }\n  if (wkt.b && !isFinite(wkt.b)) {\n    wkt.b = wkt.a;\n  }\n\n  function toMeter(input) {\n    var ratio = wkt.to_meter || 1;\n    return parseFloat(input, 10) * ratio;\n  }\n  var renamer = function(a) {\n    return rename(wkt, a);\n  };\n  var list = [\n    ['standard_parallel_1', 'Standard_Parallel_1'],\n    ['standard_parallel_2', 'Standard_Parallel_2'],\n    ['false_easting', 'False_Easting'],\n    ['false_northing', 'False_Northing'],\n    ['central_meridian', 'Central_Meridian'],\n    ['latitude_of_origin', 'Latitude_Of_Origin'],\n    ['latitude_of_origin', 'Central_Parallel'],\n    ['scale_factor', 'Scale_Factor'],\n    ['k0', 'scale_factor'],\n    ['latitude_of_center', 'Latitude_of_center'],\n    ['lat0', 'latitude_of_center', d2r],\n    ['longitude_of_center', 'Longitude_Of_Center'],\n    ['longc', 'longitude_of_center', d2r],\n    ['x0', 'false_easting', toMeter],\n    ['y0', 'false_northing', toMeter],\n    ['long0', 'central_meridian', d2r],\n    ['lat0', 'latitude_of_origin', d2r],\n    ['lat0', 'standard_parallel_1', d2r],\n    ['lat1', 'standard_parallel_1', d2r],\n    ['lat2', 'standard_parallel_2', d2r],\n    ['alpha', 'azimuth', d2r],\n    ['srsCode', 'name']\n  ];\n  list.forEach(renamer);\n  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === \"Lambert_Azimuthal_Equal_Area\")) {\n    wkt.long0 = wkt.longc;\n  }\n  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {\n    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);\n    wkt.lat_ts = wkt.lat1;\n  }\n}\nmodule.exports = function(wkt, self) {\n  var lisp = JSON.parse((\",\" + wkt).replace(/\\s*\\,\\s*([A-Z_0-9]+?)(\\[)/g, ',[\"$1\",').slice(1).replace(/\\s*\\,\\s*([A-Z_0-9]+?)\\]/g, ',\"$1\"]').replace(/,\\[\"VERTCS\".+/,''));\n  var type = lisp.shift();\n  var name = lisp.shift();\n  lisp.unshift(['name', name]);\n  lisp.unshift(['type', type]);\n  lisp.unshift('output');\n  var obj = {};\n  sExpr(lisp, obj);\n  cleanWKT(obj.output);\n  return extend(self, obj.output);\n};\n","'use strict';\n\nmodule.exports = partialSort;\n\n// Floyd-Rivest selection algorithm:\n// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];\n// The k-th element will have the (k - left + 1)th smallest value in [left, right]\n\nfunction partialSort(arr, k, left, right, compare) {\n    left = left || 0;\n    right = right || (arr.length - 1);\n    compare = compare || defaultCompare;\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            partialSort(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","'use strict';\n\nmodule.exports = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from stratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","/**\nsprintf() for JavaScript 0.7-beta1\nhttp://www.diveintojavascript.com/projects/javascript-sprintf\n\nCopyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of sprintf() for JavaScript nor the\n      names of its contributors may be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nChangelog:\n2010.11.07 - 0.7-beta1-node\n  - converted it to a node.js compatible module\n\n2010.09.06 - 0.7-beta1\n  - features: vsprintf, support for named placeholders\n  - enhancements: format cache, reduced global namespace pollution\n\n2010.05.22 - 0.6:\n - reverted to 0.4 and fixed the bug regarding the sign of the number 0\n Note:\n Thanks to Raphael Pigulla <raph (at] n3rd [dot) org> (http://www.n3rd.org/)\n who warned me about a bug in 0.5, I discovered that the last update was\n a regress. I appologize for that.\n\n2010.05.09 - 0.5:\n - bug fix: 0 is now preceeded with a + sign\n - bug fix: the sign was not at the right position on padded results (Kamal Abdali)\n - switched from GPL to BSD license\n\n2007.10.21 - 0.4:\n - unit test and patch (David Baird)\n\n2007.09.17 - 0.3:\n - bug fix: no longer throws exception on empty paramenters (Hans Pufal)\n\n2007.09.11 - 0.2:\n - feature: added argument swapping\n\n2007.04.03 - 0.1:\n - initial release\n**/\n\nvar sprintf = (function() {\n\tfunction get_type(variable) {\n\t\treturn Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();\n\t}\n\tfunction str_repeat(input, multiplier) {\n\t\tfor (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}\n\t\treturn output.join('');\n\t}\n\n\tvar str_format = function() {\n\t\tif (!str_format.cache.hasOwnProperty(arguments[0])) {\n\t\t\tstr_format.cache[arguments[0]] = str_format.parse(arguments[0]);\n\t\t}\n\t\treturn str_format.format.call(null, str_format.cache[arguments[0]], arguments);\n\t};\n\n\t// convert object to simple one line string without indentation or\n\t// newlines. Note that this implementation does not print array\n\t// values to their actual place for sparse arrays. \n\t//\n\t// For example sparse array like this\n\t//    l = []\n\t//    l[4] = 1\n\t// Would be printed as \"[1]\" instead of \"[, , , , 1]\"\n\t// \n\t// If argument 'seen' is not null and array the function will check for \n\t// circular object references from argument.\n\tstr_format.object_stringify = function(obj, depth, maxdepth, seen) {\n\t\tvar str = '';\n\t\tif (obj != null) {\n\t\t\tswitch( typeof(obj) ) {\n\t\t\tcase 'function': \n\t\t\t\treturn '[Function' + (obj.name ? ': '+obj.name : '') + ']';\n\t\t\t    break;\n\t\t\tcase 'object':\n\t\t\t\tif ( obj instanceof Error) { return '[' + obj.toString() + ']' };\n\t\t\t\tif (depth >= maxdepth) return '[Object]'\n\t\t\t\tif (seen) {\n\t\t\t\t\t// add object to seen list\n\t\t\t\t\tseen = seen.slice(0)\n\t\t\t\t\tseen.push(obj);\n\t\t\t\t}\n\t\t\t\tif (obj.length != null) { //array\n\t\t\t\t\tstr += '[';\n\t\t\t\t\tvar arr = []\n\t\t\t\t\tfor (var i in obj) {\n\t\t\t\t\t\tif (seen && seen.indexOf(obj[i]) >= 0) arr.push('[Circular]');\n\t\t\t\t\t\telse arr.push(str_format.object_stringify(obj[i], depth+1, maxdepth, seen));\n\t\t\t\t\t}\n\t\t\t\t\tstr += arr.join(', ') + ']';\n\t\t\t\t} else if ('getMonth' in obj) { // date\n\t\t\t\t\treturn 'Date(' + obj + ')';\n\t\t\t\t} else { // object\n\t\t\t\t\tstr += '{';\n\t\t\t\t\tvar arr = []\n\t\t\t\t\tfor (var k in obj) { \n\t\t\t\t\t\tif(obj.hasOwnProperty(k)) {\n\t\t\t\t\t\t\tif (seen && seen.indexOf(obj[k]) >= 0) arr.push(k + ': [Circular]');\n\t\t\t\t\t\t\telse arr.push(k +': ' +str_format.object_stringify(obj[k], depth+1, maxdepth, seen)); \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr += arr.join(', ') + '}';\n\t\t\t\t}\n\t\t\t\treturn str;\n\t\t\t\tbreak;\n\t\t\tcase 'string':\t\t\t\t\n\t\t\t\treturn '\"' + obj + '\"';\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\treturn '' + obj;\n\t}\n\n\tstr_format.format = function(parse_tree, argv) {\n\t\tvar cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;\n\t\tfor (i = 0; i < tree_length; i++) {\n\t\t\tnode_type = get_type(parse_tree[i]);\n\t\t\tif (node_type === 'string') {\n\t\t\t\toutput.push(parse_tree[i]);\n\t\t\t}\n\t\t\telse if (node_type === 'array') {\n\t\t\t\tmatch = parse_tree[i]; // convenience purposes only\n\t\t\t\tif (match[2]) { // keyword argument\n\t\t\t\t\targ = argv[cursor];\n\t\t\t\t\tfor (k = 0; k < match[2].length; k++) {\n\t\t\t\t\t\tif (!arg.hasOwnProperty(match[2][k])) {\n\t\t\t\t\t\t\tthrow new Error(sprintf('[sprintf] property \"%s\" does not exist', match[2][k]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\targ = arg[match[2][k]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (match[1]) { // positional argument (explicit)\n\t\t\t\t\targ = argv[match[1]];\n\t\t\t\t}\n\t\t\t\telse { // positional argument (implicit)\n\t\t\t\t\targ = argv[cursor++];\n\t\t\t\t}\n\n\t\t\t\tif (/[^sO]/.test(match[8]) && (get_type(arg) != 'number')) {\n\t\t\t\t\tthrow new Error(sprintf('[sprintf] expecting number but found %s \"' + arg + '\"', get_type(arg)));\n\t\t\t\t}\n\t\t\t\tswitch (match[8]) {\n\t\t\t\t\tcase 'b': arg = arg.toString(2); break;\n\t\t\t\t\tcase 'c': arg = String.fromCharCode(arg); break;\n\t\t\t\t\tcase 'd': arg = parseInt(arg, 10); break;\n\t\t\t\t\tcase 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;\n\t\t\t\t\tcase 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;\n\t\t\t\t    case 'O': arg = str_format.object_stringify(arg, 0, parseInt(match[7]) || 5); break;\n\t\t\t\t\tcase 'o': arg = arg.toString(8); break;\n\t\t\t\t\tcase 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;\n\t\t\t\t\tcase 'u': arg = Math.abs(arg); break;\n\t\t\t\t\tcase 'x': arg = arg.toString(16); break;\n\t\t\t\t\tcase 'X': arg = arg.toString(16).toUpperCase(); break;\n\t\t\t\t}\n\t\t\t\targ = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);\n\t\t\t\tpad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';\n\t\t\t\tpad_length = match[6] - String(arg).length;\n\t\t\t\tpad = match[6] ? str_repeat(pad_character, pad_length) : '';\n\t\t\t\toutput.push(match[5] ? arg + pad : pad + arg);\n\t\t\t}\n\t\t}\n\t\treturn output.join('');\n\t};\n\n\tstr_format.cache = {};\n\n\tstr_format.parse = function(fmt) {\n\t\tvar _fmt = fmt, match = [], parse_tree = [], arg_names = 0;\n\t\twhile (_fmt) {\n\t\t\tif ((match = /^[^\\x25]+/.exec(_fmt)) !== null) {\n\t\t\t\tparse_tree.push(match[0]);\n\t\t\t}\n\t\t\telse if ((match = /^\\x25{2}/.exec(_fmt)) !== null) {\n\t\t\t\tparse_tree.push('%');\n\t\t\t}\n\t\t\telse if ((match = /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fosOuxX])/.exec(_fmt)) !== null) {\n\t\t\t\tif (match[2]) {\n\t\t\t\t\targ_names |= 1;\n\t\t\t\t\tvar field_list = [], replacement_field = match[2], field_match = [];\n\t\t\t\t\tif ((field_match = /^([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n\t\t\t\t\t\tfield_list.push(field_match[1]);\n\t\t\t\t\t\twhile ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n\t\t\t\t\t\t\tif ((field_match = /^\\.([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n\t\t\t\t\t\t\t\tfield_list.push(field_match[1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if ((field_match = /^\\[(\\d+)\\]/.exec(replacement_field)) !== null) {\n\t\t\t\t\t\t\t\tfield_list.push(field_match[1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrow new Error('[sprintf] ' + replacement_field);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n                        throw new Error('[sprintf] ' + replacement_field);\n\t\t\t\t\t}\n\t\t\t\t\tmatch[2] = field_list;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targ_names |= 2;\n\t\t\t\t}\n\t\t\t\tif (arg_names === 3) {\n\t\t\t\t\tthrow new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');\n\t\t\t\t}\n\t\t\t\tparse_tree.push(match);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new Error('[sprintf] ' + _fmt);\n\t\t\t}\n\t\t\t_fmt = _fmt.substring(match[0].length);\n\t\t}\n\t\treturn parse_tree;\n\t};\n\n\treturn str_format;\n})();\n\nvar vsprintf = function(fmt, argv) {\n\tvar argvClone = argv.slice();\n\targvClone.unshift(fmt);\n\treturn sprintf.apply(null, argvClone);\n};\n\nmodule.exports = sprintf;\nsprintf.sprintf = sprintf;\nsprintf.vsprintf = vsprintf;\n","!function (definition) {\n  if (typeof module == \"object\" && module.exports) module.exports = definition();\n  else if (typeof define == \"function\") define(definition);\n  else this.tz = definition();\n} (function () {\n/*\n  function die () {\n    console.log.apply(console, __slice.call(arguments, 0));\n    return process.exit(1);\n  }\n\n  function say () { return console.log.apply(console, __slice.call(arguments, 0)) }\n*/\n  function actualize (entry, rule, year) {\n    var actualized, date = rule.day[1];\n\n    do {\n      actualized = new Date(Date.UTC(year, rule.month, Math.abs(date++)));\n    } while (rule.day[0] < 7 && actualized.getUTCDay() != rule.day[0])\n\n    actualized = {\n      clock: rule.clock,\n      sort: actualized.getTime(),\n      rule: rule,\n      save: rule.save * 6e4,\n      offset: entry.offset\n    };\n\n    actualized[actualized.clock] = actualized.sort + rule.time * 6e4;\n\n    if (actualized.posix) {\n      actualized.wallclock = actualized[actualized.clock] + (entry.offset + rule.saved);\n    } else {\n      actualized.posix = actualized[actualized.clock] - (entry.offset + rule.saved);\n    }\n\n    return actualized;\n  }\n\n  function find (request, clock, time) {\n    var i, I, entry, found, zone = request[request.zone], actualized = [], abbrev, rules\n      , j, year = new Date(time).getUTCFullYear(), off = 1;\n    for (i = 1, I = zone.length; i < I; i++) if (zone[i][clock] <= time) break;\n    entry = zone[i];\n    if (entry.rules) {\n      rules = request[entry.rules];\n      for (j = year + 1; j >= year - off; --j)\n        for (i = 0, I = rules.length; i < I; i++)\n          if (rules[i].from <= j && j <= rules[i].to) actualized.push(actualize(entry, rules[i], j));\n          else if (rules[i].to < j && off == 1) off = j - rules[i].to;\n      actualized.sort(function (a, b) { return a.sort - b.sort });\n      for (i = 0, I = actualized.length; i < I; i++) {\n        if (time >= actualized[i][clock] && actualized[i][actualized[i].clock] > entry[actualized[i].clock]) found = actualized[i];\n      }\n    }\n    if (found) {\n      if (abbrev = /^(.*)\\/(.*)$/.exec(entry.format)) {\n        found.abbrev = abbrev[found.save ? 2 : 1];\n      } else {\n        found.abbrev = entry.format.replace(/%s/, found.rule.letter);\n      }\n    }\n    return found || entry;\n  }\n\n  function convertToWallclock (request, posix) {\n    if (request.zone == \"UTC\") return posix;\n    request.entry = find(request, \"posix\", posix);\n    return posix + request.entry.offset + request.entry.save;\n  }\n\n  function convertToPOSIX (request, wallclock) {\n    if (request.zone == \"UTC\") return wallclock;\n\n    var entry, diff;\n    request.entry = entry = find(request, \"wallclock\", wallclock);\n    diff = wallclock - entry.wallclock;\n\n    return 0 < diff && diff < entry.save ? null : wallclock - entry.offset - entry.save;\n  }\n\n  function adjust (request, posix, match) {\n    var increment = +(match[1] + 1) // conversion necessary for week day addition\n      , offset = match[2] * increment\n      , index = UNITS.indexOf(match[3].toLowerCase())\n      , date\n      ;\n    if (index > 9) {\n      posix += offset * TIME[index - 10];\n    } else {\n      date = new Date(convertToWallclock(request, posix));\n      if (index < 7) {\n        while (offset) {\n          date.setUTCDate(date.getUTCDate() + increment);\n          if (date.getUTCDay() == index) offset -= increment;\n        }\n      } else if (index == 7) {\n        date.setUTCFullYear(date.getUTCFullYear() + offset);\n      } else if (index == 8) {\n        date.setUTCMonth(date.getUTCMonth() + offset);\n      } else {\n        date.setUTCDate(date.getUTCDate() + offset);\n      }\n      if ((posix = convertToPOSIX(request, date.getTime())) == null) {\n        posix = convertToPOSIX(request, date.getTime() + 864e5 * increment) - 864e5 * increment;\n      }\n    }\n    return posix;\n  }\n\n  function convert (vargs) {\n    if (!vargs.length) return \"1.0.6\";\n\n    var request = Object.create(this)\n      , adjustments = []\n      , i, I, $, argument, date\n      ;\n\n    for (i = 0; i < vargs.length; i++) { // leave the for loop alone, it works.\n      argument = vargs[i];\n      // https://twitter.com/bigeasy/status/215112186572439552\n      if (Array.isArray(argument)) {\n        if (!i && !isNaN(argument[1])) {\n          date = argument;\n        } else {\n          argument.splice.apply(vargs, [ i--, 1 ].concat(argument));\n        }\n      } else if (isNaN(argument)) {\n        $ = typeof argument;\n        if ($ == \"string\") {\n          if (~argument.indexOf(\"%\")) {\n            request.format = argument;\n          } else if (!i && argument == \"*\") {\n            date = argument;\n          } else if (!i && ($ = /^(\\d{4})-(\\d{2})-(\\d{2})(?:[T\\s](\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d+))?)?(Z|(([+-])(\\d{2}(:\\d{2}){0,2})))?)?$/.exec(argument))) {\n            date = [];\n            date.push.apply(date, $.slice(1, 8));\n            if ($[9]) {\n              date.push($[10] + 1);\n              date.push.apply(date, $[11].split(/:/));\n            } else if ($[8]) {\n              date.push(1);\n            }\n          } else if (/^\\w{2,3}_\\w{2}$/.test(argument)) {\n            request.locale = argument;\n          } else if ($ = UNIT_RE.exec(argument)) {\n            adjustments.push($);\n          } else {\n            request.zone = argument;\n          }\n        } else if ($ == \"function\") {\n          if ($ = argument.call(request)) return $;\n        } else if (/^\\w{2,3}_\\w{2}$/.test(argument.name)) {\n          request[argument.name] = argument;\n        } else if (argument.zones) {\n          for ($ in argument.zones) request[$] = argument.zones[$];\n          for ($ in argument.rules) request[$] = argument.rules[$];\n        }\n      } else if (!i) {\n        date = argument;\n      }\n    }\n\n    if (!request[request.locale]) delete request.locale;\n    if (!request[request.zone]) delete request.zone;\n\n    if (date != null) {\n      if (date == \"*\") {\n        date = request.clock();\n      } else if (Array.isArray(date)) {\n        I = !date[7];\n        for (i = 0; i < 11; i++) date[i] = +(date[i] || 0); // conversion necessary for decrement\n        --date[1]; // Grr..\n        date = Date.UTC.apply(Date.UTC, date.slice(0, 8)) +\n          -date[7] * (date[8] * 36e5 + date[9] * 6e4 + date[10] * 1e3);\n      } else {\n        date = Math.floor(date);\n      }\n      if (!isNaN(date)) {\n        if (I) date = convertToPOSIX(request, date);\n\n        if (date == null) return date;\n\n        for (i = 0, I = adjustments.length; i < I; i++) {\n          date = adjust(request, date, adjustments[i]);\n        }\n\n        if (!request.format) return date;\n\n        $ = new Date(convertToWallclock(request, date));\n        return request.format.replace(/%([-0_^]?)(:{0,3})(\\d*)(.)/g,\n        function (value, flag, colons, padding, specifier) {\n          var f, fill = \"0\", pad;\n          if (f = request[specifier]) {\n            value = String(f.call(request, $, date, flag, colons.length));\n            if ((flag || f.style) == \"_\") fill = \" \";\n            pad = flag == \"-\" ? 0 : f.pad || 0;\n            while (value.length < pad) value = fill + value;\n            pad = flag == \"-\" ? 0 : padding || f.pad;\n            while (value.length < pad) value = fill + value;\n            if (specifier == \"N\" && pad < value.length) value = value.slice(0, pad);\n            if (flag == \"^\") value = value.toUpperCase();\n          }\n          return value;\n        });\n      }\n    }\n\n    return function () { return request.convert(arguments) };\n  }\n\n  var context =\n    { clock: function () { return +(new Date()) }\n    , zone: \"UTC\"\n    , entry: { abbrev: \"UTC\", offset: 0, save: 0 }\n    , UTC: 1\n    , z: function(date, posix, flag, delimiters) {\n        var offset = this.entry.offset + this.entry.save\n          , seconds = Math.abs(offset / 1000), parts = [], part = 3600, i, z;\n        for (i = 0; i < 3; i++) {\n          parts.push((\"0\" + Math.floor(seconds / part)).slice(-2));\n          seconds %= part;\n          part /= 60;\n        }\n        if (flag == \"^\" && !offset) return \"Z\";\n        if (flag == \"^\") delimiters = 3;\n        if (delimiters == 3) {\n          z = parts.join(\":\");\n          z = z.replace(/:00$/, \"\");\n          if (flag != \"^\") z = z.replace(/:00$/, \"\");\n        } else if (delimiters) {\n          z = parts.slice(0, delimiters + 1).join(\":\");\n          if (flag == \"^\") z = z.replace(/:00$/, \"\");\n        } else {\n          z = parts.slice(0, 2).join(\"\");\n        }\n        z = (offset < 0 ? \"-\" : \"+\") + z;\n        z = z.replace(/([-+])(0)/, { \"_\": \" $1\", \"-\": \"$1\" }[flag] || \"$1$2\");\n        return z;\n      }\n    , \"%\": function(date) { return \"%\" }\n    , n: function (date) { return \"\\n\" }\n    , t: function (date) { return \"\\t\" }\n    , U: function (date) { return weekOfYear(date, 0) }\n    , W: function (date) { return weekOfYear(date, 1) }\n    , V: function (date) { return isoWeek(date)[0] }\n    , G: function (date) { return isoWeek(date)[1] }\n    , g: function (date) { return isoWeek(date)[1] % 100 }\n    , j: function (date) { return Math.floor((date.getTime() - Date.UTC(date.getUTCFullYear(), 0)) / 864e5) + 1 }\n    , s: function (date) { return Math.floor(date.getTime() / 1000) }\n    , C: function (date) { return Math.floor(date.getUTCFullYear() / 100) }\n    , N: function (date) { return date.getTime() % 1000 * 1000000 }\n    , m: function (date) { return date.getUTCMonth() + 1 }\n    , Y: function (date) { return date.getUTCFullYear() }\n    , y: function (date) { return date.getUTCFullYear() % 100 }\n    , H: function (date) { return date.getUTCHours() }\n    , M: function (date) { return date.getUTCMinutes() }\n    , S: function (date) { return date.getUTCSeconds() }\n    , e: function (date) { return date.getUTCDate() }\n    , d: function (date) { return date.getUTCDate() }\n    , u: function (date) { return date.getUTCDay() || 7 }\n    , w: function (date) { return date.getUTCDay() }\n    , l: function (date) { return date.getUTCHours() % 12 || 12 }\n    , I: function (date) { return date.getUTCHours() % 12 || 12 }\n    , k: function (date) { return date.getUTCHours() }\n    , Z: function (date) { return this.entry.abbrev }\n    , a: function (date) { return this[this.locale].day.abbrev[date.getUTCDay()] }\n    , A: function (date) { return this[this.locale].day.full[date.getUTCDay()] }\n    , h: function (date) { return this[this.locale].month.abbrev[date.getUTCMonth()] }\n    , b: function (date) { return this[this.locale].month.abbrev[date.getUTCMonth()] }\n    , B: function (date) { return this[this.locale].month.full[date.getUTCMonth()] }\n    , P: function (date) { return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)].toLowerCase() }\n    , p: function (date) { return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)] }\n    , R: function (date, posix) { return this.convert([ posix, \"%H:%M\" ]) }\n    , T: function (date, posix) { return this.convert([ posix, \"%H:%M:%S\" ]) }\n    , D: function (date, posix) { return this.convert([ posix, \"%m/%d/%y\" ]) }\n    , F: function (date, posix) { return this.convert([ posix, \"%Y-%m-%d\" ]) }\n    , x: function (date, posix) { return this.convert([ posix, this[this.locale].date ]) }\n    , r: function (date, posix) { return this.convert([ posix, this[this.locale].time12 || '%I:%M:%S' ]) }\n    , X: function (date, posix) { return this.convert([ posix, this[this.locale].time24 ]) }\n    , c: function (date, posix) { return this.convert([ posix, this[this.locale].dateTime ]) }\n    , convert: convert\n    , locale: \"en_US\"\n    , en_US: {\n        date: \"%m/%d/%Y\",\n        time24: \"%I:%M:%S %p\",\n        time12: \"%I:%M:%S %p\",\n        dateTime: \"%a %d %b %Y %I:%M:%S %p %Z\",\n        meridiem: [ \"AM\", \"PM\" ],\n        month: {\n          abbrev: \"Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec\".split(\"|\"),\n          full: \"January|February|March|April|May|June|July|August|September|October|November|December\".split(\"|\")\n        },\n        day: {\n          abbrev: \"Sun|Mon|Tue|Wed|Thu|Fri|Sat\".split(\"|\"),\n          full: \"Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday\".split(\"|\")\n        }\n      }\n    };\n  var UNITS = \"Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|year|month|day|hour|minute|second|millisecond\"\n    , UNIT_RE = new RegExp(\"^\\\\s*([+-])(\\\\d+)\\\\s+(\" + UNITS + \")s?\\\\s*$\", \"i\")\n    , TIME = [ 36e5, 6e4, 1e3, 1 ]\n    ;\n  UNITS = UNITS.toLowerCase().split(\"|\");\n\n  \"delmHMSUWVgCIky\".replace(/./g, function (e) { context[e].pad = 2 });\n\n  context.N.pad = 9;\n  context.j.pad = 3;\n\n  context.k.style = \"_\";\n  context.l.style = \"_\";\n  context.e.style = \"_\";\n\n  function weekOfYear (date, startOfWeek) {\n    var diff, nyd, weekStart;\n    nyd = new Date(Date.UTC(date.getUTCFullYear(), 0));\n    diff = Math.floor((date.getTime() - nyd.getTime()) / 864e5);\n    if (nyd.getUTCDay() == startOfWeek) {\n      weekStart = 0;\n    } else {\n      weekStart = 7 - nyd.getUTCDay() + startOfWeek;\n      if (weekStart == 8) {\n        weekStart = 1;\n      }\n    }\n    return diff >= weekStart ? Math.floor((diff - weekStart) / 7) + 1 : 0;\n  }\n\n  function isoWeek (date) {\n    var nyd, nyy, week;\n    nyy = date.getUTCFullYear();\n    nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();\n    week = weekOfYear(date, 1) + (nyd > 1 && nyd <= 4 ? 1 : 0);\n    if (!week) {\n      nyy = date.getUTCFullYear() - 1;\n      nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();\n      week = nyd == 4 || (nyd == 3 && new Date(nyy, 1, 29).getDate() == 29) ? 53 : 52;\n      return [week, date.getUTCFullYear() - 1];\n    } else if (week == 53 && !(nyd == 4 || (nyd == 3 && new Date(nyy, 1, 29).getDate() == 29))) {\n      return [1, date.getUTCFullYear() + 1];\n    } else {\n      return [week, date.getUTCFullYear()];\n    }\n  }\n\n  return function () { return context.convert(arguments) };\n});\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global global, define, System, Reflect, Promise */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __await;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"tslib\", [\"exports\"], function (exports) { factory(createExporter(root, createExporter(exports))); });\r\n    }\r\n    else if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        factory(createExporter(root, createExporter(module.exports)));\r\n    }\r\n    else {\r\n        factory(createExporter(root));\r\n    }\r\n    function createExporter(exports, previous) {\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n                t[p[i]] = s[p[i]];\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [0, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __exportStar = function (m, exports) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    };\r\n\r\n    __values = function (o) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n        if (m) return m.call(o);\r\n        return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    __await = function (v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator];\r\n        return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n    };\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__await\", __await);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n});"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RyYXZpcy9idWlsZC9ib2tlaC9ib2tlaC9ib2tlaGpzL3NyYy9qcy9wcmVsdWRlLmpzIiwiYnVpbGQvanMvdHJlZS9iYXNlLmpzIiwiYnVpbGQvanMvdHJlZS9jbGllbnQuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvYm9rZWhfZXZlbnRzLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL2J1aWxkX3ZpZXdzLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL2RvbS5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS9kb21fdmlldy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS9lbnVtcy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS9oYXNfcHJvcHMuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvaGl0dGVzdC5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS9sYXlvdXQvbGF5b3V0X2NhbnZhcy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS9sYXlvdXQvc2lkZV9wYW5lbC5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS9sYXlvdXQvc29sdmVyLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL2xvZ2dpbmcuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvcHJvcGVydGllcy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS9wcm9wZXJ0eV9taXhpbnMuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvc2VsZWN0aW9uX21hbmFnZXIuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvc2VsZWN0b3IuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvc2V0dGluZ3MuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvc2lnbmFsaW5nLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3VpX2V2ZW50cy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL2FycmF5LmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3V0aWwvYmJveC5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL2NhbGxiYWNrLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3V0aWwvY2FudmFzLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3V0aWwvY29sb3IuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdXRpbC9kYXRhX3N0cnVjdHVyZXMuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdXRpbC9lcS5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL21hdGguanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdXRpbC9vYmplY3QuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdXRpbC9wcm9qNC5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL3Byb2plY3Rpb25zLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3V0aWwvcmVmcy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL3NlbGVjdGlvbi5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL3NlcmlhbGl6YXRpb24uanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdXRpbC9zcGF0aWFsLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3V0aWwvc3RyaW5nLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3V0aWwvc3ZnX2NvbG9ycy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL3RlbXBsYXRpbmcuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdXRpbC90ZXh0LmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3V0aWwvdGhyb3R0bGUuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdXRpbC90eXBlcy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL3doZWVsLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3V0aWwvem9vbS5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS92aWV3LmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3Zpc3VhbHMuanMiLCJidWlsZC9qcy90cmVlL2RvY3VtZW50LmpzIiwiYnVpbGQvanMvdHJlZS9lbWJlZC5qcyIsImJ1aWxkL2pzL3RyZWUvbWFpbi5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWwuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9hbm5vdGF0aW9ucy9hbm5vdGF0aW9uLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvYW5ub3RhdGlvbnMvYXJyb3cuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9hbm5vdGF0aW9ucy9hcnJvd19oZWFkLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvYW5ub3RhdGlvbnMvYmFuZC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Fubm90YXRpb25zL2JveF9hbm5vdGF0aW9uLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvYW5ub3RhdGlvbnMvY29sb3JfYmFyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvYW5ub3RhdGlvbnMvaW5kZXguanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9hbm5vdGF0aW9ucy9sYWJlbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Fubm90YXRpb25zL2xhYmVsX3NldC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Fubm90YXRpb25zL2xlZ2VuZC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Fubm90YXRpb25zL2xlZ2VuZF9pdGVtLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvYW5ub3RhdGlvbnMvcG9seV9hbm5vdGF0aW9uLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvYW5ub3RhdGlvbnMvc3Bhbi5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Fubm90YXRpb25zL3RleHRfYW5ub3RhdGlvbi5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Fubm90YXRpb25zL3RpdGxlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvYW5ub3RhdGlvbnMvdG9vbHRpcC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Fubm90YXRpb25zL3doaXNrZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9heGVzL2F4aXMuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9heGVzL2NhdGVnb3JpY2FsX2F4aXMuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9heGVzL2NvbnRpbnVvdXNfYXhpcy5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2F4ZXMvZGF0ZXRpbWVfYXhpcy5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2F4ZXMvaW5kZXguanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9heGVzL2xpbmVhcl9heGlzLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvYXhlcy9sb2dfYXhpcy5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2NhbGxiYWNrcy9jdXN0b21qcy5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2NhbGxiYWNrcy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2NhbGxiYWNrcy9vcGVuX3VybC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2NhbnZhcy9jYW52YXMuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9jYW52YXMvY2FydGVzaWFuX2ZyYW1lLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvY2FudmFzL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZm9ybWF0dGVycy9iYXNpY190aWNrX2Zvcm1hdHRlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Zvcm1hdHRlcnMvY2F0ZWdvcmljYWxfdGlja19mb3JtYXR0ZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9mb3JtYXR0ZXJzL2RhdGV0aW1lX3RpY2tfZm9ybWF0dGVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZm9ybWF0dGVycy9mdW5jX3RpY2tfZm9ybWF0dGVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZm9ybWF0dGVycy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Zvcm1hdHRlcnMvbG9nX3RpY2tfZm9ybWF0dGVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZm9ybWF0dGVycy9tZXJjYXRvcl90aWNrX2Zvcm1hdHRlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Zvcm1hdHRlcnMvbnVtZXJhbF90aWNrX2Zvcm1hdHRlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Zvcm1hdHRlcnMvcHJpbnRmX3RpY2tfZm9ybWF0dGVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZm9ybWF0dGVycy90aWNrX2Zvcm1hdHRlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy9hbm51bGFyX3dlZGdlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL2FubnVsdXMuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvYXJjLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL2Jlemllci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy9jaXJjbGUuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvZWxsaXBzZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy9nbHlwaC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy9oYmFyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL2ltYWdlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL2ltYWdlX3JnYmEuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvaW1hZ2VfdXJsLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL2xpbmUuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvbXVsdGlfbGluZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy9vdmFsLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL3BhdGNoLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL3BhdGNoZXMuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvcXVhZC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy9xdWFkcmF0aWMuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvcmF5LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL3JlY3QuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvc2VnbWVudC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy90ZXh0LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL3ZiYXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvd2VkZ2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMveHlfZ2x5cGguanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9ncmlkcy9ncmlkLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ3JpZHMvaW5kZXguanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2xheW91dHMvYm94LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvbGF5b3V0cy9jb2x1bW4uanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9sYXlvdXRzL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvbGF5b3V0cy9sYXlvdXRfZG9tLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvbGF5b3V0cy9yb3cuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9sYXlvdXRzL3NwYWNlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2xheW91dHMvd2lkZ2V0X2JveC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL21hcHBlcnMvY2F0ZWdvcmljYWxfY29sb3JfbWFwcGVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvbWFwcGVycy9jb2xvcl9tYXBwZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9tYXBwZXJzL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvbWFwcGVycy9saW5lYXJfY29sb3JfbWFwcGVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvbWFwcGVycy9sb2dfY29sb3JfbWFwcGVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvbWFya2Vycy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL21hcmtlcnMvbWFya2VyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvcGxvdHMvZ21hcF9wbG90LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvcGxvdHMvZ21hcF9wbG90X2NhbnZhcy5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Bsb3RzL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvcGxvdHMvcGxvdC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Bsb3RzL3Bsb3RfY2FudmFzLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvcmFuZ2VzL2RhdGFfcmFuZ2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9yYW5nZXMvZGF0YV9yYW5nZTFkLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvcmFuZ2VzL2ZhY3Rvcl9yYW5nZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Jhbmdlcy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Jhbmdlcy9yYW5nZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Jhbmdlcy9yYW5nZTFkLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvcmVuZGVyZXJzL2dseXBoX3JlbmRlcmVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvcmVuZGVyZXJzL2d1aWRlX3JlbmRlcmVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvcmVuZGVyZXJzL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvcmVuZGVyZXJzL3JlbmRlcmVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvc2NhbGVzL2NhdGVnb3JpY2FsX3NjYWxlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvc2NhbGVzL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvc2NhbGVzL2xpbmVhcl9zY2FsZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3NjYWxlcy9sb2dfc2NhbGUuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9zY2FsZXMvc2NhbGUuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9zb3VyY2VzL2FqYXhfZGF0YV9zb3VyY2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9zb3VyY2VzL2NvbHVtbl9kYXRhX3NvdXJjZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3NvdXJjZXMvY29sdW1uYXJfZGF0YV9zb3VyY2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9zb3VyY2VzL2RhdGFfc291cmNlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvc291cmNlcy9nZW9qc29uX2RhdGFfc291cmNlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvc291cmNlcy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3NvdXJjZXMvcmVtb3RlX2RhdGFfc291cmNlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlja2Vycy9hZGFwdGl2ZV90aWNrZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWNrZXJzL2Jhc2ljX3RpY2tlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpY2tlcnMvY2F0ZWdvcmljYWxfdGlja2VyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlja2Vycy9jb21wb3NpdGVfdGlja2VyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlja2Vycy9jb250aW51b3VzX3RpY2tlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpY2tlcnMvZGF0ZXRpbWVfdGlja2VyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlja2Vycy9kYXlzX3RpY2tlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpY2tlcnMvZml4ZWRfdGlja2VyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlja2Vycy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpY2tlcnMvbG9nX3RpY2tlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpY2tlcnMvbWVyY2F0b3JfdGlja2VyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlja2Vycy9tb250aHNfdGlja2VyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlja2Vycy9zaW5nbGVfaW50ZXJ2YWxfdGlja2VyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlja2Vycy90aWNrZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWNrZXJzL3V0aWwuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWNrZXJzL3llYXJzX3RpY2tlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpbGVzL2Jib3hfdGlsZV9zb3VyY2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWxlcy9keW5hbWljX2ltYWdlX3JlbmRlcmVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlsZXMvaW1hZ2VfcG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpbGVzL2ltYWdlX3NvdXJjZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpbGVzL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlsZXMvbWVyY2F0b3JfdGlsZV9zb3VyY2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWxlcy9xdWFka2V5X3RpbGVfc291cmNlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlsZXMvdGlsZV9yZW5kZXJlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpbGVzL3RpbGVfc291cmNlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlsZXMvdGlsZV91dGlscy5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpbGVzL3Rtc190aWxlX3NvdXJjZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpbGVzL3dtdHNfdGlsZV9zb3VyY2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9hY3Rpb25zL2FjdGlvbl90b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvYWN0aW9ucy9oZWxwX3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9hY3Rpb25zL3JlZG9fdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2FjdGlvbnMvcmVzZXRfdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2FjdGlvbnMvc2F2ZV90b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvYWN0aW9ucy91bmRvX3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9hY3Rpb25zL3pvb21faW5fdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2FjdGlvbnMvem9vbV9vdXRfdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2J1dHRvbl90b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvZ2VzdHVyZXMvYm94X3NlbGVjdF90b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvZ2VzdHVyZXMvYm94X3pvb21fdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2dlc3R1cmVzL2dlc3R1cmVfdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2dlc3R1cmVzL2xhc3NvX3NlbGVjdF90b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvZ2VzdHVyZXMvcGFuX3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9nZXN0dXJlcy9wb2x5X3NlbGVjdF90b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvZ2VzdHVyZXMvcmVzaXplX3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9nZXN0dXJlcy9zZWxlY3RfdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2dlc3R1cmVzL3RhcF90b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvZ2VzdHVyZXMvd2hlZWxfcGFuX3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9nZXN0dXJlcy93aGVlbF96b29tX3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2luc3BlY3RvcnMvY3Jvc3NoYWlyX3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9pbnNwZWN0b3JzL2hvdmVyX3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9pbnNwZWN0b3JzL2luc3BlY3RfdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL29uX29mZl9idXR0b24uanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy90b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvdG9vbF9ldmVudHMuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy90b29sX3Byb3h5LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvdG9vbGJhci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL3Rvb2xiYXJfYmFzZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL3Rvb2xiYXJfYm94LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvdG9vbGJhcl90ZW1wbGF0ZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RyYW5zZm9ybXMvY3VzdG9tanNfdHJhbnNmb3JtLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdHJhbnNmb3Jtcy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RyYW5zZm9ybXMvaW50ZXJwb2xhdG9yLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdHJhbnNmb3Jtcy9qaXR0ZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90cmFuc2Zvcm1zL2xpbmVhcl9pbnRlcnBvbGF0b3IuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90cmFuc2Zvcm1zL3N0ZXBfaW50ZXJwb2xhdG9yLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdHJhbnNmb3Jtcy90cmFuc2Zvcm0uanMiLCJidWlsZC9qcy90cmVlL3BvbHlmaWxsLmpzIiwiYnVpbGQvanMvdHJlZS9zYWZlbHkuanMiLCJidWlsZC9qcy90cmVlL3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvY2FudmFzMnN2Zy9jYW52YXMyc3ZnLmpzIiwibm9kZV9tb2R1bGVzL2QvYXV0by1iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9hcnJheS8jL2NsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvYXJyYXkvIy9lLWluZGV4LW9mLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvYXJyYXkvZnJvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L2FycmF5L2Zyb20vaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9hcnJheS9mcm9tL3NoaW0uanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9mdW5jdGlvbi9pcy1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L2Z1bmN0aW9uL25vb3AuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9tYXRoL3NpZ24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9tYXRoL3NpZ24vaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9tYXRoL3NpZ24vc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L251bWJlci90by1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvbnVtYmVyL3RvLXBvcy1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L19pdGVyYXRlLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9hc3NpZ24vaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvYXNzaWduL3NoaW0uanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvY29weS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvZm9yLWVhY2guanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvaXMtY2FsbGFibGUuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvaXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2tleXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qva2V5cy9pcy1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9rZXlzL3NoaW0uanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvbWFwLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9pcy1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mL3NoaW0uanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvdmFsaWQtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pcy1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL3NoaW0uanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvc3RyaW5nL3JhbmRvbS11bmlxLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9lczYtaXRlcmF0b3IvZm9yLW9mLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9nZXQuanMiLCJub2RlX21vZHVsZXMvZXM2LWl0ZXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9pcy1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9lczYtaXRlcmF0b3Ivc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci92YWxpZC1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1zZXQvaW1wbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL2VzNi1zZXQvaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM2LXNldC9pcy1uYXRpdmUtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM2LXNldC9saWIvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvZXM2LXNldC9wb2x5ZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9lczYtc3ltYm9sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM2LXN5bWJvbC9pcy1zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvZXM2LXN5bWJvbC9wb2x5ZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9lczYtc3ltYm9sL3ZhbGlkYXRlLXN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9lczYtd2Vhay1tYXAvaW1wbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL2VzNi13ZWFrLW1hcC9pcy1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9lczYtd2Vhay1tYXAvaXMtbmF0aXZlLWltcGxlbWVudGVkLmpzIiwibm9kZV9tb2R1bGVzL2VzNi13ZWFrLW1hcC9wb2x5ZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudC1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhbW1lcmpzL2hhbW1lci5qcyIsIm5vZGVfbW9kdWxlcy9raXdpL2J1aWxkL2NvbnN0cmFpbnQuanMiLCJub2RlX21vZHVsZXMva2l3aS9idWlsZC9leHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL2tpd2kvYnVpbGQvaW5kZXguanMiLCJub2RlX21vZHVsZXMva2l3aS9idWlsZC9tYXB0eXBlLmpzIiwibm9kZV9tb2R1bGVzL2tpd2kvYnVpbGQvc29sdmVyLmpzIiwibm9kZV9tb2R1bGVzL2tpd2kvYnVpbGQvc3RyZW5ndGguanMiLCJub2RlX21vZHVsZXMva2l3aS9idWlsZC90c3UvYWxnb3JpdGhtLmpzIiwibm9kZV9tb2R1bGVzL2tpd2kvYnVpbGQvdHN1L2FycmF5X2Jhc2UuanMiLCJub2RlX21vZHVsZXMva2l3aS9idWlsZC90c3UvYXNzb2NpYXRpdmVfYXJyYXkuanMiLCJub2RlX21vZHVsZXMva2l3aS9idWlsZC90c3UvaW5kZXguanMiLCJub2RlX21vZHVsZXMva2l3aS9idWlsZC90c3UvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMva2l3aS9idWlsZC90c3UvcGFpci5qcyIsIm5vZGVfbW9kdWxlcy9raXdpL2J1aWxkL3ZhcmlhYmxlLmpzIiwibm9kZV9tb2R1bGVzL251bWJyby9udW1icm8uanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9Qcm9qLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9hZGp1c3RfYXhpcy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2FkanVzdF9sb24uanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9tc2Zuei5qcyIsIm5vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL3BoaTJ6LmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL3RvUG9pbnQuanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi90c2Zuei5qcyIsIm5vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29uc3RhbnRzL0RhdHVtLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb25zdGFudHMvRWxsaXBzb2lkLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb25zdGFudHMvUHJpbWVNZXJpZGlhbi5qcyIsIm5vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29uc3RhbnRzL3VuaXRzLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9kYXR1bS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9qNC9saWIvZGF0dW1VdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9qNC9saWIvZGF0dW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9kZWZzLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9kZXJpdmVDb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL2V4dGVuZC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9qNC9saWIvZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wYXJzZUNvZGUuanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2pTdHJpbmcuanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9sb25nbGF0LmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9tZXJjLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL3drdC5qcyIsIm5vZGVfbW9kdWxlcy9xdWlja3NlbGVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYnVzaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zcHJpbnRmL2xpYi9zcHJpbnRmLmpzIiwibm9kZV9tb2R1bGVzL3RpbWV6b25lL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2K0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2OEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNubEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbjVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcDRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDampCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBvdXRlcihtb2R1bGVzLCBjYWNoZSwgZW50cnkpIHtcbiAgICBmdW5jdGlvbiBuZXdSZXF1aXJlKG5hbWUpIHtcbiAgICAgICAgaWYgKCFjYWNoZVtuYW1lXSkge1xuICAgICAgICAgICAgaWYgKCFtb2R1bGVzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgbW9kdWxlIFxcJycgKyBuYW1lICsgJ1xcJycpO1xuICAgICAgICAgICAgICAgIGVyci5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG0gPSBjYWNoZVtuYW1lXSA9IHtleHBvcnRzOiB7fX07XG5cbiAgICAgICAgICAgIHZhciBtb2R1bGVSZXF1aXJlID0gZnVuY3Rpb24gZm9vKHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBtb2R1bGVzW25hbWVdWzFdW3hdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdSZXF1aXJlKGlkID8gaWQgOiB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZHVsZVJlcXVpcmUubW9kdWxlcyA9IG5ld1JlcXVpcmUubW9kdWxlcztcblxuICAgICAgICAgICAgbW9kdWxlc1tuYW1lXVswXS5jYWxsKG0uZXhwb3J0cywgbW9kdWxlUmVxdWlyZSwgbSwgbS5leHBvcnRzLCBvdXRlciwgbW9kdWxlcywgY2FjaGUsIGVudHJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWNoZVtuYW1lXS5leHBvcnRzO1xuICAgIH1cblxuICAgIG5ld1JlcXVpcmUubW9kdWxlcyA9IG1vZHVsZXM7XG5cbiAgICB2YXIgbWFpbiA9IG5ld1JlcXVpcmUoZW50cnlbMF0pO1xuICAgIG1haW4ucmVxdWlyZSA9IG5ld1JlcXVpcmU7XG4gICAgcmV0dXJuIG1haW47XG59KVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX2FsbF9tb2RlbHMsIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtb2RlbHMgPSByZXF1aXJlKFwiLi9tb2RlbHMvaW5kZXhcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWwvb2JqZWN0XCIpO1xuZXhwb3J0cy5vdmVycmlkZXMgPSB7fTtcbl9hbGxfbW9kZWxzID0gb2JqZWN0XzEuY2xvbmUobW9kZWxzKTtcbmV4cG9ydHMuTW9kZWxzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgbW9kZWwsIHJlZjtcbiAgICBtb2RlbCA9IChyZWYgPSBleHBvcnRzLm92ZXJyaWRlc1tuYW1lXSkgIT0gbnVsbCA/IHJlZiA6IF9hbGxfbW9kZWxzW25hbWVdO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsIGBcIiArIG5hbWUgKyBcIicgZG9lcyBub3QgZXhpc3QuIFRoaXMgY291bGQgYmUgZHVlIHRvIGEgd2lkZ2V0IG9yIGEgY3VzdG9tIG1vZGVsIG5vdCBiZWluZyByZWdpc3RlcmVkIGJlZm9yZSBmaXJzdCB1c2FnZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbn07XG5leHBvcnRzLk1vZGVscy5yZWdpc3RlciA9IGZ1bmN0aW9uIChuYW1lLCBtb2RlbCkge1xuICAgIHJldHVybiBleHBvcnRzLm92ZXJyaWRlc1tuYW1lXSA9IG1vZGVsO1xufTtcbmV4cG9ydHMuTW9kZWxzLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBkZWxldGUgZXhwb3J0cy5vdmVycmlkZXNbbmFtZV07XG59O1xuZXhwb3J0cy5Nb2RlbHMucmVnaXN0ZXJfbW9kZWxzID0gZnVuY3Rpb24gKG1vZGVscywgZm9yY2UsIGVycm9yRm4pIHtcbiAgICB2YXIgbW9kZWwsIG5hbWUsIHJlc3VsdHM7XG4gICAgaWYgKGZvcmNlID09IG51bGwpIHtcbiAgICAgICAgZm9yY2UgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGVycm9yRm4gPT0gbnVsbCkge1xuICAgICAgICBlcnJvckZuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1vZGVscyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAobmFtZSBpbiBtb2RlbHMpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwobW9kZWxzLCBuYW1lKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBtb2RlbCA9IG1vZGVsc1tuYW1lXTtcbiAgICAgICAgaWYgKGZvcmNlIHx8ICFfYWxsX21vZGVscy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKF9hbGxfbW9kZWxzW25hbWVdID0gbW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHR5cGVvZiBlcnJvckZuID09PSBcImZ1bmN0aW9uXCIgPyBlcnJvckZuKG5hbWUpIDogdm9pZCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5leHBvcnRzLk1vZGVscy5yZWdpc3RlcmVkX25hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhfYWxsX21vZGVscyk7XG59O1xuZXhwb3J0cy5pbmRleCA9IHt9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2xpZW50Q29ubmVjdGlvbiwgQ2xpZW50U2Vzc2lvbiwgTWVzc2FnZSwgbWVzc2FnZV9oYW5kbGVycztcbnZhciBlczZfcHJvbWlzZV8xID0gcmVxdWlyZShcImVzNi1wcm9taXNlXCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2NvcmUvbG9nZ2luZ1wiKTtcbnZhciBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbC9zdHJpbmdcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWwvb2JqZWN0XCIpO1xudmFyIGRvY3VtZW50XzEgPSByZXF1aXJlKFwiLi9kb2N1bWVudFwiKTtcbmV4cG9ydHMuREVGQVVMVF9TRVJWRVJfV0VCU09DS0VUX1VSTCA9IFwid3M6Ly9sb2NhbGhvc3Q6NTAwNi93c1wiO1xuZXhwb3J0cy5ERUZBVUxUX1NFU1NJT05fSUQgPSBcImRlZmF1bHRcIjtcbk1lc3NhZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2UoaGVhZGVyMSwgbWV0YWRhdGExLCBjb250ZW50MSkge1xuICAgICAgICB0aGlzLmhlYWRlciA9IGhlYWRlcjE7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTE7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQxO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICB9XG4gICAgTWVzc2FnZS5hc3NlbWJsZSA9IGZ1bmN0aW9uIChoZWFkZXJfanNvbiwgbWV0YWRhdGFfanNvbiwgY29udGVudF9qc29uKSB7XG4gICAgICAgIHZhciBjb250ZW50LCBoZWFkZXIsIG1ldGFkYXRhO1xuICAgICAgICBoZWFkZXIgPSBKU09OLnBhcnNlKGhlYWRlcl9qc29uKTtcbiAgICAgICAgbWV0YWRhdGEgPSBKU09OLnBhcnNlKG1ldGFkYXRhX2pzb24pO1xuICAgICAgICBjb250ZW50ID0gSlNPTi5wYXJzZShjb250ZW50X2pzb24pO1xuICAgICAgICByZXR1cm4gbmV3IE1lc3NhZ2UoaGVhZGVyLCBtZXRhZGF0YSwgY29udGVudCk7XG4gICAgfTtcbiAgICBNZXNzYWdlLmNyZWF0ZV9oZWFkZXIgPSBmdW5jdGlvbiAobXNndHlwZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgaGVhZGVyO1xuICAgICAgICBoZWFkZXIgPSB7XG4gICAgICAgICAgICAnbXNnaWQnOiBzdHJpbmdfMS51bmlxdWVJZCgpLFxuICAgICAgICAgICAgJ21zZ3R5cGUnOiBtc2d0eXBlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvYmplY3RfMS5leHRlbmQoaGVhZGVyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIE1lc3NhZ2UuY3JlYXRlID0gZnVuY3Rpb24gKG1zZ3R5cGUsIGhlYWRlcl9vcHRpb25zLCBjb250ZW50KSB7XG4gICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgIGlmIChjb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXIgPSBNZXNzYWdlLmNyZWF0ZV9oZWFkZXIobXNndHlwZSwgaGVhZGVyX29wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IE1lc3NhZ2UoaGVhZGVyLCB7fSwgY29udGVudCk7XG4gICAgfTtcbiAgICBNZXNzYWdlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICB2YXIgY29udGVudF9qc29uLCBoZWFkZXJfanNvbiwgbWV0YWRhdGFfanNvbjtcbiAgICAgICAgaGVhZGVyX2pzb24gPSBKU09OLnN0cmluZ2lmeSh0aGlzLmhlYWRlcik7XG4gICAgICAgIG1ldGFkYXRhX2pzb24gPSBKU09OLnN0cmluZ2lmeSh0aGlzLm1ldGFkYXRhKTtcbiAgICAgICAgY29udGVudF9qc29uID0gSlNPTi5zdHJpbmdpZnkodGhpcy5jb250ZW50KTtcbiAgICAgICAgc29ja2V0LnNlbmQoaGVhZGVyX2pzb24pO1xuICAgICAgICBzb2NrZXQuc2VuZChtZXRhZGF0YV9qc29uKTtcbiAgICAgICAgcmV0dXJuIHNvY2tldC5zZW5kKGNvbnRlbnRfanNvbik7XG4gICAgfTtcbiAgICBNZXNzYWdlLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCh0aGlzLmhlYWRlciAhPSBudWxsKSAmJiAodGhpcy5tZXRhZGF0YSAhPSBudWxsKSAmJiAodGhpcy5jb250ZW50ICE9IG51bGwpKSB7XG4gICAgICAgICAgICBpZiAoJ251bV9idWZmZXJzJyBpbiB0aGlzLmhlYWRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcnMubGVuZ3RoID09PSB0aGlzLmhlYWRlclsnbnVtX2J1ZmZlcnMnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXNzYWdlLnByb3RvdHlwZS5hZGRfYnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzLnB1c2goYnVmZmVyKTtcbiAgICB9O1xuICAgIE1lc3NhZ2UucHJvdG90eXBlLl9oZWFkZXJfZmllbGQgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgaWYgKGZpZWxkIGluIHRoaXMuaGVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJbZmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lc3NhZ2UucHJvdG90eXBlLm1zZ2lkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyX2ZpZWxkKCdtc2dpZCcpO1xuICAgIH07XG4gICAgTWVzc2FnZS5wcm90b3R5cGUubXNndHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcl9maWVsZCgnbXNndHlwZScpO1xuICAgIH07XG4gICAgTWVzc2FnZS5wcm90b3R5cGUuc2Vzc2lkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyX2ZpZWxkKCdzZXNzaWQnKTtcbiAgICB9O1xuICAgIE1lc3NhZ2UucHJvdG90eXBlLnJlcWlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyX2ZpZWxkKCdyZXFpZCcpO1xuICAgIH07XG4gICAgTWVzc2FnZS5wcm90b3R5cGUucHJvYmxlbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCEoJ21zZ2lkJyBpbiB0aGlzLmhlYWRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBcIk5vIG1zZ2lkIGluIGhlYWRlclwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoJ21zZ3R5cGUnIGluIHRoaXMuaGVhZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiTm8gbXNndHlwZSBpbiBoZWFkZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWVzc2FnZTtcbn0pKCk7XG5tZXNzYWdlX2hhbmRsZXJzID0ge1xuICAgICdQQVRDSC1ET0MnOiBmdW5jdGlvbiAoY29ubmVjdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5fZm9yX3Nlc3Npb24oZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiBzZXNzaW9uLl9oYW5kbGVfcGF0Y2gobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgJ09LJzogZnVuY3Rpb24gKGNvbm5lY3Rpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIudHJhY2UoXCJVbmhhbmRsZWQgT0sgcmVwbHkgdG8gXCIgKyAobWVzc2FnZS5yZXFpZCgpKSk7XG4gICAgfSxcbiAgICAnRVJST1InOiBmdW5jdGlvbiAoY29ubmVjdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIlVuaGFuZGxlZCBFUlJPUiByZXBseSB0byBcIiArIChtZXNzYWdlLnJlcWlkKCkpICsgXCI6IFwiICsgbWVzc2FnZS5jb250ZW50Wyd0ZXh0J10pO1xuICAgIH1cbn07XG5DbGllbnRDb25uZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBDbGllbnRDb25uZWN0aW9uLl9jb25uZWN0aW9uX2NvdW50ID0gMDtcbiAgICBmdW5jdGlvbiBDbGllbnRDb25uZWN0aW9uKHVybDEsIGlkLCBhcmdzX3N0cmluZzEsIF9vbl9oYXZlX3Nlc3Npb25faG9vaywgX29uX2Nsb3NlZF9wZXJtYW5lbnRseV9ob29rKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsMTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmFyZ3Nfc3RyaW5nID0gYXJnc19zdHJpbmcxO1xuICAgICAgICB0aGlzLl9vbl9oYXZlX3Nlc3Npb25faG9vayA9IF9vbl9oYXZlX3Nlc3Npb25faG9vaztcbiAgICAgICAgdGhpcy5fb25fY2xvc2VkX3Blcm1hbmVudGx5X2hvb2sgPSBfb25fY2xvc2VkX3Blcm1hbmVudGx5X2hvb2s7XG4gICAgICAgIHRoaXMuX251bWJlciA9IENsaWVudENvbm5lY3Rpb24uX2Nvbm5lY3Rpb25fY291bnQ7XG4gICAgICAgIENsaWVudENvbm5lY3Rpb24uX2Nvbm5lY3Rpb25fY291bnQgPSB0aGlzLl9udW1iZXIgKyAxO1xuICAgICAgICBpZiAodGhpcy51cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51cmwgPSBleHBvcnRzLkRFRkFVTFRfU0VSVkVSX1dFQlNPQ0tFVF9VUkw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IGV4cG9ydHMuREVGQVVMVF9TRVNTSU9OX0lEO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJDcmVhdGluZyB3ZWJzb2NrZXQgXCIgKyB0aGlzLl9udW1iZXIgKyBcIiB0byAnXCIgKyB0aGlzLnVybCArIFwiJyBzZXNzaW9uICdcIiArIHRoaXMuaWQgKyBcIidcIik7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbG9zZWRfcGVybWFuZW50bHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG4gICAgICAgIHRoaXMuX3BhcnRpYWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50X2hhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wZW5kaW5nX2FjayA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdfcmVwbGllcyA9IHt9O1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgIH1cbiAgICBDbGllbnRDb25uZWN0aW9uLnByb3RvdHlwZS5fZm9yX3Nlc3Npb24gPSBmdW5jdGlvbiAoZikge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZih0aGlzLnNlc3Npb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbGllbnRDb25uZWN0aW9uLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXJyb3IsIHJlZiwgdmVyc2lvbmVkX3VybDtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkX3Blcm1hbmVudGx5KSB7XG4gICAgICAgICAgICByZXR1cm4gZXM2X3Byb21pc2VfMS5Qcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJDYW5ub3QgY29ubmVjdCgpIGEgY2xvc2VkIENsaWVudENvbm5lY3Rpb25cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNvY2tldCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZXM2X3Byb21pc2VfMS5Qcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJBbHJlYWR5IGNvbm5lY3RlZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG4gICAgICAgIHRoaXMuX3BhcnRpYWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9wZW5kaW5nX3JlcGxpZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fY3VycmVudF9oYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZlcnNpb25lZF91cmwgPSB0aGlzLnVybCArIFwiP2Jva2VoLXByb3RvY29sLXZlcnNpb249MS4wJmJva2VoLXNlc3Npb24taWQ9XCIgKyB0aGlzLmlkO1xuICAgICAgICAgICAgaWYgKCgocmVmID0gdGhpcy5hcmdzX3N0cmluZykgIT0gbnVsbCA/IHJlZi5sZW5ndGggOiB2b2lkIDApID4gMCkge1xuICAgICAgICAgICAgICAgIHZlcnNpb25lZF91cmwgKz0gXCImXCIgKyB0aGlzLmFyZ3Nfc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpbmRvdy5Nb3pXZWJTb2NrZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gbmV3IE1veldlYlNvY2tldCh2ZXJzaW9uZWRfdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gbmV3IFdlYlNvY2tldCh2ZXJzaW9uZWRfdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgZXM2X3Byb21pc2VfMS5Qcm9taXNlKChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fb25fb3BlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX29uX21lc3NhZ2UoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zb2NrZXQub25jbG9zZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9vbl9jbG9zZShldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fb25fZXJyb3IocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgICAgIGVycm9yID0gZXJyb3IxO1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIndlYnNvY2tldCBjcmVhdGlvbiBmYWlsZWQgdG8gdXJsOiBcIiArIHRoaXMudXJsKTtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZXJyb3IoXCIgLSBcIiArIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBlczZfcHJvbWlzZV8xLlByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2xpZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jbG9zZWRfcGVybWFuZW50bHkpIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJQZXJtYW5lbnRseSBjbG9zaW5nIHdlYnNvY2tldCBjb25uZWN0aW9uIFwiICsgdGhpcy5fbnVtYmVyKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VkX3Blcm1hbmVudGx5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvY2tldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoMTAwMCwgXCJjbG9zZSBtZXRob2QgY2FsbGVkIG9uIENsaWVudENvbm5lY3Rpb24gXCIgKyB0aGlzLl9udW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZm9yX3Nlc3Npb24oZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbi5fY29ubmVjdGlvbl9jbG9zZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29uX2Nsb3NlZF9wZXJtYW5lbnRseV9ob29rICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbl9jbG9zZWRfcGVybWFuZW50bHlfaG9vaygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbl9jbG9zZWRfcGVybWFuZW50bHlfaG9vayA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rpb24ucHJvdG90eXBlLl9zY2hlZHVsZV9yZWNvbm5lY3QgPSBmdW5jdGlvbiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgIHZhciByZXRyeTtcbiAgICAgICAgcmV0cnkgPSAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0cnVlIHx8IF90aGlzLmNsb3NlZF9wZXJtYW5lbnRseSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmNsb3NlZF9wZXJtYW5lbnRseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5pbmZvKFwiV2Vic29ja2V0IGNvbm5lY3Rpb24gXCIgKyBfdGhpcy5fbnVtYmVyICsgXCIgZGlzY29ubmVjdGVkLCB3aWxsIG5vdCBhdHRlbXB0IHRvIHJlY29ubmVjdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcIkF0dGVtcHRpbmcgdG8gcmVjb25uZWN0IHdlYnNvY2tldCBcIiArIF90aGlzLl9udW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpO1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChyZXRyeSwgbWlsbGlzZWNvbmRzKTtcbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBjb25uZWN0ZWQgc28gY2Fubm90IHNlbmQgXCIgKyBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZS5zZW5kKHRoaXMuc29ja2V0KTtcbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRfZXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlLmNyZWF0ZSgnRVZFTlQnLCB7fSwgSlNPTi5zdHJpbmdpZnkoZXZlbnQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChtZXNzYWdlKTtcbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRfd2l0aF9yZXBseSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBwcm9taXNlO1xuICAgICAgICBwcm9taXNlID0gbmV3IGVzNl9wcm9taXNlXzEuUHJvbWlzZSgoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9wZW5kaW5nX3JlcGxpZXNbbWVzc2FnZS5tc2dpZCgpXSA9IFtyZXNvbHZlLCByZWplY3RdO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZW5kKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tc2d0eXBlKCkgPT09ICdFUlJPUicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciByZXBseSBcIiArIG1lc3NhZ2UuY29udGVudFsndGV4dCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rpb24ucHJvdG90eXBlLl9wdWxsX2RvY19qc29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWVzc2FnZSwgcHJvbWlzZTtcbiAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2UuY3JlYXRlKCdQVUxMLURPQy1SRVEnLCB7fSk7XG4gICAgICAgIHByb21pc2UgPSB0aGlzLnNlbmRfd2l0aF9yZXBseShtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVwbHkpIHtcbiAgICAgICAgICAgIGlmICghKCdkb2MnIGluIHJlcGx5LmNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gJ2RvYycgZmllbGQgaW4gUFVMTC1ET0MtUkVQTFlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVwbHkuY29udGVudFsnZG9jJ107XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2xpZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuX3JlcHVsbF9zZXNzaW9uX2RvYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcIlB1bGxpbmcgc2Vzc2lvbiBmb3IgZmlyc3QgdGltZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJSZXB1bGxpbmcgc2Vzc2lvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHVsbF9kb2NfanNvbigpLnRoZW4oKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkb2NfanNvbikge1xuICAgICAgICAgICAgICAgIHZhciBkb2N1bWVudCwgcGF0Y2gsIHBhdGNoX21lc3NhZ2U7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnNlc3Npb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmNsb3NlZF9wZXJtYW5lbnRseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJHb3QgbmV3IGRvY3VtZW50IGFmdGVyIGNvbm5lY3Rpb24gd2FzIGFscmVhZHkgY2xvc2VkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQgPSBkb2N1bWVudF8xLkRvY3VtZW50LmZyb21fanNvbihkb2NfanNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaCA9IGRvY3VtZW50XzEuRG9jdW1lbnQuX2NvbXB1dGVfcGF0Y2hfc2luY2VfanNvbihkb2NfanNvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGNoLmV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcIlNlbmRpbmcgXCIgKyBwYXRjaC5ldmVudHMubGVuZ3RoICsgXCIgY2hhbmdlcyBmcm9tIG1vZGVsIGNvbnN0cnVjdGlvbiBiYWNrIHRvIHNlcnZlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaF9tZXNzYWdlID0gTWVzc2FnZS5jcmVhdGUoJ1BBVENILURPQycsIHt9LCBwYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VuZChwYXRjaF9tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNlc3Npb24gPSBuZXcgQ2xpZW50U2Vzc2lvbihfdGhpcywgZG9jdW1lbnQsIF90aGlzLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJDcmVhdGVkIGEgbmV3IHNlc3Npb24gZnJvbSBuZXcgcHVsbGVkIGRvY1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fb25faGF2ZV9zZXNzaW9uX2hvb2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9vbl9oYXZlX3Nlc3Npb25faG9vayhfdGhpcy5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX29uX2hhdmVfc2Vzc2lvbl9ob29rID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2Vzc2lvbi5kb2N1bWVudC5yZXBsYWNlX3dpdGhfanNvbihkb2NfanNvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiVXBkYXRlZCBleGlzdGluZyBzZXNzaW9uIHdpdGggbmV3IHB1bGxlZCBkb2NcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcyksIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoY29uc29sZS50cmFjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS50cmFjZShlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byByZXB1bGwgc2Vzc2lvbiBcIiArIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDbGllbnRDb25uZWN0aW9uLnByb3RvdHlwZS5fb25fb3BlbiA9IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5pbmZvKFwiV2Vic29ja2V0IGNvbm5lY3Rpb24gXCIgKyB0aGlzLl9udW1iZXIgKyBcIiBpcyBub3cgb3BlblwiKTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ19hY2sgPSBbcmVzb2x2ZSwgcmVqZWN0XTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRfaGFuZGxlciA9IChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYXdhaXRpbmdfYWNrX2hhbmRsZXIobWVzc2FnZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKTtcbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rpb24ucHJvdG90eXBlLl9vbl9tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbl9tZXNzYWdlX3VuY2hlY2tlZChldmVudCk7XG4gICAgfTtcbiAgICBDbGllbnRDb25uZWN0aW9uLnByb3RvdHlwZS5fb25fbWVzc2FnZV91bmNoZWNrZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIG1zZywgcHJvYmxlbTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRfaGFuZGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmVycm9yKFwiZ290IGEgbWVzc2FnZSBidXQgaGF2ZW4ndCBzZXQgX2N1cnJlbnRfaGFuZGxlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuX3BhcnRpYWwgIT0gbnVsbCkgJiYgIXRoaXMuX3BhcnRpYWwuY29tcGxldGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnRpYWwuYWRkX2J1ZmZlcihldmVudC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlX2JhZF9wcm90b2NvbChcIkdvdCBiaW5hcnkgZnJvbSB3ZWJzb2NrZXQgYnV0IHdlIHdlcmUgZXhwZWN0aW5nIHRleHRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcGFydGlhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZV9iYWRfcHJvdG9jb2woXCJHb3QgdGV4dCBmcm9tIHdlYnNvY2tldCBidXQgd2Ugd2VyZSBleHBlY3RpbmcgYmluYXJ5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZnJhZ21lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnRpYWwgPSBNZXNzYWdlLmFzc2VtYmxlKHRoaXMuX2ZyYWdtZW50c1swXSwgdGhpcy5fZnJhZ21lbnRzWzFdLCB0aGlzLl9mcmFnbWVudHNbMl0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHByb2JsZW0gPSB0aGlzLl9wYXJ0aWFsLnByb2JsZW0oKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvYmxlbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZV9iYWRfcHJvdG9jb2wocHJvYmxlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5fcGFydGlhbCAhPSBudWxsKSAmJiB0aGlzLl9wYXJ0aWFsLmNvbXBsZXRlKCkpIHtcbiAgICAgICAgICAgIG1zZyA9IHRoaXMuX3BhcnRpYWw7XG4gICAgICAgICAgICB0aGlzLl9wYXJ0aWFsID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50X2hhbmRsZXIobXNnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2xpZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuX29uX2Nsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBwb3BfcGVuZGluZywgcHJvbWlzZV9mdW5jcztcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5pbmZvKFwiTG9zdCB3ZWJzb2NrZXQgXCIgKyB0aGlzLl9udW1iZXIgKyBcIiBjb25uZWN0aW9uLCBcIiArIGV2ZW50LmNvZGUgKyBcIiAoXCIgKyBldmVudC5yZWFzb24gKyBcIilcIik7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdfYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdfYWNrWzFdKG5ldyBFcnJvcihcIkxvc3Qgd2Vic29ja2V0IGNvbm5lY3Rpb24sIFwiICsgZXZlbnQuY29kZSArIFwiIChcIiArIGV2ZW50LnJlYXNvbiArIFwiKVwiKSk7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nX2FjayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcG9wX3BlbmRpbmcgPSAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlX2Z1bmNzLCByZWYsIHJlcWlkO1xuICAgICAgICAgICAgICAgIHJlZiA9IF90aGlzLl9wZW5kaW5nX3JlcGxpZXM7XG4gICAgICAgICAgICAgICAgZm9yIChyZXFpZCBpbiByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZV9mdW5jcyA9IHJlZltyZXFpZF07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5fcGVuZGluZ19yZXBsaWVzW3JlcWlkXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfZnVuY3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcyk7XG4gICAgICAgIHByb21pc2VfZnVuY3MgPSBwb3BfcGVuZGluZygpO1xuICAgICAgICB3aGlsZSAocHJvbWlzZV9mdW5jcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvbWlzZV9mdW5jc1sxXShcIkRpc2Nvbm5lY3RlZFwiKTtcbiAgICAgICAgICAgIHByb21pc2VfZnVuY3MgPSBwb3BfcGVuZGluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jbG9zZWRfcGVybWFuZW50bHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZV9yZWNvbm5lY3QoMjAwMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rpb24ucHJvdG90eXBlLl9vbl9lcnJvciA9IGZ1bmN0aW9uIChyZWplY3QpIHtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcIldlYnNvY2tldCBlcnJvciBvbiBzb2NrZXQgIFwiICsgdGhpcy5fbnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJDb3VsZCBub3Qgb3BlbiB3ZWJzb2NrZXRcIikpO1xuICAgIH07XG4gICAgQ2xpZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuX2Nsb3NlX2JhZF9wcm90b2NvbCA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIkNsb3NpbmcgY29ubmVjdGlvbjogXCIgKyBkZXRhaWwpO1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0LmNsb3NlKDEwMDIsIGRldGFpbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rpb24ucHJvdG90eXBlLl9hd2FpdGluZ19hY2tfaGFuZGxlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm1zZ3R5cGUoKSA9PT0gXCJBQ0tcIikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudF9oYW5kbGVyID0gKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3N0ZWFkeV9zdGF0ZV9oYW5kbGVyKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcHVsbF9zZXNzaW9uX2RvYygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdfYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nX2Fja1swXSh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ19hY2sgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlX2JhZF9wcm90b2NvbChcIkZpcnN0IG1lc3NhZ2Ugd2FzIG5vdCBhbiBBQ0tcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rpb24ucHJvdG90eXBlLl9zdGVhZHlfc3RhdGVfaGFuZGxlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBwcm9taXNlX2Z1bmNzO1xuICAgICAgICBpZiAobWVzc2FnZS5yZXFpZCgpIGluIHRoaXMuX3BlbmRpbmdfcmVwbGllcykge1xuICAgICAgICAgICAgcHJvbWlzZV9mdW5jcyA9IHRoaXMuX3BlbmRpbmdfcmVwbGllc1ttZXNzYWdlLnJlcWlkKCldO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdfcmVwbGllc1ttZXNzYWdlLnJlcWlkKCldO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfZnVuY3NbMF0obWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5tc2d0eXBlKCkgaW4gbWVzc2FnZV9oYW5kbGVycykge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VfaGFuZGxlcnNbbWVzc2FnZS5tc2d0eXBlKCldKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJEb2luZyBub3RoaW5nIHdpdGggbWVzc2FnZSBcIiArIChtZXNzYWdlLm1zZ3R5cGUoKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2xpZW50Q29ubmVjdGlvbjtcbn0pKCk7XG5DbGllbnRTZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGllbnRTZXNzaW9uKF9jb25uZWN0aW9uLCBkb2N1bWVudDEsIGlkKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBfY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50MTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmRvY3VtZW50X2xpc3RlbmVyID0gKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZG9jdW1lbnRfY2hhbmdlZChldmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5vbl9jaGFuZ2UodGhpcy5kb2N1bWVudF9saXN0ZW5lcik7XG4gICAgICAgIHRoaXMuZXZlbnRfbWFuYWdlciA9IHRoaXMuZG9jdW1lbnQuZXZlbnRfbWFuYWdlcjtcbiAgICAgICAgdGhpcy5ldmVudF9tYW5hZ2VyLnNlc3Npb24gPSB0aGlzO1xuICAgIH1cbiAgICBDbGllbnRTZXNzaW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9O1xuICAgIENsaWVudFNlc3Npb24ucHJvdG90eXBlLnNlbmRfZXZlbnQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbi5zZW5kX2V2ZW50KHR5cGUpO1xuICAgIH07XG4gICAgQ2xpZW50U2Vzc2lvbi5wcm90b3R5cGUuX2Nvbm5lY3Rpb25fY2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5yZW1vdmVfb25fY2hhbmdlKHRoaXMuZG9jdW1lbnRfbGlzdGVuZXIpO1xuICAgIH07XG4gICAgQ2xpZW50U2Vzc2lvbi5wcm90b3R5cGUucmVxdWVzdF9zZXJ2ZXJfaW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UsIHByb21pc2U7XG4gICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlLmNyZWF0ZSgnU0VSVkVSLUlORk8tUkVRJywge30pO1xuICAgICAgICBwcm9taXNlID0gdGhpcy5fY29ubmVjdGlvbi5zZW5kX3dpdGhfcmVwbHkobWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcGx5KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbHkuY29udGVudDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDbGllbnRTZXNzaW9uLnByb3RvdHlwZS5mb3JjZV9yb3VuZHRyaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Rfc2VydmVyX2luZm8oKS50aGVuKGZ1bmN0aW9uIChpZ25vcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENsaWVudFNlc3Npb24ucHJvdG90eXBlLl9kb2N1bWVudF9jaGFuZ2VkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBwYXRjaDtcbiAgICAgICAgaWYgKGV2ZW50LnNldHRlcl9pZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIGRvY3VtZW50XzEuTW9kZWxDaGFuZ2VkRXZlbnQgJiYgIShldmVudC5hdHRyIGluIGV2ZW50Lm1vZGVsLnNlcmlhbGl6YWJsZV9hdHRyaWJ1dGVzKCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2ggPSBNZXNzYWdlLmNyZWF0ZSgnUEFUQ0gtRE9DJywge30sIHRoaXMuZG9jdW1lbnQuY3JlYXRlX2pzb25fcGF0Y2goW2V2ZW50XSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbi5zZW5kKHBhdGNoKTtcbiAgICB9O1xuICAgIENsaWVudFNlc3Npb24ucHJvdG90eXBlLl9oYW5kbGVfcGF0Y2ggPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5hcHBseV9qc29uX3BhdGNoKG1lc3NhZ2UuY29udGVudCwgdGhpcy5pZCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2xpZW50U2Vzc2lvbjtcbn0pKCk7XG5leHBvcnRzLnB1bGxfc2Vzc2lvbiA9IGZ1bmN0aW9uICh1cmwsIHNlc3Npb25faWQsIGFyZ3Nfc3RyaW5nKSB7XG4gICAgdmFyIGNvbm5lY3Rpb24sIHByb21pc2UsIHJlamVjdGVyO1xuICAgIHJlamVjdGVyID0gbnVsbDtcbiAgICBjb25uZWN0aW9uID0gbnVsbDtcbiAgICBwcm9taXNlID0gbmV3IGVzNl9wcm9taXNlXzEuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGNvbm5lY3Rpb24gPSBuZXcgQ2xpZW50Q29ubmVjdGlvbih1cmwsIHNlc3Npb25faWQsIGFyZ3Nfc3RyaW5nLCBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICAgICAgICAgIGUgPSBlcnJvcjE7XG4gICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIlByb21pc2UgaGFuZGxlciB0aHJldyBhbiBlcnJvciwgY2xvc2luZyBzZXNzaW9uIFwiICsgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gd2FzIGNsb3NlZCBiZWZvcmUgd2Ugc3VjY2Vzc2Z1bGx5IHB1bGxlZCBhIHNlc3Npb25cIikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uY29ubmVjdCgpLnRoZW4oZnVuY3Rpb24gKHdoYXRldmVyKSB7IH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBjb25uZWN0IHRvIEJva2VoIHNlcnZlciBcIiArIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBwcm9taXNlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcIi4vdXRpbC9vYmplY3RcIik7XG52YXIgZXZlbnRfY2xhc3NlcyA9IHt9O1xuZnVuY3Rpb24gcmVnaXN0ZXJfZXZlbnRfY2xhc3MoZXZlbnRfbmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnRfY2xzKSB7XG4gICAgICAgIGV2ZW50X2Nscy5wcm90b3R5cGUuZXZlbnRfbmFtZSA9IGV2ZW50X25hbWU7XG4gICAgICAgIGV2ZW50X2NsYXNzZXNbZXZlbnRfbmFtZV0gPSBldmVudF9jbHM7XG4gICAgfTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJfZXZlbnRfY2xhc3MgPSByZWdpc3Rlcl9ldmVudF9jbGFzcztcbmZ1bmN0aW9uIHJlZ2lzdGVyX3dpdGhfZXZlbnQoZXZlbnRfY2xzKSB7XG4gICAgdmFyIG1vZGVscyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG1vZGVsc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGFwcGxpY2FibGVfbW9kZWxzID0gZXZlbnRfY2xzLnByb3RvdHlwZS5hcHBsaWNhYmxlX21vZGVscy5jb25jYXQobW9kZWxzKTtcbiAgICBldmVudF9jbHMucHJvdG90eXBlLmFwcGxpY2FibGVfbW9kZWxzID0gYXBwbGljYWJsZV9tb2RlbHM7XG59XG5leHBvcnRzLnJlZ2lzdGVyX3dpdGhfZXZlbnQgPSByZWdpc3Rlcl93aXRoX2V2ZW50O1xudmFyIEJva2VoRXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJva2VoRXZlbnQob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLm1vZGVsX2lkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zLm1vZGVsX2lkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsX2lkID0gb3B0aW9ucy5tb2RlbF9pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBCb2tlaEV2ZW50LnByb3RvdHlwZS5zZXRfbW9kZWxfaWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5tb2RlbF9pZCA9IGlkO1xuICAgICAgICB0aGlzLm1vZGVsX2lkID0gaWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQm9rZWhFdmVudC5wcm90b3R5cGUuaXNfYXBwbGljYWJsZV90byA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGljYWJsZV9tb2RlbHMuc29tZShmdW5jdGlvbiAobW9kZWwpIHsgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIG1vZGVsOyB9KTtcbiAgICB9O1xuICAgIEJva2VoRXZlbnQuZXZlbnRfY2xhc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBHaXZlbiBhbiBldmVudCB3aXRoIGEgdHlwZSBhdHRyaWJ1dGUgbWF0Y2hpbmcgdGhlIGV2ZW50X25hbWUsXG4gICAgICAgIC8vIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgQm9rZWhFdmVudCBjbGFzc1xuICAgICAgICBpZiAoZS50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRfY2xhc3Nlc1tlLnR5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci53YXJuKCdCb2tlaEV2ZW50LmV2ZW50X2NsYXNzIHJlcXVpcmVkIGV2ZW50cyB3aXRoIGEgc3RyaW5nIHR5cGUgYXR0cmlidXRlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJva2VoRXZlbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV2ZW50X25hbWU6IHRoaXMuZXZlbnRfbmFtZSxcbiAgICAgICAgICAgIGV2ZW50X3ZhbHVlczogb2JqZWN0XzEuY2xvbmUodGhpcy5fb3B0aW9ucyksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBCb2tlaEV2ZW50LnByb3RvdHlwZS5fY3VzdG9taXplX2V2ZW50ID0gZnVuY3Rpb24gKF9tb2RlbCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBCb2tlaEV2ZW50O1xufSgpKTtcbmV4cG9ydHMuQm9rZWhFdmVudCA9IEJva2VoRXZlbnQ7XG5Cb2tlaEV2ZW50LnByb3RvdHlwZS5hcHBsaWNhYmxlX21vZGVscyA9IFtdO1xudmFyIEJ1dHRvbkNsaWNrID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhCdXR0b25DbGljaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXR0b25DbGljaygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnV0dG9uQ2xpY2s7XG59KEJva2VoRXZlbnQpKTtcbkJ1dHRvbkNsaWNrID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICByZWdpc3Rlcl9ldmVudF9jbGFzcyhcImJ1dHRvbl9jbGlja1wiKVxuXSwgQnV0dG9uQ2xpY2spO1xuZXhwb3J0cy5CdXR0b25DbGljayA9IEJ1dHRvbkNsaWNrO1xuLy8gQSBVSUV2ZW50IGlzIGFuIGV2ZW50IG9yaWdpbmF0aW5nIG9uIGEgUGxvdENhbnZhcyB0aGlzIGluY2x1ZGVzXG4vLyBET00gZXZlbnRzIHN1Y2ggYXMga2V5c3Ryb2tlcyBhcyB3ZWxsIGFzIGhhbW1lciBldmVudHMgYW5kIExPRCBldmVudHMuXG52YXIgVUlFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVUlFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVSUV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBVSUV2ZW50O1xufShCb2tlaEV2ZW50KSk7XG5leHBvcnRzLlVJRXZlbnQgPSBVSUV2ZW50O1xudmFyIExPRFN0YXJ0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhMT0RTdGFydCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMT0RTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTE9EU3RhcnQ7XG59KFVJRXZlbnQpKTtcbkxPRFN0YXJ0ID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICByZWdpc3Rlcl9ldmVudF9jbGFzcyhcImxvZHN0YXJ0XCIpXG5dLCBMT0RTdGFydCk7XG5leHBvcnRzLkxPRFN0YXJ0ID0gTE9EU3RhcnQ7XG52YXIgTE9ERW5kID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhMT0RFbmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTE9ERW5kKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBMT0RFbmQ7XG59KFVJRXZlbnQpKTtcbkxPREVuZCA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgcmVnaXN0ZXJfZXZlbnRfY2xhc3MoXCJsb2RlbmRcIilcbl0sIExPREVuZCk7XG5leHBvcnRzLkxPREVuZCA9IExPREVuZDtcbnZhciBQb2ludEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQb2ludEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvaW50RXZlbnQob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zeCA9IG9wdGlvbnMuc3g7XG4gICAgICAgIF90aGlzLnN5ID0gb3B0aW9ucy5zeTtcbiAgICAgICAgX3RoaXMueCA9IG51bGw7XG4gICAgICAgIF90aGlzLnkgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBvaW50RXZlbnQuZnJvbV9ldmVudCA9IGZ1bmN0aW9uIChlLCBtb2RlbF9pZCkge1xuICAgICAgICBpZiAobW9kZWxfaWQgPT09IHZvaWQgMCkgeyBtb2RlbF9pZCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHsgc3g6IGUuYm9rZWhbJ3N4J10sIHN5OiBlLmJva2VoWydzeSddLCBtb2RlbF9pZDogbW9kZWxfaWQgfSk7XG4gICAgfTtcbiAgICBQb2ludEV2ZW50LnByb3RvdHlwZS5fY3VzdG9taXplX2V2ZW50ID0gZnVuY3Rpb24gKHBsb3QpIHtcbiAgICAgICAgdmFyIHhzY2FsZSA9IHBsb3QucGxvdF9jYW52YXMuZnJhbWUueHNjYWxlc1snZGVmYXVsdCddO1xuICAgICAgICB2YXIgeXNjYWxlID0gcGxvdC5wbG90X2NhbnZhcy5mcmFtZS55c2NhbGVzWydkZWZhdWx0J107XG4gICAgICAgIHRoaXMueCA9IHhzY2FsZS5pbnZlcnQocGxvdC5wbG90X2NhbnZhcy5jYW52YXMuc3hfdG9fdngodGhpcy5zeCkpO1xuICAgICAgICB0aGlzLnkgPSB5c2NhbGUuaW52ZXJ0KHBsb3QucGxvdF9jYW52YXMuY2FudmFzLnN5X3RvX3Z5KHRoaXMuc3kpKTtcbiAgICAgICAgdGhpcy5fb3B0aW9uc1sneCddID0gdGhpcy54O1xuICAgICAgICB0aGlzLl9vcHRpb25zWyd5J10gPSB0aGlzLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFBvaW50RXZlbnQ7XG59KFVJRXZlbnQpKTtcbmV4cG9ydHMuUG9pbnRFdmVudCA9IFBvaW50RXZlbnQ7XG52YXIgUGFuID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQYW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFuKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGVsdGFfeCA9IG9wdGlvbnMuZGVsdGFfeDtcbiAgICAgICAgX3RoaXMuZGVsdGFfeSA9IG9wdGlvbnMuZGVsdGFfeTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQYW4uZnJvbV9ldmVudCA9IGZ1bmN0aW9uIChlLCBtb2RlbF9pZCkge1xuICAgICAgICBpZiAobW9kZWxfaWQgPT09IHZvaWQgMCkgeyBtb2RlbF9pZCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHtcbiAgICAgICAgICAgIHN4OiBlLmJva2VoWydzeCddLFxuICAgICAgICAgICAgc3k6IGUuYm9rZWhbJ3N5J10sXG4gICAgICAgICAgICBkZWx0YV94OiBlLmRlbHRhWCxcbiAgICAgICAgICAgIGRlbHRhX3k6IGUuZGVsdGFZLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBlLmRpcmVjdGlvbixcbiAgICAgICAgICAgIG1vZGVsX2lkOiBtb2RlbF9pZFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQYW47XG59KFBvaW50RXZlbnQpKTtcblBhbiA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgcmVnaXN0ZXJfZXZlbnRfY2xhc3MoXCJwYW5cIilcbl0sIFBhbik7XG5leHBvcnRzLlBhbiA9IFBhbjtcbnZhciBQaW5jaCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUGluY2gsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGluY2gob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zY2FsZSA9IG9wdGlvbnMuc2NhbGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUGluY2guZnJvbV9ldmVudCA9IGZ1bmN0aW9uIChlLCBtb2RlbF9pZCkge1xuICAgICAgICBpZiAobW9kZWxfaWQgPT09IHZvaWQgMCkgeyBtb2RlbF9pZCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHtcbiAgICAgICAgICAgIHN4OiBlLmJva2VoWydzeCddLFxuICAgICAgICAgICAgc3k6IGUuYm9rZWhbJ3N5J10sXG4gICAgICAgICAgICBzY2FsZTogZS5zY2FsZSxcbiAgICAgICAgICAgIG1vZGVsX2lkOiBtb2RlbF9pZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGluY2g7XG59KFBvaW50RXZlbnQpKTtcblBpbmNoID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICByZWdpc3Rlcl9ldmVudF9jbGFzcyhcInBpbmNoXCIpXG5dLCBQaW5jaCk7XG5leHBvcnRzLlBpbmNoID0gUGluY2g7XG52YXIgTW91c2VXaGVlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTW91c2VXaGVlbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb3VzZVdoZWVsKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGVsdGEgPSBvcHRpb25zLmRlbHRhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1vdXNlV2hlZWwuZnJvbV9ldmVudCA9IGZ1bmN0aW9uIChlLCBtb2RlbF9pZCkge1xuICAgICAgICBpZiAobW9kZWxfaWQgPT09IHZvaWQgMCkgeyBtb2RlbF9pZCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHtcbiAgICAgICAgICAgIHN4OiBlLmJva2VoWydzeCddLFxuICAgICAgICAgICAgc3k6IGUuYm9rZWhbJ3N5J10sXG4gICAgICAgICAgICBkZWx0YTogZS5ib2tlaFsnZGVsdGEnXSxcbiAgICAgICAgICAgIG1vZGVsX2lkOiBtb2RlbF9pZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTW91c2VXaGVlbDtcbn0oUG9pbnRFdmVudCkpO1xuTW91c2VXaGVlbCA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgcmVnaXN0ZXJfZXZlbnRfY2xhc3MoXCJ3aGVlbFwiKVxuXSwgTW91c2VXaGVlbCk7XG5leHBvcnRzLk1vdXNlV2hlZWwgPSBNb3VzZVdoZWVsO1xudmFyIE1vdXNlTW92ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTW91c2VNb3ZlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vdXNlTW92ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTW91c2VNb3ZlO1xufShQb2ludEV2ZW50KSk7XG5Nb3VzZU1vdmUgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIHJlZ2lzdGVyX2V2ZW50X2NsYXNzKFwibW91c2Vtb3ZlXCIpXG5dLCBNb3VzZU1vdmUpO1xuZXhwb3J0cy5Nb3VzZU1vdmUgPSBNb3VzZU1vdmU7XG52YXIgTW91c2VFbnRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTW91c2VFbnRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb3VzZUVudGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBNb3VzZUVudGVyO1xufShQb2ludEV2ZW50KSk7XG5Nb3VzZUVudGVyID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICByZWdpc3Rlcl9ldmVudF9jbGFzcyhcIm1vdXNlZW50ZXJcIilcbl0sIE1vdXNlRW50ZXIpO1xuZXhwb3J0cy5Nb3VzZUVudGVyID0gTW91c2VFbnRlcjtcbnZhciBNb3VzZUxlYXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNb3VzZUxlYXZlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vdXNlTGVhdmUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1vdXNlTGVhdmU7XG59KFBvaW50RXZlbnQpKTtcbk1vdXNlTGVhdmUgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIHJlZ2lzdGVyX2V2ZW50X2NsYXNzKFwibW91c2VsZWF2ZVwiKVxuXSwgTW91c2VMZWF2ZSk7XG5leHBvcnRzLk1vdXNlTGVhdmUgPSBNb3VzZUxlYXZlO1xudmFyIFRhcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVGFwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhcCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFwO1xufShQb2ludEV2ZW50KSk7XG5UYXAgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIHJlZ2lzdGVyX2V2ZW50X2NsYXNzKFwidGFwXCIpXG5dLCBUYXApO1xuZXhwb3J0cy5UYXAgPSBUYXA7XG52YXIgRG91YmxlVGFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEb3VibGVUYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRG91YmxlVGFwKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBEb3VibGVUYXA7XG59KFBvaW50RXZlbnQpKTtcbkRvdWJsZVRhcCA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgcmVnaXN0ZXJfZXZlbnRfY2xhc3MoXCJkb3VibGV0YXBcIilcbl0sIERvdWJsZVRhcCk7XG5leHBvcnRzLkRvdWJsZVRhcCA9IERvdWJsZVRhcDtcbnZhciBQcmVzcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUHJlc3MsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJlc3MoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFByZXNzO1xufShQb2ludEV2ZW50KSk7XG5QcmVzcyA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgcmVnaXN0ZXJfZXZlbnRfY2xhc3MoXCJwcmVzc1wiKVxuXSwgUHJlc3MpO1xuZXhwb3J0cy5QcmVzcyA9IFByZXNzO1xudmFyIFBhblN0YXJ0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQYW5TdGFydCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYW5TdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGFuU3RhcnQ7XG59KFBvaW50RXZlbnQpKTtcblBhblN0YXJ0ID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICByZWdpc3Rlcl9ldmVudF9jbGFzcyhcInBhbnN0YXJ0XCIpXG5dLCBQYW5TdGFydCk7XG5leHBvcnRzLlBhblN0YXJ0ID0gUGFuU3RhcnQ7XG52YXIgUGFuRW5kID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQYW5FbmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFuRW5kKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYW5FbmQ7XG59KFBvaW50RXZlbnQpKTtcblBhbkVuZCA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgcmVnaXN0ZXJfZXZlbnRfY2xhc3MoXCJwYW5lbmRcIilcbl0sIFBhbkVuZCk7XG5leHBvcnRzLlBhbkVuZCA9IFBhbkVuZDtcbnZhciBQaW5jaFN0YXJ0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQaW5jaFN0YXJ0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBpbmNoU3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBpbmNoU3RhcnQ7XG59KFBvaW50RXZlbnQpKTtcblBpbmNoU3RhcnQgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIHJlZ2lzdGVyX2V2ZW50X2NsYXNzKFwicGluY2hzdGFydFwiKVxuXSwgUGluY2hTdGFydCk7XG5leHBvcnRzLlBpbmNoU3RhcnQgPSBQaW5jaFN0YXJ0O1xudmFyIFBpbmNoRW5kID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQaW5jaEVuZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQaW5jaEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGluY2hFbmQ7XG59KFBvaW50RXZlbnQpKTtcblBpbmNoRW5kID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICByZWdpc3Rlcl9ldmVudF9jbGFzcyhcInBpbmNoZW5kXCIpXG5dLCBQaW5jaEVuZCk7XG5leHBvcnRzLlBpbmNoRW5kID0gUGluY2hFbmQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcIi4vdXRpbC9hcnJheVwiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCIuL3V0aWwvb2JqZWN0XCIpO1xuZXhwb3J0cy5idWlsZF92aWV3cyA9IGZ1bmN0aW9uICh2aWV3X3N0b3JhZ2UsIHZpZXdfbW9kZWxzLCBvcHRpb25zLCB2aWV3X3R5cGVzKSB7XG4gICAgdmFyIGNyZWF0ZWRfdmlld3MsIGksIGosIGssIGxlbiwgbGVuMSwgbW9kZWwsIG1vZGVsX2lkLCBuZXdfbW9kZWxzLCByZWYsIHRvX3JlbW92ZSwgdmlldywgdmlld19jbHMsIHZpZXdfb3B0aW9ucztcbiAgICBpZiAodmlld190eXBlcyA9PSBudWxsKSB7XG4gICAgICAgIHZpZXdfdHlwZXMgPSBbXTtcbiAgICB9XG4gICAgdG9fcmVtb3ZlID0gYXJyYXlfMS5kaWZmZXJlbmNlKE9iamVjdC5rZXlzKHZpZXdfc3RvcmFnZSksIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBqLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gdmlld19tb2RlbHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIG1vZGVsID0gdmlld19tb2RlbHNbal07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobW9kZWwuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0pKCkpO1xuICAgIGZvciAoaiA9IDAsIGxlbiA9IHRvX3JlbW92ZS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICBtb2RlbF9pZCA9IHRvX3JlbW92ZVtqXTtcbiAgICAgICAgdmlld19zdG9yYWdlW21vZGVsX2lkXS5yZW1vdmUoKTtcbiAgICAgICAgZGVsZXRlIHZpZXdfc3RvcmFnZVttb2RlbF9pZF07XG4gICAgfVxuICAgIGNyZWF0ZWRfdmlld3MgPSBbXTtcbiAgICBuZXdfbW9kZWxzID0gdmlld19tb2RlbHMuZmlsdGVyKGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICByZXR1cm4gdmlld19zdG9yYWdlW21vZGVsLmlkXSA9PSBudWxsO1xuICAgIH0pO1xuICAgIGZvciAoaSA9IGsgPSAwLCBsZW4xID0gbmV3X21vZGVscy5sZW5ndGg7IGsgPCBsZW4xOyBpID0gKytrKSB7XG4gICAgICAgIG1vZGVsID0gbmV3X21vZGVsc1tpXTtcbiAgICAgICAgdmlld19jbHMgPSAocmVmID0gdmlld190eXBlc1tpXSkgIT0gbnVsbCA/IHJlZiA6IG1vZGVsLmRlZmF1bHRfdmlldztcbiAgICAgICAgdmlld19vcHRpb25zID0gb2JqZWN0XzEuZXh0ZW5kKHtcbiAgICAgICAgICAgIG1vZGVsOiBtb2RlbFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdmlld19zdG9yYWdlW21vZGVsLmlkXSA9IHZpZXcgPSBuZXcgdmlld19jbHModmlld19vcHRpb25zKTtcbiAgICAgICAgY3JlYXRlZF92aWV3cy5wdXNoKHZpZXcpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlZF92aWV3cztcbn07XG5leHBvcnRzLnJlbW92ZV92aWV3cyA9IGZ1bmN0aW9uICh2aWV3X3N0b3JhZ2UpIHtcbiAgICB2YXIgaWQsIGosIGxlbiwgcmVmLCByZXN1bHRzO1xuICAgIHJlZiA9IG9iamVjdF8xLmtleXModmlld19zdG9yYWdlKTtcbiAgICByZXN1bHRzID0gW107XG4gICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGlkID0gcmVmW2pdO1xuICAgICAgICB2aWV3X3N0b3JhZ2VbaWRdLnJlbW92ZSgpO1xuICAgICAgICByZXN1bHRzLnB1c2goZGVsZXRlIHZpZXdfc3RvcmFnZVtpZF0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdXRpbC90eXBlc1wiKTtcbnZhciBfY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIGZ1bmN0aW9uIChhdHRycykge1xuICAgIGlmIChhdHRycyA9PT0gdm9pZCAwKSB7IGF0dHJzID0ge307IH1cbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBjaGlsZHJlbltfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgaWYgKHRhZyA9PT0gXCJmcmFnbWVudFwiKSB7XG4gICAgICAgIC8vIFhYWDogdGhpcyBpcyB3cm9uZywgYnV0IHRoZSB0aGUgY29tbW9uIHN1cGVyIHR5cGUgb2YgRG9jdW1lbnRGcmFnbWVudCBhbmQgSFRNTEVsZW1lbnQgaXNcbiAgICAgICAgLy8gTm9kZSwgd2hpY2ggZG9lc24ndCBzdXBwb3J0IGNsYXNzTGlzdCwgc3R5bGUsIGV0Yy4gYXR0cmlidXRlcy5cbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzW2F0dHJdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZXNfMS5pc0Jvb2xlYW4odmFsdWUpICYmICF2YWx1ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChhdHRyID09PSBcImNsYXNzXCIgJiYgdHlwZXNfMS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgX2IgPSB2YWx1ZTsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNscyA9IF9iW19hXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNscyAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0dHIgPT09IFwic3R5bGVcIiAmJiB0eXBlc18xLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBlbmQoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpXG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc1N0cmluZyhjaGlsZCkpXG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkKSk7XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkICE9IG51bGwgJiYgY2hpbGQgIT09IGZhbHNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgYW4gSFRNTEVsZW1lbnQsIHN0cmluZywgZmFsc2Ugb3IgbnVsbCwgZ290IFwiICsgSlNPTi5zdHJpbmdpZnkoY2hpbGQpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2MgPSAwLCBjaGlsZHJlbl8xID0gY2hpbGRyZW47IF9jIDwgY2hpbGRyZW5fMS5sZW5ndGg7IF9jKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5fMVtfY107XG4gICAgICAgIGlmICh0eXBlc18xLmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZCA9IDAsIGNoaWxkXzEgPSBjaGlsZDsgX2QgPCBjaGlsZF8xLmxlbmd0aDsgX2QrKykge1xuICAgICAgICAgICAgICAgIHZhciBfY2hpbGQgPSBjaGlsZF8xW19kXTtcbiAgICAgICAgICAgICAgICBhcHBlbmQoX2NoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhcHBlbmQoY2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn07IH07XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZywgYXR0cnMpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBjaGlsZHJlbltfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KHRhZykuYXBwbHkodm9pZCAwLCBbYXR0cnNdLmNvbmNhdChjaGlsZHJlbikpO1xufVxuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcbmV4cG9ydHMuZGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGV4cG9ydHMuc3BhbiA9IF9jcmVhdGVFbGVtZW50KFwic3BhblwiKSwgZXhwb3J0cy5saW5rID0gX2NyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpLCBleHBvcnRzLnN0eWxlID0gX2NyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSwgZXhwb3J0cy5hID0gX2NyZWF0ZUVsZW1lbnQoXCJhXCIpLCBleHBvcnRzLnAgPSBfY3JlYXRlRWxlbWVudChcInBcIiksIGV4cG9ydHMucHJlID0gX2NyZWF0ZUVsZW1lbnQoXCJwcmVcIiksIGV4cG9ydHMuYnV0dG9uID0gX2NyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksIGV4cG9ydHMuaW5wdXQgPSBfY3JlYXRlRWxlbWVudChcImlucHV0XCIpLCBleHBvcnRzLmxhYmVsID0gX2NyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKSwgZXhwb3J0cy5jYW52YXMgPSBfY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgZXhwb3J0cy51bCA9IF9jcmVhdGVFbGVtZW50KFwidWxcIiksIGV4cG9ydHMub2wgPSBfY3JlYXRlRWxlbWVudChcIm9sXCIpLCBleHBvcnRzLmxpID0gX2NyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbmV4cG9ydHMubmJzcCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFx1MDBhMFwiKTtcbmZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICB9XG59XG5leHBvcnRzLnJlbW92ZUVsZW1lbnQgPSByZW1vdmVFbGVtZW50O1xuZnVuY3Rpb24gcmVwbGFjZVdpdGgoZWxlbWVudCwgcmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHJlcGxhY2VtZW50LCBlbGVtZW50KTtcbiAgICB9XG59XG5leHBvcnRzLnJlcGxhY2VXaXRoID0gcmVwbGFjZVdpdGg7XG5mdW5jdGlvbiBwcmVwZW5kKGVsZW1lbnQpIHtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBub2Rlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGZpcnN0ID0gZWxlbWVudC5maXJzdENoaWxkO1xuICAgIGZvciAodmFyIF9hID0gMCwgbm9kZXNfMSA9IG5vZGVzOyBfYSA8IG5vZGVzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNfMVtfYV07XG4gICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIGZpcnN0KTtcbiAgICB9XG59XG5leHBvcnRzLnByZXBlbmQgPSBwcmVwZW5kO1xuZnVuY3Rpb24gZW1wdHkoZWxlbWVudCkge1xuICAgIHZhciBjaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgPSBlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfVxufVxuZXhwb3J0cy5lbXB0eSA9IGVtcHR5O1xuZnVuY3Rpb24gc2hvdyhlbGVtZW50KSB7XG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbn1cbmV4cG9ydHMuc2hvdyA9IHNob3c7XG5mdW5jdGlvbiBoaWRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbn1cbmV4cG9ydHMuaGlkZSA9IGhpZGU7XG5mdW5jdGlvbiBwb3NpdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICAgICAgbGVmdDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgIH07XG59XG5leHBvcnRzLnBvc2l0aW9uID0gcG9zaXRpb247XG5mdW5jdGlvbiBvZmZzZXQoZWxlbWVudCkge1xuICAgIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHJlY3QudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0IC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFRvcCxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0IC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudExlZnQsXG4gICAgfTtcbn1cbmV4cG9ydHMub2Zmc2V0ID0gb2Zmc2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHZpZXdfMSA9IHJlcXVpcmUoXCIuL3ZpZXdcIik7XG52YXIgRE9NID0gcmVxdWlyZShcIi4vZG9tXCIpO1xuZXhwb3J0cy5ET01WaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERPTVZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERPTVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBET01WaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBET01WaWV3LnByb3RvdHlwZS50YWdOYW1lID0gJ2Rpdic7XG4gICAgRE9NVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIERPTVZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faGFzX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmVsID0gdGhpcy5fY3JlYXRlRWxlbWVudCgpO1xuICAgIH07XG4gICAgRE9NVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBET00ucmVtb3ZlRWxlbWVudCh0aGlzLmVsKTtcbiAgICAgICAgcmV0dXJuIERPTVZpZXcuX19zdXBlcl9fLnJlbW92ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgRE9NVmlldy5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIERPTVZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBET01WaWV3LnByb3RvdHlwZS5yZW5kZXJUbyA9IGZ1bmN0aW9uIChlbGVtZW50LCByZXBsYWNlKSB7XG4gICAgICAgIGlmIChyZXBsYWNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlcGxhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlcGxhY2UpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBET00ucmVwbGFjZVdpdGgoZWxlbWVudCwgdGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0KCk7XG4gICAgfTtcbiAgICBET01WaWV3LnByb3RvdHlwZS5oYXNfZmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNfZmluaXNoZWQ7XG4gICAgfTtcbiAgICBET01WaWV3LnByb3RvdHlwZS5ub3RpZnlfZmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Qubm90aWZ5X2ZpbmlzaGVkKCk7XG4gICAgfTtcbiAgICBET01WaWV3LmdldHRlcnMoe1xuICAgICAgICBzb2x2ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzX3Jvb3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc29sdmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnNvbHZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXNfaWRsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzX2ZpbmlzaGVkKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBET01WaWV3LnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERPTS5jcmVhdGVFbGVtZW50KHRoaXMudGFnTmFtZSwge1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBcImNsYXNzXCI6IHRoaXMuY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERPTVZpZXc7XG59KSh2aWV3XzEuVmlldyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQW5nbGVVbml0cyA9IFtcImRlZ1wiLCBcInJhZFwiXTtcbmV4cG9ydHMuRGltZW5zaW9uID0gW1wid2lkdGhcIiwgXCJoZWlnaHRcIl07XG5leHBvcnRzLkRpbWVuc2lvbnMgPSBbXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImJvdGhcIl07XG5leHBvcnRzLkRpcmVjdGlvbiA9IFtcImNsb2NrXCIsIFwiYW50aWNsb2NrXCJdO1xuZXhwb3J0cy5Gb250U3R5bGUgPSBbXCJub3JtYWxcIiwgXCJpdGFsaWNcIiwgXCJib2xkXCJdO1xuZXhwb3J0cy5MYXRMb24gPSBbXCJsYXRcIiwgXCJsb25cIl07XG5leHBvcnRzLkxpbmVDYXAgPSBbXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIl07XG5leHBvcnRzLkxpbmVKb2luID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuZXhwb3J0cy5Mb2NhdGlvbiA9IFtcImFib3ZlXCIsIFwiYmVsb3dcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl07XG5leHBvcnRzLkxlZ2VuZExvY2F0aW9uID0gW1widG9wX2xlZnRcIiwgXCJ0b3BfY2VudGVyXCIsIFwidG9wX3JpZ2h0XCIsIFwiY2VudGVyX2xlZnRcIiwgXCJjZW50ZXJcIiwgXCJjZW50ZXJfcmlnaHRcIiwgXCJib3R0b21fbGVmdFwiLCBcImJvdHRvbV9jZW50ZXJcIiwgXCJib3R0b21fcmlnaHRcIl07XG5leHBvcnRzLk9yaWVudGF0aW9uID0gW1widmVydGljYWxcIiwgXCJob3Jpem9udGFsXCJdO1xuZXhwb3J0cy5PdXRwdXRCYWNrZW5kID0gW1wiY2FudmFzXCIsIFwic3ZnXCIsIFwid2ViZ2xcIl07XG5leHBvcnRzLlJlbmRlckxldmVsID0gW1wiaW1hZ2VcIiwgXCJ1bmRlcmxheVwiLCBcImdseXBoXCIsIFwiYW5ub3RhdGlvblwiLCBcIm92ZXJsYXlcIl07XG5leHBvcnRzLlJlbmRlck1vZGUgPSBbXCJjYW52YXNcIiwgXCJjc3NcIl07XG5leHBvcnRzLlNpZGUgPSBbXCJsZWZ0XCIsIFwicmlnaHRcIl07XG5leHBvcnRzLlNwYXRpYWxVbml0cyA9IFtcInNjcmVlblwiLCBcImRhdGFcIl07XG5leHBvcnRzLlN0YXJ0RW5kID0gW1wic3RhcnRcIiwgXCJlbmRcIl07XG5leHBvcnRzLlRleHRBbGlnbiA9IFtcImxlZnRcIiwgXCJyaWdodFwiLCBcImNlbnRlclwiXTtcbmV4cG9ydHMuVGV4dEJhc2VsaW5lID0gW1widG9wXCIsIFwibWlkZGxlXCIsIFwiYm90dG9tXCIsIFwiYWxwaGFiZXRpY1wiLCBcImhhbmdpbmdcIiwgXCJpZGVvZ3JhcGhpY1wiXTtcbmV4cG9ydHMuRGlzdHJpYnV0aW9uVHlwZXMgPSBbXCJ1bmlmb3JtXCIsIFwibm9ybWFsXCJdO1xuZXhwb3J0cy5UcmFuc2Zvcm1TdGVwTW9kZXMgPSBbXCJhZnRlclwiLCBcImJlZm9yZVwiLCBcImNlbnRlclwiXTtcbmV4cG9ydHMuU2l6aW5nTW9kZSA9IFtcInN0cmV0Y2hfYm90aFwiLCBcInNjYWxlX3dpZHRoXCIsIFwic2NhbGVfaGVpZ2h0XCIsIFwic2NhbGVfYm90aFwiLCBcImZpeGVkXCJdO1xuZXhwb3J0cy5QYWRkaW5nVW5pdHMgPSBbXCJwZXJjZW50XCIsIFwiYWJzb2x1dGVcIl07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQxID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBzbGljZSA9IFtdLnNsaWNlO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG52YXIgc2lnbmFsaW5nXzEgPSByZXF1aXJlKFwiLi9zaWduYWxpbmdcIik7XG52YXIgcHJvcGVydHlfbWl4aW5zID0gcmVxdWlyZShcIi4vcHJvcGVydHlfbWl4aW5zXCIpO1xudmFyIHJlZnMgPSByZXF1aXJlKFwiLi91dGlsL3JlZnNcIik7XG52YXIgcCA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXNcIik7XG52YXIgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi91dGlsL3N0cmluZ1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcIi4vdXRpbC9hcnJheVwiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCIuL3V0aWwvb2JqZWN0XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi91dGlsL3R5cGVzXCIpO1xudmFyIGVxXzEgPSByZXF1aXJlKFwiLi91dGlsL2VxXCIpO1xuZXhwb3J0cy5IYXNQcm9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZXh0ZW5kMShIYXNQcm9wcy5wcm90b3R5cGUsIHNpZ25hbGluZ18xLlNpZ25hbGFibGUpO1xuICAgIEhhc1Byb3BzLmdldHRlcnMgPSBmdW5jdGlvbiAoc3BlY3MpIHtcbiAgICAgICAgdmFyIGZuLCBuYW1lLCByZXN1bHRzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobmFtZSBpbiBzcGVjcykge1xuICAgICAgICAgICAgZm4gPSBzcGVjc1tuYW1lXTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZuXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUucHJvcHMgPSB7fTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUubWl4aW5zID0gW107XG4gICAgSGFzUHJvcHMuZGVmaW5lID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICB2YXIgbmFtZSwgcHJvcCwgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBwcm9wID0gb2JqZWN0W25hbWVdO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUsIHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRfdmFsdWUsIGludGVybmFsLCBwcm9wcywgcmVmaW5lZF9wcm9wLCB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvdG90eXBlLnByb3BzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dGVtcHRlZCB0byByZWRlZmluZSBwcm9wZXJ0eSAnXCIgKyBfdGhpcy5uYW1lICsgXCIuXCIgKyBuYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm90b3R5cGVbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0ZW1wdGVkIHRvIHJlZGVmaW5lIGF0dHJpYnV0ZSAnXCIgKyBfdGhpcy5uYW1lICsgXCIuXCIgKyBuYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcy5wcm90b3R5cGUsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0dihuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHYobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHByb3BbMF0sIGRlZmF1bHRfdmFsdWUgPSBwcm9wWzFdLCBpbnRlcm5hbCA9IHByb3BbMl07XG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRfcHJvcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0X3ZhbHVlOiBkZWZhdWx0X3ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWw6IGludGVybmFsICE9IG51bGwgPyBpbnRlcm5hbCA6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHByb3BzID0gb2JqZWN0XzEuY2xvbmUoX3RoaXMucHJvdG90eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSByZWZpbmVkX3Byb3A7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm90b3R5cGUucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkodGhpcykobmFtZSwgcHJvcCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgSGFzUHJvcHMuaW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIHZhciBfb2JqZWN0LCBmbjEsIG5hbWUsIHByb3A7XG4gICAgICAgIF9vYmplY3QgPSB7fTtcbiAgICAgICAgZm4xID0gKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRfdmFsdWUsIHR5cGU7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHByb3BbMF0sIGRlZmF1bHRfdmFsdWUgPSBwcm9wWzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiBfb2JqZWN0W25hbWVdID0gW3R5cGUsIGRlZmF1bHRfdmFsdWUsIHRydWVdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcyk7XG4gICAgICAgIGZvciAobmFtZSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIHByb3AgPSBvYmplY3RbbmFtZV07XG4gICAgICAgICAgICBmbjEobmFtZSwgcHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmaW5lKF9vYmplY3QpO1xuICAgIH07XG4gICAgSGFzUHJvcHMubWl4aW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtaXhpbnMsIG5hbWVzO1xuICAgICAgICBuYW1lcyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgICAgICB0aGlzLmRlZmluZShwcm9wZXJ0eV9taXhpbnMuY3JlYXRlKG5hbWVzKSk7XG4gICAgICAgIG1peGlucyA9IHRoaXMucHJvdG90eXBlLm1peGlucy5jb25jYXQobmFtZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUubWl4aW5zID0gbWl4aW5zO1xuICAgIH07XG4gICAgSGFzUHJvcHMubWl4aW5zID0gZnVuY3Rpb24gKG5hbWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1peGluLmFwcGx5KHRoaXMsIG5hbWVzKTtcbiAgICB9O1xuICAgIEhhc1Byb3BzLm92ZXJyaWRlID0gZnVuY3Rpb24gKG5hbWVfb3Jfb2JqZWN0LCBkZWZhdWx0X3ZhbHVlKSB7XG4gICAgICAgIHZhciBuYW1lLCBvYmplY3QsIHJlc3VsdHM7XG4gICAgICAgIGlmICh0eXBlc18xLmlzU3RyaW5nKG5hbWVfb3Jfb2JqZWN0KSkge1xuICAgICAgICAgICAgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBvYmplY3RbbmFtZV0gPSBkZWZhdWx0X3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqZWN0ID0gbmFtZV9vcl9vYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBkZWZhdWx0X3ZhbHVlID0gb2JqZWN0W25hbWVdO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzLCB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5wcm90b3R5cGUucHJvcHNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdHRlbXB0ZWQgdG8gb3ZlcnJpZGUgbm9uZXhpc3RlbnQgJ1wiICsgX3RoaXMubmFtZSArIFwiLlwiICsgbmFtZSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IG9iamVjdF8xLmNsb25lKF90aGlzLnByb3RvdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW25hbWVdID0gb2JqZWN0XzEuZXh0ZW5kKHt9LCB2YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdF92YWx1ZTogZGVmYXVsdF92YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3RvdHlwZS5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSh0aGlzKShuYW1lLCBkZWZhdWx0X3ZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBIYXNQcm9wcy5kZWZpbmUoe1xuICAgICAgICBpZDogW3AuQW55XVxuICAgIH0pO1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArIFwiKFwiICsgdGhpcy5pZCArIFwiKVwiO1xuICAgIH07XG4gICAgZnVuY3Rpb24gSGFzUHJvcHMoYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgZGVmYXVsdF92YWx1ZSwgbmFtZSwgcmVmLCByZWYxLCB0eXBlO1xuICAgICAgICBpZiAoYXR0cmlidXRlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgXCJkZXN0cm95ZWRcIik7XG4gICAgICAgIHRoaXMuY2hhbmdlID0gbmV3IHNpZ25hbGluZ18xLlNpZ25hbCh0aGlzLCBcImNoYW5nZVwiKTtcbiAgICAgICAgdGhpcy5wcm9wY2hhbmdlID0gbmV3IHNpZ25hbGluZ18xLlNpZ25hbCh0aGlzLCBcInByb3BjaGFuZ2VcIik7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtY2hhbmdlID0gbmV3IHNpZ25hbGluZ18xLlNpZ25hbCh0aGlzLCBcInRyYW5zZm9ybWNoYW5nZVwiKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuICAgICAgICByZWYgPSB0aGlzLnByb3BzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgICByZWYxID0gcmVmW25hbWVdLCB0eXBlID0gcmVmMS50eXBlLCBkZWZhdWx0X3ZhbHVlID0gcmVmMS5kZWZhdWx0X3ZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZGVmaW5lZCBwcm9wZXJ0eSB0eXBlIGZvciBcIiArIHRoaXMudHlwZSArIFwiLlwiICsgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSBuZXcgdHlwZSh7XG4gICAgICAgICAgICAgICAgb2JqOiB0aGlzLFxuICAgICAgICAgICAgICAgIGF0dHI6IG5hbWUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdF92YWx1ZTogZGVmYXVsdF92YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0X2FmdGVyX2RlZmF1bHRzID0ge307XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLmlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dihcImlkXCIsIHN0cmluZ18xLnVuaXF1ZUlkKCksIHtcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0dihhdHRyaWJ1dGVzLCBvYmplY3RfMS5leHRlbmQoe1xuICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmRlZmVyX2luaXRpYWxpemF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmFsaXplKGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBuYW1lLCBwcm9wLCByZWY7XG4gICAgICAgIHJlZiA9IHRoaXMucHJvcGVydGllcztcbiAgICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICAgICAgcHJvcCA9IHJlZltuYW1lXTtcbiAgICAgICAgICAgIHByb3AudXBkYXRlKCk7XG4gICAgICAgICAgICBpZiAocHJvcC5zcGVjLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdChwcm9wLnNwZWMudHJhbnNmb3JtLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1jaGFuZ2UuZW1pdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShhdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdF9zaWduYWxzKCk7XG4gICAgfTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVzLCBvcHRpb25zKSB7IH07XG4gICAgSGFzUHJvcHMucHJvdG90eXBlLmNvbm5lY3Rfc2lnbmFscyA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUuZGlzY29ubmVjdF9zaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2lnbmFsaW5nXzEuU2lnbmFsLmRpc2Nvbm5lY3RSZWNlaXZlcih0aGlzKTtcbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3Rfc2lnbmFscygpO1xuICAgICAgICByZXR1cm4gdGhpcy5kZXN0cm95ZWQuZW1pdCgpO1xuICAgIH07XG4gICAgSGFzUHJvcHMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5fc2V0diA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICB2YXIgYXR0ciwgY2hhbmdlcywgY2hhbmdpbmcsIGN1cnJlbnQsIGksIGosIHJlZiwgc2lsZW50LCB2YWw7XG4gICAgICAgIHNpbGVudCA9IG9wdGlvbnMuc2lsZW50O1xuICAgICAgICBjaGFuZ2VzID0gW107XG4gICAgICAgIGNoYW5naW5nID0gdGhpcy5fY2hhbmdpbmc7XG4gICAgICAgIHRoaXMuX2NoYW5naW5nID0gdHJ1ZTtcbiAgICAgICAgY3VycmVudCA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgICAgZm9yIChhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgICAgICB2YWwgPSBhdHRyc1thdHRyXTtcbiAgICAgICAgICAgIHZhbCA9IGF0dHJzW2F0dHJdO1xuICAgICAgICAgICAgaWYgKCFlcV8xLmlzRXF1YWwoY3VycmVudFthdHRyXSwgdmFsKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRbYXR0cl0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNoYW5nZXMubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbY2hhbmdlc1tpXV0uY2hhbmdlLmVtaXQoY3VycmVudFtjaGFuZ2VzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5naW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNpbGVudCAmJiAhb3B0aW9ucy5ub19jaGFuZ2UpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9wZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlLmVtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NoYW5naW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSGFzUHJvcHMucHJvdG90eXBlLnNldHYgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYXR0cnMsIG9sZCwgcHJvcF9uYW1lLCByZXN1bHRzLCB2YWw7XG4gICAgICAgIGlmICh0eXBlc18xLmlzT2JqZWN0KGtleSkgfHwga2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICBhdHRycyA9IGtleTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJzID0ge307XG4gICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChhdHRycywga2V5KSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhbCA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBwcm9wX25hbWUgPSBrZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wc1twcm9wX25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9wZXJ0eSBcIiArIHRoaXMudHlwZSArIFwiLlwiICsgcHJvcF9uYW1lICsgXCIgd2Fzbid0IGRlY2xhcmVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoKG9wdGlvbnMgIT0gbnVsbCkgJiYgb3B0aW9ucy5kZWZhdWx0cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRfYWZ0ZXJfZGVmYXVsdHNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvYmplY3RfMS5pc0VtcHR5KGF0dHJzKSkge1xuICAgICAgICAgICAgb2xkID0ge307XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgICAgICBvbGRba2V5XSA9IHRoaXMuZ2V0dihrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0dihhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuc2lsZW50IDogdm9pZCAwKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuX3RlbGxfZG9jdW1lbnRfYWJvdXRfY2hhbmdlKGtleSwgb2xkW2tleV0sIHRoaXMuZ2V0dihrZXkpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci53YXJuKFwiSGFzUHJvcHMuc2V0KCdwcm9wX25hbWUnLCB2YWx1ZSkgaXMgZGVwcmVjYXRlZCwgdXNlIEhhc1Byb3BzLnByb3BfbmFtZSA9IHZhbHVlIGluc3RlYWRcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHYoa2V5LCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHByb3BfbmFtZSkge1xuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJIYXNQcm9wcy5nZXQoJ3Byb3BfbmFtZScpIGlzIGRlcHJlY2F0ZWQsIHVzZSBIYXNQcm9wcy5wcm9wX25hbWUgaW5zdGVhZFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0dihwcm9wX25hbWUpO1xuICAgIH07XG4gICAgSGFzUHJvcHMucHJvdG90eXBlLmdldHYgPSBmdW5jdGlvbiAocHJvcF9uYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzW3Byb3BfbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvcGVydHkgXCIgKyB0aGlzLnR5cGUgKyBcIi5cIiArIHByb3BfbmFtZSArIFwiIHdhc24ndCBkZWNsYXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbcHJvcF9uYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGFzUHJvcHMucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlZnMuY3JlYXRlX3JlZih0aGlzKTtcbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5zZXRfc3VidHlwZSA9IGZ1bmN0aW9uIChzdWJ0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJ0eXBlID0gc3VidHlwZTtcbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5hdHRyaWJ1dGVfaXNfc2VyaWFsaXphYmxlID0gZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgdmFyIHByb3A7XG4gICAgICAgIHByb3AgPSB0aGlzLnByb3BzW2F0dHJdO1xuICAgICAgICBpZiAocHJvcCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy50eXBlICsgXCIuYXR0cmlidXRlX2lzX3NlcmlhbGl6YWJsZSgnXCIgKyBhdHRyICsgXCInKTogXCIgKyBhdHRyICsgXCIgd2Fzbid0IGRlY2xhcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICFwcm9wLmludGVybmFsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUuc2VyaWFsaXphYmxlX2F0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdHRycywgbmFtZSwgcmVmLCB2YWx1ZTtcbiAgICAgICAgYXR0cnMgPSB7fTtcbiAgICAgICAgcmVmID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlZltuYW1lXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZV9pc19zZXJpYWxpemFibGUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRycztcbiAgICB9O1xuICAgIEhhc1Byb3BzLl92YWx1ZV90b19qc29uID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9wdGlvbmFsX3BhcmVudF9vYmplY3QpIHtcbiAgICAgICAgdmFyIGksIGosIGxlbiwgcmVmX2FycmF5LCByZWZfb2JqLCBzdWJrZXksIHY7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhhc1Byb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucmVmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmVmX2FycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG4gICAgICAgICAgICAgICAgdiA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgICAgIHJlZl9hcnJheS5wdXNoKEhhc1Byb3BzLl92YWx1ZV90b19qc29uKGksIHYsIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVmX2FycmF5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZWZfb2JqID0ge307XG4gICAgICAgICAgICBmb3IgKHN1YmtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHZhbHVlLCBzdWJrZXkpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZWZfb2JqW3N1YmtleV0gPSBIYXNQcm9wcy5fdmFsdWVfdG9fanNvbihzdWJrZXksIHZhbHVlW3N1YmtleV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWZfb2JqO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUuYXR0cmlidXRlc19hc19qc29uID0gZnVuY3Rpb24gKGluY2x1ZGVfZGVmYXVsdHMsIHZhbHVlX3RvX2pzb24pIHtcbiAgICAgICAgdmFyIGF0dHJzLCBrZXksIHJlZiwgdmFsdWU7XG4gICAgICAgIGlmIChpbmNsdWRlX2RlZmF1bHRzID09IG51bGwpIHtcbiAgICAgICAgICAgIGluY2x1ZGVfZGVmYXVsdHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZV90b19qc29uID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlX3RvX2pzb24gPSBIYXNQcm9wcy5fdmFsdWVfdG9fanNvbjtcbiAgICAgICAgfVxuICAgICAgICBhdHRycyA9IHt9O1xuICAgICAgICByZWYgPSB0aGlzLnNlcmlhbGl6YWJsZV9hdHRyaWJ1dGVzKCk7XG4gICAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBrZXkpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFsdWUgPSByZWZba2V5XTtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlX2RlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHRoaXMuX3NldF9hZnRlcl9kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVfdG9fanNvbihcImF0dHJpYnV0ZXNcIiwgYXR0cnMsIHRoaXMpO1xuICAgIH07XG4gICAgSGFzUHJvcHMuX2pzb25fcmVjb3JkX3JlZmVyZW5jZXMgPSBmdW5jdGlvbiAoZG9jLCB2LCByZXN1bHQsIHJlY3Vyc2UpIHtcbiAgICAgICAgdmFyIGVsZW0sIGosIGssIGxlbiwgbW9kZWwsIHJlc3VsdHMsIHJlc3VsdHMxO1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVmcy5pc19yZWYodikpIHtcbiAgICAgICAgICAgIGlmICghKHYuaWQgaW4gcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIG1vZGVsID0gZG9jLmdldF9tb2RlbF9ieV9pZCh2LmlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gSGFzUHJvcHMuX3ZhbHVlX3JlY29yZF9yZWZlcmVuY2VzKG1vZGVsLCByZXN1bHQsIHJlY3Vyc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gdi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIGVsZW0gPSB2W2pdO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChIYXNQcm9wcy5fanNvbl9yZWNvcmRfcmVmZXJlbmNlcyhkb2MsIGVsZW0sIHJlc3VsdCwgcmVjdXJzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc09iamVjdCh2KSkge1xuICAgICAgICAgICAgcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICAgIGZvciAoayBpbiB2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwodiwgaykpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVsZW0gPSB2W2tdO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMxLnB1c2goSGFzUHJvcHMuX2pzb25fcmVjb3JkX3JlZmVyZW5jZXMoZG9jLCBlbGVtLCByZXN1bHQsIHJlY3Vyc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGFzUHJvcHMuX3ZhbHVlX3JlY29yZF9yZWZlcmVuY2VzID0gZnVuY3Rpb24gKHYsIHJlc3VsdCwgcmVjdXJzZSkge1xuICAgICAgICB2YXIgZWxlbSwgaW1tZWRpYXRlLCBqLCBrLCBsLCBsZW4sIGxlbjEsIG9iaiwgcmVzdWx0cywgcmVzdWx0czEsIHJlc3VsdHMyO1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEhhc1Byb3BzKSB7XG4gICAgICAgICAgICBpZiAoISh2LmlkIGluIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbdi5pZF0gPSB2O1xuICAgICAgICAgICAgICAgIGlmIChyZWN1cnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZSA9IHYuX2ltbWVkaWF0ZV9yZWZlcmVuY2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW1tZWRpYXRlLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBpbW1lZGlhdGVbal07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goSGFzUHJvcHMuX3ZhbHVlX3JlY29yZF9yZWZlcmVuY2VzKG9iaiwgcmVzdWx0LCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlc18xLmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIHJlc3VsdHMxID0gW107XG4gICAgICAgICAgICBmb3IgKGwgPSAwLCBsZW4xID0gdi5sZW5ndGg7IGwgPCBsZW4xOyBsKyspIHtcbiAgICAgICAgICAgICAgICBlbGVtID0gdltsXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzMS5wdXNoKEhhc1Byb3BzLl92YWx1ZV9yZWNvcmRfcmVmZXJlbmNlcyhlbGVtLCByZXN1bHQsIHJlY3Vyc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlc18xLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgICByZXN1bHRzMiA9IFtdO1xuICAgICAgICAgICAgZm9yIChrIGluIHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbCh2LCBrKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZWxlbSA9IHZba107XG4gICAgICAgICAgICAgICAgcmVzdWx0czIucHVzaChIYXNQcm9wcy5fdmFsdWVfcmVjb3JkX3JlZmVyZW5jZXMoZWxlbSwgcmVzdWx0LCByZWN1cnNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0czI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5faW1tZWRpYXRlX3JlZmVyZW5jZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdHRycywga2V5LCByZXN1bHQsIHZhbHVlO1xuICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgYXR0cnMgPSB0aGlzLnNlcmlhbGl6YWJsZV9hdHRyaWJ1dGVzKCk7XG4gICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBIYXNQcm9wcy5fdmFsdWVfcmVjb3JkX3JlZmVyZW5jZXModmFsdWUsIHJlc3VsdCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3RfMS52YWx1ZXMocmVzdWx0KTtcbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5yZWZlcmVuY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVmZXJlbmNlcztcbiAgICAgICAgcmVmZXJlbmNlcyA9IHt9O1xuICAgICAgICBIYXNQcm9wcy5fdmFsdWVfcmVjb3JkX3JlZmVyZW5jZXModGhpcywgcmVmZXJlbmNlcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBvYmplY3RfMS52YWx1ZXMocmVmZXJlbmNlcyk7XG4gICAgfTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUuYXR0YWNoX2RvY3VtZW50ID0gZnVuY3Rpb24gKGRvYykge1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudCAhPT0gbnVsbCAmJiB0aGlzLmRvY3VtZW50ICE9PSBkb2MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vZGVscyBtdXN0IGJlIG93bmVkIGJ5IG9ubHkgYSBzaW5nbGUgZG9jdW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvYztcbiAgICAgICAgaWYgKHRoaXMuX2RvY19hdHRhY2hlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9jX2F0dGFjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5kZXRhY2hfZG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50ID0gbnVsbDtcbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5fdGVsbF9kb2N1bWVudF9hYm91dF9jaGFuZ2UgPSBmdW5jdGlvbiAoYXR0ciwgb2xkLCBuZXdfLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBuZWVkX2ludmFsaWRhdGUsIG5ld19pZCwgbmV3X3JlZiwgbmV3X3JlZnMsIG9sZF9pZCwgb2xkX3JlZiwgb2xkX3JlZnM7XG4gICAgICAgIGlmICghdGhpcy5hdHRyaWJ1dGVfaXNfc2VyaWFsaXphYmxlKGF0dHIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld19yZWZzID0ge307XG4gICAgICAgICAgICBIYXNQcm9wcy5fdmFsdWVfcmVjb3JkX3JlZmVyZW5jZXMobmV3XywgbmV3X3JlZnMsIGZhbHNlKTtcbiAgICAgICAgICAgIG9sZF9yZWZzID0ge307XG4gICAgICAgICAgICBIYXNQcm9wcy5fdmFsdWVfcmVjb3JkX3JlZmVyZW5jZXMob2xkLCBvbGRfcmVmcywgZmFsc2UpO1xuICAgICAgICAgICAgbmVlZF9pbnZhbGlkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKG5ld19pZCBpbiBuZXdfcmVmcykge1xuICAgICAgICAgICAgICAgIG5ld19yZWYgPSBuZXdfcmVmc1tuZXdfaWRdO1xuICAgICAgICAgICAgICAgIGlmICghKG5ld19pZCBpbiBvbGRfcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVlZF9pbnZhbGlkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZWVkX2ludmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKG9sZF9pZCBpbiBvbGRfcmVmcykge1xuICAgICAgICAgICAgICAgICAgICBvbGRfcmVmID0gb2xkX3JlZnNbb2xkX2lkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEob2xkX2lkIGluIG5ld19yZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZF9pbnZhbGlkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5lZWRfaW52YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuX2ludmFsaWRhdGVfYWxsX21vZGVscygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuX25vdGlmeV9jaGFuZ2UodGhpcywgYXR0ciwgb2xkLCBuZXdfLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGFzUHJvcHMucHJvdG90eXBlLm1hdGVyaWFsaXplX2RhdGFzcGVjcyA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIGRhdGEsIG5hbWUsIHByb3AsIHJlZjtcbiAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICByZWYgPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcbiAgICAgICAgICAgIHByb3AgPSByZWZbbmFtZV07XG4gICAgICAgICAgICBpZiAoIXByb3AuZGF0YXNwZWMpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgocHJvcC5vcHRpb25hbCB8fCBmYWxzZSkgJiYgcHJvcC5zcGVjLnZhbHVlID09PSBudWxsICYmICghKG5hbWUgaW4gdGhpcy5fc2V0X2FmdGVyX2RlZmF1bHRzKSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFbXCJfXCIgKyBuYW1lXSA9IHByb3AuYXJyYXkoc291cmNlKTtcbiAgICAgICAgICAgIGlmICgocHJvcC5zcGVjLmZpZWxkICE9IG51bGwpICYmIHByb3Auc3BlYy5maWVsZCBpbiBzb3VyY2UuX3NoYXBlcykge1xuICAgICAgICAgICAgICAgIGRhdGFbXCJfXCIgKyBuYW1lICsgXCJfc2hhcGVcIl0gPSBzb3VyY2UuX3NoYXBlc1twcm9wLnNwZWMuZmllbGRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBwLkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtcIm1heF9cIiArIG5hbWVdID0gYXJyYXlfMS5tYXgoZGF0YVtcIl9cIiArIG5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIHJldHVybiBIYXNQcm9wcztcbn0pKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkaXN0X3RvX3NlZ21lbnRfc3F1YXJlZCwgbnVsbHJldHVybmVyLCBzcXI7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL3V0aWwvYXJyYXlcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiLi91dGlsL29iamVjdFwiKTtcbmV4cG9ydHMucG9pbnRfaW5fcG9seSA9IGZ1bmN0aW9uICh4LCB5LCBweCwgcHkpIHtcbiAgICB2YXIgaSwgaW5zaWRlLCBqLCByZWYsIHgxLCB4MiwgeTEsIHkyO1xuICAgIGluc2lkZSA9IGZhbHNlO1xuICAgIHgxID0gcHhbcHgubGVuZ3RoIC0gMV07XG4gICAgeTEgPSBweVtweS5sZW5ndGggLSAxXTtcbiAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gcHgubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgeDIgPSBweFtpXTtcbiAgICAgICAgeTIgPSBweVtpXTtcbiAgICAgICAgaWYgKCh5MSA8IHkpICE9PSAoeTIgPCB5KSkge1xuICAgICAgICAgICAgaWYgKHgxICsgKHkgLSB5MSkgLyAoeTIgLSB5MSkgKiAoeDIgLSB4MSkgPCB4KSB7XG4gICAgICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4MSA9IHgyO1xuICAgICAgICB5MSA9IHkyO1xuICAgIH1cbiAgICByZXR1cm4gaW5zaWRlO1xufTtcbm51bGxyZXR1cm5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbn07XG5leHBvcnRzLkhpdFRlc3RSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhpdFRlc3RSZXN1bHQoKSB7XG4gICAgICAgIHRoaXNbJzBkJ10gPSB7XG4gICAgICAgICAgICBnbHlwaDogbnVsbCxcbiAgICAgICAgICAgIGdldF92aWV3OiBudWxscmV0dXJuZXIsXG4gICAgICAgICAgICBpbmRpY2VzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzWycxZCddID0ge1xuICAgICAgICAgICAgaW5kaWNlczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpc1snMmQnXSA9IHtcbiAgICAgICAgICAgIGluZGljZXM6IHt9XG4gICAgICAgIH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIaXRUZXN0UmVzdWx0LnByb3RvdHlwZSwgJ18wZCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1snMGQnXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIaXRUZXN0UmVzdWx0LnByb3RvdHlwZSwgJ18xZCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1snMWQnXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIaXRUZXN0UmVzdWx0LnByb3RvdHlwZSwgJ18yZCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1snMmQnXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIEhpdFRlc3RSZXN1bHQucHJvdG90eXBlLmlzX2VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fMGQuaW5kaWNlcy5sZW5ndGggPT09IDAgJiYgdGhpcy5fMWQuaW5kaWNlcy5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICBIaXRUZXN0UmVzdWx0LnByb3RvdHlwZS51cGRhdGVfdGhyb3VnaF91bmlvbiA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB0aGlzWycwZCddLmluZGljZXMgPSBhcnJheV8xLnVuaW9uKG90aGVyWycwZCddLmluZGljZXMsIHRoaXNbJzBkJ10uaW5kaWNlcyk7XG4gICAgICAgIHRoaXNbJzBkJ10uZ2x5cGggPSBvdGhlclsnMGQnXS5nbHlwaCB8fCB0aGlzWycwZCddLmdseXBoO1xuICAgICAgICB0aGlzWycxZCddLmluZGljZXMgPSBhcnJheV8xLnVuaW9uKG90aGVyWycxZCddLmluZGljZXMsIHRoaXNbJzFkJ10uaW5kaWNlcyk7XG4gICAgICAgIHJldHVybiB0aGlzWycyZCddLmluZGljZXMgPSBvYmplY3RfMS5tZXJnZShvdGhlclsnMmQnXS5pbmRpY2VzLCB0aGlzWycyZCddLmluZGljZXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEhpdFRlc3RSZXN1bHQ7XG59KSgpO1xuZXhwb3J0cy5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5IaXRUZXN0UmVzdWx0KCk7XG59O1xuZXhwb3J0cy5jcmVhdGVfMWRfaGl0X3Rlc3RfcmVzdWx0ID0gZnVuY3Rpb24gKGhpdHMpIHtcbiAgICB2YXIgX2Rpc3QsIGksIHJlc3VsdDtcbiAgICByZXN1bHQgPSBuZXcgZXhwb3J0cy5IaXRUZXN0UmVzdWx0KCk7XG4gICAgcmVzdWx0WycxZCddLmluZGljZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaiwgbGVuLCByZWYsIHJlZjEsIHJlc3VsdHM7XG4gICAgICAgIHJlZiA9IGFycmF5XzEuc29ydEJ5KGhpdHMsIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIHZhciBfaSwgZGlzdDtcbiAgICAgICAgICAgIF9pID0gYXJnWzBdLCBkaXN0ID0gYXJnWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGRpc3Q7XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgcmVmMSA9IHJlZltqXSwgaSA9IHJlZjFbMF0sIF9kaXN0ID0gcmVmMVsxXTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9KSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy52YWxpZGF0ZV9iYm94X2Nvb3JkcyA9IGZ1bmN0aW9uIChhcmcsIGFyZzEpIHtcbiAgICB2YXIgcmVmLCByZWYxLCB4MCwgeDEsIHkwLCB5MTtcbiAgICB4MCA9IGFyZ1swXSwgeDEgPSBhcmdbMV07XG4gICAgeTAgPSBhcmcxWzBdLCB5MSA9IGFyZzFbMV07XG4gICAgaWYgKHgwID4geDEpIHtcbiAgICAgICAgcmVmID0gW3gxLCB4MF0sIHgwID0gcmVmWzBdLCB4MSA9IHJlZlsxXTtcbiAgICB9XG4gICAgaWYgKHkwID4geTEpIHtcbiAgICAgICAgcmVmMSA9IFt5MSwgeTBdLCB5MCA9IHJlZjFbMF0sIHkxID0gcmVmMVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluWDogeDAsXG4gICAgICAgIG1pblk6IHkwLFxuICAgICAgICBtYXhYOiB4MSxcbiAgICAgICAgbWF4WTogeTFcbiAgICB9O1xufTtcbnNxciA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHggKiB4O1xufTtcbmV4cG9ydHMuZGlzdF8yX3B0cyA9IGZ1bmN0aW9uICh2eCwgdnksIHd4LCB3eSkge1xuICAgIHJldHVybiBzcXIodnggLSB3eCkgKyBzcXIodnkgLSB3eSk7XG59O1xuZGlzdF90b19zZWdtZW50X3NxdWFyZWQgPSBmdW5jdGlvbiAocCwgdiwgdykge1xuICAgIHZhciBsMiwgdDtcbiAgICBsMiA9IGV4cG9ydHMuZGlzdF8yX3B0cyh2LngsIHYueSwgdy54LCB3LnkpO1xuICAgIGlmIChsMiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5kaXN0XzJfcHRzKHAueCwgcC55LCB2LngsIHYueSk7XG4gICAgfVxuICAgIHQgPSAoKHAueCAtIHYueCkgKiAody54IC0gdi54KSArIChwLnkgLSB2LnkpICogKHcueSAtIHYueSkpIC8gbDI7XG4gICAgaWYgKHQgPCAwKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmRpc3RfMl9wdHMocC54LCBwLnksIHYueCwgdi55KTtcbiAgICB9XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmRpc3RfMl9wdHMocC54LCBwLnksIHcueCwgdy55KTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuZGlzdF8yX3B0cyhwLngsIHAueSwgdi54ICsgdCAqICh3LnggLSB2LngpLCB2LnkgKyB0ICogKHcueSAtIHYueSkpO1xufTtcbmV4cG9ydHMuZGlzdF90b19zZWdtZW50ID0gZnVuY3Rpb24gKHAsIHYsIHcpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGRpc3RfdG9fc2VnbWVudF9zcXVhcmVkKHAsIHYsIHcpKTtcbn07XG5leHBvcnRzLmNoZWNrXzJfc2VnbWVudHNfaW50ZXJzZWN0ID0gZnVuY3Rpb24gKGwwX3gwLCBsMF95MCwgbDBfeDEsIGwwX3kxLCBsMV94MCwgbDFfeTAsIGwxX3gxLCBsMV95MSkge1xuICAgIC8qIENoZWNrIGlmIDIgc2VnbWVudHMgKGwwIGFuZCBsMSkgaW50ZXJzZWN0LiBSZXR1cm5zIGEgc3RydWN0dXJlIHdpdGhcbiAgICAgIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAgICAgICAgKiBoaXQgKGJvb2xlYW4pOiB3aGV0aGVyIHRoZSAyIHNlZ21lbnRzIGludGVyc2VjdFxuICAgICAgICAqIHggKGZsb2F0KTogeCBjb29yZGluYXRlIG9mIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgKiB5IChmbG9hdCk6IHkgY29vcmRpbmF0ZSBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICovXG4gICAgdmFyIGEsIGIsIGRlbiwgbnVtMSwgbnVtMiwgeCwgeTtcbiAgICBkZW4gPSAoKGwxX3kxIC0gbDFfeTApICogKGwwX3gxIC0gbDBfeDApKSAtICgobDFfeDEgLSBsMV94MCkgKiAobDBfeTEgLSBsMF95MCkpO1xuICAgIGlmIChkZW4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhpdDogZmFsc2UsXG4gICAgICAgICAgICB4OiBudWxsLFxuICAgICAgICAgICAgeTogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYSA9IGwwX3kwIC0gbDFfeTA7XG4gICAgICAgIGIgPSBsMF94MCAtIGwxX3gwO1xuICAgICAgICBudW0xID0gKChsMV94MSAtIGwxX3gwKSAqIGEpIC0gKChsMV95MSAtIGwxX3kwKSAqIGIpO1xuICAgICAgICBudW0yID0gKChsMF94MSAtIGwwX3gwKSAqIGEpIC0gKChsMF95MSAtIGwwX3kwKSAqIGIpO1xuICAgICAgICBhID0gbnVtMSAvIGRlbjtcbiAgICAgICAgYiA9IG51bTIgLyBkZW47XG4gICAgICAgIHggPSBsMF94MCArIChhICogKGwwX3gxIC0gbDBfeDApKTtcbiAgICAgICAgeSA9IGwwX3kwICsgKGEgKiAobDBfeTEgLSBsMF95MCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGl0OiAoYSA+IDAgJiYgYSA8IDEpICYmIChiID4gMCAmJiBiIDwgMSksXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeVxuICAgICAgICB9O1xuICAgIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgc29sdmVyXzEgPSByZXF1aXJlKFwiLi9zb2x2ZXJcIik7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbFwiKTtcbmV4cG9ydHMuTGF5b3V0Q2FudmFzID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExheW91dENhbnZhcywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGF5b3V0Q2FudmFzKCkge1xuICAgICAgICByZXR1cm4gTGF5b3V0Q2FudmFzLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMYXlvdXRDYW52YXMucHJvdG90eXBlLnR5cGUgPSAnTGF5b3V0Q2FudmFzJztcbiAgICBMYXlvdXRDYW52YXMucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgTGF5b3V0Q2FudmFzLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl90b3AgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJ0b3AgXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IG5ldyBzb2x2ZXJfMS5WYXJpYWJsZShcImxlZnQgXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJ3aWR0aCBcIiArIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJoZWlnaHQgXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJyaWdodCBcIiArIHRoaXMuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYm90dG9tID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKFwiYm90dG9tIFwiICsgdGhpcy5pZCk7XG4gICAgfTtcbiAgICBMYXlvdXRDYW52YXMucHJvdG90eXBlLmdldF9lZGl0X3ZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVkaXRhYmxlcztcbiAgICAgICAgZWRpdGFibGVzID0gW107XG4gICAgICAgIGVkaXRhYmxlcy5wdXNoKHtcbiAgICAgICAgICAgIGVkaXRfdmFyaWFibGU6IHRoaXMuX3RvcCxcbiAgICAgICAgICAgIHN0cmVuZ3RoOiBzb2x2ZXJfMS5TdHJlbmd0aC5zdHJvbmdcbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRhYmxlcy5wdXNoKHtcbiAgICAgICAgICAgIGVkaXRfdmFyaWFibGU6IHRoaXMuX2xlZnQsXG4gICAgICAgICAgICBzdHJlbmd0aDogc29sdmVyXzEuU3RyZW5ndGguc3Ryb25nXG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0YWJsZXMucHVzaCh7XG4gICAgICAgICAgICBlZGl0X3ZhcmlhYmxlOiB0aGlzLl93aWR0aCxcbiAgICAgICAgICAgIHN0cmVuZ3RoOiBzb2x2ZXJfMS5TdHJlbmd0aC5zdHJvbmdcbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRhYmxlcy5wdXNoKHtcbiAgICAgICAgICAgIGVkaXRfdmFyaWFibGU6IHRoaXMuX2hlaWdodCxcbiAgICAgICAgICAgIHN0cmVuZ3RoOiBzb2x2ZXJfMS5TdHJlbmd0aC5zdHJvbmdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlZGl0YWJsZXM7XG4gICAgfTtcbiAgICBMYXlvdXRDYW52YXMucHJvdG90eXBlLmdldF9jb25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgTGF5b3V0Q2FudmFzLmdldHRlcnMoe1xuICAgICAgICBsYXlvdXRfYmJveDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuX3RvcC52YWx1ZSxcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLl9sZWZ0LnZhbHVlLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLl93aWR0aC52YWx1ZSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuX2hlaWdodC52YWx1ZSxcbiAgICAgICAgICAgICAgICByaWdodDogdGhpcy5fcmlnaHQudmFsdWUsXG4gICAgICAgICAgICAgICAgYm90dG9tOiB0aGlzLl9ib3R0b20udmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBMYXlvdXRDYW52YXMucHJvdG90eXBlLmR1bXBfbGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29uc29sZS5sb2codGhpcy50b1N0cmluZygpLCB0aGlzLmxheW91dF9iYm94KTtcbiAgICB9O1xuICAgIHJldHVybiBMYXlvdXRDYW52YXM7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFMUEhBQkVUSUMsIEJPVFRPTSwgQ0VOVEVSLCBIQU5HSU5HLCBMRUZULCBNSURETEUsIFJJR0hULCBUT1AsIF9hbGlnbl9sb29rdXAsIF9hbGlnbl9sb29rdXBfbmVnYXRpdmUsIF9hbGlnbl9sb29rdXBfcG9zaXRpdmUsIF9hbmdsZV9sb29rdXAsIF9iYXNlbGluZV9sb29rdXAsIHBpMiwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHNvbHZlcl8xID0gcmVxdWlyZShcIi4vc29sdmVyXCIpO1xudmFyIGxheW91dF9jYW52YXNfMSA9IHJlcXVpcmUoXCIuL2xheW91dF9jYW52YXNcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90eXBlc1wiKTtcbnBpMiA9IE1hdGguUEkgLyAyO1xuQUxQSEFCRVRJQyA9ICdhbHBoYWJldGljJztcblRPUCA9ICd0b3AnO1xuQk9UVE9NID0gJ2JvdHRvbSc7XG5NSURETEUgPSAnbWlkZGxlJztcbkhBTkdJTkcgPSAnaGFuZ2luZyc7XG5MRUZUID0gJ2xlZnQnO1xuUklHSFQgPSAncmlnaHQnO1xuQ0VOVEVSID0gJ2NlbnRlcic7XG5fYW5nbGVfbG9va3VwID0ge1xuICAgIGFib3ZlOiB7XG4gICAgICAgIHBhcmFsbGVsOiAwLFxuICAgICAgICBub3JtYWw6IC1waTIsXG4gICAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICAgIHZlcnRpY2FsOiAtcGkyXG4gICAgfSxcbiAgICBiZWxvdzoge1xuICAgICAgICBwYXJhbGxlbDogMCxcbiAgICAgICAgbm9ybWFsOiBwaTIsXG4gICAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICAgIHZlcnRpY2FsOiBwaTJcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgICAgcGFyYWxsZWw6IC1waTIsXG4gICAgICAgIG5vcm1hbDogMCxcbiAgICAgICAgaG9yaXpvbnRhbDogMCxcbiAgICAgICAgdmVydGljYWw6IC1waTJcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICAgIHBhcmFsbGVsOiBwaTIsXG4gICAgICAgIG5vcm1hbDogMCxcbiAgICAgICAgaG9yaXpvbnRhbDogMCxcbiAgICAgICAgdmVydGljYWw6IHBpMlxuICAgIH1cbn07XG5fYmFzZWxpbmVfbG9va3VwID0ge1xuICAgIGFib3ZlOiB7XG4gICAgICAgIGp1c3RpZmllZDogVE9QLFxuICAgICAgICBwYXJhbGxlbDogQUxQSEFCRVRJQyxcbiAgICAgICAgbm9ybWFsOiBNSURETEUsXG4gICAgICAgIGhvcml6b250YWw6IEFMUEhBQkVUSUMsXG4gICAgICAgIHZlcnRpY2FsOiBNSURETEVcbiAgICB9LFxuICAgIGJlbG93OiB7XG4gICAgICAgIGp1c3RpZmllZDogQk9UVE9NLFxuICAgICAgICBwYXJhbGxlbDogSEFOR0lORyxcbiAgICAgICAgbm9ybWFsOiBNSURETEUsXG4gICAgICAgIGhvcml6b250YWw6IEhBTkdJTkcsXG4gICAgICAgIHZlcnRpY2FsOiBNSURETEVcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgICAganVzdGlmaWVkOiBUT1AsXG4gICAgICAgIHBhcmFsbGVsOiBBTFBIQUJFVElDLFxuICAgICAgICBub3JtYWw6IE1JRERMRSxcbiAgICAgICAgaG9yaXpvbnRhbDogTUlERExFLFxuICAgICAgICB2ZXJ0aWNhbDogQUxQSEFCRVRJQ1xuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgICAganVzdGlmaWVkOiBUT1AsXG4gICAgICAgIHBhcmFsbGVsOiBBTFBIQUJFVElDLFxuICAgICAgICBub3JtYWw6IE1JRERMRSxcbiAgICAgICAgaG9yaXpvbnRhbDogTUlERExFLFxuICAgICAgICB2ZXJ0aWNhbDogQUxQSEFCRVRJQ1xuICAgIH1cbn07XG5fYWxpZ25fbG9va3VwID0ge1xuICAgIGFib3ZlOiB7XG4gICAgICAgIGp1c3RpZmllZDogQ0VOVEVSLFxuICAgICAgICBwYXJhbGxlbDogQ0VOVEVSLFxuICAgICAgICBub3JtYWw6IExFRlQsXG4gICAgICAgIGhvcml6b250YWw6IENFTlRFUixcbiAgICAgICAgdmVydGljYWw6IExFRlRcbiAgICB9LFxuICAgIGJlbG93OiB7XG4gICAgICAgIGp1c3RpZmllZDogQ0VOVEVSLFxuICAgICAgICBwYXJhbGxlbDogQ0VOVEVSLFxuICAgICAgICBub3JtYWw6IExFRlQsXG4gICAgICAgIGhvcml6b250YWw6IENFTlRFUixcbiAgICAgICAgdmVydGljYWw6IExFRlRcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgICAganVzdGlmaWVkOiBDRU5URVIsXG4gICAgICAgIHBhcmFsbGVsOiBDRU5URVIsXG4gICAgICAgIG5vcm1hbDogUklHSFQsXG4gICAgICAgIGhvcml6b250YWw6IFJJR0hULFxuICAgICAgICB2ZXJ0aWNhbDogQ0VOVEVSXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgICBqdXN0aWZpZWQ6IENFTlRFUixcbiAgICAgICAgcGFyYWxsZWw6IENFTlRFUixcbiAgICAgICAgbm9ybWFsOiBMRUZULFxuICAgICAgICBob3Jpem9udGFsOiBMRUZULFxuICAgICAgICB2ZXJ0aWNhbDogQ0VOVEVSXG4gICAgfVxufTtcbl9hbGlnbl9sb29rdXBfbmVnYXRpdmUgPSB7XG4gICAgYWJvdmU6IFJJR0hULFxuICAgIGJlbG93OiBMRUZULFxuICAgIGxlZnQ6IFJJR0hULFxuICAgIHJpZ2h0OiBMRUZUXG59O1xuX2FsaWduX2xvb2t1cF9wb3NpdGl2ZSA9IHtcbiAgICBhYm92ZTogTEVGVCxcbiAgICBiZWxvdzogUklHSFQsXG4gICAgbGVmdDogUklHSFQsXG4gICAgcmlnaHQ6IExFRlRcbn07XG5leHBvcnRzLnVwZGF0ZV9wYW5lbF9jb25zdHJhaW50cyA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgdmFyIHM7XG4gICAgaWYgKCh2aWV3Lm1vZGVsLnByb3BzLnZpc2libGUgIT0gbnVsbCkgJiYgIXZpZXcubW9kZWwudmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHMgPSB2aWV3LnNvbHZlcjtcbiAgICBpZiAoKHZpZXcuX3NpemVfY29uc3RyYWludCAhPSBudWxsKSAmJiBzLmhhc19jb25zdHJhaW50KHZpZXcuX3NpemVfY29uc3RyYWludCkpIHtcbiAgICAgICAgcy5yZW1vdmVfY29uc3RyYWludCh2aWV3Ll9zaXplX2NvbnN0cmFpbnQpO1xuICAgIH1cbiAgICB2aWV3Ll9zaXplX2NvbnN0cmFpbnQgPSBzb2x2ZXJfMS5HRSh2aWV3Lm1vZGVsLnBhbmVsLl9zaXplLCAtdmlldy5fZ2V0X3NpemUoKSk7XG4gICAgcy5hZGRfY29uc3RyYWludCh2aWV3Ll9zaXplX2NvbnN0cmFpbnQpO1xuICAgIGlmICgodmlldy5fZnVsbF9jb25zdHJhaW50ICE9IG51bGwpICYmIHMuaGFzX2NvbnN0cmFpbnQodmlldy5fZnVsbF9jb25zdHJhaW50KSkge1xuICAgICAgICBzLnJlbW92ZV9jb25zdHJhaW50KHZpZXcuX2Z1bGxfY29uc3RyYWludCk7XG4gICAgfVxuICAgIHZpZXcuX2Z1bGxfY29uc3RyYWludCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodmlldy5tb2RlbC5wYW5lbC5zaWRlKSB7XG4gICAgICAgICAgICBjYXNlICdhYm92ZSc6XG4gICAgICAgICAgICBjYXNlICdiZWxvdyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvbHZlcl8xLkVRKHZpZXcubW9kZWwucGFuZWwuX3dpZHRoLCBbLTEsIHZpZXcucGxvdF9tb2RlbC5jYW52YXMuX3dpZHRoXSk7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc29sdmVyXzEuRVEodmlldy5tb2RlbC5wYW5lbC5faGVpZ2h0LCBbLTEsIHZpZXcucGxvdF9tb2RlbC5jYW52YXMuX2hlaWdodF0pO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICByZXR1cm4gcy5hZGRfY29uc3RyYWludCh2aWV3Ll9mdWxsX2NvbnN0cmFpbnQpO1xufTtcbmV4cG9ydHMuU2lkZVBhbmVsID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFNpZGVQYW5lbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gU2lkZVBhbmVsKCkge1xuICAgICAgICByZXR1cm4gU2lkZVBhbmVsLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTaWRlUGFuZWwuaW50ZXJuYWwoe1xuICAgICAgICBzaWRlOiBbcC5TdHJpbmddLFxuICAgICAgICBwbG90OiBbcC5JbnN0YW5jZV1cbiAgICB9KTtcbiAgICBTaWRlUGFuZWwucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgU2lkZVBhbmVsLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2lkZSkge1xuICAgICAgICAgICAgY2FzZSBcImFib3ZlXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3JtYWxzID0gWzAsIC0xXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZSA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgICAgIGNhc2UgXCJiZWxvd1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFscyA9IFswLCAxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZSA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3JtYWxzID0gWy0xLCAwXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZSA9IHRoaXMuX3dpZHRoO1xuICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3JtYWxzID0gWzEsIDBdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplID0gdGhpcy5fd2lkdGg7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLmVycm9yKFwidW5yZWNvZ25pemVkIHNpZGU6ICdcIiArIHRoaXMuc2lkZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2lkZVBhbmVsLnByb3RvdHlwZS5nZXRfY29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbc29sdmVyXzEuR0UodGhpcy5fdG9wKSwgc29sdmVyXzEuR0UodGhpcy5fYm90dG9tKSwgc29sdmVyXzEuR0UodGhpcy5fbGVmdCksIHNvbHZlcl8xLkdFKHRoaXMuX3JpZ2h0KSwgc29sdmVyXzEuR0UodGhpcy5fd2lkdGgpLCBzb2x2ZXJfMS5HRSh0aGlzLl9oZWlnaHQpLCBzb2x2ZXJfMS5FUSh0aGlzLl9sZWZ0LCB0aGlzLl93aWR0aCwgWy0xLCB0aGlzLl9yaWdodF0pLCBzb2x2ZXJfMS5FUSh0aGlzLl9ib3R0b20sIHRoaXMuX2hlaWdodCwgWy0xLCB0aGlzLl90b3BdKV07XG4gICAgfTtcbiAgICBTaWRlUGFuZWwucHJvdG90eXBlLmFwcGx5X2xhYmVsX3RleHRfaGV1cmlzdGljcyA9IGZ1bmN0aW9uIChjdHgsIG9yaWVudCkge1xuICAgICAgICB2YXIgYWxpZ24sIGJhc2VsaW5lLCBzaWRlO1xuICAgICAgICBzaWRlID0gdGhpcy5zaWRlO1xuICAgICAgICBpZiAodHlwZXNfMS5pc1N0cmluZyhvcmllbnQpKSB7XG4gICAgICAgICAgICBiYXNlbGluZSA9IF9iYXNlbGluZV9sb29rdXBbc2lkZV1bb3JpZW50XTtcbiAgICAgICAgICAgIGFsaWduID0gX2FsaWduX2xvb2t1cFtzaWRlXVtvcmllbnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9yaWVudCA9PT0gMCkge1xuICAgICAgICAgICAgYmFzZWxpbmUgPSBfYmFzZWxpbmVfbG9va3VwW3NpZGVdW29yaWVudF07XG4gICAgICAgICAgICBhbGlnbiA9IF9hbGlnbl9sb29rdXBbc2lkZV1bb3JpZW50XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcmllbnQgPCAwKSB7XG4gICAgICAgICAgICBiYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgYWxpZ24gPSBfYWxpZ25fbG9va3VwX25lZ2F0aXZlW3NpZGVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9yaWVudCA+IDApIHtcbiAgICAgICAgICAgIGJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBhbGlnbiA9IF9hbGlnbl9sb29rdXBfcG9zaXRpdmVbc2lkZV07XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IGJhc2VsaW5lO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gYWxpZ247XG4gICAgICAgIHJldHVybiBjdHg7XG4gICAgfTtcbiAgICBTaWRlUGFuZWwucHJvdG90eXBlLmdldF9sYWJlbF9hbmdsZV9oZXVyaXN0aWMgPSBmdW5jdGlvbiAob3JpZW50KSB7XG4gICAgICAgIHZhciBzaWRlO1xuICAgICAgICBzaWRlID0gdGhpcy5zaWRlO1xuICAgICAgICByZXR1cm4gX2FuZ2xlX2xvb2t1cFtzaWRlXVtvcmllbnRdO1xuICAgIH07XG4gICAgcmV0dXJuIFNpZGVQYW5lbDtcbn0pKGxheW91dF9jYW52YXNfMS5MYXlvdXRDYW52YXMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIga2l3aV8xID0gcmVxdWlyZShcImtpd2lcIik7XG5leHBvcnRzLlZhcmlhYmxlID0ga2l3aV8xLlZhcmlhYmxlO1xuZXhwb3J0cy5FeHByZXNzaW9uID0ga2l3aV8xLkV4cHJlc3Npb247XG5leHBvcnRzLkNvbnN0cmFpbnQgPSBraXdpXzEuQ29uc3RyYWludDtcbmV4cG9ydHMuT3BlcmF0b3IgPSBraXdpXzEuT3BlcmF0b3I7XG5leHBvcnRzLlN0cmVuZ3RoID0ga2l3aV8xLlN0cmVuZ3RoO1xuZnVuY3Rpb24gX2NvbnN0cmFpbmVyKG9wKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRlcm1zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB0ZXJtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcga2l3aV8xLkNvbnN0cmFpbnQobmV3IChraXdpXzEuRXhwcmVzc2lvbi5iaW5kLmFwcGx5KGtpd2lfMS5FeHByZXNzaW9uLCBbdm9pZCAwXS5jb25jYXQodGVybXMpKSkoKSwgb3ApO1xuICAgIH07XG59XG5mdW5jdGlvbiBfd2Vha19jb25zdHJhaW5lcihvcCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZXJtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdGVybXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGtpd2lfMS5Db25zdHJhaW50KG5ldyAoa2l3aV8xLkV4cHJlc3Npb24uYmluZC5hcHBseShraXdpXzEuRXhwcmVzc2lvbiwgW3ZvaWQgMF0uY29uY2F0KHRlcm1zKSkpKCksIG9wLCBraXdpXzEuU3RyZW5ndGgud2Vhayk7XG4gICAgfTtcbn1cbmV4cG9ydHMuRVEgPSBfY29uc3RyYWluZXIoa2l3aV8xLk9wZXJhdG9yLkVxKTtcbmV4cG9ydHMuTEUgPSBfY29uc3RyYWluZXIoa2l3aV8xLk9wZXJhdG9yLkxlKTtcbmV4cG9ydHMuR0UgPSBfY29uc3RyYWluZXIoa2l3aV8xLk9wZXJhdG9yLkdlKTtcbmV4cG9ydHMuV0VBS19FUSA9IF93ZWFrX2NvbnN0cmFpbmVyKGtpd2lfMS5PcGVyYXRvci5FcSk7XG5leHBvcnRzLldFQUtfTEUgPSBfd2Vha19jb25zdHJhaW5lcihraXdpXzEuT3BlcmF0b3IuTGUpO1xuZXhwb3J0cy5XRUFLX0dFID0gX3dlYWtfY29uc3RyYWluZXIoa2l3aV8xLk9wZXJhdG9yLkdlKTtcbnZhciBTb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNvbHZlcigpIHtcbiAgICAgICAgdGhpcy5zb2x2ZXIgPSBuZXcga2l3aV8xLlNvbHZlcigpO1xuICAgIH1cbiAgICBTb2x2ZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNvbHZlciA9IG5ldyBraXdpXzEuU29sdmVyKCk7XG4gICAgfTtcbiAgICBTb2x2ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJTb2x2ZXIobnVtX2NvbnN0cmFpbnRzPVwiICsgdGhpcy5udW1fY29uc3RyYWludHMgKyBcIiwgbnVtX2VkaXRfdmFyaWFibGVzPVwiICsgdGhpcy5udW1fZWRpdF92YXJpYWJsZXMgKyBcIilcIjtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb2x2ZXIucHJvdG90eXBlLCBcIm51bV9jb25zdHJhaW50c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc29sdmVyLm51bUNvbnN0cmFpbnRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU29sdmVyLnByb3RvdHlwZSwgXCJudW1fZWRpdF92YXJpYWJsZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvbHZlci5udW1FZGl0VmFyaWFibGVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTb2x2ZXIucHJvdG90eXBlLnVwZGF0ZV92YXJpYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc29sdmVyLnVwZGF0ZVZhcmlhYmxlcygpO1xuICAgIH07XG4gICAgU29sdmVyLnByb3RvdHlwZS5oYXNfY29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvbHZlci5oYXNDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xuICAgIH07XG4gICAgU29sdmVyLnByb3RvdHlwZS5hZGRfY29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICAgIHRoaXMuc29sdmVyLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG4gICAgfTtcbiAgICBTb2x2ZXIucHJvdG90eXBlLnJlbW92ZV9jb25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgdGhpcy5zb2x2ZXIucmVtb3ZlQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAgICB9O1xuICAgIFNvbHZlci5wcm90b3R5cGUuYWRkX2VkaXRfdmFyaWFibGUgPSBmdW5jdGlvbiAodmFyaWFibGUsIHN0cmVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc29sdmVyLmFkZEVkaXRWYXJpYWJsZSh2YXJpYWJsZSwgc3RyZW5ndGgpO1xuICAgIH07XG4gICAgU29sdmVyLnByb3RvdHlwZS5yZW1vdmVfZWRpdF92YXJpYWJsZSA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgICAgICB0aGlzLnNvbHZlci5yZW1vdmVFZGl0VmFyaWFibGUodmFyaWFibGUpO1xuICAgIH07XG4gICAgU29sdmVyLnByb3RvdHlwZS5zdWdnZXN0X3ZhbHVlID0gZnVuY3Rpb24gKHZhcmlhYmxlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnNvbHZlci5zdWdnZXN0VmFsdWUodmFyaWFibGUsIHZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBTb2x2ZXI7XG59KCkpO1xuZXhwb3J0cy5Tb2x2ZXIgPSBTb2x2ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMb2dMZXZlbCwgX2xvZ2dlcnMsIF9tZXRob2RfZmFjdG9yeSwgbm9vcCwgaW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSlcbiAgICAgICAgcmV0dXJuIGk7XG59IHJldHVybiAtMTsgfTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdXRpbC90eXBlc1wiKTtcbm5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG5fbWV0aG9kX2ZhY3RvcnkgPSBmdW5jdGlvbiAobWV0aG9kX25hbWUsIGxvZ2dlcl9uYW1lKSB7XG4gICAgaWYgKGNvbnNvbGVbbWV0aG9kX25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGVbbWV0aG9kX25hbWVdLmJpbmQoY29uc29sZSwgbG9nZ2VyX25hbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb25zb2xlLmxvZyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUsIGxvZ2dlcl9uYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbn07XG5fbG9nZ2VycyA9IHt9O1xuTG9nTGV2ZWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ0xldmVsKG5hbWUsIGxldmVsKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgcmV0dXJuIExvZ0xldmVsO1xufSkoKTtcbmV4cG9ydHMuTG9nZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBMb2dnZXIuVFJBQ0UgPSBuZXcgTG9nTGV2ZWwoXCJ0cmFjZVwiLCAwKTtcbiAgICBMb2dnZXIuREVCVUcgPSBuZXcgTG9nTGV2ZWwoXCJkZWJ1Z1wiLCAxKTtcbiAgICBMb2dnZXIuSU5GTyA9IG5ldyBMb2dMZXZlbChcImluZm9cIiwgMik7XG4gICAgTG9nZ2VyLldBUk4gPSBuZXcgTG9nTGV2ZWwoXCJ3YXJuXCIsIDYpO1xuICAgIExvZ2dlci5FUlJPUiA9IG5ldyBMb2dMZXZlbChcImVycm9yXCIsIDcpO1xuICAgIExvZ2dlci5GQVRBTCA9IG5ldyBMb2dMZXZlbChcImZhdGFsXCIsIDgpO1xuICAgIExvZ2dlci5PRkYgPSBuZXcgTG9nTGV2ZWwoXCJvZmZcIiwgOSk7XG4gICAgTG9nZ2VyLmxvZ19sZXZlbHMgPSB7XG4gICAgICAgIHRyYWNlOiBMb2dnZXIuVFJBQ0UsXG4gICAgICAgIGRlYnVnOiBMb2dnZXIuREVCVUcsXG4gICAgICAgIGluZm86IExvZ2dlci5JTkZPLFxuICAgICAgICB3YXJuOiBMb2dnZXIuV0FSTixcbiAgICAgICAgZXJyb3I6IExvZ2dlci5FUlJPUixcbiAgICAgICAgZmF0YWw6IExvZ2dlci5GQVRBTCxcbiAgICAgICAgb2ZmOiBMb2dnZXIuT0ZGXG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nZ2VyLCAnbGV2ZWxzJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhMb2dnZXIubG9nX2xldmVscyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBMb2dnZXIuZ2V0ID0gZnVuY3Rpb24gKG5hbWUsIGxldmVsKSB7XG4gICAgICAgIHZhciBsb2dnZXI7XG4gICAgICAgIGlmIChsZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXZlbCA9IExvZ2dlci5JTkZPO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlc18xLmlzU3RyaW5nKG5hbWUpICYmIG5hbWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNbbmFtZV07XG4gICAgICAgICAgICBpZiAobG9nZ2VyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc1tuYW1lXSA9IG5ldyBMb2dnZXIobmFtZSwgbGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJMb2dnZXIuZ2V0KCkgZXhwZWN0cyBhIHN0cmluZyBuYW1lIGFuZCBhbiBvcHRpb25hbCBsb2ctbGV2ZWxcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBsZXZlbCkge1xuICAgICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV2ZWwgPSBMb2dnZXIuSU5GTztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zZXRfbGV2ZWwobGV2ZWwpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nZ2VyLnByb3RvdHlwZSwgJ2xldmVsJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldF9sZXZlbCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgTG9nZ2VyLnByb3RvdHlwZS5nZXRfbGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dfbGV2ZWw7XG4gICAgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLnNldF9sZXZlbCA9IGZ1bmN0aW9uIChsb2dfbGV2ZWwpIHtcbiAgICAgICAgdmFyIF9fLCBsb2dnZXJfbmFtZSwgbWV0aG9kX25hbWUsIHJlZiwgcmVzdWx0cztcbiAgICAgICAgaWYgKGxvZ19sZXZlbCBpbnN0YW5jZW9mIExvZ0xldmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dfbGV2ZWwgPSBsb2dfbGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc1N0cmluZyhsb2dfbGV2ZWwpICYmIChMb2dnZXIubG9nX2xldmVsc1tsb2dfbGV2ZWxdICE9IG51bGwpKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dfbGV2ZWwgPSBMb2dnZXIubG9nX2xldmVsc1tsb2dfbGV2ZWxdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9nZ2VyLnNldF9sZXZlbCgpIGV4cGVjdHMgYSBsb2ctbGV2ZWwgb2JqZWN0IG9yIGEgc3RyaW5nIG5hbWUgb2YgYSBsb2ctbGV2ZWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyX25hbWUgPSBcIltcIiArIHRoaXMuX25hbWUgKyBcIl1cIjtcbiAgICAgICAgcmVmID0gTG9nZ2VyLmxvZ19sZXZlbHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfXyBpbiByZWYpIHtcbiAgICAgICAgICAgIGxvZ19sZXZlbCA9IHJlZltfX107XG4gICAgICAgICAgICBpZiAobG9nX2xldmVsID09PSBMb2dnZXIuT0ZGKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRob2RfbmFtZSA9IGxvZ19sZXZlbC5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChsb2dfbGV2ZWwubGV2ZWwgPCB0aGlzLl9sb2dfbGV2ZWwubGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXNbbWV0aG9kX25hbWVdID0gbm9vcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpc1ttZXRob2RfbmFtZV0gPSBfbWV0aG9kX2ZhY3RvcnkobWV0aG9kX25hbWUsIGxvZ2dlcl9uYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgcmV0dXJuIExvZ2dlcjtcbn0pKCk7XG5leHBvcnRzLmxvZ2dlciA9IGV4cG9ydHMuTG9nZ2VyLmdldChcImJva2VoXCIpO1xuZXhwb3J0cy5zZXRfbG9nX2xldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgaWYgKGluZGV4T2YuY2FsbChleHBvcnRzLkxvZ2dlci5sZXZlbHMsIGxldmVsKSA8IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbYm9rZWhdIHVucmVjb2duaXplZCBsb2dnaW5nIGxldmVsICdcIiArIGxldmVsICsgXCInIHBhc3NlZCB0byBCb2tlaC5zZXRfbG9nX2xldmVsKCksIGlnbm9yaW5nXCIpO1xuICAgICAgICByZXR1cm4gY29uc29sZS5sb2coXCJbYm9rZWhdIHZhbGlkIGxvZyBsZXZlbHMgYXJlOiBcIiArIChleHBvcnRzLkxvZ2dlci5sZXZlbHMuam9pbignLCAnKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbYm9rZWhdIHNldHRpbmcgbG9nIGxldmVsIHRvOiAnXCIgKyBsZXZlbCArIFwiJ1wiKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubG9nZ2VyLnNldF9sZXZlbChsZXZlbCk7XG4gICAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZhbHVlVG9TdHJpbmcsIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSwgaW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSlcbiAgICAgICAgcmV0dXJuIGk7XG59IHJldHVybiAtMTsgfTtcbnZhciBzaWduYWxpbmdfMSA9IHJlcXVpcmUoXCIuL3NpZ25hbGluZ1wiKTtcbnZhciBlbnVtcyA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xudmFyIHN2Z19jb2xvcnMgPSByZXF1aXJlKFwiLi91dGlsL3N2Z19jb2xvcnNcIik7XG52YXIgY29sb3JfMSA9IHJlcXVpcmUoXCIuL3V0aWwvY29sb3JcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL3V0aWwvYXJyYXlcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3V0aWwvdHlwZXNcIik7XG52YWx1ZVRvU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbn07XG5leHBvcnRzLlByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBleHRlbmQoUHJvcGVydHkucHJvdG90eXBlLCBzaWduYWxpbmdfMS5TaWduYWxhYmxlKTtcbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUuZGF0YXNwZWMgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBQcm9wZXJ0eShhcmcpIHtcbiAgICAgICAgdGhpcy5vYmogPSBhcmcub2JqLCB0aGlzLmF0dHIgPSBhcmcuYXR0ciwgdGhpcy5kZWZhdWx0X3ZhbHVlID0gYXJnLmRlZmF1bHRfdmFsdWU7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgICAgdGhpcy5jaGFuZ2UgPSBuZXcgc2lnbmFsaW5nXzEuU2lnbmFsKHRoaXMub2JqLCBcImNoYW5nZVwiKTtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMuY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9pbml0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9iai5wcm9wY2hhbmdlLmVtaXQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICB9XG4gICAgUHJvcGVydHkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXQoKTtcbiAgICB9O1xuICAgIFByb3BlcnR5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFByb3BlcnR5LnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHsgfTtcbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoZG9fc3BlY190cmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgaWYgKGRvX3NwZWNfdHJhbnNmb3JtID09IG51bGwpIHtcbiAgICAgICAgICAgIGRvX3NwZWNfdHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zcGVjLnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dGVtcHRlZCB0byByZXRyaWV2ZSBwcm9wZXJ0eSB2YWx1ZSBmb3IgcHJvcGVydHkgd2l0aG91dCB2YWx1ZSBzcGVjaWZpY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldCA9IHRoaXMudHJhbnNmb3JtKFt0aGlzLnNwZWMudmFsdWVdKVswXTtcbiAgICAgICAgaWYgKCh0aGlzLnNwZWMudHJhbnNmb3JtICE9IG51bGwpICYmIGRvX3NwZWNfdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXQgPSB0aGlzLnNwZWMudHJhbnNmb3JtLmNvbXB1dGUocmV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgUHJvcGVydHkucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICB2YXIgZGF0YSwgaSwgbGVuZ3RoLCByZXQsIHZhbHVlO1xuICAgICAgICBpZiAoIXRoaXMuZGF0YXNwZWMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dGVtcHRlZCB0byByZXRyaWV2ZSBwcm9wZXJ0eSBhcnJheSBmb3Igbm9uLWRhdGFzcGVjIHByb3BlcnR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBzb3VyY2UuZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy5maWVsZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zcGVjLmZpZWxkIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXQgPSB0aGlzLnRyYW5zZm9ybShzb3VyY2UuZ2V0X2NvbHVtbih0aGlzLnNwZWMuZmllbGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dGVtcHRlZCB0byByZXRyaWV2ZSBwcm9wZXJ0eSBhcnJheSBmb3Igbm9uZXhpc3RlbnQgZmllbGQgJ1wiICsgdGhpcy5zcGVjLmZpZWxkICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gc291cmNlLmdldF9sZW5ndGgoKTtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWUoZmFsc2UpO1xuICAgICAgICAgICAgcmV0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gbGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNwZWMudHJhbnNmb3JtICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldCA9IHRoaXMuc3BlYy50cmFuc2Zvcm0udl9jb21wdXRlKHJldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIFByb3BlcnR5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGF0dHIsIGF0dHJfdmFsdWUsIGRlZmF1bHRfdmFsdWUsIG9iajtcbiAgICAgICAgb2JqID0gdGhpcy5vYmo7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBwcm9wZXJ0eSBvYmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5wcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb3BlcnR5IG9iamVjdCBtdXN0IGJlIGEgSGFzUHJvcHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXR0ciA9IHRoaXMuYXR0cjtcbiAgICAgICAgaWYgKGF0dHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBwcm9wZXJ0eSBhdHRyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJfdmFsdWUgPSBvYmouZ2V0dihhdHRyKTtcbiAgICAgICAgaWYgKGF0dHJfdmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVmYXVsdF92YWx1ZSA9IHRoaXMuZGVmYXVsdF92YWx1ZTtcbiAgICAgICAgICAgIGF0dHJfdmFsdWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBkZWZhdWx0X3ZhbHVlICE9PSB2b2lkIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAhdHlwZXNfMS5pc0FycmF5KGRlZmF1bHRfdmFsdWUpOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5XzEuY29weShkZWZhdWx0X3ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAhdHlwZXNfMS5pc0Z1bmN0aW9uKGRlZmF1bHRfdmFsdWUpOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRfdmFsdWUob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0X3ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBvYmouc2V0dihhdHRyLCBhdHRyX3ZhbHVlLCB7XG4gICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZXNfMS5pc0FycmF5KGF0dHJfdmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWMgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGF0dHJfdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc09iamVjdChhdHRyX3ZhbHVlKSAmJiAoKGF0dHJfdmFsdWUudmFsdWUgPT09IHZvaWQgMCkgIT09IChhdHRyX3ZhbHVlLmZpZWxkID09PSB2b2lkIDApKSkge1xuICAgICAgICAgICAgdGhpcy5zcGVjID0gYXR0cl92YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3BlYyA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXR0cl92YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRoaXMuc3BlYy5maWVsZCAhPSBudWxsKSAmJiAhdHlwZXNfMS5pc1N0cmluZyh0aGlzLnNwZWMuZmllbGQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaWVsZCB2YWx1ZSBmb3IgcHJvcGVydHkgJ1wiICsgYXR0ciArIFwiJyBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3BlYy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlKHRoaXMuc3BlYy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdCgpO1xuICAgIH07XG4gICAgUHJvcGVydHkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCIoXCIgKyB0aGlzLm9iaiArIFwiLlwiICsgdGhpcy5hdHRyICsgXCIsIHNwZWM6IFwiICsgKHZhbHVlVG9TdHJpbmcodGhpcy5zcGVjKSkgKyBcIilcIjtcbiAgICB9O1xuICAgIHJldHVybiBQcm9wZXJ0eTtcbn0pKCk7XG5leHBvcnRzLnNpbXBsZV9wcm9wID0gZnVuY3Rpb24gKG5hbWUsIHByZWQpIHtcbiAgICB2YXIgUHJvcDtcbiAgICByZXR1cm4gUHJvcCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgICAgICBleHRlbmQoUHJvcCwgc3VwZXJDbGFzcyk7XG4gICAgICAgIGZ1bmN0aW9uIFByb3AoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvcC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBQcm9wLnByb3RvdHlwZS5uYW1lID0gbmFtZTtcbiAgICAgICAgUHJvcC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghcHJlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArIFwiIHByb3BlcnR5ICdcIiArIHRoaXMuYXR0ciArIFwiJyBnaXZlbiBpbnZhbGlkIHZhbHVlOiBcIiArICh2YWx1ZVRvU3RyaW5nKHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJvcDtcbiAgICB9KShleHBvcnRzLlByb3BlcnR5KTtcbn07XG5leHBvcnRzLkFueSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBbnksIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFueSgpIHtcbiAgICAgICAgcmV0dXJuIEFueS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIEFueTtcbn0pKGV4cG9ydHMuc2ltcGxlX3Byb3AoXCJBbnlcIiwgZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pKTtcbmV4cG9ydHMuQXJyYXkgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQXJyYXksIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFycmF5KCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheTtcbn0pKGV4cG9ydHMuc2ltcGxlX3Byb3AoXCJBcnJheVwiLCBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB0eXBlc18xLmlzQXJyYXkoeCkgfHwgeCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheTtcbn0pKTtcbmV4cG9ydHMuQm9vbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChCb29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBCb29sKCkge1xuICAgICAgICByZXR1cm4gQm9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIEJvb2w7XG59KShleHBvcnRzLnNpbXBsZV9wcm9wKFwiQm9vbFwiLCB0eXBlc18xLmlzQm9vbGVhbikpO1xuZXhwb3J0cy5Cb29sZWFuID0gZXhwb3J0cy5Cb29sO1xuZXhwb3J0cy5Db2xvciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDb2xvciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiBDb2xvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIENvbG9yO1xufSkoZXhwb3J0cy5zaW1wbGVfcHJvcChcIkNvbG9yXCIsIGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIChzdmdfY29sb3JzW3gudG9Mb3dlckNhc2UoKV0gIT0gbnVsbCkgfHwgeC5zdWJzdHJpbmcoMCwgMSkgPT09IFwiI1wiIHx8IGNvbG9yXzEudmFsaWRfcmdiKHgpO1xufSkpO1xuZXhwb3J0cy5JbnN0YW5jZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChJbnN0YW5jZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiBJbnN0YW5jZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIEluc3RhbmNlO1xufSkoZXhwb3J0cy5zaW1wbGVfcHJvcChcIkluc3RhbmNlXCIsIGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHgucHJvcGVydGllcyAhPSBudWxsO1xufSkpO1xuZXhwb3J0cy5OdW1iZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTnVtYmVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXI7XG59KShleHBvcnRzLnNpbXBsZV9wcm9wKFwiTnVtYmVyXCIsIGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHR5cGVzXzEuaXNOdW1iZXIoeCkgfHwgdHlwZXNfMS5pc0Jvb2xlYW4oeCk7XG59KSk7XG5leHBvcnRzLkludCA9IGV4cG9ydHMuTnVtYmVyO1xuZXhwb3J0cy5QZXJjZW50ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFBlcmNlbnQsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFBlcmNlbnQoKSB7XG4gICAgICAgIHJldHVybiBQZXJjZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gUGVyY2VudDtcbn0pKGV4cG9ydHMuc2ltcGxlX3Byb3AoXCJOdW1iZXJcIiwgZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gKHR5cGVzXzEuaXNOdW1iZXIoeCkgfHwgdHlwZXNfMS5pc0Jvb2xlYW4oeCkpICYmICgoMCA8PSB4ICYmIHggPD0gMS4wKSk7XG59KSk7XG5leHBvcnRzLlN0cmluZyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTdHJpbmcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZztcbn0pKGV4cG9ydHMuc2ltcGxlX3Byb3AoXCJTdHJpbmdcIiwgdHlwZXNfMS5pc1N0cmluZykpO1xuZXhwb3J0cy5Gb250ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEZvbnQsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEZvbnQoKSB7XG4gICAgICAgIHJldHVybiBGb250Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gRm9udDtcbn0pKGV4cG9ydHMuU3RyaW5nKTtcbmV4cG9ydHMuZW51bV9wcm9wID0gZnVuY3Rpb24gKG5hbWUsIGVudW1fdmFsdWVzKSB7XG4gICAgdmFyIEVudW07XG4gICAgcmV0dXJuIEVudW0gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgZXh0ZW5kKEVudW0sIHN1cGVyQ2xhc3MpO1xuICAgICAgICBmdW5jdGlvbiBFbnVtKCkge1xuICAgICAgICAgICAgcmV0dXJuIEVudW0uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgRW51bS5wcm90b3R5cGUubmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBFbnVtO1xuICAgIH0pKGV4cG9ydHMuc2ltcGxlX3Byb3AobmFtZSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4T2YuY2FsbChlbnVtX3ZhbHVlcywgeCkgPj0gMDtcbiAgICB9KSk7XG59O1xuZXhwb3J0cy5BbmNob3IgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQW5jaG9yLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBbmNob3IoKSB7XG4gICAgICAgIHJldHVybiBBbmNob3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBBbmNob3I7XG59KShleHBvcnRzLmVudW1fcHJvcChcIkFuY2hvclwiLCBlbnVtcy5MZWdlbmRMb2NhdGlvbikpO1xuZXhwb3J0cy5BbmdsZVVuaXRzID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFuZ2xlVW5pdHMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFuZ2xlVW5pdHMoKSB7XG4gICAgICAgIHJldHVybiBBbmdsZVVuaXRzLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gQW5nbGVVbml0cztcbn0pKGV4cG9ydHMuZW51bV9wcm9wKFwiQW5nbGVVbml0c1wiLCBlbnVtcy5BbmdsZVVuaXRzKSk7XG5leHBvcnRzLkRpcmVjdGlvbiA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEaXJlY3Rpb24sIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERpcmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGlyZWN0aW9uLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBpLCBqLCByZWYsIHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB2YWx1ZXMubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIHN3aXRjaCAodmFsdWVzW2ldKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xvY2snOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYW50aWNsb2NrJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIERpcmVjdGlvbjtcbn0pKGV4cG9ydHMuZW51bV9wcm9wKFwiRGlyZWN0aW9uXCIsIGVudW1zLkRpcmVjdGlvbikpO1xuZXhwb3J0cy5EaW1lbnNpb24gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRGltZW5zaW9uLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBEaW1lbnNpb24oKSB7XG4gICAgICAgIHJldHVybiBEaW1lbnNpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBEaW1lbnNpb247XG59KShleHBvcnRzLmVudW1fcHJvcChcIkRpbWVuc2lvblwiLCBlbnVtcy5EaW1lbnNpb24pKTtcbmV4cG9ydHMuRGltZW5zaW9ucyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEaW1lbnNpb25zLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBEaW1lbnNpb25zKCkge1xuICAgICAgICByZXR1cm4gRGltZW5zaW9ucy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIERpbWVuc2lvbnM7XG59KShleHBvcnRzLmVudW1fcHJvcChcIkRpbWVuc2lvbnNcIiwgZW51bXMuRGltZW5zaW9ucykpO1xuZXhwb3J0cy5Gb250U3R5bGUgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRm9udFN0eWxlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBGb250U3R5bGUoKSB7XG4gICAgICAgIHJldHVybiBGb250U3R5bGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBGb250U3R5bGU7XG59KShleHBvcnRzLmVudW1fcHJvcChcIkZvbnRTdHlsZVwiLCBlbnVtcy5Gb250U3R5bGUpKTtcbmV4cG9ydHMuTGF0TG9uID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExhdExvbiwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGF0TG9uKCkge1xuICAgICAgICByZXR1cm4gTGF0TG9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gTGF0TG9uO1xufSkoZXhwb3J0cy5lbnVtX3Byb3AoXCJMYXRMb25cIiwgZW51bXMuTGF0TG9uKSk7XG5leHBvcnRzLkxpbmVDYXAgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTGluZUNhcCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGluZUNhcCgpIHtcbiAgICAgICAgcmV0dXJuIExpbmVDYXAuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBMaW5lQ2FwO1xufSkoZXhwb3J0cy5lbnVtX3Byb3AoXCJMaW5lQ2FwXCIsIGVudW1zLkxpbmVDYXApKTtcbmV4cG9ydHMuTGluZUpvaW4gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTGluZUpvaW4sIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExpbmVKb2luKCkge1xuICAgICAgICByZXR1cm4gTGluZUpvaW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBMaW5lSm9pbjtcbn0pKGV4cG9ydHMuZW51bV9wcm9wKFwiTGluZUpvaW5cIiwgZW51bXMuTGluZUpvaW4pKTtcbmV4cG9ydHMuTGVnZW5kTG9jYXRpb24gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTGVnZW5kTG9jYXRpb24sIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExlZ2VuZExvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gTGVnZW5kTG9jYXRpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBMZWdlbmRMb2NhdGlvbjtcbn0pKGV4cG9ydHMuZW51bV9wcm9wKFwiTGVnZW5kTG9jYXRpb25cIiwgZW51bXMuTGVnZW5kTG9jYXRpb24pKTtcbmV4cG9ydHMuTG9jYXRpb24gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTG9jYXRpb24sIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gTG9jYXRpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBMb2NhdGlvbjtcbn0pKGV4cG9ydHMuZW51bV9wcm9wKFwiTG9jYXRpb25cIiwgZW51bXMuTG9jYXRpb24pKTtcbmV4cG9ydHMuT3V0cHV0QmFja2VuZCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChPdXRwdXRCYWNrZW5kLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBPdXRwdXRCYWNrZW5kKCkge1xuICAgICAgICByZXR1cm4gT3V0cHV0QmFja2VuZC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIE91dHB1dEJhY2tlbmQ7XG59KShleHBvcnRzLmVudW1fcHJvcChcIk91dHB1dEJhY2tlbmRcIiwgZW51bXMuT3V0cHV0QmFja2VuZCkpO1xuZXhwb3J0cy5PcmllbnRhdGlvbiA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChPcmllbnRhdGlvbiwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gT3JpZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiBPcmllbnRhdGlvbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIE9yaWVudGF0aW9uO1xufSkoZXhwb3J0cy5lbnVtX3Byb3AoXCJPcmllbnRhdGlvblwiLCBlbnVtcy5PcmllbnRhdGlvbikpO1xuZXhwb3J0cy5UZXh0QWxpZ24gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVGV4dEFsaWduLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUZXh0QWxpZ24oKSB7XG4gICAgICAgIHJldHVybiBUZXh0QWxpZ24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBUZXh0QWxpZ247XG59KShleHBvcnRzLmVudW1fcHJvcChcIlRleHRBbGlnblwiLCBlbnVtcy5UZXh0QWxpZ24pKTtcbmV4cG9ydHMuVGV4dEJhc2VsaW5lID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRleHRCYXNlbGluZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVGV4dEJhc2VsaW5lKCkge1xuICAgICAgICByZXR1cm4gVGV4dEJhc2VsaW5lLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gVGV4dEJhc2VsaW5lO1xufSkoZXhwb3J0cy5lbnVtX3Byb3AoXCJUZXh0QmFzZWxpbmVcIiwgZW51bXMuVGV4dEJhc2VsaW5lKSk7XG5leHBvcnRzLlJlbmRlckxldmVsID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJlbmRlckxldmVsLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBSZW5kZXJMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIFJlbmRlckxldmVsLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gUmVuZGVyTGV2ZWw7XG59KShleHBvcnRzLmVudW1fcHJvcChcIlJlbmRlckxldmVsXCIsIGVudW1zLlJlbmRlckxldmVsKSk7XG5leHBvcnRzLlJlbmRlck1vZGUgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmVuZGVyTW9kZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUmVuZGVyTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIFJlbmRlck1vZGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBSZW5kZXJNb2RlO1xufSkoZXhwb3J0cy5lbnVtX3Byb3AoXCJSZW5kZXJNb2RlXCIsIGVudW1zLlJlbmRlck1vZGUpKTtcbmV4cG9ydHMuU2l6aW5nTW9kZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTaXppbmdNb2RlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTaXppbmdNb2RlKCkge1xuICAgICAgICByZXR1cm4gU2l6aW5nTW9kZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFNpemluZ01vZGU7XG59KShleHBvcnRzLmVudW1fcHJvcChcIlNpemluZ01vZGVcIiwgZW51bXMuU2l6aW5nTW9kZSkpO1xuZXhwb3J0cy5TcGF0aWFsVW5pdHMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU3BhdGlhbFVuaXRzLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTcGF0aWFsVW5pdHMoKSB7XG4gICAgICAgIHJldHVybiBTcGF0aWFsVW5pdHMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBTcGF0aWFsVW5pdHM7XG59KShleHBvcnRzLmVudW1fcHJvcChcIlNwYXRpYWxVbml0c1wiLCBlbnVtcy5TcGF0aWFsVW5pdHMpKTtcbmV4cG9ydHMuRGlzdHJpYnV0aW9uID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERpc3RyaWJ1dGlvbiwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRGlzdHJpYnV0aW9uKCkge1xuICAgICAgICByZXR1cm4gRGlzdHJpYnV0aW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gRGlzdHJpYnV0aW9uO1xufSkoZXhwb3J0cy5lbnVtX3Byb3AoXCJEaXN0cmlidXRpb25cIiwgZW51bXMuRGlzdHJpYnV0aW9uVHlwZXMpKTtcbmV4cG9ydHMuVHJhbnNmb3JtU3RlcE1vZGUgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVHJhbnNmb3JtU3RlcE1vZGUsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0ZXBNb2RlKCkge1xuICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RlcE1vZGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc2Zvcm1TdGVwTW9kZTtcbn0pKGV4cG9ydHMuZW51bV9wcm9wKFwiVHJhbnNmb3JtU3RlcE1vZGVcIiwgZW51bXMuVHJhbnNmb3JtU3RlcE1vZGVzKSk7XG5leHBvcnRzLlBhZGRpbmdVbml0cyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQYWRkaW5nVW5pdHMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFBhZGRpbmdVbml0cygpIHtcbiAgICAgICAgcmV0dXJuIFBhZGRpbmdVbml0cy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFBhZGRpbmdVbml0cztcbn0pKGV4cG9ydHMuZW51bV9wcm9wKFwiUGFkZGluZ1VuaXRzXCIsIGVudW1zLlBhZGRpbmdVbml0cykpO1xuZXhwb3J0cy5TdGFydEVuZCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTdGFydEVuZCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gU3RhcnRFbmQoKSB7XG4gICAgICAgIHJldHVybiBTdGFydEVuZC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0YXJ0RW5kO1xufSkoZXhwb3J0cy5lbnVtX3Byb3AoXCJTdGFydEVuZFwiLCBlbnVtcy5TdGFydEVuZCkpO1xuZXhwb3J0cy51bml0c19wcm9wID0gZnVuY3Rpb24gKG5hbWUsIHZhbGlkX3VuaXRzLCBkZWZhdWx0X3VuaXRzKSB7XG4gICAgdmFyIFVuaXRzUHJvcDtcbiAgICByZXR1cm4gVW5pdHNQcm9wID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgICAgIGV4dGVuZChVbml0c1Byb3AsIHN1cGVyQ2xhc3MpO1xuICAgICAgICBmdW5jdGlvbiBVbml0c1Byb3AoKSB7XG4gICAgICAgICAgICByZXR1cm4gVW5pdHNQcm9wLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIFVuaXRzUHJvcC5wcm90b3R5cGUubmFtZSA9IG5hbWU7XG4gICAgICAgIFVuaXRzUHJvcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1bml0cztcbiAgICAgICAgICAgIGlmICh0aGlzLnNwZWMudW5pdHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3BlYy51bml0cyA9IGRlZmF1bHRfdW5pdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVuaXRzID0gdGhpcy5zcGVjLnVuaXRzO1xuICAgICAgICAgICAgdW5pdHMgPSB0aGlzLnNwZWMudW5pdHM7XG4gICAgICAgICAgICBpZiAoaW5kZXhPZi5jYWxsKHZhbGlkX3VuaXRzLCB1bml0cykgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyBcIiB1bml0cyBtdXN0IGJlIG9uZSBvZiBcIiArIHZhbGlkX3VuaXRzICsgXCIsIGdpdmVuIGludmFsaWQgdmFsdWU6IFwiICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVW5pdHNQcm9wO1xuICAgIH0pKGV4cG9ydHMuTnVtYmVyKTtcbn07XG5leHBvcnRzLkFuZ2xlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFuZ2xlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBbmdsZSgpIHtcbiAgICAgICAgcmV0dXJuIEFuZ2xlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBbmdsZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICB2YXIgeDtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy51bml0cyA9PT0gXCJkZWdcIikge1xuICAgICAgICAgICAgdmFsdWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHZhbHVlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHggKiBNYXRoLlBJIC8gMTgwLjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICB4ID0gdmFsdWVzW2pdO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCgteCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIEFuZ2xlLl9fc3VwZXJfXy50cmFuc2Zvcm0uY2FsbCh0aGlzLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEFuZ2xlO1xufSkoZXhwb3J0cy51bml0c19wcm9wKFwiQW5nbGVcIiwgZW51bXMuQW5nbGVVbml0cywgXCJyYWRcIikpO1xuZXhwb3J0cy5EaXN0YW5jZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEaXN0YW5jZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRGlzdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiBEaXN0YW5jZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIERpc3RhbmNlO1xufSkoZXhwb3J0cy51bml0c19wcm9wKFwiRGlzdGFuY2VcIiwgZW51bXMuU3BhdGlhbFVuaXRzLCBcImRhdGFcIikpO1xuZXhwb3J0cy5BbmdsZVNwZWMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQW5nbGVTcGVjLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBbmdsZVNwZWMoKSB7XG4gICAgICAgIHJldHVybiBBbmdsZVNwZWMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFuZ2xlU3BlYy5wcm90b3R5cGUuZGF0YXNwZWMgPSB0cnVlO1xuICAgIHJldHVybiBBbmdsZVNwZWM7XG59KShleHBvcnRzLkFuZ2xlKTtcbmV4cG9ydHMuQ29sb3JTcGVjID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENvbG9yU3BlYywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ29sb3JTcGVjKCkge1xuICAgICAgICByZXR1cm4gQ29sb3JTcGVjLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDb2xvclNwZWMucHJvdG90eXBlLmRhdGFzcGVjID0gdHJ1ZTtcbiAgICByZXR1cm4gQ29sb3JTcGVjO1xufSkoZXhwb3J0cy5Db2xvcik7XG5leHBvcnRzLkRpcmVjdGlvblNwZWMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRGlyZWN0aW9uU3BlYywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRGlyZWN0aW9uU3BlYygpIHtcbiAgICAgICAgcmV0dXJuIERpcmVjdGlvblNwZWMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpcmVjdGlvblNwZWMucHJvdG90eXBlLmRhdGFzcGVjID0gdHJ1ZTtcbiAgICByZXR1cm4gRGlyZWN0aW9uU3BlYztcbn0pKGV4cG9ydHMuRGlzdGFuY2UpO1xuZXhwb3J0cy5EaXN0YW5jZVNwZWMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRGlzdGFuY2VTcGVjLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBEaXN0YW5jZVNwZWMoKSB7XG4gICAgICAgIHJldHVybiBEaXN0YW5jZVNwZWMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpc3RhbmNlU3BlYy5wcm90b3R5cGUuZGF0YXNwZWMgPSB0cnVlO1xuICAgIHJldHVybiBEaXN0YW5jZVNwZWM7XG59KShleHBvcnRzLkRpc3RhbmNlKTtcbmV4cG9ydHMuRm9udFNpemVTcGVjID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEZvbnRTaXplU3BlYywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRm9udFNpemVTcGVjKCkge1xuICAgICAgICByZXR1cm4gRm9udFNpemVTcGVjLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBGb250U2l6ZVNwZWMucHJvdG90eXBlLmRhdGFzcGVjID0gdHJ1ZTtcbiAgICByZXR1cm4gRm9udFNpemVTcGVjO1xufSkoZXhwb3J0cy5TdHJpbmcpO1xuZXhwb3J0cy5OdW1iZXJTcGVjID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE51bWJlclNwZWMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIE51bWJlclNwZWMoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXJTcGVjLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBOdW1iZXJTcGVjLnByb3RvdHlwZS5kYXRhc3BlYyA9IHRydWU7XG4gICAgcmV0dXJuIE51bWJlclNwZWM7XG59KShleHBvcnRzLk51bWJlcik7XG5leHBvcnRzLlN0cmluZ1NwZWMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU3RyaW5nU3BlYywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gU3RyaW5nU3BlYygpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZ1NwZWMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFN0cmluZ1NwZWMucHJvdG90eXBlLmRhdGFzcGVjID0gdHJ1ZTtcbiAgICByZXR1cm4gU3RyaW5nU3BlYztcbn0pKGV4cG9ydHMuU3RyaW5nKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9maWxsX21peGluLCBfZ2VuX21peGluLCBfbGluZV9taXhpbiwgX3RleHRfbWl4aW47XG52YXIgcCA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXNcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiLi91dGlsL29iamVjdFwiKTtcbl9nZW5fbWl4aW4gPSBmdW5jdGlvbiAobWl4aW4sIHByZWZpeCkge1xuICAgIHZhciBuYW1lLCByZXN1bHQsIHR5cGU7XG4gICAgcmVzdWx0ID0ge307XG4gICAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgICAgIHByZWZpeCA9IFwiXCI7XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBtaXhpbikge1xuICAgICAgICB0eXBlID0gbWl4aW5bbmFtZV07XG4gICAgICAgIHJlc3VsdFtwcmVmaXggKyBuYW1lXSA9IHR5cGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuX2xpbmVfbWl4aW4gPSB7XG4gICAgbGluZV9jb2xvcjogW3AuQ29sb3JTcGVjLCAnYmxhY2snXSxcbiAgICBsaW5lX3dpZHRoOiBbcC5OdW1iZXJTcGVjLCAxXSxcbiAgICBsaW5lX2FscGhhOiBbcC5OdW1iZXJTcGVjLCAxLjBdLFxuICAgIGxpbmVfam9pbjogW3AuTGluZUpvaW4sICdtaXRlciddLFxuICAgIGxpbmVfY2FwOiBbcC5MaW5lQ2FwLCAnYnV0dCddLFxuICAgIGxpbmVfZGFzaDogW3AuQXJyYXksIFtdXSxcbiAgICBsaW5lX2Rhc2hfb2Zmc2V0OiBbcC5OdW1iZXIsIDBdXG59O1xuZXhwb3J0cy5saW5lID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIHJldHVybiBfZ2VuX21peGluKF9saW5lX21peGluLCBwcmVmaXgpO1xufTtcbl9maWxsX21peGluID0ge1xuICAgIGZpbGxfY29sb3I6IFtwLkNvbG9yU3BlYywgJ2dyYXknXSxcbiAgICBmaWxsX2FscGhhOiBbcC5OdW1iZXJTcGVjLCAxLjBdXG59O1xuZXhwb3J0cy5maWxsID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIHJldHVybiBfZ2VuX21peGluKF9maWxsX21peGluLCBwcmVmaXgpO1xufTtcbl90ZXh0X21peGluID0ge1xuICAgIHRleHRfZm9udDogW3AuRm9udCwgJ2hlbHZldGljYSddLFxuICAgIHRleHRfZm9udF9zaXplOiBbcC5Gb250U2l6ZVNwZWMsICcxMnB0J10sXG4gICAgdGV4dF9mb250X3N0eWxlOiBbcC5Gb250U3R5bGUsICdub3JtYWwnXSxcbiAgICB0ZXh0X2NvbG9yOiBbcC5Db2xvclNwZWMsICcjNDQ0NDQ0J10sXG4gICAgdGV4dF9hbHBoYTogW3AuTnVtYmVyU3BlYywgMS4wXSxcbiAgICB0ZXh0X2FsaWduOiBbcC5UZXh0QWxpZ24sICdsZWZ0J10sXG4gICAgdGV4dF9iYXNlbGluZTogW3AuVGV4dEJhc2VsaW5lLCAnYm90dG9tJ11cbn07XG5leHBvcnRzLnRleHQgPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgcmV0dXJuIF9nZW5fbWl4aW4oX3RleHRfbWl4aW4sIHByZWZpeCk7XG59O1xuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiAoY29uZmlncykge1xuICAgIHZhciBjb25maWcsIGksIGtpbmQsIGxlbiwgcHJlZml4LCByZWYsIHJlc3VsdDtcbiAgICByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb25maWdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZ3NbaV07XG4gICAgICAgIHJlZiA9IGNvbmZpZy5zcGxpdChcIjpcIiksIGtpbmQgPSByZWZbMF0sIHByZWZpeCA9IHJlZlsxXTtcbiAgICAgICAgaWYgKHRoaXNba2luZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwcm9wZXJ0eSBtaXhpbiBraW5kICdcIiArIGtpbmQgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0XzEuZXh0ZW5kKHJlc3VsdCwgdGhpc1traW5kXShwcmVmaXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgaGFzX3Byb3BzXzEgPSByZXF1aXJlKFwiLi9oYXNfcHJvcHNcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbnZhciBzZWxlY3Rvcl8xID0gcmVxdWlyZShcIi4vc2VsZWN0b3JcIik7XG52YXIgaGl0dGVzdCA9IHJlcXVpcmUoXCIuL2hpdHRlc3RcIik7XG52YXIgcCA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLlNlbGVjdGlvbk1hbmFnZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU2VsZWN0aW9uTWFuYWdlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gU2VsZWN0aW9uTWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIFNlbGVjdGlvbk1hbmFnZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnR5cGUgPSAnU2VsZWN0aW9uTWFuYWdlcic7XG4gICAgU2VsZWN0aW9uTWFuYWdlci5pbnRlcm5hbCh7XG4gICAgICAgIHNvdXJjZTogW3AuQW55XVxuICAgIH0pO1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgU2VsZWN0aW9uTWFuYWdlci5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IG5ldyBzZWxlY3Rvcl8xLlNlbGVjdG9yKCk7XG4gICAgICAgIHRoaXMuaW5zcGVjdG9ycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0X2luc3BlY3Rpb25fd2FzX2VtcHR5ID0ge307XG4gICAgfTtcbiAgICBTZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAodG9vbCwgcmVuZGVyZXJfdmlld3MsIGdlb21ldHJ5LCBmaW5hbCwgYXBwZW5kKSB7XG4gICAgICAgIHZhciBpLCBpbmRpY2VzLCBpbmRpY2VzX290aGVyLCBpbmRpY2VzX3JlbmRlcmVycywgaiwgbGVuLCByLCBzb3VyY2U7XG4gICAgICAgIGlmIChhcHBlbmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBwZW5kID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UgIT09IHJlbmRlcmVyX3ZpZXdzWzBdLm1vZGVsLmRhdGFfc291cmNlKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oJ3NlbGVjdCBjYWxsZWQgd2l0aCBtaXMtbWF0Y2hlZCBkYXRhIHNvdXJjZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpbmRpY2VzX3JlbmRlcmVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaiwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVuZGVyZXJfdmlld3MubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICByID0gcmVuZGVyZXJfdmlld3Nbal07XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHIuaGl0X3Rlc3QoZ2VvbWV0cnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpO1xuICAgICAgICBpbmRpY2VzX3JlbmRlcmVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaiwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW5kaWNlc19yZW5kZXJlcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpID0gaW5kaWNlc19yZW5kZXJlcnNbal07XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpO1xuICAgICAgICBpZiAoaW5kaWNlc19yZW5kZXJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGljZXNfcmVuZGVyZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGluZGljZXMgPSBpbmRpY2VzX3JlbmRlcmVyc1swXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGluZGljZXNfcmVuZGVyZXJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNlc19vdGhlciA9IGluZGljZXNfcmVuZGVyZXJzW2pdO1xuICAgICAgICAgICAgICAgIGluZGljZXMudXBkYXRlX3Rocm91Z2hfdW5pb24oaW5kaWNlc19vdGhlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yLnVwZGF0ZShpbmRpY2VzLCBmaW5hbCwgYXBwZW5kKTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnNlbGVjdGVkID0gdGhpcy5zZWxlY3Rvci5pbmRpY2VzO1xuICAgICAgICAgICAgc291cmNlLnNlbGVjdC5lbWl0KCk7XG4gICAgICAgICAgICByZXR1cm4gIWluZGljZXMuaXNfZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICh0b29sLCByZW5kZXJlcl92aWV3LCBnZW9tZXRyeSwgZGF0YSkge1xuICAgICAgICB2YXIgaW5kaWNlcywgaW5zcGVjdG9yLCByX2lkLCBzb3VyY2U7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICE9PSByZW5kZXJlcl92aWV3Lm1vZGVsLmRhdGFfc291cmNlKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oJ2luc3BlY3QgY2FsbGVkIHdpdGggbWlzLW1hdGNoZWQgZGF0YSBzb3VyY2VzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kaWNlcyA9IHJlbmRlcmVyX3ZpZXcuaGl0X3Rlc3QoZ2VvbWV0cnkpO1xuICAgICAgICBpZiAoaW5kaWNlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByX2lkID0gcmVuZGVyZXJfdmlldy5tb2RlbC5pZDtcbiAgICAgICAgICAgIGlmIChpbmRpY2VzLmlzX2VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0X2luc3BlY3Rpb25fd2FzX2VtcHR5W3JfaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0X2luc3BlY3Rpb25fd2FzX2VtcHR5W3JfaWRdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RfaW5zcGVjdGlvbl93YXNfZW1wdHlbcl9pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0X2luc3BlY3Rpb25fd2FzX2VtcHR5W3JfaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RfaW5zcGVjdGlvbl93YXNfZW1wdHlbcl9pZF0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3BlY3RvciA9IHRoaXMuX2dldF9pbnNwZWN0b3IocmVuZGVyZXJfdmlldyk7XG4gICAgICAgICAgICBpbnNwZWN0b3IudXBkYXRlKGluZGljZXMsIHRydWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnNldHYoe1xuICAgICAgICAgICAgICAgIGluc3BlY3RlZDogaW5zcGVjdG9yLmluZGljZXNcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInNpbGVudFwiOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNvdXJjZS5pbnNwZWN0LmVtaXQoW2luZGljZXMsIHRvb2wsIHJlbmRlcmVyX3ZpZXcsIHNvdXJjZSwgZGF0YV0pO1xuICAgICAgICAgICAgcmV0dXJuICFpbmRpY2VzLmlzX2VtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKHJ2aWV3KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnNlbGVjdGVkID0gaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5fZ2V0X2luc3BlY3RvciA9IGZ1bmN0aW9uIChydmlldykge1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlkID0gcnZpZXcubW9kZWwuaWQ7XG4gICAgICAgIGlmICh0aGlzLmluc3BlY3RvcnNbaWRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3BlY3RvcnNbaWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zcGVjdG9yc1tpZF0gPSBuZXcgc2VsZWN0b3JfMS5TZWxlY3RvcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0aW9uTWFuYWdlcjtcbn0pKGhhc19wcm9wc18xLkhhc1Byb3BzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBoYXNfcHJvcHNfMSA9IHJlcXVpcmUoXCIuL2hhc19wcm9wc1wiKTtcbnZhciBoaXR0ZXN0ID0gcmVxdWlyZShcIi4vaGl0dGVzdFwiKTtcbnZhciBwID0gcmVxdWlyZShcIi4vcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuU2VsZWN0b3IgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU2VsZWN0b3IsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gU2VsZWN0b3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNlbGVjdG9yLnByb3RvdHlwZS50eXBlID0gJ1NlbGVjdG9yJztcbiAgICBTZWxlY3Rvci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGluZGljZXMsIGZpbmFsLCBhcHBlbmQsIHNpbGVudCkge1xuICAgICAgICBpZiAoc2lsZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHNpbGVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0digndGltZXN0YW1wJywgbmV3IERhdGUoKSwge1xuICAgICAgICAgICAgc2lsZW50OiBzaWxlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0dignZmluYWwnLCBmaW5hbCwge1xuICAgICAgICAgICAgc2lsZW50OiBzaWxlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhcHBlbmQpIHtcbiAgICAgICAgICAgIGluZGljZXMudXBkYXRlX3Rocm91Z2hfdW5pb24odGhpcy5pbmRpY2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZXR2KCdpbmRpY2VzJywgaW5kaWNlcywge1xuICAgICAgICAgICAgc2lsZW50OiBzaWxlbnRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZWxlY3Rvci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5maW5hbCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGljZXMgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICB9O1xuICAgIFNlbGVjdG9yLmludGVybmFsKHtcbiAgICAgICAgaW5kaWNlczogW1xuICAgICAgICAgICAgcC5BbnksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGZpbmFsOiBbcC5Cb29sZWFuXSxcbiAgICAgICAgdGltZXN0YW1wOiBbcC5BbnldXG4gICAgfSk7XG4gICAgcmV0dXJuIFNlbGVjdG9yO1xufSkoaGFzX3Byb3BzXzEuSGFzUHJvcHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU2V0dGluZ3MgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLl9kZXYgPSBmYWxzZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldHRpbmdzLnByb3RvdHlwZSwgXCJkZXZcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXY7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRldikge1xuICAgICAgICAgICAgdGhpcy5fZGV2ID0gZGV2O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gU2V0dGluZ3M7XG59KCkpO1xuZXhwb3J0cy5TZXR0aW5ncyA9IFNldHRpbmdzO1xuZXhwb3J0cy5zZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vcGhvc3Bob3Jqcy9waG9zcGhvci9ibG9iL21hc3Rlci9wYWNrYWdlcy9zaWduYWxpbmcvc3JjL2luZGV4LnRzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbnZhciBjYWxsYmFja18xID0gcmVxdWlyZShcIi4vdXRpbC9jYWxsYmFja1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcIi4vdXRpbC9hcnJheVwiKTtcbnZhciBTaWduYWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpZ25hbChzZW5kZXIsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIFNpZ25hbC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChzbG90LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgaWYgKCFyZWNlaXZlcnNGb3JTZW5kZXIuaGFzKHRoaXMuc2VuZGVyKSkge1xuICAgICAgICAgICAgcmVjZWl2ZXJzRm9yU2VuZGVyLnNldCh0aGlzLnNlbmRlciwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWNlaXZlcnMgPSByZWNlaXZlcnNGb3JTZW5kZXIuZ2V0KHRoaXMuc2VuZGVyKTtcbiAgICAgICAgaWYgKGZpbmRDb25uZWN0aW9uKHJlY2VpdmVycywgdGhpcywgc2xvdCwgY29udGV4dCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWNlaXZlciA9IGNvbnRleHQgfHwgc2xvdDtcbiAgICAgICAgaWYgKCFzZW5kZXJzRm9yUmVjZWl2ZXIuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgICAgICAgc2VuZGVyc0ZvclJlY2VpdmVyLnNldChyZWNlaXZlciwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZW5kZXJzID0gc2VuZGVyc0ZvclJlY2VpdmVyLmdldChyZWNlaXZlcik7XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0geyBzaWduYWw6IHRoaXMsIHNsb3Q6IHNsb3QsIGNvbnRleHQ6IGNvbnRleHQgfTtcbiAgICAgICAgcmVjZWl2ZXJzLnB1c2goY29ubmVjdGlvbik7XG4gICAgICAgIHNlbmRlcnMucHVzaChjb25uZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTaWduYWwucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoc2xvdCwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHZhciByZWNlaXZlcnMgPSByZWNlaXZlcnNGb3JTZW5kZXIuZ2V0KHRoaXMuc2VuZGVyKTtcbiAgICAgICAgaWYgKHJlY2VpdmVycyA9PSBudWxsIHx8IHJlY2VpdmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IGZpbmRDb25uZWN0aW9uKHJlY2VpdmVycywgdGhpcywgc2xvdCwgY29udGV4dCk7XG4gICAgICAgIGlmIChjb25uZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBjb250ZXh0IHx8IHNsb3Q7XG4gICAgICAgIHZhciBzZW5kZXJzID0gc2VuZGVyc0ZvclJlY2VpdmVyLmdldChyZWNlaXZlcik7XG4gICAgICAgIGNvbm5lY3Rpb24uc2lnbmFsID0gbnVsbDtcbiAgICAgICAgc2NoZWR1bGVDbGVhbnVwKHJlY2VpdmVycyk7XG4gICAgICAgIHNjaGVkdWxlQ2xlYW51cChzZW5kZXJzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTaWduYWwucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgcmVjZWl2ZXJzID0gcmVjZWl2ZXJzRm9yU2VuZGVyLmdldCh0aGlzLnNlbmRlcikgfHwgW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcmVjZWl2ZXJzXzEgPSByZWNlaXZlcnM7IF9pIDwgcmVjZWl2ZXJzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSByZWNlaXZlcnNfMVtfaV0sIHNpZ25hbCA9IF9hLnNpZ25hbCwgc2xvdCA9IF9hLnNsb3QsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICAgICAgaWYgKHNpZ25hbCA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHNsb3QuY2FsbChjb250ZXh0LCBhcmdzLCB0aGlzLnNlbmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTaWduYWw7XG59KCkpO1xuZXhwb3J0cy5TaWduYWwgPSBTaWduYWw7XG4oZnVuY3Rpb24gKFNpZ25hbCkge1xuICAgIGZ1bmN0aW9uIGRpc2Nvbm5lY3RCZXR3ZWVuKHNlbmRlciwgcmVjZWl2ZXIpIHtcbiAgICAgICAgdmFyIHJlY2VpdmVycyA9IHJlY2VpdmVyc0ZvclNlbmRlci5nZXQoc2VuZGVyKTtcbiAgICAgICAgaWYgKHJlY2VpdmVycyA9PSBudWxsIHx8IHJlY2VpdmVycy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBzZW5kZXJzID0gc2VuZGVyc0ZvclJlY2VpdmVyLmdldChyZWNlaXZlcik7XG4gICAgICAgIGlmIChzZW5kZXJzID09IG51bGwgfHwgc2VuZGVycy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgc2VuZGVyc18xID0gc2VuZGVyczsgX2kgPCBzZW5kZXJzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHNlbmRlcnNfMVtfaV07XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5zaWduYWwgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5zaWduYWwuc2VuZGVyID09PSBzZW5kZXIpXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5zaWduYWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVkdWxlQ2xlYW51cChyZWNlaXZlcnMpO1xuICAgICAgICBzY2hlZHVsZUNsZWFudXAoc2VuZGVycyk7XG4gICAgfVxuICAgIFNpZ25hbC5kaXNjb25uZWN0QmV0d2VlbiA9IGRpc2Nvbm5lY3RCZXR3ZWVuO1xuICAgIGZ1bmN0aW9uIGRpc2Nvbm5lY3RTZW5kZXIoc2VuZGVyKSB7XG4gICAgICAgIHZhciByZWNlaXZlcnMgPSByZWNlaXZlcnNGb3JTZW5kZXIuZ2V0KHNlbmRlcik7XG4gICAgICAgIGlmIChyZWNlaXZlcnMgPT0gbnVsbCB8fCByZWNlaXZlcnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHJlY2VpdmVyc18yID0gcmVjZWl2ZXJzOyBfaSA8IHJlY2VpdmVyc18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSByZWNlaXZlcnNfMltfaV07XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5zaWduYWwgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBjb25uZWN0aW9uLmNvbnRleHQgfHwgY29ubmVjdGlvbi5zbG90O1xuICAgICAgICAgICAgY29ubmVjdGlvbi5zaWduYWwgPSBudWxsO1xuICAgICAgICAgICAgc2NoZWR1bGVDbGVhbnVwKHNlbmRlcnNGb3JSZWNlaXZlci5nZXQocmVjZWl2ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBzY2hlZHVsZUNsZWFudXAocmVjZWl2ZXJzKTtcbiAgICB9XG4gICAgU2lnbmFsLmRpc2Nvbm5lY3RTZW5kZXIgPSBkaXNjb25uZWN0U2VuZGVyO1xuICAgIGZ1bmN0aW9uIGRpc2Nvbm5lY3RSZWNlaXZlcihyZWNlaXZlcikge1xuICAgICAgICB2YXIgc2VuZGVycyA9IHNlbmRlcnNGb3JSZWNlaXZlci5nZXQocmVjZWl2ZXIpO1xuICAgICAgICBpZiAoc2VuZGVycyA9PSBudWxsIHx8IHNlbmRlcnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNlbmRlcnNfMiA9IHNlbmRlcnM7IF9pIDwgc2VuZGVyc18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBzZW5kZXJzXzJbX2ldO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uc2lnbmFsID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHNlbmRlciA9IGNvbm5lY3Rpb24uc2lnbmFsLnNlbmRlcjtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uc2lnbmFsID0gbnVsbDtcbiAgICAgICAgICAgIHNjaGVkdWxlQ2xlYW51cChyZWNlaXZlcnNGb3JTZW5kZXIuZ2V0KHNlbmRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVkdWxlQ2xlYW51cChzZW5kZXJzKTtcbiAgICB9XG4gICAgU2lnbmFsLmRpc2Nvbm5lY3RSZWNlaXZlciA9IGRpc2Nvbm5lY3RSZWNlaXZlcjtcbiAgICBmdW5jdGlvbiBkaXNjb25uZWN0QWxsKG9iaikge1xuICAgICAgICB2YXIgcmVjZWl2ZXJzID0gcmVjZWl2ZXJzRm9yU2VuZGVyLmdldChvYmopO1xuICAgICAgICBpZiAocmVjZWl2ZXJzICE9IG51bGwgJiYgcmVjZWl2ZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByZWNlaXZlcnNfMyA9IHJlY2VpdmVyczsgX2kgPCByZWNlaXZlcnNfMy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHJlY2VpdmVyc18zW19pXTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnNpZ25hbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY2hlZHVsZUNsZWFudXAocmVjZWl2ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VuZGVycyA9IHNlbmRlcnNGb3JSZWNlaXZlci5nZXQob2JqKTtcbiAgICAgICAgaWYgKHNlbmRlcnMgIT0gbnVsbCAmJiBzZW5kZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBzZW5kZXJzXzMgPSBzZW5kZXJzOyBfYSA8IHNlbmRlcnNfMy5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHNlbmRlcnNfM1tfYV07XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5zaWduYWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NoZWR1bGVDbGVhbnVwKHNlbmRlcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFNpZ25hbC5kaXNjb25uZWN0QWxsID0gZGlzY29ubmVjdEFsbDtcbn0pKFNpZ25hbCA9IGV4cG9ydHMuU2lnbmFsIHx8IChleHBvcnRzLlNpZ25hbCA9IHt9KSk7XG5leHBvcnRzLlNpZ25hbCA9IFNpZ25hbDtcbnZhciBTaWduYWxhYmxlO1xuKGZ1bmN0aW9uIChTaWduYWxhYmxlKSB7XG4gICAgZnVuY3Rpb24gY29ubmVjdChzaWduYWwsIHNsb3QpIHtcbiAgICAgICAgcmV0dXJuIHNpZ25hbC5jb25uZWN0KHNsb3QsIHRoaXMpO1xuICAgIH1cbiAgICBTaWduYWxhYmxlLmNvbm5lY3QgPSBjb25uZWN0O1xuICAgIGZ1bmN0aW9uIGxpc3RlblRvKGV2ZW50LCBzbG90KSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIud2FybihcIm9iai5saXN0ZW5UbygnZXZlbnQnLCBoYW5kbGVyKSBpcyBkZXByZWNhdGVkLCB1c2Ugb2JqLmNvbm5lY3Qoc2lnbmFsLCBzbG90KVwiKTtcbiAgICAgICAgdmFyIF9hID0gZXZlbnQuc3BsaXQoXCI6XCIpLCBuYW1lID0gX2FbMF0sIGF0dHIgPSBfYVsxXTtcbiAgICAgICAgdmFyIHNpZ25hbCA9IChhdHRyID09IG51bGwpID8gdGhpc1tuYW1lXSA6IHRoaXMucHJvcGVydGllc1thdHRyXVtuYW1lXTtcbiAgICAgICAgcmV0dXJuIHNpZ25hbC5jb25uZWN0KHNsb3QsIHRoaXMpO1xuICAgIH1cbiAgICBTaWduYWxhYmxlLmxpc3RlblRvID0gbGlzdGVuVG87XG4gICAgZnVuY3Rpb24gdHJpZ2dlcihldmVudCwgYXJncykge1xuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJvYmoudHJpZ2dlcignZXZlbnQnLCBhcmdzKSBpcyBkZXByZWNhdGVkLCB1c2Ugc2lnbmFsLmVtaXQoYXJncylcIik7XG4gICAgICAgIHZhciBfYSA9IGV2ZW50LnNwbGl0KFwiOlwiKSwgbmFtZSA9IF9hWzBdLCBhdHRyID0gX2FbMV07XG4gICAgICAgIHZhciBzaWduYWwgPSAoYXR0ciA9PSBudWxsKSA/IHRoaXNbbmFtZV0gOiB0aGlzLnByb3BlcnRpZXNbYXR0cl1bbmFtZV07XG4gICAgICAgIHJldHVybiBzaWduYWwuZW1pdChhcmdzKTtcbiAgICB9XG4gICAgU2lnbmFsYWJsZS50cmlnZ2VyID0gdHJpZ2dlcjtcbn0pKFNpZ25hbGFibGUgPSBleHBvcnRzLlNpZ25hbGFibGUgfHwgKGV4cG9ydHMuU2lnbmFsYWJsZSA9IHt9KSk7XG52YXIgcmVjZWl2ZXJzRm9yU2VuZGVyID0gbmV3IFdlYWtNYXAoKTtcbnZhciBzZW5kZXJzRm9yUmVjZWl2ZXIgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gZmluZENvbm5lY3Rpb24oY29ubnMsIHNpZ25hbCwgc2xvdCwgY29udGV4dCkge1xuICAgIHJldHVybiBhcnJheV8xLmZpbmQoY29ubnMsIGZ1bmN0aW9uIChjb25uKSB7IHJldHVybiBjb25uLnNpZ25hbCA9PT0gc2lnbmFsICYmIGNvbm4uc2xvdCA9PT0gc2xvdCAmJiBjb25uLmNvbnRleHQgPT09IGNvbnRleHQ7IH0pO1xufVxudmFyIGRpcnR5U2V0ID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gc2NoZWR1bGVDbGVhbnVwKGNvbm5lY3Rpb25zKSB7XG4gICAgaWYgKGRpcnR5U2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2tfMS5kZWZlcihjbGVhbnVwRGlydHlTZXQpO1xuICAgIH1cbiAgICBkaXJ0eVNldC5hZGQoY29ubmVjdGlvbnMpO1xufVxuZnVuY3Rpb24gY2xlYW51cERpcnR5U2V0KCkge1xuICAgIGRpcnR5U2V0LmZvckVhY2goZnVuY3Rpb24gKGNvbm5lY3Rpb25zKSB7XG4gICAgICAgIGFycmF5XzEucmVtb3ZlQnkoY29ubmVjdGlvbnMsIGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7IHJldHVybiBjb25uZWN0aW9uLnNpZ25hbCA9PSBudWxsOyB9KTtcbiAgICB9KTtcbiAgICBkaXJ0eVNldC5jbGVhcigpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgSGFtbWVyID0gcmVxdWlyZShcImhhbW1lcmpzXCIpO1xudmFyIHNpZ25hbGluZ18xID0gcmVxdWlyZShcIi4vc2lnbmFsaW5nXCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG52YXIgZG9tXzEgPSByZXF1aXJlKFwiLi9kb21cIik7XG52YXIgd2hlZWxfMSA9IHJlcXVpcmUoXCIuL3V0aWwvd2hlZWxcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiLi91dGlsL29iamVjdFwiKTtcbnZhciBib2tlaF9ldmVudHNfMSA9IHJlcXVpcmUoXCIuL2Jva2VoX2V2ZW50c1wiKTtcbmV4cG9ydHMuVUlFdmVudHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVJRXZlbnRzKHBsb3RfdmlldywgdG9vbGJhciwgaGl0X2FyZWEsIHBsb3QpIHtcbiAgICAgICAgdGhpcy5wbG90X3ZpZXcgPSBwbG90X3ZpZXc7XG4gICAgICAgIHRoaXMudG9vbGJhciA9IHRvb2xiYXI7XG4gICAgICAgIHRoaXMuaGl0X2FyZWEgPSBoaXRfYXJlYTtcbiAgICAgICAgdGhpcy5wbG90ID0gcGxvdDtcbiAgICAgICAgdGhpcy50YXAgPSBuZXcgc2lnbmFsaW5nXzEuU2lnbmFsKHRoaXMsICd0YXAnKTtcbiAgICAgICAgdGhpcy5kb3VibGV0YXAgPSBuZXcgc2lnbmFsaW5nXzEuU2lnbmFsKHRoaXMsICdkb3VibGV0YXAnKTtcbiAgICAgICAgdGhpcy5wcmVzcyA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgJ3ByZXNzJyk7XG4gICAgICAgIHRoaXMucGFuX3N0YXJ0ID0gbmV3IHNpZ25hbGluZ18xLlNpZ25hbCh0aGlzLCAncGFuOnN0YXJ0Jyk7XG4gICAgICAgIHRoaXMucGFuID0gbmV3IHNpZ25hbGluZ18xLlNpZ25hbCh0aGlzLCAncGFuJyk7XG4gICAgICAgIHRoaXMucGFuX2VuZCA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgJ3BhbjplbmQnKTtcbiAgICAgICAgdGhpcy5waW5jaF9zdGFydCA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgJ3BpbmNoOnN0YXJ0Jyk7XG4gICAgICAgIHRoaXMucGluY2ggPSBuZXcgc2lnbmFsaW5nXzEuU2lnbmFsKHRoaXMsICdwaW5jaCcpO1xuICAgICAgICB0aGlzLnBpbmNoX2VuZCA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgJ3BpbmNoOmVuZCcpO1xuICAgICAgICB0aGlzLnJvdGF0ZV9zdGFydCA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgJ3JvdGF0ZTpzdGFydCcpO1xuICAgICAgICB0aGlzLnJvdGF0ZSA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgJ3JvdGF0ZScpO1xuICAgICAgICB0aGlzLnJvdGF0ZV9lbmQgPSBuZXcgc2lnbmFsaW5nXzEuU2lnbmFsKHRoaXMsICdyb3RhdGU6ZW5kJyk7XG4gICAgICAgIHRoaXMubW92ZV9lbnRlciA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgJ21vdmU6ZW50ZXInKTtcbiAgICAgICAgdGhpcy5tb3ZlID0gbmV3IHNpZ25hbGluZ18xLlNpZ25hbCh0aGlzLCAnbW92ZScpO1xuICAgICAgICB0aGlzLm1vdmVfZXhpdCA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgJ21vdmU6ZXhpdCcpO1xuICAgICAgICB0aGlzLnNjcm9sbCA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgJ3Njcm9sbCcpO1xuICAgICAgICB0aGlzLmtleWRvd24gPSBuZXcgc2lnbmFsaW5nXzEuU2lnbmFsKHRoaXMsICdrZXlkb3duJyk7XG4gICAgICAgIHRoaXMua2V5dXAgPSBuZXcgc2lnbmFsaW5nXzEuU2lnbmFsKHRoaXMsICdrZXl1cCcpO1xuICAgICAgICB0aGlzLl9jb25maWd1cmVfaGFtbWVyanMoKTtcbiAgICB9XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl9jb25maWd1cmVfaGFtbWVyanMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLmhpdF9hcmVhKTtcbiAgICAgICAgdGhpcy5oYW1tZXIuZ2V0KCdkb3VibGV0YXAnKS5yZWNvZ25pemVXaXRoKCd0YXAnKTtcbiAgICAgICAgdGhpcy5oYW1tZXIuZ2V0KCd0YXAnKS5yZXF1aXJlRmFpbHVyZSgnZG91YmxldGFwJyk7XG4gICAgICAgIHRoaXMuaGFtbWVyLmdldCgnZG91YmxldGFwJykuZHJvcFJlcXVpcmVGYWlsdXJlKCd0YXAnKTtcbiAgICAgICAgdGhpcy5oYW1tZXIub24oJ2RvdWJsZXRhcCcsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZG91YmxldGFwKGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigndGFwJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl90YXAoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwcmVzcycsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcHJlc3MoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLmdldCgncGFuJykuc2V0KHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9BTExcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5zdGFydCcsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcGFuX3N0YXJ0KGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigncGFuJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9wYW4oZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5lbmQnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3Bhbl9lbmQoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLmdldCgncGluY2gnKS5zZXQoe1xuICAgICAgICAgICAgZW5hYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigncGluY2hzdGFydCcsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcGluY2hfc3RhcnQoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwaW5jaCcsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcGluY2goZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwaW5jaGVuZCcsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcGluY2hfZW5kKGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB0aGlzLmhhbW1lci5nZXQoJ3JvdGF0ZScpLnNldCh7XG4gICAgICAgICAgICBlbmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdyb3RhdGVzdGFydCcsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcm90YXRlX3N0YXJ0KGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigncm90YXRlJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yb3RhdGUoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdyb3RhdGVlbmQnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JvdGF0ZV9lbmQoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGl0X2FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX21vdXNlX21vdmUoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGl0X2FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9tb3VzZV9lbnRlcihlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgdGhpcy5oaXRfYXJlYS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX21vdXNlX2V4aXQoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGl0X2FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fbW91c2Vfd2hlZWwoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fa2V5X2Rvd24oZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9rZXlfdXAoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUucmVnaXN0ZXJfdG9vbCA9IGZ1bmN0aW9uICh0b29sX3ZpZXcpIHtcbiAgICAgICAgdmFyIGV0LCBpZCwgdHlwZSwgdjtcbiAgICAgICAgZXQgPSB0b29sX3ZpZXcubW9kZWwuZXZlbnRfdHlwZTtcbiAgICAgICAgaWQgPSB0b29sX3ZpZXcubW9kZWwuaWQ7XG4gICAgICAgIHR5cGUgPSB0b29sX3ZpZXcubW9kZWwudHlwZTtcbiAgICAgICAgaWYgKGV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJCdXR0b24gdG9vbDogXCIgKyB0eXBlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2ID0gdG9vbF92aWV3O1xuICAgICAgICBzd2l0Y2ggKGV0KSB7XG4gICAgICAgICAgICBjYXNlIFwicGFuXCI6XG4gICAgICAgICAgICAgICAgaWYgKHYuX3Bhbl9zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHYuY29ubmVjdCh0aGlzLnBhbl9zdGFydCwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2Ll9wYW5fc3RhcnQoeC5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2Ll9wYW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2LmNvbm5lY3QodGhpcy5wYW4sIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5fcGFuKHguZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodi5fcGFuX2VuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHYuY29ubmVjdCh0aGlzLnBhbl9lbmQsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5fcGFuX2VuZCh4LmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicGluY2hcIjpcbiAgICAgICAgICAgICAgICBpZiAodi5fcGluY2hfc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2LmNvbm5lY3QodGhpcy5waW5jaF9zdGFydCwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2Ll9waW5jaF9zdGFydCh4LmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHYuX3BpbmNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdi5jb25uZWN0KHRoaXMucGluY2gsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5fcGluY2goeC5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2Ll9waW5jaF9lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2LmNvbm5lY3QodGhpcy5waW5jaF9lbmQsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5fcGluY2hfZW5kKHguZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyb3RhdGVcIjpcbiAgICAgICAgICAgICAgICBpZiAodi5fcm90YXRlX3N0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdi5jb25uZWN0KHRoaXMucm90YXRlX3N0YXJ0LCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHguaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYuX3JvdGF0ZV9zdGFydCh4LmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHYuX3JvdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHYuY29ubmVjdCh0aGlzLnJvdGF0ZSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2Ll9yb3RhdGUoeC5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2Ll9yb3RhdGVfZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdi5jb25uZWN0KHRoaXMucm90YXRlX2VuZCwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2Ll9yb3RhdGVfZW5kKHguZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtb3ZlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHYuX21vdmVfZW50ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2LmNvbm5lY3QodGhpcy5tb3ZlX2VudGVyLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHguaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYuX21vdmVfZW50ZXIoeC5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2Ll9tb3ZlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdi5jb25uZWN0KHRoaXMubW92ZSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2Ll9tb3ZlKHguZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodi5fbW92ZV9leGl0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdi5jb25uZWN0KHRoaXMubW92ZV9leGl0LCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHguaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYuX21vdmVfZXhpdCh4LmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidGFwXCI6XG4gICAgICAgICAgICAgICAgaWYgKHYuX3RhcCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHYuY29ubmVjdCh0aGlzLnRhcCwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2Ll90YXAoeC5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInByZXNzXCI6XG4gICAgICAgICAgICAgICAgaWYgKHYuX3ByZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdi5jb25uZWN0KHRoaXMucHJlc3MsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5fcHJlc3MoeC5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNjcm9sbFwiOlxuICAgICAgICAgICAgICAgIGlmICh2Ll9zY3JvbGwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2LmNvbm5lY3QodGhpcy5zY3JvbGwsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5fc2Nyb2xsKHguZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgZXZlbnRfdHlwZTogXCIgKyBldik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYuX2RvdWJsZXRhcCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2LmNvbm5lY3QodGhpcy5kb3VibGV0YXAsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYuX2RvdWJsZXRhcCh4LmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYuX2tleWRvd24gIT0gbnVsbCkge1xuICAgICAgICAgICAgdi5jb25uZWN0KHRoaXMua2V5ZG93biwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5fa2V5ZG93bih4LmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYuX2tleXVwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHYuY29ubmVjdCh0aGlzLmtleXVwLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2Ll9rZXl1cCh4LmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwKSB7XG4gICAgICAgICAgICBpZiAoZXQgPT09ICdwaW5jaCcpIHtcbiAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiUmVnaXN0ZXJpbmcgc2Nyb2xsIG9uIHRvdWNoIHNjcmVlblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5jb25uZWN0KHRoaXMuc2Nyb2xsLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeC5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2Ll9zY3JvbGwoeC5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUuX2hpdF90ZXN0X3JlbmRlcmVycyA9IGZ1bmN0aW9uIChzeCwgc3kpIHtcbiAgICAgICAgdmFyIGksIHJlZiwgcmVmMSwgdmlldztcbiAgICAgICAgcmVmID0gdGhpcy5wbG90X3ZpZXcuZ2V0X3JlbmRlcmVyX3ZpZXdzKCk7XG4gICAgICAgIGZvciAoaSA9IHJlZi5sZW5ndGggLSAxOyBpID49IDA7IGkgKz0gLTEpIHtcbiAgICAgICAgICAgIHZpZXcgPSByZWZbaV07XG4gICAgICAgICAgICBpZiAoKChyZWYxID0gdmlldy5tb2RlbC5sZXZlbCkgPT09ICdhbm5vdGF0aW9uJyB8fCByZWYxID09PSAnb3ZlcmxheScpICYmICh2aWV3LmJib3ggIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlldy5iYm94KCkuY29udGFpbnMoc3gsIHN5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlldztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUuX2hpdF90ZXN0X2ZyYW1lID0gZnVuY3Rpb24gKHN4LCBzeSkge1xuICAgICAgICB2YXIgY2FudmFzLCB2eCwgdnk7XG4gICAgICAgIGNhbnZhcyA9IHRoaXMucGxvdF92aWV3LmNhbnZhcztcbiAgICAgICAgdnggPSBjYW52YXMuc3hfdG9fdngoc3gpO1xuICAgICAgICB2eSA9IGNhbnZhcy5zeV90b192eShzeSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5mcmFtZS5jb250YWlucyh2eCwgdnkpO1xuICAgIH07XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl90cmlnZ2VyID0gZnVuY3Rpb24gKHNpZ25hbCwgZSkge1xuICAgICAgICB2YXIgYWN0aXZlX2dlc3R1cmUsIGFjdGl2ZV9pbnNwZWN0b3JzLCBiYXNlLCBiYXNlX3R5cGUsIGN1cnNvciwgZXZlbnRfdHlwZSwgaSwgaW5zcGVjdG9yLCBsZW4sIHJlc3VsdHMsIHZpZXc7XG4gICAgICAgIGV2ZW50X3R5cGUgPSBzaWduYWwubmFtZTtcbiAgICAgICAgYmFzZV90eXBlID0gZXZlbnRfdHlwZS5zcGxpdChcIjpcIilbMF07XG4gICAgICAgIHZpZXcgPSB0aGlzLl9oaXRfdGVzdF9yZW5kZXJlcnMoZS5ib2tlaC5zeCwgZS5ib2tlaC5zeSk7XG4gICAgICAgIHN3aXRjaCAoYmFzZV90eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwibW92ZVwiOlxuICAgICAgICAgICAgICAgIGFjdGl2ZV9pbnNwZWN0b3JzID0gdGhpcy50b29sYmFyLmluc3BlY3RvcnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmFjdGl2ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgICAgICBpZiAodmlldyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3Lm1vZGVsLmN1cnNvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSB2aWV3Lm1vZGVsLmN1cnNvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghb2JqZWN0XzEuaXNFbXB0eShhY3RpdmVfaW5zcGVjdG9ycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbCA9IHRoaXMubW92ZV9leGl0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRfdHlwZSA9IHNpZ25hbC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2hpdF90ZXN0X2ZyYW1lKGUuYm9rZWguc3gsIGUuYm9rZWguc3kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb2JqZWN0XzEuaXNFbXB0eShhY3RpdmVfaW5zcGVjdG9ycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IFwiY3Jvc3NoYWlyXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90X3ZpZXcuc2V0X2N1cnNvcihjdXJzb3IpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBhY3RpdmVfaW5zcGVjdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpbnNwZWN0b3IgPSBhY3RpdmVfaW5zcGVjdG9yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMudHJpZ2dlcihzaWduYWwsIGUsIGluc3BlY3Rvci5pZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0YXBcIjpcbiAgICAgICAgICAgICAgICBpZiAodmlldyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygdmlldy5vbl9oaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5vbl9oaXQoZS5ib2tlaC5zeCwgZS5ib2tlaC5zeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWN0aXZlX2dlc3R1cmUgPSB0aGlzLnRvb2xiYXIuZ2VzdHVyZXNbYmFzZV90eXBlXS5hY3RpdmU7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZV9nZXN0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihzaWduYWwsIGUsIGFjdGl2ZV9nZXN0dXJlLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2Nyb2xsXCI6XG4gICAgICAgICAgICAgICAgYmFzZSA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwID8gXCJwaW5jaFwiIDogXCJzY3JvbGxcIjtcbiAgICAgICAgICAgICAgICBhY3RpdmVfZ2VzdHVyZSA9IHRoaXMudG9vbGJhci5nZXN0dXJlc1tiYXNlXS5hY3RpdmU7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZV9nZXN0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKHNpZ25hbCwgZSwgYWN0aXZlX2dlc3R1cmUuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYWN0aXZlX2dlc3R1cmUgPSB0aGlzLnRvb2xiYXIuZ2VzdHVyZXNbYmFzZV90eXBlXS5hY3RpdmU7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZV9nZXN0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihzaWduYWwsIGUsIGFjdGl2ZV9nZXN0dXJlLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKHNpZ25hbCwgZXZlbnQsIGlkKSB7XG4gICAgICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25hbC5lbWl0KHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGU6IGV2ZW50XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl9ib2tpZnlfaGFtbWVyID0gZnVuY3Rpb24gKGUsIGV4dHJhcykge1xuICAgICAgICB2YXIgZXZlbnRfY2xzLCBsZWZ0LCByZWYsIHRvcCwgeCwgeTtcbiAgICAgICAgaWYgKGV4dHJhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBleHRyYXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xuICAgICAgICAgICAgeCA9IGUuc3JjRXZlbnQucGFnZVg7XG4gICAgICAgICAgICB5ID0gZS5zcmNFdmVudC5wYWdlWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHggPSBlLnBvaW50ZXJzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgeSA9IGUucG9pbnRlcnNbMF0ucGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgcmVmID0gZG9tXzEub2Zmc2V0KGUudGFyZ2V0KSwgbGVmdCA9IHJlZi5sZWZ0LCB0b3AgPSByZWYudG9wO1xuICAgICAgICBlLmJva2VoID0ge1xuICAgICAgICAgICAgc3g6IHggLSBsZWZ0LFxuICAgICAgICAgICAgc3k6IHkgLSB0b3BcbiAgICAgICAgfTtcbiAgICAgICAgZS5ib2tlaCA9IG9iamVjdF8xLmV4dGVuZChlLmJva2VoLCBleHRyYXMpO1xuICAgICAgICBldmVudF9jbHMgPSBib2tlaF9ldmVudHNfMS5Cb2tlaEV2ZW50LmV2ZW50X2NsYXNzKGUpO1xuICAgICAgICBpZiAoZXZlbnRfY2xzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsb3QudHJpZ2dlcl9ldmVudChldmVudF9jbHMuZnJvbV9ldmVudChlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZygnVW5oYW5kbGVkIGV2ZW50IG9mIHR5cGUgJyArIGUudHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5fYm9raWZ5X3BvaW50X2V2ZW50ID0gZnVuY3Rpb24gKGUsIGV4dHJhcykge1xuICAgICAgICB2YXIgZXZlbnRfY2xzLCBsZWZ0LCByZWYsIHRvcDtcbiAgICAgICAgaWYgKGV4dHJhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBleHRyYXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZWYgPSBkb21fMS5vZmZzZXQoZS5jdXJyZW50VGFyZ2V0KSwgbGVmdCA9IHJlZi5sZWZ0LCB0b3AgPSByZWYudG9wO1xuICAgICAgICBlLmJva2VoID0ge1xuICAgICAgICAgICAgc3g6IGUucGFnZVggLSBsZWZ0LFxuICAgICAgICAgICAgc3k6IGUucGFnZVkgLSB0b3BcbiAgICAgICAgfTtcbiAgICAgICAgZS5ib2tlaCA9IG9iamVjdF8xLmV4dGVuZChlLmJva2VoLCBleHRyYXMpO1xuICAgICAgICBldmVudF9jbHMgPSBib2tlaF9ldmVudHNfMS5Cb2tlaEV2ZW50LmV2ZW50X2NsYXNzKGUpO1xuICAgICAgICBpZiAoZXZlbnRfY2xzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsb3QudHJpZ2dlcl9ldmVudChldmVudF9jbHMuZnJvbV9ldmVudChlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZygnVW5oYW5kbGVkIGV2ZW50IG9mIHR5cGUgJyArIGUudHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5fdGFwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fYm9raWZ5X2hhbW1lcihlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXIodGhpcy50YXAsIGUpO1xuICAgIH07XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl9kb3VibGV0YXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9ib2tpZnlfaGFtbWVyKGUpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKHRoaXMuZG91YmxldGFwLCBlKTtcbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5fcHJlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9ib2tpZnlfaGFtbWVyKGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcih0aGlzLnByZXNzLCBlKTtcbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5fcGFuX3N0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fYm9raWZ5X2hhbW1lcihlKTtcbiAgICAgICAgZS5ib2tlaC5zeCAtPSBlLmRlbHRhWDtcbiAgICAgICAgZS5ib2tlaC5zeSAtPSBlLmRlbHRhWTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXIodGhpcy5wYW5fc3RhcnQsIGUpO1xuICAgIH07XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl9wYW4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9ib2tpZnlfaGFtbWVyKGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcih0aGlzLnBhbiwgZSk7XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUuX3Bhbl9lbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9ib2tpZnlfaGFtbWVyKGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcih0aGlzLnBhbl9lbmQsIGUpO1xuICAgIH07XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl9waW5jaF9zdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX2Jva2lmeV9oYW1tZXIoZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyKHRoaXMucGluY2hfc3RhcnQsIGUpO1xuICAgIH07XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl9waW5jaCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX2Jva2lmeV9oYW1tZXIoZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyKHRoaXMucGluY2gsIGUpO1xuICAgIH07XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl9waW5jaF9lbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9ib2tpZnlfaGFtbWVyKGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcih0aGlzLnBpbmNoX2VuZCwgZSk7XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUuX3JvdGF0ZV9zdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX2Jva2lmeV9oYW1tZXIoZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyKHRoaXMucm90YXRlX3N0YXJ0LCBlKTtcbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5fcm90YXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fYm9raWZ5X2hhbW1lcihlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXIodGhpcy5yb3RhdGUsIGUpO1xuICAgIH07XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl9yb3RhdGVfZW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fYm9raWZ5X2hhbW1lcihlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXIodGhpcy5yb3RhdGVfZW5kLCBlKTtcbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5fbW91c2VfZW50ZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9ib2tpZnlfcG9pbnRfZXZlbnQoZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyKHRoaXMubW92ZV9lbnRlciwgZSk7XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUuX21vdXNlX21vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9ib2tpZnlfcG9pbnRfZXZlbnQoZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyKHRoaXMubW92ZSwgZSk7XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUuX21vdXNlX2V4aXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9ib2tpZnlfcG9pbnRfZXZlbnQoZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyKHRoaXMubW92ZV9leGl0LCBlKTtcbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5fbW91c2Vfd2hlZWwgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9ib2tpZnlfcG9pbnRfZXZlbnQoZSwge1xuICAgICAgICAgICAgZGVsdGE6IHdoZWVsXzEuZ2V0RGVsdGFZKGUpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcih0aGlzLnNjcm9sbCwgZSk7XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUuX2tleV9kb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcih0aGlzLmtleWRvd24sIGUpO1xuICAgIH07XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl9rZXlfdXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKHRoaXMua2V5dXAsIGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFVJRXZlbnRzO1xufSkoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gICAgIFVuZGVyc2NvcmUuanMgMS44LjNcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1hdGhfMSA9IHJlcXVpcmUoXCIuL21hdGhcIik7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5mdW5jdGlvbiBjb3B5KGFycmF5IC8qfCBUeXBlZEFycmF5Ki8pIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSk7XG59XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZnVuY3Rpb24gY29uY2F0KGFycmF5cykge1xuICAgIHJldHVybiAoX2EgPSBbXSkuY29uY2F0LmFwcGx5KF9hLCBhcnJheXMpO1xuICAgIHZhciBfYTtcbn1cbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xuZnVuY3Rpb24gY29udGFpbnMoYXJyYXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5LmluZGV4T2YodmFsdWUpID49IDA7XG59XG5leHBvcnRzLmNvbnRhaW5zID0gY29udGFpbnM7XG5mdW5jdGlvbiBudGgoYXJyYXksIGluZGV4KSB7XG4gICAgcmV0dXJuIGFycmF5W2luZGV4ID49IDAgPyBpbmRleCA6IGFycmF5Lmxlbmd0aCArIGluZGV4XTtcbn1cbmV4cG9ydHMubnRoID0gbnRoO1xuZnVuY3Rpb24gemlwKEFzLCBCcykge1xuICAgIHZhciBuID0gTWF0aC5taW4oQXMubGVuZ3RoLCBCcy5sZW5ndGgpO1xuICAgIHZhciBBQnMgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgQUJzW2ldID0gW0FzW2ldLCBCc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBBQnM7XG59XG5leHBvcnRzLnppcCA9IHppcDtcbmZ1bmN0aW9uIHVuemlwKEFCcykge1xuICAgIHZhciBuID0gQUJzLmxlbmd0aDtcbiAgICB2YXIgQXMgPSBuZXcgQXJyYXkobik7XG4gICAgdmFyIEJzID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIF9hID0gQUJzW2ldLCBBc1tpXSA9IF9hWzBdLCBCc1tpXSA9IF9hWzFdO1xuICAgIH1cbiAgICByZXR1cm4gW0FzLCBCc107XG4gICAgdmFyIF9hO1xufVxuZXhwb3J0cy51bnppcCA9IHVuemlwO1xuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoc3RlcCA9PT0gdm9pZCAwKSB7IHN0ZXAgPSAxOyB9XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgICAgcmFuZ2VbaV0gPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xufVxuZXhwb3J0cy5yYW5nZSA9IHJhbmdlO1xuZnVuY3Rpb24gbGluc3BhY2Uoc3RhcnQsIHN0b3AsIG51bSkge1xuICAgIGlmIChudW0gPT09IHZvaWQgMCkgeyBudW0gPSAxMDA7IH1cbiAgICB2YXIgc3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gKG51bSAtIDEpO1xuICAgIHZhciBhcnJheSA9IG5ldyBBcnJheShudW0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0gPSBzdGFydCArIHN0ZXAgKiBpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLmxpbnNwYWNlID0gbGluc3BhY2U7XG5mdW5jdGlvbiB0cmFuc3Bvc2UoYXJyYXkpIHtcbiAgICB2YXIgcm93cyA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgY29scyA9IGFycmF5WzBdLmxlbmd0aDtcbiAgICB2YXIgdHJhbnNwb3NlZCA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sczsgaisrKSB7XG4gICAgICAgIHRyYW5zcG9zZWRbal0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAgIHRyYW5zcG9zZWRbal1baV0gPSBhcnJheVtpXVtqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3NlZDtcbn1cbmV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuZnVuY3Rpb24gc3VtKGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSArIGI7IH0sIDApO1xufVxuZXhwb3J0cy5zdW0gPSBzdW07XG5mdW5jdGlvbiBjdW1zdW0oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgYXJyYXkucmVkdWNlKGZ1bmN0aW9uIChhLCBiLCBpKSB7IHJldHVybiByZXN1bHRbaV0gPSBhICsgYjsgfSwgMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY3Vtc3VtID0gY3Vtc3VtO1xuZnVuY3Rpb24gbWluKGFycmF5KSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzEgPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGhfMTsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gYXJyYXlbaV07XG4gICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMubWluID0gbWluO1xuZnVuY3Rpb24gbWluQnkoYXJyYXksIGtleSkge1xuICAgIGlmIChhcnJheS5sZW5ndGggPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWluQnkoKSBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhcnJheVwiKTtcbiAgICB2YXIgcmVzdWx0ID0gYXJyYXlbMF07XG4gICAgdmFyIHJlc3VsdENvbXB1dGVkID0ga2V5KHJlc3VsdCk7XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aF8yID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoXzI7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXTtcbiAgICAgICAgdmFyIGNvbXB1dGVkID0ga2V5KHZhbHVlKTtcbiAgICAgICAgaWYgKGNvbXB1dGVkIDwgcmVzdWx0Q29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmVzdWx0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5taW5CeSA9IG1pbkJ5O1xuZnVuY3Rpb24gbWF4KGFycmF5KSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8zID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoXzM7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2ldO1xuICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLm1heCA9IG1heDtcbmZ1bmN0aW9uIG1heEJ5KGFycmF5LCBrZXkpIHtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1heEJ5KCkgY2FsbGVkIHdpdGggYW4gZW1wdHkgYXJyYXlcIik7XG4gICAgdmFyIHJlc3VsdCA9IGFycmF5WzBdO1xuICAgIHZhciByZXN1bHRDb21wdXRlZCA9IGtleShyZXN1bHQpO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGhfNCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aF80OyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV07XG4gICAgICAgIHZhciBjb21wdXRlZCA9IGtleSh2YWx1ZSk7XG4gICAgICAgIGlmIChjb21wdXRlZCA+IHJlc3VsdENvbXB1dGVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJlc3VsdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMubWF4QnkgPSBtYXhCeTtcbmZ1bmN0aW9uIGFyZ21pbihhcnJheSkge1xuICAgIHJldHVybiBtaW5CeShyYW5nZShhcnJheS5sZW5ndGgpLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4gYXJyYXlbaV07IH0pO1xufVxuZXhwb3J0cy5hcmdtaW4gPSBhcmdtaW47XG5mdW5jdGlvbiBhcmdtYXgoYXJyYXkpIHtcbiAgICByZXR1cm4gbWF4QnkocmFuZ2UoYXJyYXkubGVuZ3RoKSwgZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGFycmF5W2ldOyB9KTtcbn1cbmV4cG9ydHMuYXJnbWF4ID0gYXJnbWF4O1xuZnVuY3Rpb24gYWxsKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGFycmF5XzEgPSBhcnJheTsgX2kgPCBhcnJheV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaXRlbSA9IGFycmF5XzFbX2ldO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZShpdGVtKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmFsbCA9IGFsbDtcbmZ1bmN0aW9uIGFueShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBhcnJheV8yID0gYXJyYXk7IF9pIDwgYXJyYXlfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBhcnJheV8yW19pXTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShpdGVtKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmFueSA9IGFueTtcbmZ1bmN0aW9uIGZpbmRJbmRleEZhY3RvcnkoZGlyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbn1cbmV4cG9ydHMuZmluZEluZGV4ID0gZmluZEluZGV4RmFjdG9yeSgxKTtcbmV4cG9ydHMuZmluZExhc3RJbmRleCA9IGZpbmRJbmRleEZhY3RvcnkoLTEpO1xuZnVuY3Rpb24gZmluZChhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gZXhwb3J0cy5maW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSk7XG4gICAgcmV0dXJuIGluZGV4ID09IC0xID8gdW5kZWZpbmVkIDogYXJyYXlbaW5kZXhdO1xufVxuZXhwb3J0cy5maW5kID0gZmluZDtcbmZ1bmN0aW9uIGZpbmRMYXN0KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSBleHBvcnRzLmZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSk7XG4gICAgcmV0dXJuIGluZGV4ID09IC0xID8gdW5kZWZpbmVkIDogYXJyYXlbaW5kZXhdO1xufVxuZXhwb3J0cy5maW5kTGFzdCA9IGZpbmRMYXN0O1xuZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgdmFyIGxvdyA9IDA7XG4gICAgdmFyIGhpZ2ggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgIGlmIChhcnJheVttaWRdIDwgdmFsdWUpXG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xufVxuZXhwb3J0cy5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuZnVuY3Rpb24gc29ydEJ5KGFycmF5LCBrZXkpIHtcbiAgICB2YXIgdG1wID0gYXJyYXkubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBpbmRleDogaW5kZXgsIGtleToga2V5KHZhbHVlKSB9O1xuICAgIH0pO1xuICAgIHRtcC5zb3J0KGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgYSA9IGxlZnQua2V5O1xuICAgICAgICB2YXIgYiA9IHJpZ2h0LmtleTtcbiAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICAgIGlmIChhID4gYiB8fCBhID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pO1xuICAgIHJldHVybiB0bXAubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLnZhbHVlOyB9KTtcbn1cbmV4cG9ydHMuc29ydEJ5ID0gc29ydEJ5O1xuZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGFycmF5XzMgPSBhcnJheTsgX2kgPCBhcnJheV8zLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheV8zW19pXTtcbiAgICAgICAgaWYgKCFjb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnVuaXEgPSB1bmlxO1xuZnVuY3Rpb24gdW5pcUJ5KGFycmF5LCBrZXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGFycmF5XzQgPSBhcnJheTsgX2kgPCBhcnJheV80Lmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheV80W19pXTtcbiAgICAgICAgdmFyIGNvbXB1dGVkID0ga2V5KHZhbHVlKTtcbiAgICAgICAgaWYgKCFjb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudW5pcUJ5ID0gdW5pcUJ5O1xuZnVuY3Rpb24gdW5pb24oKSB7XG4gICAgdmFyIGFycmF5cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFycmF5c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gdW5pcShjb25jYXQoYXJyYXlzKSk7XG59XG5leHBvcnRzLnVuaW9uID0gdW5pb247XG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgYXJyYXlzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJyYXlzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdG9wOiBmb3IgKHZhciBfYSA9IDAsIGFycmF5XzUgPSBhcnJheTsgX2EgPCBhcnJheV81Lmxlbmd0aDsgX2ErKykge1xuICAgICAgICB2YXIgaXRlbSA9IGFycmF5XzVbX2FdO1xuICAgICAgICBpZiAoY29udGFpbnMocmVzdWx0LCBpdGVtKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIGFycmF5c18xID0gYXJyYXlzOyBfYiA8IGFycmF5c18xLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gYXJyYXlzXzFbX2JdO1xuICAgICAgICAgICAgaWYgKCFjb250YWlucyhvdGhlciwgaXRlbSkpXG4gICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG5mdW5jdGlvbiBkaWZmZXJlbmNlKGFycmF5KSB7XG4gICAgdmFyIGFycmF5cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFycmF5c1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHJlc3QgPSBjb25jYXQoYXJyYXlzKTtcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gIWNvbnRhaW5zKHJlc3QsIHZhbHVlKTsgfSk7XG59XG5leHBvcnRzLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuZnVuY3Rpb24gcmVtb3ZlQnkoYXJyYXksIGtleSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOykge1xuICAgICAgICBpZiAoa2V5KGFycmF5W2ldKSlcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaSsrO1xuICAgIH1cbn1cbmV4cG9ydHMucmVtb3ZlQnkgPSByZW1vdmVCeTtcbi8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLCB1c2luZyB0aGUgbW9kZXJuIHZlcnNpb24gb2YgdGhlXG4vLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG5mdW5jdGlvbiBzaHVmZmxlKGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgc2h1ZmZsZWQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByYW5kID0gbWF0aF8xLnJhbmRvbUluKDAsIGkpO1xuICAgICAgICBpZiAocmFuZCAhPT0gaSlcbiAgICAgICAgICAgIHNodWZmbGVkW2ldID0gc2h1ZmZsZWRbcmFuZF07XG4gICAgICAgIHNodWZmbGVkW3JhbmRdID0gYXJyYXlbaV07XG4gICAgfVxuICAgIHJldHVybiBzaHVmZmxlZDtcbn1cbmV4cG9ydHMuc2h1ZmZsZSA9IHNodWZmbGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGVtcHR5KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pblg6IEluZmluaXR5LFxuICAgICAgICBtaW5ZOiBJbmZpbml0eSxcbiAgICAgICAgbWF4WDogLUluZmluaXR5LFxuICAgICAgICBtYXhZOiAtSW5maW5pdHksXG4gICAgfTtcbn1cbmV4cG9ydHMuZW1wdHkgPSBlbXB0eTtcbmZ1bmN0aW9uIHBvc2l0aXZlX3goKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluWDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgbWluWTogLUluZmluaXR5LFxuICAgICAgICBtYXhYOiBJbmZpbml0eSxcbiAgICAgICAgbWF4WTogSW5maW5pdHksXG4gICAgfTtcbn1cbmV4cG9ydHMucG9zaXRpdmVfeCA9IHBvc2l0aXZlX3g7XG5mdW5jdGlvbiBwb3NpdGl2ZV95KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pblg6IC1JbmZpbml0eSxcbiAgICAgICAgbWluWTogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgbWF4WDogSW5maW5pdHksXG4gICAgICAgIG1heFk6IEluZmluaXR5LFxuICAgIH07XG59XG5leHBvcnRzLnBvc2l0aXZlX3kgPSBwb3NpdGl2ZV95O1xuZnVuY3Rpb24gdW5pb24oYSwgYikge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pblg6IE1hdGgubWluKGEubWluWCwgYi5taW5YKSxcbiAgICAgICAgbWF4WDogTWF0aC5tYXgoYS5tYXhYLCBiLm1heFgpLFxuICAgICAgICBtaW5ZOiBNYXRoLm1pbihhLm1pblksIGIubWluWSksXG4gICAgICAgIG1heFk6IE1hdGgubWF4KGEubWF4WSwgYi5tYXhZKSxcbiAgICB9O1xufVxuZXhwb3J0cy51bmlvbiA9IHVuaW9uO1xudmFyIEJCb3ggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJCb3goYmJveCkge1xuICAgICAgICBpZiAoYmJveCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLngwID0gSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLnkwID0gLUluZmluaXR5O1xuICAgICAgICAgICAgdGhpcy54MSA9IEluZmluaXR5O1xuICAgICAgICAgICAgdGhpcy55MSA9IC1JbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueDAgPSBiYm94LngwO1xuICAgICAgICAgICAgdGhpcy55MCA9IGJib3gueTA7XG4gICAgICAgICAgICB0aGlzLngxID0gYmJveC54MTtcbiAgICAgICAgICAgIHRoaXMueTEgPSBiYm94LnkxO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCQm94LnByb3RvdHlwZSwgXCJtaW5YXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLngwOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQkJveC5wcm90b3R5cGUsIFwibWluWVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy55MDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJCb3gucHJvdG90eXBlLCBcIm1heFhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMueDE7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCQm94LnByb3RvdHlwZSwgXCJtYXhZXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnkxOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQkJveC5wcm90b3R5cGUsIFwicHQwXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbdGhpcy54MCwgdGhpcy55MF07IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCQm94LnByb3RvdHlwZSwgXCJwdDFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt0aGlzLngxLCB0aGlzLnkxXTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJCb3gucHJvdG90eXBlLCBcInhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMueDA7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCQm94LnByb3RvdHlwZSwgXCJ5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLngxOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQkJveC5wcm90b3R5cGUsIFwid2lkdGhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMueDEgLSB0aGlzLngwOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQkJveC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnkxIC0gdGhpcy55MDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQkJveC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4geCA+PSB0aGlzLngwICYmIHggPD0gdGhpcy54MSAmJiB5ID49IHRoaXMueTAgJiYgeSA8PSB0aGlzLnkxO1xuICAgIH07XG4gICAgQkJveC5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICByZXR1cm4gbmV3IEJCb3goe1xuICAgICAgICAgICAgeDA6IE1hdGgubWluKHRoaXMueDAsIHRoYXQueDApLFxuICAgICAgICAgICAgeTA6IE1hdGgubWluKHRoaXMueTAsIHRoYXQueTApLFxuICAgICAgICAgICAgeDE6IE1hdGgubWF4KHRoaXMueDEsIHRoYXQueDEpLFxuICAgICAgICAgICAgeTE6IE1hdGgubWF4KHRoaXMueTEsIHRoYXQueTEpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBCQm94O1xufSgpKTtcbmV4cG9ydHMuQkJveCA9IEJCb3g7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGRlbGF5KGZ1bmMsIHdhaXQpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jLCB3YWl0KTtcbn1cbmV4cG9ydHMuZGVsYXkgPSBkZWxheTtcbnZhciBfZGVmZXIgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSBcImZ1bmN0aW9uXCIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBzZXRJbW1lZGlhdGU7XG5mdW5jdGlvbiBkZWZlcihmdW5jKSB7XG4gICAgcmV0dXJuIF9kZWZlcihmdW5jKTtcbn1cbmV4cG9ydHMuZGVmZXIgPSBkZWZlcjtcbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogRGF0ZS5ub3coKTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dClcbiAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCF0aW1lb3V0KVxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuZXhwb3J0cy50aHJvdHRsZSA9IHRocm90dGxlO1xuZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICB2YXIgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgbWVtbyA9IGZ1bmMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xufVxuZXhwb3J0cy5vbmNlID0gb25jZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGZpeHVwX2VsbGlwc2UsIGZpeHVwX2ltYWdlX3Ntb290aGluZywgZml4dXBfbGluZV9kYXNoLCBmaXh1cF9saW5lX2Rhc2hfb2Zmc2V0LCBmaXh1cF9tZWFzdXJlX3RleHQ7XG5maXh1cF9saW5lX2Rhc2ggPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgaWYgKCFjdHguc2V0TGluZURhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoID0gZnVuY3Rpb24gKGRhc2gpIHtcbiAgICAgICAgICAgIGN0eC5tb3pEYXNoID0gZGFzaDtcbiAgICAgICAgICAgIHJldHVybiBjdHgud2Via2l0TGluZURhc2ggPSBkYXNoO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWN0eC5nZXRMaW5lRGFzaCkge1xuICAgICAgICByZXR1cm4gY3R4LmdldExpbmVEYXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5tb3pEYXNoO1xuICAgICAgICB9O1xuICAgIH1cbn07XG5maXh1cF9saW5lX2Rhc2hfb2Zmc2V0ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eC5zZXRMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uIChkYXNoX29mZnNldCkge1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoX29mZnNldDtcbiAgICAgICAgY3R4Lm1vekRhc2hPZmZzZXQgPSBkYXNoX29mZnNldDtcbiAgICAgICAgcmV0dXJuIGN0eC53ZWJraXRMaW5lRGFzaE9mZnNldCA9IGRhc2hfb2Zmc2V0O1xuICAgIH07XG4gICAgcmV0dXJuIGN0eC5nZXRMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5tb3pEYXNoT2Zmc2V0O1xuICAgIH07XG59O1xuZml4dXBfaW1hZ2Vfc21vb3RoaW5nID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eC5zZXRJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHZhbHVlO1xuICAgICAgICBjdHgubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdmFsdWU7XG4gICAgICAgIGN0eC5vSW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjdHgud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4gY3R4LmdldEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuIChyZWYgPSBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkKSAhPSBudWxsID8gcmVmIDogdHJ1ZTtcbiAgICB9O1xufTtcbmZpeHVwX21lYXN1cmVfdGV4dCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICBpZiAoY3R4Lm1lYXN1cmVUZXh0ICYmIChjdHguaHRtbDVNZWFzdXJlVGV4dCA9PSBudWxsKSkge1xuICAgICAgICBjdHguaHRtbDVNZWFzdXJlVGV4dCA9IGN0eC5tZWFzdXJlVGV4dDtcbiAgICAgICAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgdGV4dE1ldHJpY3M7XG4gICAgICAgICAgICB0ZXh0TWV0cmljcyA9IGN0eC5odG1sNU1lYXN1cmVUZXh0KHRleHQpO1xuICAgICAgICAgICAgdGV4dE1ldHJpY3MuYXNjZW50ID0gY3R4Lmh0bWw1TWVhc3VyZVRleHQoXCJtXCIpLndpZHRoICogMS42O1xuICAgICAgICAgICAgcmV0dXJuIHRleHRNZXRyaWNzO1xuICAgICAgICB9O1xuICAgIH1cbn07XG5maXh1cF9lbGxpcHNlID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBlbGxpcHNlX2JlemllcjtcbiAgICBlbGxpcHNlX2JlemllciA9IGZ1bmN0aW9uICh4LCB5LCByYWRpdXNYLCByYWRpdXNZLCByb3RhdGlvbiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgdmFyIGMsIHJ4LCByeTtcbiAgICAgICAgaWYgKGFudGljbG9ja3dpc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW50aWNsb2Nrd2lzZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGMgPSAwLjU1MTc4NDtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgY3R4LnJvdGF0ZShyb3RhdGlvbik7XG4gICAgICAgIHJ4ID0gcmFkaXVzWDtcbiAgICAgICAgcnkgPSByYWRpdXNZO1xuICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgcnggPSAtcmFkaXVzWDtcbiAgICAgICAgICAgIHJ5ID0gLXJhZGl1c1k7XG4gICAgICAgIH1cbiAgICAgICAgY3R4Lm1vdmVUbygtcngsIDApO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbygtcngsIHJ5ICogYywgLXJ4ICogYywgcnksIDAsIHJ5KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8ocnggKiBjLCByeSwgcngsIHJ5ICogYywgcngsIDApO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhyeCwgLXJ5ICogYywgcnggKiBjLCAtcnksIDAsIC1yeSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKC1yeCAqIGMsIC1yeSwgLXJ4LCAtcnkgKiBjLCAtcngsIDApO1xuICAgICAgICBjdHgucm90YXRlKC1yb3RhdGlvbik7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXgsIC15KTtcbiAgICB9O1xuICAgIGlmICghY3R4LmVsbGlwc2UpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5lbGxpcHNlID0gZWxsaXBzZV9iZXppZXI7XG4gICAgfVxufTtcbmV4cG9ydHMuZml4dXBfY3R4ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIGZpeHVwX2xpbmVfZGFzaChjdHgpO1xuICAgIGZpeHVwX2xpbmVfZGFzaF9vZmZzZXQoY3R4KTtcbiAgICBmaXh1cF9pbWFnZV9zbW9vdGhpbmcoY3R4KTtcbiAgICBmaXh1cF9tZWFzdXJlX3RleHQoY3R4KTtcbiAgICByZXR1cm4gZml4dXBfZWxsaXBzZShjdHgpO1xufTtcbmV4cG9ydHMuZ2V0X3NjYWxlX3JhdGlvID0gZnVuY3Rpb24gKGN0eCwgaGlkcGksIGJhY2tlbmQpIHtcbiAgICB2YXIgYmFja2luZ1N0b3JlUmF0aW8sIGRldmljZVBpeGVsUmF0aW87XG4gICAgaWYgKGJhY2tlbmQgPT09IFwic3ZnXCIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhpZHBpKSB7XG4gICAgICAgIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICBiYWNraW5nU3RvcmVSYXRpbyA9IGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX2NvbXBvbmVudDJoZXgsIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uIChpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pXG4gICAgICAgIHJldHVybiBpO1xufSByZXR1cm4gLTE7IH07XG52YXIgc3ZnX2NvbG9ycyA9IHJlcXVpcmUoXCIuL3N2Z19jb2xvcnNcIik7XG5fY29tcG9uZW50MmhleCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGg7XG4gICAgaCA9IE51bWJlcih2KS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGggPSBoLmxlbmd0aCA9PT0gMSA/ICcwJyArIGggOiBoO1xufTtcbmV4cG9ydHMuY29sb3IyaGV4ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdmFyIGhleCwgcmdiLCB2O1xuICAgIGNvbG9yID0gY29sb3IgKyAnJztcbiAgICBpZiAoY29sb3IuaW5kZXhPZignIycpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3ZnX2NvbG9yc1tjb2xvcl0gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3ZnX2NvbG9yc1tjb2xvcl07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbG9yLmluZGV4T2YoJ3JnYicpID09PSAwKSB7XG4gICAgICAgIHJnYiA9IGNvbG9yLm1hdGNoKC9cXGQrL2cpO1xuICAgICAgICBoZXggPSAoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZ2IubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2ID0gcmdiW2pdO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChfY29tcG9uZW50MmhleCh2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKSkuam9pbignJyk7XG4gICAgICAgIHJldHVybiAnIycgKyBoZXguc2xpY2UoMCwgOCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxufTtcbmV4cG9ydHMuY29sb3IycmdiYSA9IGZ1bmN0aW9uIChjb2xvciwgYWxwaGEpIHtcbiAgICB2YXIgaGV4LCBpLCByZ2JhO1xuICAgIGlmIChhbHBoYSA9PSBudWxsKSB7XG4gICAgICAgIGFscGhhID0gMTtcbiAgICB9XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICAgIH1cbiAgICBoZXggPSBleHBvcnRzLmNvbG9yMmhleChjb2xvcik7XG4gICAgaGV4ID0gaGV4LnJlcGxhY2UoLyB8Iy9nLCAnJyk7XG4gICAgaWYgKGhleC5sZW5ndGggPD0gNCkge1xuICAgICAgICBoZXggPSBoZXgucmVwbGFjZSgvKC4pL2csICckMSQxJyk7XG4gICAgfVxuICAgIGhleCA9IGhleC5tYXRjaCgvLi4vZyk7XG4gICAgcmdiYSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBqLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaGV4Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpID0gaGV4W2pdO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHBhcnNlSW50KGksIDE2KSAvIDI1NSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSkoKTtcbiAgICB3aGlsZSAocmdiYS5sZW5ndGggPCAzKSB7XG4gICAgICAgIHJnYmEucHVzaCgwKTtcbiAgICB9XG4gICAgaWYgKHJnYmEubGVuZ3RoIDwgNCkge1xuICAgICAgICByZ2JhLnB1c2goYWxwaGEpO1xuICAgIH1cbiAgICByZXR1cm4gcmdiYS5zbGljZSgwLCA0KTtcbn07XG5leHBvcnRzLnZhbGlkX3JnYiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBjb250ZW50cywgcGFyYW1zLCByZWYsIHJnYjtcbiAgICBzd2l0Y2ggKHZhbHVlLnN1YnN0cmluZygwLCA0KSkge1xuICAgICAgICBjYXNlIFwicmdiYVwiOlxuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBcInJnYmEoXCIsXG4gICAgICAgICAgICAgICAgbGVuOiA0LFxuICAgICAgICAgICAgICAgIGFscGhhOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZ2IoXCI6XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IFwicmdiKFwiLFxuICAgICAgICAgICAgICAgIGxlbjogMyxcbiAgICAgICAgICAgICAgICBhbHBoYTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5ldyBSZWdFeHAoXCIuKj8oXFxcXC4pLiooLClcIikudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29sb3IgZXhwZWN0cyBpbnRlZ2VycyBmb3IgcmdiIGluIHJnYi9yZ2JhIHR1cGxlLCByZWNlaXZlZCBcIiArIHZhbHVlKTtcbiAgICB9XG4gICAgY29udGVudHMgPSB2YWx1ZS5yZXBsYWNlKHBhcmFtcy5zdGFydCwgXCJcIikucmVwbGFjZShcIilcIiwgXCJcIikuc3BsaXQoJywnKS5tYXAocGFyc2VGbG9hdCk7XG4gICAgaWYgKGNvbnRlbnRzLmxlbmd0aCAhPT0gcGFyYW1zLmxlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb2xvciBleHBlY3RzIHJnYmEgXCIgKyBleHBlY3RfbGVuICsgXCItdHVwbGUsIHJlY2VpdmVkIFwiICsgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmFscGhhICYmICEoKDAgPD0gKHJlZiA9IGNvbnRlbnRzWzNdKSAmJiByZWYgPD0gMSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbG9yIGV4cGVjdHMgcmdiYSA0LXR1cGxlIHRvIGhhdmUgYWxwaGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxXCIpO1xuICAgIH1cbiAgICBpZiAoaW5kZXhPZi5jYWxsKChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBqLCBsZW4sIHJlZjEsIHJlc3VsdHM7XG4gICAgICAgIHJlZjEgPSBjb250ZW50cy5zbGljZSgwLCAzKTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByZ2IgPSByZWYxW2pdO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCgwIDw9IHJnYiAmJiByZ2IgPD0gMjU1KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSkoKSwgZmFsc2UpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29sb3IgZXhwZWN0cyByZ2IgdG8gaGF2ZSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xudmFyIGVxXzEgPSByZXF1aXJlKFwiLi9lcVwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5leHBvcnRzLk11bHRpRGljdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTXVsdGlEaWN0KCkge1xuICAgICAgICB0aGlzLl9kaWN0ID0ge307XG4gICAgfVxuICAgIE11bHRpRGljdC5wcm90b3R5cGUuX2V4aXN0aW5nID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5IGluIHRoaXMuX2RpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTXVsdGlEaWN0LnByb3RvdHlwZS5hZGRfdmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3Rpbmc7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcHV0IG51bGwgaW4gdGhpcyBkaWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlc18xLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwdXQgYXJyYXlzIGluIHRoaXMgZGljdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBleGlzdGluZyA9IHRoaXMuX2V4aXN0aW5nKGtleSk7XG4gICAgICAgIGlmIChleGlzdGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWN0W2tleV0gPSBbZXhpc3RpbmcsIHZhbHVlXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTXVsdGlEaWN0LnByb3RvdHlwZS5yZW1vdmVfdmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcsIG5ld19hcnJheTtcbiAgICAgICAgZXhpc3RpbmcgPSB0aGlzLl9leGlzdGluZyhrZXkpO1xuICAgICAgICBpZiAodHlwZXNfMS5pc0FycmF5KGV4aXN0aW5nKSkge1xuICAgICAgICAgICAgbmV3X2FycmF5ID0gYXJyYXlfMS5kaWZmZXJlbmNlKGV4aXN0aW5nLCBbdmFsdWVdKTtcbiAgICAgICAgICAgIGlmIChuZXdfYXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWN0W2tleV0gPSBuZXdfYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlIHRoaXMuX2RpY3Rba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcV8xLmlzRXF1YWwoZXhpc3RpbmcsIHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSB0aGlzLl9kaWN0W2tleV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE11bHRpRGljdC5wcm90b3R5cGUuZ2V0X29uZSA9IGZ1bmN0aW9uIChrZXksIGR1cGxpY2F0ZV9lcnJvcikge1xuICAgICAgICB2YXIgZXhpc3Rpbmc7XG4gICAgICAgIGV4aXN0aW5nID0gdGhpcy5fZXhpc3Rpbmcoa2V5KTtcbiAgICAgICAgaWYgKHR5cGVzXzEuaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgIGlmIChleGlzdGluZy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZHVwbGljYXRlX2Vycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE11bHRpRGljdDtcbn0pKCk7XG5leHBvcnRzLlNldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0KGFycmF5KSB7XG4gICAgICAgIGlmICghYXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJyYXkuY29uc3RydWN0b3IgPT09IFNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2V0KGFycmF5LnZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJyYXkuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBTZXQuY29tcGFjdChhcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IFthcnJheV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgU2V0LmNvbXBhY3QgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgdmFyIGl0ZW0sIGosIGxlbiwgbmV3QXJyYXk7XG4gICAgICAgIG5ld0FycmF5ID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpdGVtID0gYXJyYXlbal07XG4gICAgICAgICAgICBpZiAobmV3QXJyYXkuaW5kZXhPZihpdGVtKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXdBcnJheS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICh0aGlzLm1pc3NpbmcoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBpID0gdGhpcy52YWx1ZXMuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzID0gdGhpcy52YWx1ZXMuc2xpY2UoMCwgaSkuY29uY2F0KHRoaXMudmFsdWVzLnNsaWNlKGkgKyAxKSk7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLmxlbmd0aDtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMuaW5kZXhPZihpdGVtKSAhPT0gLTE7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLm1pc3NpbmcgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaW5jbHVkZXMoaXRlbSk7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5zbGljZShmcm9tLCB0byk7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5qb2luKHN0cik7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qb2luKCcsICcpO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5pbmRleE9mKGl0ZW0pICE9PSAtMTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy52YWx1ZXMuY29uY2F0KHNldC52YWx1ZXMpKTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKHNldCkge1xuICAgICAgICB2YXIgaXRlbSwgaiwgbGVuLCBuZXdTZXQsIHJlZjtcbiAgICAgICAgc2V0ID0gbmV3IFNldChzZXQpO1xuICAgICAgICBuZXdTZXQgPSBuZXcgU2V0O1xuICAgICAgICByZWYgPSBzZXQudmFsdWVzO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSByZWZbal07XG4gICAgICAgICAgICBpZiAodGhpcy5pbmNsdWRlcyhpdGVtKSAmJiBzZXQuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBuZXdTZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U2V0O1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKHNldCkge1xuICAgICAgICB2YXIgaXRlbSwgaiwgbGVuLCBuZXdTZXQsIHJlZjtcbiAgICAgICAgc2V0ID0gbmV3IFNldChzZXQpO1xuICAgICAgICBuZXdTZXQgPSBuZXcgU2V0O1xuICAgICAgICByZWYgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpdGVtID0gcmVmW2pdO1xuICAgICAgICAgICAgaWYgKHNldC5taXNzaW5nKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgbmV3U2V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1NldDtcbiAgICB9O1xuICAgIHJldHVybiBTZXQ7XG59KSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyAgICAgVW5kZXJzY29yZS5qcyAxLjguM1xuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbi8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG5mdW5jdGlvbiBlcShhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgICAgICBpZiAoK2EgIT09ICthKVxuICAgICAgICAgICAgICAgIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICAgICAgcmV0dXJuICthID09PSArYjtcbiAgICB9XG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICBpZiAoIWFyZUFycmF5cykge1xuICAgICAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgISh0eXBlc18xLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgICAgIHR5cGVzXzEuaXNGdW5jdGlvbihiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcilcbiAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSlcbiAgICAgICAgICAgIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleSA9IHZvaWQgMDtcbiAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAgICAgICAga2V5ID0ga2V5c1tsZW5ndGhdO1xuICAgICAgICAgICAgaWYgKCEoYi5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG5mdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYik7XG59XG5leHBvcnRzLmlzRXF1YWwgPSBpc0VxdWFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBhbmdsZV9ub3JtKGFuZ2xlKSB7XG4gICAgd2hpbGUgKGFuZ2xlIDwgMCkge1xuICAgICAgICBhbmdsZSArPSAyICogTWF0aC5QSTtcbiAgICB9XG4gICAgd2hpbGUgKGFuZ2xlID4gMiAqIE1hdGguUEkpIHtcbiAgICAgICAgYW5nbGUgLT0gMiAqIE1hdGguUEk7XG4gICAgfVxuICAgIHJldHVybiBhbmdsZTtcbn1cbmV4cG9ydHMuYW5nbGVfbm9ybSA9IGFuZ2xlX25vcm07XG5mdW5jdGlvbiBhbmdsZV9kaXN0KGxocywgcmhzKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGFuZ2xlX25vcm0obGhzIC0gcmhzKSk7XG59XG5leHBvcnRzLmFuZ2xlX2Rpc3QgPSBhbmdsZV9kaXN0O1xuZnVuY3Rpb24gYW5nbGVfYmV0d2VlbihtaWQsIGxocywgcmhzLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgbm9ybV9taWQgPSBhbmdsZV9ub3JtKG1pZCk7XG4gICAgdmFyIGQgPSBhbmdsZV9kaXN0KGxocywgcmhzKTtcbiAgICB2YXIgY29uZCA9IGFuZ2xlX2Rpc3QobGhzLCBub3JtX21pZCkgPD0gZCAmJiBhbmdsZV9kaXN0KG5vcm1fbWlkLCByaHMpIDw9IGQ7XG4gICAgaWYgKGRpcmVjdGlvbiA9PSBcImFudGljbG9ja1wiKVxuICAgICAgICByZXR1cm4gY29uZDtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiAhY29uZDtcbn1cbmV4cG9ydHMuYW5nbGVfYmV0d2VlbiA9IGFuZ2xlX2JldHdlZW47XG5mdW5jdGlvbiByYW5kb20oKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XG59XG5leHBvcnRzLnJhbmRvbSA9IHJhbmRvbTtcbmZ1bmN0aW9uIHJhbmRvbUluKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICAgIG1heCA9IG1pbjtcbiAgICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG59XG5leHBvcnRzLnJhbmRvbUluID0gcmFuZG9tSW47XG5mdW5jdGlvbiBhdGFuMihzdGFydCwgZW5kKSB7XG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gYSBsaW5lIGNvbnRhaW5pbmcgc3RhcnQgYW5kIGVuZCBwb2ludHMgKGNvbXBvc2VkXG4gICAgICogb2YgW3gsIHldIGFycmF5cykgYW5kIHRoZSBwb3NpdGl2ZSB4LWF4aXMuXG4gICAgICovXG4gICAgcmV0dXJuIE1hdGguYXRhbjIoZW5kWzFdIC0gc3RhcnRbMV0sIGVuZFswXSAtIHN0YXJ0WzBdKTtcbn1cbmV4cG9ydHMuYXRhbjIgPSBhdGFuMjtcbi8vIGh0dHA6Ly93d3cyLmVjb24ub3Nha2EtdS5hYy5qcC9+dGFuaXpha2kvY2xhc3MvMjAxMy9lY29ub21lMy8xMy5wZGYgKFBhZ2UgNDMyKVxuZnVuY3Rpb24gcm5vcm0obXUsIHNpZ21hKSB7XG4gICAgLy8gR2VuZXJhdGUgYSByYW5kb20gbm9ybWFsIHdpdGggYSBtZWFuIG9mIDAgYW5kIGEgc2lnbWEgb2YgMVxuICAgIHZhciByMTtcbiAgICB2YXIgcjI7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgcjEgPSByYW5kb20oKTtcbiAgICAgICAgcjIgPSByYW5kb20oKTtcbiAgICAgICAgcjIgPSAoMiAqIHIyIC0gMSkgKiBNYXRoLnNxcnQoMiAqICgxIC8gTWF0aC5FKSk7XG4gICAgICAgIGlmICgtNCAqIHIxICogcjEgKiBNYXRoLmxvZyhyMSkgPj0gcjIgKiByMilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgcm4gPSByMiAvIHIxO1xuICAgIC8vIFRyYW5zZm9ybSB0aGUgc3RhbmRhcmQgbm9ybWFsIHRvIG1lZXQgdGhlIGNoYXJhY3RlcmlzdGljcyB0aGF0IHdlIHdhbnQgKG11LCBzaWdtYSlcbiAgICBybiA9IG11ICsgc2lnbWEgKiBybjtcbiAgICByZXR1cm4gcm47XG59XG5leHBvcnRzLnJub3JtID0gcm5vcm07XG5mdW5jdGlvbiBjbGFtcCh2YWwsIG1pbiwgbWF4KSB7XG4gICAgaWYgKHZhbCA+IG1heClcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICBpZiAodmFsIDwgbWluKVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIHJldHVybiB2YWw7XG59XG5leHBvcnRzLmNsYW1wID0gY2xhbXA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG5leHBvcnRzLmtleXMgPSBPYmplY3Qua2V5cztcbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlc1tpXSA9IG9iamVjdFtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuZnVuY3Rpb24gZXh0ZW5kKGRlc3QpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGZvciAodmFyIF9hID0gMCwgc291cmNlc18xID0gc291cmNlczsgX2EgPCBzb3VyY2VzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzXzFbX2FdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBkZXN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn1cbmV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgcmV0dXJuIGV4dGVuZCh7fSwgb2JqKTtcbn1cbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmZ1bmN0aW9uIG1lcmdlKG9iajEsIG9iajIpIHtcbiAgICAvKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGFycmF5IHZhbHVlcyBmb3Igb2JqMSBhbmQgb2JqMiB1bmlvbmVkIGJ5IGtleS5cbiAgICAgKi9cbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QucHJvdG90eXBlKTtcbiAgICB2YXIga2V5cyA9IGFycmF5XzEuY29uY2F0KFtPYmplY3Qua2V5cyhvYmoxKSwgT2JqZWN0LmtleXMob2JqMildKTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGtleXNfMSA9IGtleXM7IF9pIDwga2V5c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c18xW19pXTtcbiAgICAgICAgdmFyIGFycjEgPSBvYmoxLmhhc093blByb3BlcnR5KGtleSkgPyBvYmoxW2tleV0gOiBbXTtcbiAgICAgICAgdmFyIGFycjIgPSBvYmoyLmhhc093blByb3BlcnR5KGtleSkgPyBvYmoyW2tleV0gOiBbXTtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBhcnJheV8xLnVuaW9uKGFycjEsIGFycjIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuZnVuY3Rpb24gc2l6ZShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGg7XG59XG5leHBvcnRzLnNpemUgPSBzaXplO1xuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICByZXR1cm4gc2l6ZShvYmopID09PSAwO1xufVxuZXhwb3J0cy5pc0VtcHR5ID0gaXNFbXB0eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHByb2o0ID0gcmVxdWlyZShcInByb2o0L2xpYi9jb3JlXCIpO1xuZXhwb3J0cy5wcm9qNCA9IHByb2o0O1xudmFyIFByb2ogPSByZXF1aXJlKFwicHJvajQvbGliL1Byb2pcIik7XG52YXIgdG9Qb2ludCA9IHJlcXVpcmUoXCJwcm9qNC9saWIvY29tbW9uL3RvUG9pbnRcIik7XG52YXIgZGVmcyA9IHJlcXVpcmUoXCJwcm9qNC9saWIvZGVmc1wiKTtcbnZhciB0cmFuc2Zvcm0gPSByZXF1aXJlKFwicHJvajQvbGliL3RyYW5zZm9ybVwiKTtcbnByb2o0LmRlZmF1bHREYXR1bSA9ICdXR1M4NCc7XG5wcm9qNC5XR1M4NCA9IG5ldyBQcm9qKCdXR1M4NCcpO1xucHJvajQuUHJvaiA9IFByb2o7XG5wcm9qNC50b1BvaW50ID0gdG9Qb2ludDtcbnByb2o0LmRlZnMgPSBkZWZzO1xucHJvajQudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuZXhwb3J0cy5tZXJjYXRvciA9IGRlZnMoJ0dPT0dMRScpO1xuZXhwb3J0cy53Z3M4NCA9IGRlZnMoJ1dHUzg0Jyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcm9qNF8xID0gcmVxdWlyZShcIi4vcHJvajRcIik7XG5leHBvcnRzLnByb2plY3RfeHkgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciBpLCBqLCBtZXJjX3gsIG1lcmNfeF9zLCBtZXJjX3ksIG1lcmNfeV9zLCByZWYsIHJlZjE7XG4gICAgbWVyY194X3MgPSBbXTtcbiAgICBtZXJjX3lfcyA9IFtdO1xuICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB4Lmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgIHJlZjEgPSBwcm9qNF8xLnByb2o0KHByb2o0XzEubWVyY2F0b3IsIFt4W2ldLCB5W2ldXSksIG1lcmNfeCA9IHJlZjFbMF0sIG1lcmNfeSA9IHJlZjFbMV07XG4gICAgICAgIG1lcmNfeF9zW2ldID0gbWVyY194O1xuICAgICAgICBtZXJjX3lfc1tpXSA9IG1lcmNfeTtcbiAgICB9XG4gICAgcmV0dXJuIFttZXJjX3hfcywgbWVyY195X3NdO1xufTtcbmV4cG9ydHMucHJvamVjdF94c3lzID0gZnVuY3Rpb24gKHhzLCB5cykge1xuICAgIHZhciBpLCBqLCBtZXJjX3hfcywgbWVyY194c19zLCBtZXJjX3lfcywgbWVyY195c19zLCByZWYsIHJlZjE7XG4gICAgbWVyY194c19zID0gW107XG4gICAgbWVyY195c19zID0gW107XG4gICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHhzLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgIHJlZjEgPSBleHBvcnRzLnByb2plY3RfeHkoeHNbaV0sIHlzW2ldKSwgbWVyY194X3MgPSByZWYxWzBdLCBtZXJjX3lfcyA9IHJlZjFbMV07XG4gICAgICAgIG1lcmNfeHNfc1tpXSA9IG1lcmNfeF9zO1xuICAgICAgICBtZXJjX3lzX3NbaV0gPSBtZXJjX3lfcztcbiAgICB9XG4gICAgcmV0dXJuIFttZXJjX3hzX3MsIG1lcmNfeXNfc107XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFzX3Byb3BzXzEgPSByZXF1aXJlKFwiLi4vaGFzX3Byb3BzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmV4cG9ydHMuY3JlYXRlX3JlZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVmO1xuICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIGhhc19wcm9wc18xLkhhc1Byb3BzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4gb25seSBjcmVhdGUgcmVmcyBmb3IgSGFzUHJvcHMgc3ViY2xhc3Nlc1wiKTtcbiAgICB9XG4gICAgcmVmID0ge1xuICAgICAgICAndHlwZSc6IG9iai50eXBlLFxuICAgICAgICAnaWQnOiBvYmouaWRcbiAgICB9O1xuICAgIGlmIChvYmouX3N1YnR5cGUgIT0gbnVsbCkge1xuICAgICAgICByZWZbJ3N1YnR5cGUnXSA9IG9iai5fc3VidHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn07XG5leHBvcnRzLmlzX3JlZiA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICB2YXIga2V5cztcbiAgICBpZiAodHlwZXNfMS5pc09iamVjdChhcmcpKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhhcmcpLnNvcnQoKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5c1swXSA9PT0gJ2lkJyAmJiBrZXlzWzFdID09PSAndHlwZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5c1swXSA9PT0gJ2lkJyAmJiBrZXlzWzFdID09PSAnc3VidHlwZScgJiYga2V5c1syXSA9PT0gJ3R5cGUnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5leHBvcnRzLmNvbnZlcnRfdG9fcmVmID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVzXzEuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChleHBvcnRzLmNvbnZlcnRfdG9fcmVmKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGhhc19wcm9wc18xLkhhc1Byb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldF9pbmRpY2VzID0gZnVuY3Rpb24gKGRhdGFfc291cmNlKSB7XG4gICAgdmFyIHNlbGVjdGVkO1xuICAgIHNlbGVjdGVkID0gZGF0YV9zb3VyY2Uuc2VsZWN0ZWQ7XG4gICAgaWYgKHNlbGVjdGVkWycwZCddLmdseXBoKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZFsnMGQnXS5pbmRpY2VzO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWxlY3RlZFsnMWQnXS5pbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkWycxZCddLmluZGljZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbGVjdGVkWycyZCddLmluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWRbJzJkJ10uaW5kaWNlcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQVJSQVlfVFlQRVMsIERUWVBFUywgX2FycmF5QnVmZmVyVG9CYXNlNjQsIF9iYXNlNjRUb0FycmF5QnVmZmVyLCBrLCB2O1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbkFSUkFZX1RZUEVTID0ge1xuICAgIGZsb2F0MzI6IEZsb2F0MzJBcnJheSxcbiAgICBmbG9hdDY0OiBGbG9hdDY0QXJyYXksXG4gICAgdWludDg6IFVpbnQ4QXJyYXksXG4gICAgaW50ODogSW50OEFycmF5LFxuICAgIHVpbnQxNjogVWludDE2QXJyYXksXG4gICAgaW50MTY6IEludDE2QXJyYXksXG4gICAgdWludDMyOiBVaW50MzJBcnJheSxcbiAgICBpbnQzMjogSW50MzJBcnJheVxufTtcbkRUWVBFUyA9IHt9O1xuZm9yIChrIGluIEFSUkFZX1RZUEVTKSB7XG4gICAgdiA9IEFSUkFZX1RZUEVTW2tdO1xuICAgIERUWVBFU1t2Lm5hbWVdID0gaztcbn1cbl9hcnJheUJ1ZmZlclRvQmFzZTY0ID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgIHZhciBiLCBiaW5hcnksIGJ5dGVzO1xuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBiaW5hcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaiwgbGVuMSwgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gYnl0ZXMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAgICBiID0gYnl0ZXNbal07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gYnRvYShiaW5hcnkuam9pbihcIlwiKSk7XG59O1xuX2Jhc2U2NFRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoYmFzZTY0KSB7XG4gICAgdmFyIGJpbmFyeV9zdHJpbmcsIGJ5dGVzLCBpLCBqLCBsZW4sIHJlZjtcbiAgICBiaW5hcnlfc3RyaW5nID0gYXRvYihiYXNlNjQpO1xuICAgIGxlbiA9IGJpbmFyeV9zdHJpbmcubGVuZ3RoO1xuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gbGVuOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBiaW5hcnlfc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcy5idWZmZXI7XG59O1xuZXhwb3J0cy5kZWNvZGVfYmFzZTY0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIGFycmF5LCBieXRlcywgZHR5cGUsIHNoYXBlO1xuICAgIGJ5dGVzID0gX2Jhc2U2NFRvQXJyYXlCdWZmZXIoaW5wdXRbJ19fbmRhcnJheV9fJ10pO1xuICAgIGR0eXBlID0gaW5wdXRbJ2R0eXBlJ107XG4gICAgaWYgKGR0eXBlIGluIEFSUkFZX1RZUEVTKSB7XG4gICAgICAgIGFycmF5ID0gbmV3IEFSUkFZX1RZUEVTW2R0eXBlXShieXRlcyk7XG4gICAgfVxuICAgIHNoYXBlID0gaW5wdXRbJ3NoYXBlJ107XG4gICAgcmV0dXJuIFthcnJheSwgc2hhcGVdO1xufTtcbmV4cG9ydHMuZW5jb2RlX2Jhc2U2NCA9IGZ1bmN0aW9uIChhcnJheSwgc2hhcGUpIHtcbiAgICB2YXIgYjY0LCBkYXRhLCBkdHlwZTtcbiAgICBiNjQgPSBfYXJyYXlCdWZmZXJUb0Jhc2U2NChhcnJheS5idWZmZXIpO1xuICAgIGR0eXBlID0gRFRZUEVTW2FycmF5LmNvbnN0cnVjdG9yLm5hbWVdO1xuICAgIGRhdGEgPSB7XG4gICAgICAgIF9fbmRhcnJheV9fOiBiNjQsXG4gICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgZHR5cGU6IGR0eXBlXG4gICAgfTtcbiAgICByZXR1cm4gZGF0YTtcbn07XG5leHBvcnRzLmRlY29kZV9jb2x1bW5fZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGFyciwgYXJyYXlzLCBkYXRhX3NoYXBlcywgaiwgbGVuMSwgbmV3X2RhdGEsIHJlZiwgcmVmMSwgc2hhcGUsIHNoYXBlcztcbiAgICBuZXdfZGF0YSA9IHt9O1xuICAgIGRhdGFfc2hhcGVzID0ge307XG4gICAgZm9yIChrIGluIGRhdGEpIHtcbiAgICAgICAgdiA9IGRhdGFba107XG4gICAgICAgIGlmICh0eXBlc18xLmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIGFycmF5cyA9IFtdO1xuICAgICAgICAgICAgc2hhcGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gdi5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgICAgICAgICAgICBhcnIgPSB2W2pdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlc18xLmlzT2JqZWN0KGFycikgJiYgJ19fbmRhcnJheV9fJyBpbiBhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmID0gZXhwb3J0cy5kZWNvZGVfYmFzZTY0KGFyciksIGFyciA9IHJlZlswXSwgc2hhcGUgPSByZWZbMV07XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlcy5wdXNoKHNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlzLnB1c2goYXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVzLnB1c2goW10pO1xuICAgICAgICAgICAgICAgICAgICBhcnJheXMucHVzaChhcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaGFwZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG5ld19kYXRhW2tdID0gYXJyYXlzO1xuICAgICAgICAgICAgICAgIGRhdGFfc2hhcGVzW2tdID0gc2hhcGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3X2RhdGFba10gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNPYmplY3QodikgJiYgJ19fbmRhcnJheV9fJyBpbiB2KSB7XG4gICAgICAgICAgICByZWYxID0gZXhwb3J0cy5kZWNvZGVfYmFzZTY0KHYpLCBhcnIgPSByZWYxWzBdLCBzaGFwZSA9IHJlZjFbMV07XG4gICAgICAgICAgICBuZXdfZGF0YVtrXSA9IGFycjtcbiAgICAgICAgICAgIGRhdGFfc2hhcGVzW2tdID0gc2hhcGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdfZGF0YVtrXSA9IHY7XG4gICAgICAgICAgICBkYXRhX3NoYXBlc1trXSA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbmV3X2RhdGEsIGRhdGFfc2hhcGVzXTtcbn07XG5leHBvcnRzLmVuY29kZV9jb2x1bW5fZGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBzaGFwZXMpIHtcbiAgICB2YXIgaSwgaiwgbmV3X2FycmF5LCBuZXdfZGF0YSwgcmVmLCByZWYxLCByZWYyO1xuICAgIG5ld19kYXRhID0ge307XG4gICAgZm9yIChrIGluIGRhdGEpIHtcbiAgICAgICAgdiA9IGRhdGFba107XG4gICAgICAgIGlmICgodiAhPSBudWxsID8gdi5idWZmZXIgOiB2b2lkIDApIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHYgPSBleHBvcnRzLmVuY29kZV9iYXNlNjQodiwgc2hhcGVzICE9IG51bGwgPyBzaGFwZXNba10gOiB2b2lkIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgbmV3X2FycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdi5sZW5ndGg7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgIGlmICgoKHJlZjEgPSB2W2ldKSAhPSBudWxsID8gcmVmMS5idWZmZXIgOiB2b2lkIDApIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3X2FycmF5LnB1c2goZXhwb3J0cy5lbmNvZGVfYmFzZTY0KHZbaV0sIHNoYXBlcyAhPSBudWxsID8gKHJlZjIgPSBzaGFwZXNba10pICE9IG51bGwgPyByZWYyW2ldIDogdm9pZCAwIDogdm9pZCAwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdfYXJyYXkucHVzaCh2W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ID0gbmV3X2FycmF5O1xuICAgICAgICB9XG4gICAgICAgIG5ld19kYXRhW2tdID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIG5ld19kYXRhO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cIkB0eXBlcy9yYnVzaFwiIC8+XG52YXIgcmJ1c2ggPSByZXF1aXJlKFwicmJ1c2hcIik7XG52YXIgU3BhdGlhbEluZGV4ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcGF0aWFsSW5kZXgoKSB7XG4gICAgfVxuICAgIHJldHVybiBTcGF0aWFsSW5kZXg7XG59KCkpO1xuZXhwb3J0cy5TcGF0aWFsSW5kZXggPSBTcGF0aWFsSW5kZXg7XG52YXIgUkJ1c2ggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJCdXNoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJCdXNoKHBvaW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbmRleCA9IHJidXNoKCk7XG4gICAgICAgIF90aGlzLmluZGV4LmxvYWQocG9pbnRzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUkJ1c2gucHJvdG90eXBlLCBcImJib3hcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuaW5kZXgudG9KU09OKCksIG1pblggPSBfYS5taW5YLCBtaW5ZID0gX2EubWluWSwgbWF4WCA9IF9hLm1heFgsIG1heFkgPSBfYS5tYXhZO1xuICAgICAgICAgICAgcmV0dXJuIHsgbWluWDogbWluWCwgbWluWTogbWluWSwgbWF4WDogbWF4WCwgbWF4WTogbWF4WSB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBSQnVzaC5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXguc2VhcmNoKHJlY3QpO1xuICAgIH07XG4gICAgUkJ1c2gucHJvdG90eXBlLmluZGljZXMgPSBmdW5jdGlvbiAocmVjdCkge1xuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5zZWFyY2gocmVjdCk7XG4gICAgICAgIHZhciBuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGluZGljZXMgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICBpbmRpY2VzW2pdID0gcG9pbnRzW2pdLmk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGljZXM7XG4gICAgfTtcbiAgICByZXR1cm4gUkJ1c2g7XG59KFNwYXRpYWxJbmRleCkpO1xuZXhwb3J0cy5SQnVzaCA9IFJCdXNoO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuLi9zZXR0aW5nc1wiKTtcbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgaWYgKHBvc2l0aW9uID09PSB2b2lkIDApIHsgcG9zaXRpb24gPSAwOyB9XG4gICAgcmV0dXJuIHN0ci5zdWJzdHIocG9zaXRpb24sIHNlYXJjaFN0cmluZy5sZW5ndGgpID09IHNlYXJjaFN0cmluZztcbn1cbmV4cG9ydHMuc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XG5mdW5jdGlvbiB1dWlkNCgpIHtcbiAgICAvLyBmcm9tIGlweXRob24gcHJvamVjdFxuICAgIC8vIGh0dHA6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzQxMjIudHh0XG4gICAgdmFyIHMgPSBuZXcgQXJyYXkoMzIpO1xuICAgIHZhciBoZXhEaWdpdHMgPSBcIjAxMjM0NTY3ODlBQkNERUZcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgc1tpXSA9IGhleERpZ2l0cy5zdWJzdHIoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMCksIDEpO1xuICAgIH1cbiAgICBzWzEyXSA9IFwiNFwiOyAvLyBiaXRzIDEyLTE1IG9mIHRoZSB0aW1lX2hpX2FuZF92ZXJzaW9uIGZpZWxkIHRvIDAwMTBcbiAgICBzWzE2XSA9IGhleERpZ2l0cy5zdWJzdHIoKHNbMTZdLmNoYXJDb2RlQXQoMCkgJiAweDMpIHwgMHg4LCAxKTsgLy8gYml0cyA2LTcgb2YgdGhlIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWQgdG8gMDFcbiAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xufVxuZXhwb3J0cy51dWlkNCA9IHV1aWQ0O1xudmFyIGNvdW50ZXIgPSAxMDAwO1xuZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgdmFyIGlkID0gc2V0dGluZ3NfMS5zZXR0aW5ncy5kZXYgPyBcImpcIiArIGNvdW50ZXIrKyA6IHV1aWQ0KCk7XG4gICAgaWYgKHByZWZpeCAhPSBudWxsKVxuICAgICAgICByZXR1cm4gcHJlZml4ICsgXCItXCIgKyBpZDtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBpZDtcbn1cbmV4cG9ydHMudW5pcXVlSWQgPSB1bmlxdWVJZDtcbmZ1bmN0aW9uIGVzY2FwZShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvKD86WyY8PlwiJ2BdKS9nLCBmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgY2FzZSAnJic6IHJldHVybiAnJmFtcDsnO1xuICAgICAgICAgICAgY2FzZSAnPCc6IHJldHVybiAnJmx0Oyc7XG4gICAgICAgICAgICBjYXNlICc+JzogcmV0dXJuICcmZ3Q7JztcbiAgICAgICAgICAgIGNhc2UgJ1wiJzogcmV0dXJuICcmcXVvdDsnO1xuICAgICAgICAgICAgY2FzZSBcIidcIjogcmV0dXJuICcmI3gyNzsnO1xuICAgICAgICAgICAgY2FzZSAnYCc6IHJldHVybiAnJiN4NjA7JztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBjaDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5lc2NhcGUgPSBlc2NhcGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5kaWFucmVkID0gXCIjQ0Q1QzVDXCI7XG5leHBvcnRzLmxpZ2h0Y29yYWwgPSBcIiNGMDgwODBcIjtcbmV4cG9ydHMuc2FsbW9uID0gXCIjRkE4MDcyXCI7XG5leHBvcnRzLmRhcmtzYWxtb24gPSBcIiNFOTk2N0FcIjtcbmV4cG9ydHMubGlnaHRzYWxtb24gPSBcIiNGRkEwN0FcIjtcbmV4cG9ydHMuY3JpbXNvbiA9IFwiI0RDMTQzQ1wiO1xuZXhwb3J0cy5yZWQgPSBcIiNGRjAwMDBcIjtcbmV4cG9ydHMuZmlyZWJyaWNrID0gXCIjQjIyMjIyXCI7XG5leHBvcnRzLmRhcmtyZWQgPSBcIiM4QjAwMDBcIjtcbmV4cG9ydHMucGluayA9IFwiI0ZGQzBDQlwiO1xuZXhwb3J0cy5saWdodHBpbmsgPSBcIiNGRkI2QzFcIjtcbmV4cG9ydHMuaG90cGluayA9IFwiI0ZGNjlCNFwiO1xuZXhwb3J0cy5kZWVwcGluayA9IFwiI0ZGMTQ5M1wiO1xuZXhwb3J0cy5tZWRpdW12aW9sZXRyZWQgPSBcIiNDNzE1ODVcIjtcbmV4cG9ydHMucGFsZXZpb2xldHJlZCA9IFwiI0RCNzA5M1wiO1xuZXhwb3J0cy5jb3JhbCA9IFwiI0ZGN0Y1MFwiO1xuZXhwb3J0cy50b21hdG8gPSBcIiNGRjYzNDdcIjtcbmV4cG9ydHMub3JhbmdlcmVkID0gXCIjRkY0NTAwXCI7XG5leHBvcnRzLmRhcmtvcmFuZ2UgPSBcIiNGRjhDMDBcIjtcbmV4cG9ydHMub3JhbmdlID0gXCIjRkZBNTAwXCI7XG5leHBvcnRzLmdvbGQgPSBcIiNGRkQ3MDBcIjtcbmV4cG9ydHMueWVsbG93ID0gXCIjRkZGRjAwXCI7XG5leHBvcnRzLmxpZ2h0eWVsbG93ID0gXCIjRkZGRkUwXCI7XG5leHBvcnRzLmxlbW9uY2hpZmZvbiA9IFwiI0ZGRkFDRFwiO1xuZXhwb3J0cy5saWdodGdvbGRlbnJvZHllbGxvdyA9IFwiI0ZBRkFEMlwiO1xuZXhwb3J0cy5wYXBheWF3aGlwID0gXCIjRkZFRkQ1XCI7XG5leHBvcnRzLm1vY2Nhc2luID0gXCIjRkZFNEI1XCI7XG5leHBvcnRzLnBlYWNocHVmZiA9IFwiI0ZGREFCOVwiO1xuZXhwb3J0cy5wYWxlZ29sZGVucm9kID0gXCIjRUVFOEFBXCI7XG5leHBvcnRzLmtoYWtpID0gXCIjRjBFNjhDXCI7XG5leHBvcnRzLmRhcmtraGFraSA9IFwiI0JEQjc2QlwiO1xuZXhwb3J0cy5sYXZlbmRlciA9IFwiI0U2RTZGQVwiO1xuZXhwb3J0cy50aGlzdGxlID0gXCIjRDhCRkQ4XCI7XG5leHBvcnRzLnBsdW0gPSBcIiNEREEwRERcIjtcbmV4cG9ydHMudmlvbGV0ID0gXCIjRUU4MkVFXCI7XG5leHBvcnRzLm9yY2hpZCA9IFwiI0RBNzBENlwiO1xuZXhwb3J0cy5mdWNoc2lhID0gXCIjRkYwMEZGXCI7XG5leHBvcnRzLm1hZ2VudGEgPSBcIiNGRjAwRkZcIjtcbmV4cG9ydHMubWVkaXVtb3JjaGlkID0gXCIjQkE1NUQzXCI7XG5leHBvcnRzLm1lZGl1bXB1cnBsZSA9IFwiIzkzNzBEQlwiO1xuZXhwb3J0cy5ibHVldmlvbGV0ID0gXCIjOEEyQkUyXCI7XG5leHBvcnRzLmRhcmt2aW9sZXQgPSBcIiM5NDAwRDNcIjtcbmV4cG9ydHMuZGFya29yY2hpZCA9IFwiIzk5MzJDQ1wiO1xuZXhwb3J0cy5kYXJrbWFnZW50YSA9IFwiIzhCMDA4QlwiO1xuZXhwb3J0cy5wdXJwbGUgPSBcIiM4MDAwODBcIjtcbmV4cG9ydHMuaW5kaWdvID0gXCIjNEIwMDgyXCI7XG5leHBvcnRzLnNsYXRlYmx1ZSA9IFwiIzZBNUFDRFwiO1xuZXhwb3J0cy5kYXJrc2xhdGVibHVlID0gXCIjNDgzRDhCXCI7XG5leHBvcnRzLm1lZGl1bXNsYXRlYmx1ZSA9IFwiIzdCNjhFRVwiO1xuZXhwb3J0cy5ncmVlbnllbGxvdyA9IFwiI0FERkYyRlwiO1xuZXhwb3J0cy5jaGFydHJldXNlID0gXCIjN0ZGRjAwXCI7XG5leHBvcnRzLmxhd25ncmVlbiA9IFwiIzdDRkMwMFwiO1xuZXhwb3J0cy5saW1lID0gXCIjMDBGRjAwXCI7XG5leHBvcnRzLmxpbWVncmVlbiA9IFwiIzMyQ0QzMlwiO1xuZXhwb3J0cy5wYWxlZ3JlZW4gPSBcIiM5OEZCOThcIjtcbmV4cG9ydHMubGlnaHRncmVlbiA9IFwiIzkwRUU5MFwiO1xuZXhwb3J0cy5tZWRpdW1zcHJpbmdncmVlbiA9IFwiIzAwRkE5QVwiO1xuZXhwb3J0cy5zcHJpbmdncmVlbiA9IFwiIzAwRkY3RlwiO1xuZXhwb3J0cy5tZWRpdW1zZWFncmVlbiA9IFwiIzNDQjM3MVwiO1xuZXhwb3J0cy5zZWFncmVlbiA9IFwiIzJFOEI1N1wiO1xuZXhwb3J0cy5mb3Jlc3RncmVlbiA9IFwiIzIyOEIyMlwiO1xuZXhwb3J0cy5ncmVlbiA9IFwiIzAwODAwMFwiO1xuZXhwb3J0cy5kYXJrZ3JlZW4gPSBcIiMwMDY0MDBcIjtcbmV4cG9ydHMueWVsbG93Z3JlZW4gPSBcIiM5QUNEMzJcIjtcbmV4cG9ydHMub2xpdmVkcmFiID0gXCIjNkI4RTIzXCI7XG5leHBvcnRzLm9saXZlID0gXCIjODA4MDAwXCI7XG5leHBvcnRzLmRhcmtvbGl2ZWdyZWVuID0gXCIjNTU2QjJGXCI7XG5leHBvcnRzLm1lZGl1bWFxdWFtYXJpbmUgPSBcIiM2NkNEQUFcIjtcbmV4cG9ydHMuZGFya3NlYWdyZWVuID0gXCIjOEZCQzhGXCI7XG5leHBvcnRzLmxpZ2h0c2VhZ3JlZW4gPSBcIiMyMEIyQUFcIjtcbmV4cG9ydHMuZGFya2N5YW4gPSBcIiMwMDhCOEJcIjtcbmV4cG9ydHMudGVhbCA9IFwiIzAwODA4MFwiO1xuZXhwb3J0cy5hcXVhID0gXCIjMDBGRkZGXCI7XG5leHBvcnRzLmN5YW4gPSBcIiMwMEZGRkZcIjtcbmV4cG9ydHMubGlnaHRjeWFuID0gXCIjRTBGRkZGXCI7XG5leHBvcnRzLnBhbGV0dXJxdW9pc2UgPSBcIiNBRkVFRUVcIjtcbmV4cG9ydHMuYXF1YW1hcmluZSA9IFwiIzdGRkZENFwiO1xuZXhwb3J0cy50dXJxdW9pc2UgPSBcIiM0MEUwRDBcIjtcbmV4cG9ydHMubWVkaXVtdHVycXVvaXNlID0gXCIjNDhEMUNDXCI7XG5leHBvcnRzLmRhcmt0dXJxdW9pc2UgPSBcIiMwMENFRDFcIjtcbmV4cG9ydHMuY2FkZXRibHVlID0gXCIjNUY5RUEwXCI7XG5leHBvcnRzLnN0ZWVsYmx1ZSA9IFwiIzQ2ODJCNFwiO1xuZXhwb3J0cy5saWdodHN0ZWVsYmx1ZSA9IFwiI0IwQzRERVwiO1xuZXhwb3J0cy5wb3dkZXJibHVlID0gXCIjQjBFMEU2XCI7XG5leHBvcnRzLmxpZ2h0Ymx1ZSA9IFwiI0FERDhFNlwiO1xuZXhwb3J0cy5za3libHVlID0gXCIjODdDRUVCXCI7XG5leHBvcnRzLmxpZ2h0c2t5Ymx1ZSA9IFwiIzg3Q0VGQVwiO1xuZXhwb3J0cy5kZWVwc2t5Ymx1ZSA9IFwiIzAwQkZGRlwiO1xuZXhwb3J0cy5kb2RnZXJibHVlID0gXCIjMUU5MEZGXCI7XG5leHBvcnRzLmNvcm5mbG93ZXJibHVlID0gXCIjNjQ5NUVEXCI7XG5leHBvcnRzLnJveWFsYmx1ZSA9IFwiIzQxNjlFMVwiO1xuZXhwb3J0cy5ibHVlID0gXCIjMDAwMEZGXCI7XG5leHBvcnRzLm1lZGl1bWJsdWUgPSBcIiMwMDAwQ0RcIjtcbmV4cG9ydHMuZGFya2JsdWUgPSBcIiMwMDAwOEJcIjtcbmV4cG9ydHMubmF2eSA9IFwiIzAwMDA4MFwiO1xuZXhwb3J0cy5taWRuaWdodGJsdWUgPSBcIiMxOTE5NzBcIjtcbmV4cG9ydHMuY29ybnNpbGsgPSBcIiNGRkY4RENcIjtcbmV4cG9ydHMuYmxhbmNoZWRhbG1vbmQgPSBcIiNGRkVCQ0RcIjtcbmV4cG9ydHMuYmlzcXVlID0gXCIjRkZFNEM0XCI7XG5leHBvcnRzLm5hdmFqb3doaXRlID0gXCIjRkZERUFEXCI7XG5leHBvcnRzLndoZWF0ID0gXCIjRjVERUIzXCI7XG5leHBvcnRzLmJ1cmx5d29vZCA9IFwiI0RFQjg4N1wiO1xuZXhwb3J0cy50YW4gPSBcIiNEMkI0OENcIjtcbmV4cG9ydHMucm9zeWJyb3duID0gXCIjQkM4RjhGXCI7XG5leHBvcnRzLnNhbmR5YnJvd24gPSBcIiNGNEE0NjBcIjtcbmV4cG9ydHMuZ29sZGVucm9kID0gXCIjREFBNTIwXCI7XG5leHBvcnRzLmRhcmtnb2xkZW5yb2QgPSBcIiNCODg2MEJcIjtcbmV4cG9ydHMucGVydSA9IFwiI0NEODUzRlwiO1xuZXhwb3J0cy5jaG9jb2xhdGUgPSBcIiNEMjY5MUVcIjtcbmV4cG9ydHMuc2FkZGxlYnJvd24gPSBcIiM4QjQ1MTNcIjtcbmV4cG9ydHMuc2llbm5hID0gXCIjQTA1MjJEXCI7XG5leHBvcnRzLmJyb3duID0gXCIjQTUyQTJBXCI7XG5leHBvcnRzLm1hcm9vbiA9IFwiIzgwMDAwMFwiO1xuZXhwb3J0cy53aGl0ZSA9IFwiI0ZGRkZGRlwiO1xuZXhwb3J0cy5zbm93ID0gXCIjRkZGQUZBXCI7XG5leHBvcnRzLmhvbmV5ZGV3ID0gXCIjRjBGRkYwXCI7XG5leHBvcnRzLm1pbnRjcmVhbSA9IFwiI0Y1RkZGQVwiO1xuZXhwb3J0cy5henVyZSA9IFwiI0YwRkZGRlwiO1xuZXhwb3J0cy5hbGljZWJsdWUgPSBcIiNGMEY4RkZcIjtcbmV4cG9ydHMuZ2hvc3R3aGl0ZSA9IFwiI0Y4RjhGRlwiO1xuZXhwb3J0cy53aGl0ZXNtb2tlID0gXCIjRjVGNUY1XCI7XG5leHBvcnRzLnNlYXNoZWxsID0gXCIjRkZGNUVFXCI7XG5leHBvcnRzLmJlaWdlID0gXCIjRjVGNURDXCI7XG5leHBvcnRzLm9sZGxhY2UgPSBcIiNGREY1RTZcIjtcbmV4cG9ydHMuZmxvcmFsd2hpdGUgPSBcIiNGRkZBRjBcIjtcbmV4cG9ydHMuaXZvcnkgPSBcIiNGRkZGRjBcIjtcbmV4cG9ydHMuYW50aXF1ZXdoaXRlID0gXCIjRkFFQkQ3XCI7XG5leHBvcnRzLmxpbmVuID0gXCIjRkFGMEU2XCI7XG5leHBvcnRzLmxhdmVuZGVyYmx1c2ggPSBcIiNGRkYwRjVcIjtcbmV4cG9ydHMubWlzdHlyb3NlID0gXCIjRkZFNEUxXCI7XG5leHBvcnRzLmdhaW5zYm9ybyA9IFwiI0RDRENEQ1wiO1xuZXhwb3J0cy5saWdodGdyYXkgPSBcIiNEM0QzRDNcIjtcbmV4cG9ydHMubGlnaHRncmV5ID0gXCIjRDNEM0QzXCI7XG5leHBvcnRzLnNpbHZlciA9IFwiI0MwQzBDMFwiO1xuZXhwb3J0cy5kYXJrZ3JheSA9IFwiI0E5QTlBOVwiO1xuZXhwb3J0cy5kYXJrZ3JleSA9IFwiI0E5QTlBOVwiO1xuZXhwb3J0cy5ncmF5ID0gXCIjODA4MDgwXCI7XG5leHBvcnRzLmdyZXkgPSBcIiM4MDgwODBcIjtcbmV4cG9ydHMuZGltZ3JheSA9IFwiIzY5Njk2OVwiO1xuZXhwb3J0cy5kaW1ncmV5ID0gXCIjNjk2OTY5XCI7XG5leHBvcnRzLmxpZ2h0c2xhdGVncmF5ID0gXCIjNzc4ODk5XCI7XG5leHBvcnRzLmxpZ2h0c2xhdGVncmV5ID0gXCIjNzc4ODk5XCI7XG5leHBvcnRzLnNsYXRlZ3JheSA9IFwiIzcwODA5MFwiO1xuZXhwb3J0cy5zbGF0ZWdyZXkgPSBcIiM3MDgwOTBcIjtcbmV4cG9ydHMuZGFya3NsYXRlZ3JheSA9IFwiIzJGNEY0RlwiO1xuZXhwb3J0cy5kYXJrc2xhdGVncmV5ID0gXCIjMkY0RjRGXCI7XG5leHBvcnRzLmJsYWNrID0gXCIjMDAwMDAwXCI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfZm9ybWF0X251bWJlcjtcbnZhciBTUHJpbnRmID0gcmVxdWlyZShcInNwcmludGZcIik7XG52YXIgTnVtYnJvID0gcmVxdWlyZShcIm51bWJyb1wiKTtcbnZhciB0eiA9IHJlcXVpcmUoXCJ0aW1lem9uZVwiKTtcbnZhciBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ1wiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5fZm9ybWF0X251bWJlciA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICB2YXIgZm9ybWF0O1xuICAgIGlmICh0eXBlc18xLmlzTnVtYmVyKG51bWJlcikpIHtcbiAgICAgICAgZm9ybWF0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE1hdGguZmxvb3IobnVtYmVyKSAhPT0gbnVtYmVyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIlZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgIShNYXRoLmFicyhudW1iZXIpID4gMC4xICYmIE1hdGguYWJzKG51bWJlcikgPCAxMDAwKTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJTAuM2ZcIjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIlMC4zZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gU1ByaW50Zi5zcHJpbnRmKGZvcm1hdCwgbnVtYmVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgbnVtYmVyO1xuICAgIH1cbn07XG5leHBvcnRzLnJlcGxhY2VfcGxhY2Vob2xkZXJzID0gZnVuY3Rpb24gKHN0cmluZywgZGF0YV9zb3VyY2UsIGksIGZvcm1hdHRlcnMsIHNwZWNpYWxfdmFycykge1xuICAgIGlmIChzcGVjaWFsX3ZhcnMgPT0gbnVsbCkge1xuICAgICAgICBzcGVjaWFsX3ZhcnMgPSB7fTtcbiAgICB9XG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoLyhefFteXFwkXSlcXCQoXFx3KykvZywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoLCBwcmVmaXgsIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBcIkAkXCIgKyBuYW1lO1xuICAgICAgICB9O1xuICAgIH0pKHRoaXMpKTtcbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvKF58W15AXSlAKD86KFxcJD9cXHcrKXx7KFtee31dKyl9KSg/OnsoW157fV0rKX0pPy9nLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobWF0Y2gsIHByZWZpeCwgbmFtZSwgbG9uZ19uYW1lLCBmb3JtYXQpIHtcbiAgICAgICAgICAgIHZhciByZWYsIHJlcGxhY2VtZW50LCB2YWx1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBsb25nX25hbWUgIT0gbnVsbCA/IGxvbmdfbmFtZSA6IG5hbWU7XG4gICAgICAgICAgICB2YWx1ZSA9IG5hbWVbMF0gPT09IFwiJFwiID8gc3BlY2lhbF92YXJzW25hbWUuc3Vic3RyaW5nKDEpXSA6IChyZWYgPSBkYXRhX3NvdXJjZS5nZXRfY29sdW1uKG5hbWUpKSAhPSBudWxsID8gcmVmW2ldIDogdm9pZCAwO1xuICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IFwiPz8/XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnc2FmZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBwcmVmaXggKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChmb3JtYXR0ZXJzICE9IG51bGwpICYmIG5hbWUgaW4gZm9ybWF0dGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlcnNbbmFtZV0gPT09IFwibnVtZXJhbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBOdW1icm8uZm9ybWF0KHZhbHVlLCBmb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0dGVyc1tuYW1lXSA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSB0eih2YWx1ZSwgZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdHRlcnNbbmFtZV0gPT09IFwicHJpbnRmXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IFNQcmludGYoZm9ybWF0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRvb2x0aXAgZmllbGQgZm9ybWF0dGVyIHR5cGUgJ1wiICsgZm9ybWF0dGVyc1tuYW1lXSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gTnVtYnJvLmZvcm1hdCh2YWx1ZSwgZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBfZm9ybWF0X251bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50ID0gXCJcIiArIHByZWZpeCArIChzdHJpbmdfMS5lc2NhcGUocmVwbGFjZW1lbnQpKTtcbiAgICAgICAgfTtcbiAgICB9KSh0aGlzKSk7XG4gICAgcmV0dXJuIHN0cmluZztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjYWNoZTtcbnZhciBkb21fMSA9IHJlcXVpcmUoXCIuLi9kb21cIik7XG5jYWNoZSA9IHt9O1xuZXhwb3J0cy5nZXRfdGV4dF9oZWlnaHQgPSBmdW5jdGlvbiAoZm9udCkge1xuICAgIHZhciBibG9jaywgZWxlbSwgcmVzdWx0LCB0ZXh0O1xuICAgIGlmIChjYWNoZVtmb250XSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjYWNoZVtmb250XTtcbiAgICB9XG4gICAgdGV4dCA9IGRvbV8xLnNwYW4oe1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgZm9udDogZm9udFxuICAgICAgICB9XG4gICAgfSwgXCJIZ1wiKTtcbiAgICBibG9jayA9IGRvbV8xLmRpdih7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICAgICAgd2lkdGg6IFwiMXB4XCIsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiMHB4XCJcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGVsZW0gPSBkb21fMS5kaXYoe30sIHRleHQsIGJsb2NrKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW0pO1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICBibG9jay5zdHlsZS52ZXJ0aWNhbEFsaWduID0gXCJiYXNlbGluZVwiO1xuICAgICAgICByZXN1bHQuYXNjZW50ID0gZG9tXzEub2Zmc2V0KGJsb2NrKS50b3AgLSBkb21fMS5vZmZzZXQodGV4dCkudG9wO1xuICAgICAgICBibG9jay5zdHlsZS52ZXJ0aWNhbEFsaWduID0gXCJib3R0b21cIjtcbiAgICAgICAgcmVzdWx0LmhlaWdodCA9IGRvbV8xLm9mZnNldChibG9jaykudG9wIC0gZG9tXzEub2Zmc2V0KHRleHQpLnRvcDtcbiAgICAgICAgcmVzdWx0LmRlc2NlbnQgPSByZXN1bHQuaGVpZ2h0IC0gcmVzdWx0LmFzY2VudDtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gICAgfVxuICAgIGNhY2hlW2ZvbnRdID0gcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX2RlbGF5X2FuaW1hdGlvbiwgZGVsYXlfYW5pbWF0aW9uO1xuX2RlbGF5X2FuaW1hdGlvbiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYoKTtcbn07XG5kZWxheV9hbmltYXRpb24gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogdm9pZCAwKSB8fCAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwgPyB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogdm9pZCAwKSB8fCAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwgPyB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogdm9pZCAwKSB8fCAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwgPyB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiB2b2lkIDApIHx8IF9kZWxheV9hbmltYXRpb247XG5leHBvcnRzLnRocm90dGxlID0gZnVuY3Rpb24gKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncywgY29udGV4dCwgbGF0ZXIsIHBlbmRpbmcsIHByZXZpb3VzLCByZWYsIHJlc3VsdCwgdGltZW91dDtcbiAgICByZWYgPSBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sIGNvbnRleHQgPSByZWZbMF0sIGFyZ3MgPSByZWZbMV0sIHRpbWVvdXQgPSByZWZbMl0sIHJlc3VsdCA9IHJlZlszXTtcbiAgICBwcmV2aW91cyA9IDA7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIGxhdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBwcmV2aW91cyA9IG5ldyBEYXRlO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub3csIHJlbWFpbmluZztcbiAgICAgICAgbm93ID0gbmV3IERhdGU7XG4gICAgICAgIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwICYmICFwZW5kaW5nKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGF5X2FuaW1hdGlvbihsYXRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXQgJiYgIXBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGF5X2FuaW1hdGlvbihsYXRlcik7XG4gICAgICAgICAgICB9KSwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyAgICAgVW5kZXJzY29yZS5qcyAxLjguM1xuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IE51bWJlcl1cIjtcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBTdHJpbmddXCI7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5mdW5jdGlvbiBpc1N0cmljdE5hTihvYmopIHtcbiAgICByZXR1cm4gaXNOdW1iZXIob2JqKSAmJiBvYmogIT09ICtvYmo7XG59XG5leHBvcnRzLmlzU3RyaWN0TmFOID0gaXNTdHJpY3ROYU47XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBGdW5jdGlvbl1cIjtcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgdmFyIHRwID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHAgPT09ICdmdW5jdGlvbicgfHwgdHAgPT09ICdvYmplY3QnICYmICEhb2JqO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIGpRdWVyeSBNb3VzZXdoZWVsIDMuMS4xM1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZm9udFNpemUoZWxlbWVudCkge1xuICAgIHZhciB2YWx1ZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZm9udFNpemU7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbGluZUhlaWdodChlbGVtZW50KSB7XG4gICAgdmFyIHBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gICAgcmV0dXJuIGZvbnRTaXplKHBhcmVudCkgfHwgZm9udFNpemUoZWxlbWVudCkgfHwgMTY7XG59XG5mdW5jdGlvbiBwYWdlSGVpZ2h0KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGllbnRIZWlnaHQ7IC8vIFhYWDogc2hvdWxkIGJlIGNvbnRlbnQgaGVpZ2h0P1xufVxuZnVuY3Rpb24gZ2V0RGVsdGFZKGV2ZW50KSB7XG4gICAgdmFyIGRlbHRhWSA9IC1ldmVudC5kZWx0YVk7XG4gICAgaWYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQuZGVsdGFNb2RlKSB7XG4gICAgICAgICAgICBjYXNlIGV2ZW50LkRPTV9ERUxUQV9MSU5FOlxuICAgICAgICAgICAgICAgIGRlbHRhWSAqPSBsaW5lSGVpZ2h0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV2ZW50LkRPTV9ERUxUQV9QQUdFOlxuICAgICAgICAgICAgICAgIGRlbHRhWSAqPSBwYWdlSGVpZ2h0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlbHRhWTtcbn1cbmV4cG9ydHMuZ2V0RGVsdGFZID0gZ2V0RGVsdGFZO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbWF0aF8xID0gcmVxdWlyZShcIi4vbWF0aFwiKTtcbmV4cG9ydHMuc2NhbGVfaGlnaGxvdyA9IGZ1bmN0aW9uIChyYW5nZSwgZmFjdG9yLCBjZW50ZXIpIHtcbiAgICB2YXIgaGlnaCwgbG93LCByZWYsIHgsIHgwLCB4MTtcbiAgICBpZiAoY2VudGVyID09IG51bGwpIHtcbiAgICAgICAgY2VudGVyID0gbnVsbDtcbiAgICB9XG4gICAgcmVmID0gW3JhbmdlLnN0YXJ0LCByYW5nZS5lbmRdLCBsb3cgPSByZWZbMF0sIGhpZ2ggPSByZWZbMV07XG4gICAgeCA9IGNlbnRlciAhPSBudWxsID8gY2VudGVyIDogKGhpZ2ggKyBsb3cpIC8gMi4wO1xuICAgIHgwID0gbG93IC0gKGxvdyAtIHgpICogZmFjdG9yO1xuICAgIHgxID0gaGlnaCAtIChoaWdoIC0geCkgKiBmYWN0b3I7XG4gICAgcmV0dXJuIFt4MCwgeDFdO1xufTtcbmV4cG9ydHMuZ2V0X2luZm8gPSBmdW5jdGlvbiAoc2NhbGVzLCBhcmcpIHtcbiAgICB2YXIgZW5kLCBpbmZvLCBuYW1lLCByZWYsIHNjYWxlLCBzdGFydCwgeDAsIHgxO1xuICAgIHgwID0gYXJnWzBdLCB4MSA9IGFyZ1sxXTtcbiAgICBpbmZvID0ge307XG4gICAgZm9yIChuYW1lIGluIHNjYWxlcykge1xuICAgICAgICBzY2FsZSA9IHNjYWxlc1tuYW1lXTtcbiAgICAgICAgcmVmID0gc2NhbGUudl9pbnZlcnQoW3gwLCB4MV0sIHRydWUpLCBzdGFydCA9IHJlZlswXSwgZW5kID0gcmVmWzFdO1xuICAgICAgICBpbmZvW25hbWVdID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm87XG59O1xuZXhwb3J0cy5zY2FsZV9yYW5nZSA9IGZ1bmN0aW9uIChmcmFtZSwgZmFjdG9yLCBoX2F4aXMsIHZfYXhpcywgY2VudGVyKSB7XG4gICAgdmFyIGhmYWN0b3IsIHJlZiwgcmVmMSwgdmZhY3RvciwgdngwLCB2eDEsIHZ5MCwgdnkxLCB4cnMsIHlycztcbiAgICBpZiAoaF9heGlzID09IG51bGwpIHtcbiAgICAgICAgaF9heGlzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZfYXhpcyA9PSBudWxsKSB7XG4gICAgICAgIHZfYXhpcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjZW50ZXIgPT0gbnVsbCkge1xuICAgICAgICBjZW50ZXIgPSBudWxsO1xuICAgIH1cbiAgICBcIlV0aWxpdHkgZnVuY3Rpb24gZm9yIHpvb20gdG9vbHMgdG8gY2FsY3VsYXRlL2NyZWF0ZSB0aGUgem9vbV9pbmZvIG9iamVjdFxcbm9mIHRoZSBmb3JtIHJlcXVpcmVkIGJ5IGBgUGxvdENhbnZhc1ZpZXcudXBkYXRlX3JhbmdlYGBcXG5cXG5QYXJhbWV0ZXJzOlxcbiAgZnJhbWUgOiBDYXJ0ZXNpYW5GcmFtZVxcbiAgZmFjdG9yIDogTnVtYmVyXFxuICBoX2F4aXMgOiBCb29sZWFuLCBvcHRpb25hbFxcbiAgICB3aGV0aGVyIHRvIHpvb20gdGhlIGhvcml6b250YWwgYXhpcyAoZGVmYXVsdCA9IHRydWUpXFxuICB2X2F4aXMgOiBCb29sZWFuLCBvcHRpb25hbFxcbiAgICB3aGV0aGVyIHRvIHpvb20gdGhlIGhvcml6b250YWwgYXhpcyAoZGVmYXVsdCA9IHRydWUpXFxuICBjZW50ZXIgOiBvYmplY3QsIG9wdGlvbmFsXFxuICAgIG9mIGZvcm0geyd4JzogTnVtYmVyLCAneScsIE51bWJlcn1cXG5cXG5SZXR1cm5zOlxcbiAgb2JqZWN0OlwiO1xuICAgIGZhY3RvciA9IG1hdGhfMS5jbGFtcChmYWN0b3IsIC0wLjksIDAuOSk7XG4gICAgaGZhY3RvciA9IGhfYXhpcyA/IGZhY3RvciA6IDA7XG4gICAgcmVmID0gZXhwb3J0cy5zY2FsZV9oaWdobG93KGZyYW1lLmhfcmFuZ2UsIGhmYWN0b3IsIGNlbnRlciAhPSBudWxsID8gY2VudGVyLnggOiB2b2lkIDApLCB2eDAgPSByZWZbMF0sIHZ4MSA9IHJlZlsxXTtcbiAgICB4cnMgPSBleHBvcnRzLmdldF9pbmZvKGZyYW1lLnhzY2FsZXMsIFt2eDAsIHZ4MV0pO1xuICAgIHZmYWN0b3IgPSB2X2F4aXMgPyBmYWN0b3IgOiAwO1xuICAgIHJlZjEgPSBleHBvcnRzLnNjYWxlX2hpZ2hsb3coZnJhbWUudl9yYW5nZSwgdmZhY3RvciwgY2VudGVyICE9IG51bGwgPyBjZW50ZXIueSA6IHZvaWQgMCksIHZ5MCA9IHJlZjFbMF0sIHZ5MSA9IHJlZjFbMV07XG4gICAgeXJzID0gZXhwb3J0cy5nZXRfaW5mbyhmcmFtZS55c2NhbGVzLCBbdnkwLCB2eTFdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4cnM6IHhycyxcbiAgICAgICAgeXJzOiB5cnMsXG4gICAgICAgIGZhY3RvcjogZmFjdG9yXG4gICAgfTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgc2lnbmFsaW5nXzEgPSByZXF1aXJlKFwiLi9zaWduYWxpbmdcIik7XG52YXIgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi91dGlsL3N0cmluZ1wiKTtcbmV4cG9ydHMuVmlldyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZXh0ZW5kKFZpZXcucHJvdG90eXBlLCBzaWduYWxpbmdfMS5TaWduYWxhYmxlKTtcbiAgICBWaWV3LmdldHRlcnMgPSBmdW5jdGlvbiAoc3BlY3MpIHtcbiAgICAgICAgdmFyIGZuLCBuYW1lLCByZXN1bHRzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobmFtZSBpbiBzcGVjcykge1xuICAgICAgICAgICAgZm4gPSBzcGVjc1tuYW1lXTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZuXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBWaWV3KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlZCA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgXCJyZW1vdmVkXCIpO1xuICAgICAgICBpZiAob3B0aW9ucy5tb2RlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vZGVsIG9mIGEgdmlldyB3YXNuJ3QgY29uZmlndXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICAgICAgdGhpcy5pZCA9IChyZWYgPSBvcHRpb25zLmlkKSAhPSBudWxsID8gcmVmIDogc3RyaW5nXzEudW5pcXVlSWQoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgICBWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHsgfTtcbiAgICBWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0X3NpZ25hbHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlZC5lbWl0KCk7XG4gICAgfTtcbiAgICBWaWV3LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwudHlwZSArIFwiVmlldyhcIiArIHRoaXMuaWQgKyBcIilcIjtcbiAgICB9O1xuICAgIFZpZXcuZ2V0dGVycyh7XG4gICAgICAgIHBhcmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBhcmVudCBvZiBhIHZpZXcgd2Fzbid0IGNvbmZpZ3VyZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlzX3Jvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA9PT0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgcm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNfcm9vdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBWaWV3LnByb3RvdHlwZS5jb25uZWN0X3NpZ25hbHMgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgVmlldy5wcm90b3R5cGUuZGlzY29ubmVjdF9zaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2lnbmFsaW5nXzEuU2lnbmFsLmRpc2Nvbm5lY3RSZWNlaXZlcih0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBWaWV3O1xufSkoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENvbnRleHRQcm9wZXJ0aWVzLCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgbWl4aW5zID0gcmVxdWlyZShcIi4vcHJvcGVydHlfbWl4aW5zXCIpO1xudmFyIGNvbG9yXzEgPSByZXF1aXJlKFwiLi91dGlsL2NvbG9yXCIpO1xuQ29udGV4dFByb3BlcnRpZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnRleHRQcm9wZXJ0aWVzKG9iaiwgcHJlZml4KSB7XG4gICAgICAgIHZhciBhdHRyLCBkb19zcGVjLCBqLCBsZW4sIHJlZjtcbiAgICAgICAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmVmaXggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgICAgICBkb19zcGVjID0gb2JqLnByb3BlcnRpZXNbcHJlZml4ICsgdGhpcy5kb19hdHRyXS5zcGVjO1xuICAgICAgICB0aGlzLmRvaXQgPSBkb19zcGVjLnZhbHVlICE9PSBudWxsO1xuICAgICAgICByZWYgPSB0aGlzLmF0dHJzO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGF0dHIgPSByZWZbal07XG4gICAgICAgICAgICB0aGlzW2F0dHJdID0gb2JqLnByb3BlcnRpZXNbcHJlZml4ICsgYXR0cl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ29udGV4dFByb3BlcnRpZXMucHJvdG90eXBlLndhcm1fY2FjaGUgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBhdHRyLCBqLCBsZW4sIHByb3AsIHJlZiwgcmVzdWx0cztcbiAgICAgICAgcmVmID0gdGhpcy5hdHRycztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGF0dHIgPSByZWZbal07XG4gICAgICAgICAgICBwcm9wID0gdGhpcy5vYmoucHJvcGVydGllc1t0aGlzLnByZWZpeCArIGF0dHJdO1xuICAgICAgICAgICAgaWYgKHByb3Auc3BlYy52YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuY2FjaGVbYXR0cl0gPSBwcm9wLnNwZWMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuY2FjaGVbYXR0ciArIFwiX2FycmF5XCJdID0gcHJvcC5hcnJheShzb3VyY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIENvbnRleHRQcm9wZXJ0aWVzLnByb3RvdHlwZS5jYWNoZV9zZWxlY3QgPSBmdW5jdGlvbiAoYXR0ciwgaSkge1xuICAgICAgICB2YXIgcHJvcDtcbiAgICAgICAgcHJvcCA9IHRoaXMub2JqLnByb3BlcnRpZXNbdGhpcy5wcmVmaXggKyBhdHRyXTtcbiAgICAgICAgaWYgKHByb3Auc3BlYy52YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVthdHRyXSA9IHByb3Auc3BlYy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlW2F0dHJdID0gdGhpcy5jYWNoZVthdHRyICsgXCJfYXJyYXlcIl1baV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb250ZXh0UHJvcGVydGllcztcbn0pKCk7XG5leHBvcnRzLkxpbmUgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTGluZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGluZSgpIHtcbiAgICAgICAgcmV0dXJuIExpbmUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExpbmUucHJvdG90eXBlLmF0dHJzID0gT2JqZWN0LmtleXMobWl4aW5zLmxpbmUoKSk7XG4gICAgTGluZS5wcm90b3R5cGUuZG9fYXR0ciA9IFwibGluZV9jb2xvclwiO1xuICAgIExpbmUucHJvdG90eXBlLnNldF92YWx1ZSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5saW5lX2NvbG9yLnZhbHVlKCk7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMubGluZV9hbHBoYS52YWx1ZSgpO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lX3dpZHRoLnZhbHVlKCk7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IHRoaXMubGluZV9qb2luLnZhbHVlKCk7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gdGhpcy5saW5lX2NhcC52YWx1ZSgpO1xuICAgICAgICBjdHguc2V0TGluZURhc2godGhpcy5saW5lX2Rhc2gudmFsdWUoKSk7XG4gICAgICAgIHJldHVybiBjdHguc2V0TGluZURhc2hPZmZzZXQodGhpcy5saW5lX2Rhc2hfb2Zmc2V0LnZhbHVlKCkpO1xuICAgIH07XG4gICAgTGluZS5wcm90b3R5cGUuc2V0X3ZlY3Rvcml6ZSA9IGZ1bmN0aW9uIChjdHgsIGkpIHtcbiAgICAgICAgdGhpcy5jYWNoZV9zZWxlY3QoXCJsaW5lX2NvbG9yXCIsIGkpO1xuICAgICAgICBpZiAoY3R4LnN0cm9rZVN0eWxlICE9PSB0aGlzLmNhY2hlLmxpbmVfY29sb3IpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY2FjaGUubGluZV9jb2xvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlX3NlbGVjdChcImxpbmVfYWxwaGFcIiwgaSk7XG4gICAgICAgIGlmIChjdHguZ2xvYmFsQWxwaGEgIT09IHRoaXMuY2FjaGUubGluZV9hbHBoYSkge1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jYWNoZS5saW5lX2FscGhhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVfc2VsZWN0KFwibGluZV93aWR0aFwiLCBpKTtcbiAgICAgICAgaWYgKGN0eC5saW5lV2lkdGggIT09IHRoaXMuY2FjaGUubGluZV93aWR0aCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuY2FjaGUubGluZV93aWR0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlX3NlbGVjdChcImxpbmVfam9pblwiLCBpKTtcbiAgICAgICAgaWYgKGN0eC5saW5lSm9pbiAhPT0gdGhpcy5jYWNoZS5saW5lX2pvaW4pIHtcbiAgICAgICAgICAgIGN0eC5saW5lSm9pbiA9IHRoaXMuY2FjaGUubGluZV9qb2luO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVfc2VsZWN0KFwibGluZV9jYXBcIiwgaSk7XG4gICAgICAgIGlmIChjdHgubGluZUNhcCAhPT0gdGhpcy5jYWNoZS5saW5lX2NhcCkge1xuICAgICAgICAgICAgY3R4LmxpbmVDYXAgPSB0aGlzLmNhY2hlLmxpbmVfY2FwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVfc2VsZWN0KFwibGluZV9kYXNoXCIsIGkpO1xuICAgICAgICBpZiAoY3R4LmdldExpbmVEYXNoKCkgIT09IHRoaXMuY2FjaGUubGluZV9kYXNoKSB7XG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2godGhpcy5jYWNoZS5saW5lX2Rhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVfc2VsZWN0KFwibGluZV9kYXNoX29mZnNldFwiLCBpKTtcbiAgICAgICAgaWYgKGN0eC5nZXRMaW5lRGFzaE9mZnNldCgpICE9PSB0aGlzLmNhY2hlLmxpbmVfZGFzaF9vZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHguc2V0TGluZURhc2hPZmZzZXQodGhpcy5jYWNoZS5saW5lX2Rhc2hfb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluZS5wcm90b3R5cGUuY29sb3JfdmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2xvcjtcbiAgICAgICAgY29sb3IgPSBjb2xvcl8xLmNvbG9yMnJnYmEodGhpcy5saW5lX2NvbG9yLnZhbHVlKCksIHRoaXMubGluZV9hbHBoYS52YWx1ZSgpKTtcbiAgICAgICAgcmV0dXJuIFwicmdiYShcIiArIChjb2xvclswXSAqIDI1NSkgKyBcIixcIiArIChjb2xvclsxXSAqIDI1NSkgKyBcIixcIiArIChjb2xvclsyXSAqIDI1NSkgKyBcIixcIiArIGNvbG9yWzNdICsgXCIpXCI7XG4gICAgfTtcbiAgICByZXR1cm4gTGluZTtcbn0pKENvbnRleHRQcm9wZXJ0aWVzKTtcbmV4cG9ydHMuRmlsbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChGaWxsLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBGaWxsKCkge1xuICAgICAgICByZXR1cm4gRmlsbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRmlsbC5wcm90b3R5cGUuYXR0cnMgPSBPYmplY3Qua2V5cyhtaXhpbnMuZmlsbCgpKTtcbiAgICBGaWxsLnByb3RvdHlwZS5kb19hdHRyID0gXCJmaWxsX2NvbG9yXCI7XG4gICAgRmlsbC5wcm90b3R5cGUuc2V0X3ZhbHVlID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsX2NvbG9yLnZhbHVlKCk7XG4gICAgICAgIHJldHVybiBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmZpbGxfYWxwaGEudmFsdWUoKTtcbiAgICB9O1xuICAgIEZpbGwucHJvdG90eXBlLnNldF92ZWN0b3JpemUgPSBmdW5jdGlvbiAoY3R4LCBpKSB7XG4gICAgICAgIHRoaXMuY2FjaGVfc2VsZWN0KFwiZmlsbF9jb2xvclwiLCBpKTtcbiAgICAgICAgaWYgKGN0eC5maWxsU3R5bGUgIT09IHRoaXMuY2FjaGUuZmlsbF9jb2xvcikge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY2FjaGUuZmlsbF9jb2xvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlX3NlbGVjdChcImZpbGxfYWxwaGFcIiwgaSk7XG4gICAgICAgIGlmIChjdHguZ2xvYmFsQWxwaGEgIT09IHRoaXMuY2FjaGUuZmlsbF9hbHBoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY2FjaGUuZmlsbF9hbHBoYTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlsbC5wcm90b3R5cGUuY29sb3JfdmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2xvcjtcbiAgICAgICAgY29sb3IgPSBjb2xvcl8xLmNvbG9yMnJnYmEodGhpcy5maWxsX2NvbG9yLnZhbHVlKCksIHRoaXMuZmlsbF9hbHBoYS52YWx1ZSgpKTtcbiAgICAgICAgcmV0dXJuIFwicmdiYShcIiArIChjb2xvclswXSAqIDI1NSkgKyBcIixcIiArIChjb2xvclsxXSAqIDI1NSkgKyBcIixcIiArIChjb2xvclsyXSAqIDI1NSkgKyBcIixcIiArIGNvbG9yWzNdICsgXCIpXCI7XG4gICAgfTtcbiAgICByZXR1cm4gRmlsbDtcbn0pKENvbnRleHRQcm9wZXJ0aWVzKTtcbmV4cG9ydHMuVGV4dCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUZXh0LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUZXh0KCkge1xuICAgICAgICByZXR1cm4gVGV4dC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGV4dC5wcm90b3R5cGUuYXR0cnMgPSBPYmplY3Qua2V5cyhtaXhpbnMudGV4dCgpKTtcbiAgICBUZXh0LnByb3RvdHlwZS5kb19hdHRyID0gXCJ0ZXh0X2NvbG9yXCI7XG4gICAgVGV4dC5wcm90b3R5cGUuY2FjaGVfc2VsZWN0ID0gZnVuY3Rpb24gKG5hbWUsIGkpIHtcbiAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgaWYgKG5hbWUgPT09IFwiZm9udFwiKSB7XG4gICAgICAgICAgICB2YWwgPSBUZXh0Ll9fc3VwZXJfXy5jYWNoZV9zZWxlY3QuY2FsbCh0aGlzLCBcInRleHRfZm9udF9zdHlsZVwiLCBpKSArIFwiIFwiICsgVGV4dC5fX3N1cGVyX18uY2FjaGVfc2VsZWN0LmNhbGwodGhpcywgXCJ0ZXh0X2ZvbnRfc2l6ZVwiLCBpKSArIFwiIFwiICsgVGV4dC5fX3N1cGVyX18uY2FjaGVfc2VsZWN0LmNhbGwodGhpcywgXCJ0ZXh0X2ZvbnRcIiwgaSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5mb250ID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFRleHQuX19zdXBlcl9fLmNhY2hlX3NlbGVjdC5jYWxsKHRoaXMsIG5hbWUsIGkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS5mb250X3ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZm9udCwgZm9udF9zaXplLCBmb250X3N0eWxlO1xuICAgICAgICBmb250ID0gdGhpcy50ZXh0X2ZvbnQudmFsdWUoKTtcbiAgICAgICAgZm9udF9zaXplID0gdGhpcy50ZXh0X2ZvbnRfc2l6ZS52YWx1ZSgpO1xuICAgICAgICBmb250X3N0eWxlID0gdGhpcy50ZXh0X2ZvbnRfc3R5bGUudmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIGZvbnRfc3R5bGUgKyBcIiBcIiArIGZvbnRfc2l6ZSArIFwiIFwiICsgZm9udDtcbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLmNvbG9yX3ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29sb3I7XG4gICAgICAgIGNvbG9yID0gY29sb3JfMS5jb2xvcjJyZ2JhKHRoaXMudGV4dF9jb2xvci52YWx1ZSgpLCB0aGlzLnRleHRfYWxwaGEudmFsdWUoKSk7XG4gICAgICAgIHJldHVybiBcInJnYmEoXCIgKyAoY29sb3JbMF0gKiAyNTUpICsgXCIsXCIgKyAoY29sb3JbMV0gKiAyNTUpICsgXCIsXCIgKyAoY29sb3JbMl0gKiAyNTUpICsgXCIsXCIgKyBjb2xvclszXSArIFwiKVwiO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuc2V0X3ZhbHVlID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICBjdHguZm9udCA9IHRoaXMuZm9udF92YWx1ZSgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy50ZXh0X2NvbG9yLnZhbHVlKCk7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMudGV4dF9hbHBoYS52YWx1ZSgpO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gdGhpcy50ZXh0X2FsaWduLnZhbHVlKCk7XG4gICAgICAgIHJldHVybiBjdHgudGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0X2Jhc2VsaW5lLnZhbHVlKCk7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS5zZXRfdmVjdG9yaXplID0gZnVuY3Rpb24gKGN0eCwgaSkge1xuICAgICAgICB0aGlzLmNhY2hlX3NlbGVjdChcImZvbnRcIiwgaSk7XG4gICAgICAgIGlmIChjdHguZm9udCAhPT0gdGhpcy5jYWNoZS5mb250KSB7XG4gICAgICAgICAgICBjdHguZm9udCA9IHRoaXMuY2FjaGUuZm9udDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlX3NlbGVjdChcInRleHRfY29sb3JcIiwgaSk7XG4gICAgICAgIGlmIChjdHguZmlsbFN0eWxlICE9PSB0aGlzLmNhY2hlLnRleHRfY29sb3IpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNhY2hlLnRleHRfY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZV9zZWxlY3QoXCJ0ZXh0X2FscGhhXCIsIGkpO1xuICAgICAgICBpZiAoY3R4Lmdsb2JhbEFscGhhICE9PSB0aGlzLmNhY2hlLnRleHRfYWxwaGEpIHtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY2FjaGUudGV4dF9hbHBoYTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlX3NlbGVjdChcInRleHRfYWxpZ25cIiwgaSk7XG4gICAgICAgIGlmIChjdHgudGV4dEFsaWduICE9PSB0aGlzLmNhY2hlLnRleHRfYWxpZ24pIHtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0aGlzLmNhY2hlLnRleHRfYWxpZ247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZV9zZWxlY3QoXCJ0ZXh0X2Jhc2VsaW5lXCIsIGkpO1xuICAgICAgICBpZiAoY3R4LnRleHRCYXNlbGluZSAhPT0gdGhpcy5jYWNoZS50ZXh0X2Jhc2VsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4LnRleHRCYXNlbGluZSA9IHRoaXMuY2FjaGUudGV4dF9iYXNlbGluZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRleHQ7XG59KShDb250ZXh0UHJvcGVydGllcyk7XG5leHBvcnRzLlZpc3VhbHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpc3VhbHMobW9kZWwpIHtcbiAgICAgICAgdmFyIGNscywgaiwgbGVuLCBuYW1lLCBwcmVmaXgsIHJlZiwgcmVmMSwgcmVmMiwgc3BlYztcbiAgICAgICAgcmVmID0gbW9kZWwubWl4aW5zO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHNwZWMgPSByZWZbal07XG4gICAgICAgICAgICByZWYxID0gc3BlYy5zcGxpdChcIjpcIiksIG5hbWUgPSByZWYxWzBdLCBwcmVmaXggPSAocmVmMiA9IHJlZjFbMV0pICE9IG51bGwgPyByZWYyIDogXCJcIjtcbiAgICAgICAgICAgIGNscyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsaW5lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5MaW5lO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmlsbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuRmlsbDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHRoaXNbcHJlZml4ICsgbmFtZV0gPSBuZXcgY2xzKG1vZGVsLCBwcmVmaXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFZpc3VhbHMucHJvdG90eXBlLndhcm1fY2FjaGUgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBuYW1lLCBwcm9wLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIHJlZiA9IHRoaXM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBuYW1lKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHByb3AgPSByZWZbbmFtZV07XG4gICAgICAgICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIENvbnRleHRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHByb3Aud2FybV9jYWNoZShzb3VyY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgcmV0dXJuIFZpc3VhbHM7XG59KSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRXZlbnRNYW5hZ2VyLCBleHRlbmQxID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKVxuICAgICAgICByZXR1cm4gaTtcbn0gcmV0dXJuIC0xOyB9O1xudmFyIGJhc2VfMSA9IHJlcXVpcmUoXCIuL2Jhc2VcIik7XG52YXIgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9jb3JlL2xvZ2dpbmdcIik7XG52YXIgaGFzX3Byb3BzXzEgPSByZXF1aXJlKFwiLi9jb3JlL2hhc19wcm9wc1wiKTtcbnZhciBzaWduYWxpbmdfMSA9IHJlcXVpcmUoXCIuL2NvcmUvc2lnbmFsaW5nXCIpO1xudmFyIHJlZnNfMSA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbC9yZWZzXCIpO1xudmFyIHNlcmlhbGl6YXRpb25fMSA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbC9zZXJpYWxpemF0aW9uXCIpO1xudmFyIGRhdGFfc3RydWN0dXJlc18xID0gcmVxdWlyZShcIi4vY29yZS91dGlsL2RhdGFfc3RydWN0dXJlc1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcIi4vY29yZS91dGlsL2FycmF5XCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcIi4vY29yZS91dGlsL29iamVjdFwiKTtcbnZhciBlcV8xID0gcmVxdWlyZShcIi4vY29yZS91dGlsL2VxXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWwvdHlwZXNcIik7XG52YXIgbGF5b3V0X2RvbV8xID0gcmVxdWlyZShcIi4vbW9kZWxzL2xheW91dHMvbGF5b3V0X2RvbVwiKTtcbnZhciBjb2x1bW5fZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuL21vZGVscy9zb3VyY2VzL2NvbHVtbl9kYXRhX3NvdXJjZVwiKTtcbkV2ZW50TWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRNYW5hZ2VyKGRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkX21vZGVscyA9IG5ldyBkYXRhX3N0cnVjdHVyZXNfMS5TZXQoKTtcbiAgICB9XG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5zZW5kX2V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciByZWYxO1xuICAgICAgICByZXR1cm4gKHJlZjEgPSB0aGlzLnNlc3Npb24pICE9IG51bGwgPyByZWYxLnNlbmRfZXZlbnQoZXZlbnQpIDogdm9pZCAwO1xuICAgIH07XG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBqLCBsZW4sIG1vZGVsLCBtb2RlbF9pZCwgcmVmMSwgcmVzdWx0cztcbiAgICAgICAgcmVmMSA9IHRoaXMuc3Vic2NyaWJlZF9tb2RlbHMudmFsdWVzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZjEubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIG1vZGVsX2lkID0gcmVmMVtqXTtcbiAgICAgICAgICAgIGlmIChldmVudC5tb2RlbF9pZCAhPT0gbnVsbCAmJiBldmVudC5tb2RlbF9pZCAhPT0gbW9kZWxfaWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZGVsID0gdGhpcy5kb2N1bWVudC5fYWxsX21vZGVsc1ttb2RlbF9pZF07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobW9kZWwgIT0gbnVsbCA/IG1vZGVsLl9wcm9jZXNzX2V2ZW50KGV2ZW50KSA6IHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRNYW5hZ2VyO1xufSkoKTtcbmV4cG9ydHMuRG9jdW1lbnRDaGFuZ2VkRXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvY3VtZW50Q2hhbmdlZEV2ZW50KGRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB9XG4gICAgcmV0dXJuIERvY3VtZW50Q2hhbmdlZEV2ZW50O1xufSkoKTtcbmV4cG9ydHMuTW9kZWxDaGFuZ2VkRXZlbnQgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKE1vZGVsQ2hhbmdlZEV2ZW50LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBNb2RlbENoYW5nZWRFdmVudChkb2N1bWVudCwgbW9kZWwxLCBhdHRyMSwgb2xkMSwgbmV3XzEsIHNldHRlcl9pZDEpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWwxO1xuICAgICAgICB0aGlzLmF0dHIgPSBhdHRyMTtcbiAgICAgICAgdGhpcy5vbGQgPSBvbGQxO1xuICAgICAgICB0aGlzLm5ld18gPSBuZXdfMTtcbiAgICAgICAgdGhpcy5zZXR0ZXJfaWQgPSBzZXR0ZXJfaWQxO1xuICAgICAgICBNb2RlbENoYW5nZWRFdmVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCB0aGlzLmRvY3VtZW50KTtcbiAgICB9XG4gICAgTW9kZWxDaGFuZ2VkRXZlbnQucHJvdG90eXBlLmpzb24gPSBmdW5jdGlvbiAocmVmZXJlbmNlcykge1xuICAgICAgICB2YXIgaWQsIHZhbHVlLCB2YWx1ZV9qc29uLCB2YWx1ZV9yZWZzO1xuICAgICAgICBpZiAodGhpcy5hdHRyID09PSAnaWQnKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCInaWQnIGZpZWxkIGlzIGltbXV0YWJsZSBhbmQgc2hvdWxkIG5ldmVyIGJlIGluIGEgTW9kZWxDaGFuZ2VkRXZlbnQgXCIsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2lkJyBmaWVsZCBzaG91bGQgbmV2ZXIgY2hhbmdlLCB3aGF0ZXZlciBjb2RlIGp1c3Qgc2V0IGl0IGlzIHdyb25nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdGhpcy5uZXdfO1xuICAgICAgICB2YWx1ZV9qc29uID0gdGhpcy5tb2RlbC5jb25zdHJ1Y3Rvci5fdmFsdWVfdG9fanNvbih0aGlzLmF0dHIsIHZhbHVlLCB0aGlzLm1vZGVsKTtcbiAgICAgICAgdmFsdWVfcmVmcyA9IHt9O1xuICAgICAgICBoYXNfcHJvcHNfMS5IYXNQcm9wcy5fdmFsdWVfcmVjb3JkX3JlZmVyZW5jZXModmFsdWUsIHZhbHVlX3JlZnMsIHRydWUpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5pZCBpbiB2YWx1ZV9yZWZzICYmIHRoaXMubW9kZWwgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBkZWxldGUgdmFsdWVfcmVmc1t0aGlzLm1vZGVsLmlkXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGlkIGluIHZhbHVlX3JlZnMpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXNbaWRdID0gdmFsdWVfcmVmc1tpZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdraW5kJzogJ01vZGVsQ2hhbmdlZCcsXG4gICAgICAgICAgICAnbW9kZWwnOiB0aGlzLm1vZGVsLnJlZigpLFxuICAgICAgICAgICAgJ2F0dHInOiB0aGlzLmF0dHIsXG4gICAgICAgICAgICAnbmV3JzogdmFsdWVfanNvblxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIE1vZGVsQ2hhbmdlZEV2ZW50O1xufSkoZXhwb3J0cy5Eb2N1bWVudENoYW5nZWRFdmVudCk7XG5leHBvcnRzLlRpdGxlQ2hhbmdlZEV2ZW50ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShUaXRsZUNoYW5nZWRFdmVudCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVGl0bGVDaGFuZ2VkRXZlbnQoZG9jdW1lbnQsIHRpdGxlMSwgc2V0dGVyX2lkMSkge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZTE7XG4gICAgICAgIHRoaXMuc2V0dGVyX2lkID0gc2V0dGVyX2lkMTtcbiAgICAgICAgVGl0bGVDaGFuZ2VkRXZlbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgdGhpcy5kb2N1bWVudCk7XG4gICAgfVxuICAgIFRpdGxlQ2hhbmdlZEV2ZW50LnByb3RvdHlwZS5qc29uID0gZnVuY3Rpb24gKHJlZmVyZW5jZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdraW5kJzogJ1RpdGxlQ2hhbmdlZCcsXG4gICAgICAgICAgICAndGl0bGUnOiB0aGlzLnRpdGxlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGl0bGVDaGFuZ2VkRXZlbnQ7XG59KShleHBvcnRzLkRvY3VtZW50Q2hhbmdlZEV2ZW50KTtcbmV4cG9ydHMuUm9vdEFkZGVkRXZlbnQgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKFJvb3RBZGRlZEV2ZW50LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBSb290QWRkZWRFdmVudChkb2N1bWVudCwgbW9kZWwxLCBzZXR0ZXJfaWQxKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsMTtcbiAgICAgICAgdGhpcy5zZXR0ZXJfaWQgPSBzZXR0ZXJfaWQxO1xuICAgICAgICBSb290QWRkZWRFdmVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCB0aGlzLmRvY3VtZW50KTtcbiAgICB9XG4gICAgUm9vdEFkZGVkRXZlbnQucHJvdG90eXBlLmpzb24gPSBmdW5jdGlvbiAocmVmZXJlbmNlcykge1xuICAgICAgICBoYXNfcHJvcHNfMS5IYXNQcm9wcy5fdmFsdWVfcmVjb3JkX3JlZmVyZW5jZXModGhpcy5tb2RlbCwgcmVmZXJlbmNlcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAna2luZCc6ICdSb290QWRkZWQnLFxuICAgICAgICAgICAgJ21vZGVsJzogdGhpcy5tb2RlbC5yZWYoKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFJvb3RBZGRlZEV2ZW50O1xufSkoZXhwb3J0cy5Eb2N1bWVudENoYW5nZWRFdmVudCk7XG5leHBvcnRzLlJvb3RSZW1vdmVkRXZlbnQgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKFJvb3RSZW1vdmVkRXZlbnQsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFJvb3RSZW1vdmVkRXZlbnQoZG9jdW1lbnQsIG1vZGVsMSwgc2V0dGVyX2lkMSkge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDE7XG4gICAgICAgIHRoaXMuc2V0dGVyX2lkID0gc2V0dGVyX2lkMTtcbiAgICAgICAgUm9vdFJlbW92ZWRFdmVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCB0aGlzLmRvY3VtZW50KTtcbiAgICB9XG4gICAgUm9vdFJlbW92ZWRFdmVudC5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uIChyZWZlcmVuY2VzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAna2luZCc6ICdSb290UmVtb3ZlZCcsXG4gICAgICAgICAgICAnbW9kZWwnOiB0aGlzLm1vZGVsLnJlZigpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gUm9vdFJlbW92ZWRFdmVudDtcbn0pKGV4cG9ydHMuRG9jdW1lbnRDaGFuZ2VkRXZlbnQpO1xuZXhwb3J0cy5kb2N1bWVudHMgPSBbXTtcbmV4cG9ydHMuREVGQVVMVF9USVRMRSA9IFwiQm9rZWggQXBwbGljYXRpb25cIjtcbmV4cG9ydHMuRG9jdW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvY3VtZW50KCkge1xuICAgICAgICBleHBvcnRzLmRvY3VtZW50cy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLl90aXRsZSA9IGV4cG9ydHMuREVGQVVMVF9USVRMRTtcbiAgICAgICAgdGhpcy5fcm9vdHMgPSBbXTtcbiAgICAgICAgdGhpcy5fYWxsX21vZGVscyA9IHt9O1xuICAgICAgICB0aGlzLl9hbGxfbW9kZWxzX2J5X25hbWUgPSBuZXcgZGF0YV9zdHJ1Y3R1cmVzXzEuTXVsdGlEaWN0KCk7XG4gICAgICAgIHRoaXMuX2FsbF9tb2RlbHNfZnJlZXplX2NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuZXZlbnRfbWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIodGhpcyk7XG4gICAgICAgIHRoaXMuaWRsZSA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgXCJpZGxlXCIpO1xuICAgICAgICB0aGlzLl9pZGxlX3Jvb3RzID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY3VtZW50LnByb3RvdHlwZSwgXCJsYXlvdXRhYmxlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGosIGxlbiwgcmVmMSwgcmVzdWx0cywgcm9vdDtcbiAgICAgICAgICAgIHJlZjEgPSB0aGlzLl9yb290cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZjEubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICByb290ID0gcmVmMVtqXTtcbiAgICAgICAgICAgICAgICBpZiAocm9vdCBpbnN0YW5jZW9mIGxheW91dF9kb21fMS5MYXlvdXRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJvb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY3VtZW50LnByb3RvdHlwZSwgXCJpc19pZGxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaiwgbGVuLCByZWYxLCByb290O1xuICAgICAgICAgICAgcmVmMSA9IHRoaXMubGF5b3V0YWJsZXM7XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm9vdCA9IHJlZjFbal07XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pZGxlX3Jvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUubm90aWZ5X2lkbGUgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdGhpcy5faWRsZV9yb290cy5zZXQobW9kZWwsIHRydWUpO1xuICAgICAgICBpZiAodGhpcy5pc19pZGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZGxlLmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0cztcbiAgICAgICAgdGhpcy5fcHVzaF9hbGxfbW9kZWxzX2ZyZWV6ZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3Jvb3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5yZW1vdmVfcm9vdCh0aGlzLl9yb290c1swXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9wb3BfYWxsX21vZGVsc19mcmVlemUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmRlc3RydWN0aXZlbHlfbW92ZSA9IGZ1bmN0aW9uIChkZXN0X2RvYykge1xuICAgICAgICB2YXIgaiwgbCwgbGVuLCBsZW4xLCBsZW4yLCBuLCByLCByZWYxLCByb290cztcbiAgICAgICAgaWYgKGRlc3RfZG9jID09PSB0aGlzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gb3ZlcndyaXRlIGEgZG9jdW1lbnQgd2l0aCBpdHNlbGZcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdF9kb2MuY2xlYXIoKTtcbiAgICAgICAgcm9vdHMgPSBbXTtcbiAgICAgICAgcmVmMSA9IHRoaXMuX3Jvb3RzO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByID0gcmVmMVtqXTtcbiAgICAgICAgICAgIHJvb3RzLnB1c2gocik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICBmb3IgKGwgPSAwLCBsZW4xID0gcm9vdHMubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICByID0gcm9vdHNbbF07XG4gICAgICAgICAgICBpZiAoci5kb2N1bWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNvbWVob3cgd2UgZGlkbid0IGRldGFjaCBcIiArIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9hbGxfbW9kZWxzKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBfYWxsX21vZGVscyBzdGlsbCBoYWQgc3R1ZmYgaW4gaXQ6IFwiICsgdGhpcy5fYWxsX21vZGVscyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChuID0gMCwgbGVuMiA9IHJvb3RzLmxlbmd0aDsgbiA8IGxlbjI7IG4rKykge1xuICAgICAgICAgICAgciA9IHJvb3RzW25dO1xuICAgICAgICAgICAgZGVzdF9kb2MuYWRkX3Jvb3Qocik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3RfZG9jLnNldF90aXRsZSh0aGlzLl90aXRsZSk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuX3B1c2hfYWxsX21vZGVsc19mcmVlemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGxfbW9kZWxzX2ZyZWV6ZV9jb3VudCArPSAxO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLl9wb3BfYWxsX21vZGVsc19mcmVlemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2FsbF9tb2RlbHNfZnJlZXplX2NvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLl9hbGxfbW9kZWxzX2ZyZWV6ZV9jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29tcHV0ZV9hbGxfbW9kZWxzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5faW52YWxpZGF0ZV9hbGxfbW9kZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiaW52YWxpZGF0aW5nIGRvY3VtZW50IG1vZGVsc1wiKTtcbiAgICAgICAgaWYgKHRoaXMuX2FsbF9tb2RlbHNfZnJlZXplX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjb21wdXRlX2FsbF9tb2RlbHMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLl9yZWNvbXB1dGVfYWxsX21vZGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEsIGQsIGosIGwsIGxlbiwgbGVuMSwgbGVuMiwgbGVuMywgbSwgbiwgbmFtZSwgbmV3X2FsbF9tb2RlbHNfc2V0LCBvLCBvbGRfYWxsX21vZGVsc19zZXQsIHIsIHJlY29tcHV0ZWQsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHRvX2F0dGFjaCwgdG9fZGV0YWNoO1xuICAgICAgICBuZXdfYWxsX21vZGVsc19zZXQgPSBuZXcgZGF0YV9zdHJ1Y3R1cmVzXzEuU2V0KCk7XG4gICAgICAgIHJlZjEgPSB0aGlzLl9yb290cztcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgciA9IHJlZjFbal07XG4gICAgICAgICAgICBuZXdfYWxsX21vZGVsc19zZXQgPSBuZXdfYWxsX21vZGVsc19zZXQudW5pb24oci5yZWZlcmVuY2VzKCkpO1xuICAgICAgICB9XG4gICAgICAgIG9sZF9hbGxfbW9kZWxzX3NldCA9IG5ldyBkYXRhX3N0cnVjdHVyZXNfMS5TZXQob2JqZWN0XzEudmFsdWVzKHRoaXMuX2FsbF9tb2RlbHMpKTtcbiAgICAgICAgdG9fZGV0YWNoID0gb2xkX2FsbF9tb2RlbHNfc2V0LmRpZmYobmV3X2FsbF9tb2RlbHNfc2V0KTtcbiAgICAgICAgdG9fYXR0YWNoID0gbmV3X2FsbF9tb2RlbHNfc2V0LmRpZmYob2xkX2FsbF9tb2RlbHNfc2V0KTtcbiAgICAgICAgcmVjb21wdXRlZCA9IHt9O1xuICAgICAgICByZWYyID0gbmV3X2FsbF9tb2RlbHNfc2V0LnZhbHVlcztcbiAgICAgICAgZm9yIChsID0gMCwgbGVuMSA9IHJlZjIubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICBtID0gcmVmMltsXTtcbiAgICAgICAgICAgIHJlY29tcHV0ZWRbbS5pZF0gPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJlZjMgPSB0b19kZXRhY2gudmFsdWVzO1xuICAgICAgICBmb3IgKG4gPSAwLCBsZW4yID0gcmVmMy5sZW5ndGg7IG4gPCBsZW4yOyBuKyspIHtcbiAgICAgICAgICAgIGQgPSByZWYzW25dO1xuICAgICAgICAgICAgZC5kZXRhY2hfZG9jdW1lbnQoKTtcbiAgICAgICAgICAgIG5hbWUgPSBkLm5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsbF9tb2RlbHNfYnlfbmFtZS5yZW1vdmVfdmFsdWUobmFtZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVmNCA9IHRvX2F0dGFjaC52YWx1ZXM7XG4gICAgICAgIGZvciAobyA9IDAsIGxlbjMgPSByZWY0Lmxlbmd0aDsgbyA8IGxlbjM7IG8rKykge1xuICAgICAgICAgICAgYSA9IHJlZjRbb107XG4gICAgICAgICAgICBhLmF0dGFjaF9kb2N1bWVudCh0aGlzKTtcbiAgICAgICAgICAgIG5hbWUgPSBhLm5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsbF9tb2RlbHNfYnlfbmFtZS5hZGRfdmFsdWUobmFtZSwgYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbF9tb2RlbHMgPSByZWNvbXB1dGVkO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLnJvb3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdHM7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuYWRkX3Jvb3QgPSBmdW5jdGlvbiAobW9kZWwsIHNldHRlcl9pZCkge1xuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiQWRkaW5nIHJvb3Q6IFwiICsgbW9kZWwpO1xuICAgICAgICBpZiAoaW5kZXhPZi5jYWxsKHRoaXMuX3Jvb3RzLCBtb2RlbCkgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3B1c2hfYWxsX21vZGVsc19mcmVlemUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnB1c2gobW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fcG9wX2FsbF9tb2RlbHNfZnJlZXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXJfb25fY2hhbmdlKG5ldyBleHBvcnRzLlJvb3RBZGRlZEV2ZW50KHRoaXMsIG1vZGVsLCBzZXR0ZXJfaWQpKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5yZW1vdmVfcm9vdCA9IGZ1bmN0aW9uIChtb2RlbCwgc2V0dGVyX2lkKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBpID0gdGhpcy5fcm9vdHMuaW5kZXhPZihtb2RlbCk7XG4gICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3B1c2hfYWxsX21vZGVsc19mcmVlemUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX3BvcF9hbGxfbW9kZWxzX2ZyZWV6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyX29uX2NoYW5nZShuZXcgZXhwb3J0cy5Sb290UmVtb3ZlZEV2ZW50KHRoaXMsIG1vZGVsLCBzZXR0ZXJfaWQpKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS50aXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpdGxlO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLnNldF90aXRsZSA9IGZ1bmN0aW9uICh0aXRsZSwgc2V0dGVyX2lkKSB7XG4gICAgICAgIGlmICh0aXRsZSAhPT0gdGhpcy5fdGl0bGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpdGxlID0gdGl0bGU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcl9vbl9jaGFuZ2UobmV3IGV4cG9ydHMuVGl0bGVDaGFuZ2VkRXZlbnQodGhpcywgdGl0bGUsIHNldHRlcl9pZCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuZ2V0X21vZGVsX2J5X2lkID0gZnVuY3Rpb24gKG1vZGVsX2lkKSB7XG4gICAgICAgIGlmIChtb2RlbF9pZCBpbiB0aGlzLl9hbGxfbW9kZWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxsX21vZGVsc1ttb2RlbF9pZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmdldF9tb2RlbF9ieV9uYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbF9tb2RlbHNfYnlfbmFtZS5nZXRfb25lKG5hbWUsIFwiTXVsdGlwbGUgbW9kZWxzIGFyZSBuYW1lZCAnXCIgKyBuYW1lICsgXCInXCIpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLm9uX2NoYW5nZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoaW5kZXhPZi5jYWxsKHRoaXMuX2NhbGxiYWNrcywgY2FsbGJhY2spID49IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLnJlbW92ZV9vbl9jaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGkgPSB0aGlzLl9jYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuX3RyaWdnZXJfb25fY2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjYiwgaiwgbGVuLCByZWYxLCByZXN1bHRzO1xuICAgICAgICByZWYxID0gdGhpcy5fY2FsbGJhY2tzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZjEubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGNiID0gcmVmMVtqXTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChjYihldmVudCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLl9ub3RpZnlfY2hhbmdlID0gZnVuY3Rpb24gKG1vZGVsLCBhdHRyLCBvbGQsIG5ld18sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGF0dHIgPT09ICduYW1lJykge1xuICAgICAgICAgICAgdGhpcy5fYWxsX21vZGVsc19ieV9uYW1lLnJlbW92ZV92YWx1ZShvbGQsIG1vZGVsKTtcbiAgICAgICAgICAgIGlmIChuZXdfICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsX21vZGVsc19ieV9uYW1lLmFkZF92YWx1ZShuZXdfLCBtb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXJfb25fY2hhbmdlKG5ldyBleHBvcnRzLk1vZGVsQ2hhbmdlZEV2ZW50KHRoaXMsIG1vZGVsLCBhdHRyLCBvbGQsIG5ld18sIG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuc2V0dGVyX2lkIDogdm9pZCAwKSk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5fcmVmZXJlbmNlc19qc29uID0gZnVuY3Rpb24gKHJlZmVyZW5jZXMsIGluY2x1ZGVfZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIGosIGxlbiwgciwgcmVmLCByZWZlcmVuY2VzX2pzb247XG4gICAgICAgIGlmIChpbmNsdWRlX2RlZmF1bHRzID09IG51bGwpIHtcbiAgICAgICAgICAgIGluY2x1ZGVfZGVmYXVsdHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlZmVyZW5jZXNfanNvbiA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWZlcmVuY2VzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByID0gcmVmZXJlbmNlc1tqXTtcbiAgICAgICAgICAgIHJlZiA9IHIucmVmKCk7XG4gICAgICAgICAgICByZWZbJ2F0dHJpYnV0ZXMnXSA9IHIuYXR0cmlidXRlc19hc19qc29uKGluY2x1ZGVfZGVmYXVsdHMpO1xuICAgICAgICAgICAgZGVsZXRlIHJlZlsnYXR0cmlidXRlcyddWydpZCddO1xuICAgICAgICAgICAgcmVmZXJlbmNlc19qc29uLnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmZXJlbmNlc19qc29uO1xuICAgIH07XG4gICAgRG9jdW1lbnQuX2luc3RhbnRpYXRlX29iamVjdCA9IGZ1bmN0aW9uIChvYmpfaWQsIG9ial90eXBlLCBvYmpfYXR0cnMpIHtcbiAgICAgICAgdmFyIGZ1bGxfYXR0cnMsIG1vZGVsO1xuICAgICAgICBmdWxsX2F0dHJzID0gb2JqZWN0XzEuZXh0ZW5kKHt9LCBvYmpfYXR0cnMsIHtcbiAgICAgICAgICAgIGlkOiBvYmpfaWRcbiAgICAgICAgfSk7XG4gICAgICAgIG1vZGVsID0gYmFzZV8xLk1vZGVscyhvYmpfdHlwZSk7XG4gICAgICAgIHJldHVybiBuZXcgbW9kZWwoZnVsbF9hdHRycywge1xuICAgICAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICAgICAgZGVmZXJfaW5pdGlhbGl6YXRpb246IHRydWVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5faW5zdGFudGlhdGVfcmVmZXJlbmNlc19qc29uID0gZnVuY3Rpb24gKHJlZmVyZW5jZXNfanNvbiwgZXhpc3RpbmdfbW9kZWxzKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSwgaiwgbGVuLCBvYmosIG9ial9hdHRycywgb2JqX2lkLCBvYmpfdHlwZSwgcmVmZXJlbmNlcztcbiAgICAgICAgcmVmZXJlbmNlcyA9IHt9O1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWZlcmVuY2VzX2pzb24ubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIG9iaiA9IHJlZmVyZW5jZXNfanNvbltqXTtcbiAgICAgICAgICAgIG9ial9pZCA9IG9ialsnaWQnXTtcbiAgICAgICAgICAgIG9ial90eXBlID0gb2JqWyd0eXBlJ107XG4gICAgICAgICAgICBvYmpfYXR0cnMgPSBvYmpbJ2F0dHJpYnV0ZXMnXTtcbiAgICAgICAgICAgIGlmIChvYmpfaWQgaW4gZXhpc3RpbmdfbW9kZWxzKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBleGlzdGluZ19tb2RlbHNbb2JqX2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gRG9jdW1lbnQuX2luc3RhbnRpYXRlX29iamVjdChvYmpfaWQsIG9ial90eXBlLCBvYmpfYXR0cnMpO1xuICAgICAgICAgICAgICAgIGlmICgnc3VidHlwZScgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnNldF9zdWJ0eXBlKG9ialsnc3VidHlwZSddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWZlcmVuY2VzW2luc3RhbmNlLmlkXSA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VzO1xuICAgIH07XG4gICAgRG9jdW1lbnQuX3Jlc29sdmVfcmVmcyA9IGZ1bmN0aW9uICh2YWx1ZSwgb2xkX3JlZmVyZW5jZXMsIG5ld19yZWZlcmVuY2VzKSB7XG4gICAgICAgIHZhciByZXNvbHZlX2FycmF5LCByZXNvbHZlX2RpY3QsIHJlc29sdmVfcmVmO1xuICAgICAgICByZXNvbHZlX3JlZiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAocmVmc18xLmlzX3JlZih2KSkge1xuICAgICAgICAgICAgICAgIGlmICh2WydpZCddIGluIG9sZF9yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvbGRfcmVmZXJlbmNlc1t2WydpZCddXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodlsnaWQnXSBpbiBuZXdfcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3X3JlZmVyZW5jZXNbdlsnaWQnXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWZlcmVuY2UgXCIgKyAoSlNPTi5zdHJpbmdpZnkodikpICsgXCIgaXNuJ3Qga25vd24gKG5vdCBpbiBEb2N1bWVudD8pXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlX2FycmF5KHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc09iamVjdCh2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlX2RpY3Qodik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmVzb2x2ZV9kaWN0ID0gZnVuY3Rpb24gKGRpY3QpIHtcbiAgICAgICAgICAgIHZhciBrLCByZXNvbHZlZCwgdjtcbiAgICAgICAgICAgIHJlc29sdmVkID0ge307XG4gICAgICAgICAgICBmb3IgKGsgaW4gZGljdCkge1xuICAgICAgICAgICAgICAgIHYgPSBkaWN0W2tdO1xuICAgICAgICAgICAgICAgIHJlc29sdmVkW2tdID0gcmVzb2x2ZV9yZWYodik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHJlc29sdmVfYXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlc3VsdHMsIHY7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIHYgPSBhcnJheVtqXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzb2x2ZV9yZWYodikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXNvbHZlX3JlZih2YWx1ZSk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5faW5pdGlhbGl6ZV9yZWZlcmVuY2VzX2pzb24gPSBmdW5jdGlvbiAocmVmZXJlbmNlc19qc29uLCBvbGRfcmVmZXJlbmNlcywgbmV3X3JlZmVyZW5jZXMpIHtcbiAgICAgICAgdmFyIGZvcmVhY2hfZGVwdGhfZmlyc3QsIGluc3RhbmNlLCBqLCBsZW4sIG9iaiwgb2JqX2F0dHJzLCBvYmpfaWQsIHRvX3VwZGF0ZSwgd2FzX25ldztcbiAgICAgICAgdG9fdXBkYXRlID0ge307XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZmVyZW5jZXNfanNvbi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgb2JqID0gcmVmZXJlbmNlc19qc29uW2pdO1xuICAgICAgICAgICAgb2JqX2lkID0gb2JqWydpZCddO1xuICAgICAgICAgICAgb2JqX2F0dHJzID0gb2JqWydhdHRyaWJ1dGVzJ107XG4gICAgICAgICAgICB3YXNfbmV3ID0gZmFsc2U7XG4gICAgICAgICAgICBpbnN0YW5jZSA9IG9ial9pZCBpbiBvbGRfcmVmZXJlbmNlcyA/IG9sZF9yZWZlcmVuY2VzW29ial9pZF0gOiAod2FzX25ldyA9IHRydWUsIG5ld19yZWZlcmVuY2VzW29ial9pZF0pO1xuICAgICAgICAgICAgb2JqX2F0dHJzID0gRG9jdW1lbnQuX3Jlc29sdmVfcmVmcyhvYmpfYXR0cnMsIG9sZF9yZWZlcmVuY2VzLCBuZXdfcmVmZXJlbmNlcyk7XG4gICAgICAgICAgICB0b191cGRhdGVbaW5zdGFuY2UuaWRdID0gW2luc3RhbmNlLCBvYmpfYXR0cnMsIHdhc19uZXddO1xuICAgICAgICB9XG4gICAgICAgIGZvcmVhY2hfZGVwdGhfZmlyc3QgPSBmdW5jdGlvbiAoaXRlbXMsIGYpIHtcbiAgICAgICAgICAgIHZhciBhbHJlYWR5X3N0YXJ0ZWQsIGZvcmVhY2hfdmFsdWUsIGssIHJlc3VsdHMsIHY7XG4gICAgICAgICAgICBhbHJlYWR5X3N0YXJ0ZWQgPSB7fTtcbiAgICAgICAgICAgIGZvcmVhY2hfdmFsdWUgPSBmdW5jdGlvbiAodiwgZikge1xuICAgICAgICAgICAgICAgIHZhciBhLCBhdHRycywgZSwgaywgbCwgbGVuMSwgcmVmMSwgcmVzdWx0cywgcmVzdWx0czEsIHNhbWVfYXNfdjtcbiAgICAgICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIGhhc19wcm9wc18xLkhhc1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHYuaWQgaW4gYWxyZWFkeV9zdGFydGVkKSAmJiB2LmlkIGluIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5X3N0YXJ0ZWRbdi5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmMSA9IGl0ZW1zW3YuaWRdLCBzYW1lX2FzX3YgPSByZWYxWzBdLCBhdHRycyA9IHJlZjFbMV0sIHdhc19uZXcgPSByZWYxWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChhIGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGF0dHJzW2FdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmVhY2hfdmFsdWUoZSwgZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZih2LCBhdHRycywgd2FzX25ldyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gMCwgbGVuMSA9IHYubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gdltsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmb3JlYWNoX3ZhbHVlKGUsIGYpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc09iamVjdCh2KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzMSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHZba107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzMS5wdXNoKGZvcmVhY2hfdmFsdWUoZSwgZikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChrIGluIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgdiA9IGl0ZW1zW2tdO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmb3JlYWNoX3ZhbHVlKHZbMF0sIGYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9O1xuICAgICAgICBmb3JlYWNoX2RlcHRoX2ZpcnN0KHRvX3VwZGF0ZSwgZnVuY3Rpb24gKGluc3RhbmNlLCBhdHRycywgd2FzX25ldykge1xuICAgICAgICAgICAgaWYgKHdhc19uZXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc2V0dihhdHRycywge1xuICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3JlYWNoX2RlcHRoX2ZpcnN0KHRvX3VwZGF0ZSwgZnVuY3Rpb24gKGluc3RhbmNlLCBhdHRycywgd2FzX25ldykge1xuICAgICAgICAgICAgaWYgKHdhc19uZXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UuZmluYWxpemUoYXR0cnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERvY3VtZW50Ll9ldmVudF9mb3JfYXR0cmlidXRlX2NoYW5nZSA9IGZ1bmN0aW9uIChjaGFuZ2VkX29iaiwga2V5LCBuZXdfdmFsdWUsIGRvYywgdmFsdWVfcmVmcykge1xuICAgICAgICB2YXIgY2hhbmdlZF9tb2RlbCwgZXZlbnQ7XG4gICAgICAgIGNoYW5nZWRfbW9kZWwgPSBkb2MuZ2V0X21vZGVsX2J5X2lkKGNoYW5nZWRfb2JqLmlkKTtcbiAgICAgICAgaWYgKCFjaGFuZ2VkX21vZGVsLmF0dHJpYnV0ZV9pc19zZXJpYWxpemFibGUoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgICAna2luZCc6ICdNb2RlbENoYW5nZWQnLFxuICAgICAgICAgICAgJ21vZGVsJzoge1xuICAgICAgICAgICAgICAgIGlkOiBjaGFuZ2VkX29iai5pZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBjaGFuZ2VkX29iai50eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2F0dHInOiBrZXksXG4gICAgICAgICAgICAnbmV3JzogbmV3X3ZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGhhc19wcm9wc18xLkhhc1Byb3BzLl9qc29uX3JlY29yZF9yZWZlcmVuY2VzKGRvYywgbmV3X3ZhbHVlLCB2YWx1ZV9yZWZzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG4gICAgRG9jdW1lbnQuX2V2ZW50c190b19zeW5jX29iamVjdHMgPSBmdW5jdGlvbiAoZnJvbV9vYmosIHRvX29iaiwgdG9fZG9jLCB2YWx1ZV9yZWZzKSB7XG4gICAgICAgIHZhciBhZGRlZCwgZXZlbnRzLCBmcm9tX2tleXMsIGosIGtleSwgbCwgbGVuLCBsZW4xLCBsZW4yLCBuLCBuZXdfdmFsdWUsIG9sZF92YWx1ZSwgcmVtb3ZlZCwgc2hhcmVkLCB0b19rZXlzO1xuICAgICAgICBmcm9tX2tleXMgPSBPYmplY3Qua2V5cyhmcm9tX29iai5hdHRyaWJ1dGVzKTtcbiAgICAgICAgdG9fa2V5cyA9IE9iamVjdC5rZXlzKHRvX29iai5hdHRyaWJ1dGVzKTtcbiAgICAgICAgcmVtb3ZlZCA9IGFycmF5XzEuZGlmZmVyZW5jZShmcm9tX2tleXMsIHRvX2tleXMpO1xuICAgICAgICBhZGRlZCA9IGFycmF5XzEuZGlmZmVyZW5jZSh0b19rZXlzLCBmcm9tX2tleXMpO1xuICAgICAgICBzaGFyZWQgPSBhcnJheV8xLmludGVyc2VjdGlvbihmcm9tX2tleXMsIHRvX2tleXMpO1xuICAgICAgICBldmVudHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVtb3ZlZC5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAga2V5ID0gcmVtb3ZlZFtqXTtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIud2FybihcIlNlcnZlciBzZW50IGtleSBcIiArIGtleSArIFwiIGJ1dCB3ZSBkb24ndCBzZWVtIHRvIGhhdmUgaXQgaW4gb3VyIEpTT05cIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsID0gMCwgbGVuMSA9IGFkZGVkLmxlbmd0aDsgbCA8IGxlbjE7IGwrKykge1xuICAgICAgICAgICAga2V5ID0gYWRkZWRbbF07XG4gICAgICAgICAgICBuZXdfdmFsdWUgPSB0b19vYmouYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgZXZlbnRzLnB1c2goRG9jdW1lbnQuX2V2ZW50X2Zvcl9hdHRyaWJ1dGVfY2hhbmdlKGZyb21fb2JqLCBrZXksIG5ld192YWx1ZSwgdG9fZG9jLCB2YWx1ZV9yZWZzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChuID0gMCwgbGVuMiA9IHNoYXJlZC5sZW5ndGg7IG4gPCBsZW4yOyBuKyspIHtcbiAgICAgICAgICAgIGtleSA9IHNoYXJlZFtuXTtcbiAgICAgICAgICAgIG9sZF92YWx1ZSA9IGZyb21fb2JqLmF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIG5ld192YWx1ZSA9IHRvX29iai5hdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICBpZiAob2xkX3ZhbHVlID09PSBudWxsICYmIG5ld192YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob2xkX3ZhbHVlID09PSBudWxsIHx8IG5ld192YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKERvY3VtZW50Ll9ldmVudF9mb3JfYXR0cmlidXRlX2NoYW5nZShmcm9tX29iaiwga2V5LCBuZXdfdmFsdWUsIHRvX2RvYywgdmFsdWVfcmVmcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcV8xLmlzRXF1YWwob2xkX3ZhbHVlLCBuZXdfdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKERvY3VtZW50Ll9ldmVudF9mb3JfYXR0cmlidXRlX2NoYW5nZShmcm9tX29iaiwga2V5LCBuZXdfdmFsdWUsIHRvX2RvYywgdmFsdWVfcmVmcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUgIT09IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRG9jdW1lbnQuX2NvbXB1dGVfcGF0Y2hfc2luY2VfanNvbiA9IGZ1bmN0aW9uIChmcm9tX2pzb24sIHRvX2RvYykge1xuICAgICAgICB2YXIgZXZlbnRzLCBmcm9tX3JlZmVyZW5jZXMsIGZyb21fcm9vdF9pZHMsIGZyb21fcm9vdHMsIGlkLCBpbmNsdWRlX2RlZmF1bHRzLCBqLCBsLCBsZW4sIGxlbjEsIG1vZGVsLCByLCByZWYxLCByZWYyLCByZWYzLCByZWZzLCB0b19qc29uLCB0b19yZWZlcmVuY2VzLCB0b19yb290X2lkcywgdG9fcm9vdHMsIHVwZGF0ZV9tb2RlbF9ldmVudHMsIHZhbHVlX3JlZnM7XG4gICAgICAgIHRvX2pzb24gPSB0b19kb2MudG9fanNvbihpbmNsdWRlX2RlZmF1bHRzID0gZmFsc2UpO1xuICAgICAgICByZWZzID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgICAgIHZhciBqLCBsZW4sIG9iaiwgcmVmMSwgcmVzdWx0O1xuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICByZWYxID0ganNvblsncm9vdHMnXVsncmVmZXJlbmNlcyddO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIG9iaiA9IHJlZjFbal07XG4gICAgICAgICAgICAgICAgcmVzdWx0W29iai5pZF0gPSBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBmcm9tX3JlZmVyZW5jZXMgPSByZWZzKGZyb21fanNvbik7XG4gICAgICAgIGZyb21fcm9vdHMgPSB7fTtcbiAgICAgICAgZnJvbV9yb290X2lkcyA9IFtdO1xuICAgICAgICByZWYxID0gZnJvbV9qc29uWydyb290cyddWydyb290X2lkcyddO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByID0gcmVmMVtqXTtcbiAgICAgICAgICAgIGZyb21fcm9vdHNbcl0gPSBmcm9tX3JlZmVyZW5jZXNbcl07XG4gICAgICAgICAgICBmcm9tX3Jvb3RfaWRzLnB1c2gocik7XG4gICAgICAgIH1cbiAgICAgICAgdG9fcmVmZXJlbmNlcyA9IHJlZnModG9fanNvbik7XG4gICAgICAgIHRvX3Jvb3RzID0ge307XG4gICAgICAgIHRvX3Jvb3RfaWRzID0gW107XG4gICAgICAgIHJlZjIgPSB0b19qc29uWydyb290cyddWydyb290X2lkcyddO1xuICAgICAgICBmb3IgKGwgPSAwLCBsZW4xID0gcmVmMi5sZW5ndGg7IGwgPCBsZW4xOyBsKyspIHtcbiAgICAgICAgICAgIHIgPSByZWYyW2xdO1xuICAgICAgICAgICAgdG9fcm9vdHNbcl0gPSB0b19yZWZlcmVuY2VzW3JdO1xuICAgICAgICAgICAgdG9fcm9vdF9pZHMucHVzaChyKTtcbiAgICAgICAgfVxuICAgICAgICBmcm9tX3Jvb3RfaWRzLnNvcnQoKTtcbiAgICAgICAgdG9fcm9vdF9pZHMuc29ydCgpO1xuICAgICAgICBpZiAoYXJyYXlfMS5kaWZmZXJlbmNlKGZyb21fcm9vdF9pZHMsIHRvX3Jvb3RfaWRzKS5sZW5ndGggPiAwIHx8IGFycmF5XzEuZGlmZmVyZW5jZSh0b19yb290X2lkcywgZnJvbV9yb290X2lkcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkOiBjb21wdXRpbmcgYWRkL3JlbW92ZSBvZiBkb2N1bWVudCByb290c1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZV9yZWZzID0ge307XG4gICAgICAgIGV2ZW50cyA9IFtdO1xuICAgICAgICByZWYzID0gdG9fZG9jLl9hbGxfbW9kZWxzO1xuICAgICAgICBmb3IgKGlkIGluIHJlZjMpIHtcbiAgICAgICAgICAgIG1vZGVsID0gcmVmM1tpZF07XG4gICAgICAgICAgICBpZiAoaWQgaW4gZnJvbV9yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlX21vZGVsX2V2ZW50cyA9IERvY3VtZW50Ll9ldmVudHNfdG9fc3luY19vYmplY3RzKGZyb21fcmVmZXJlbmNlc1tpZF0sIHRvX3JlZmVyZW5jZXNbaWRdLCB0b19kb2MsIHZhbHVlX3JlZnMpO1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQodXBkYXRlX21vZGVsX2V2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdldmVudHMnOiBldmVudHMsXG4gICAgICAgICAgICAncmVmZXJlbmNlcyc6IERvY3VtZW50Ll9yZWZlcmVuY2VzX2pzb24ob2JqZWN0XzEudmFsdWVzKHZhbHVlX3JlZnMpLCBpbmNsdWRlX2RlZmF1bHRzID0gZmFsc2UpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUudG9fanNvbl9zdHJpbmcgPSBmdW5jdGlvbiAoaW5jbHVkZV9kZWZhdWx0cykge1xuICAgICAgICBpZiAoaW5jbHVkZV9kZWZhdWx0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmNsdWRlX2RlZmF1bHRzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b19qc29uKGluY2x1ZGVfZGVmYXVsdHMpKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS50b19qc29uID0gZnVuY3Rpb24gKGluY2x1ZGVfZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIGosIGxlbiwgciwgcmVmMSwgcm9vdF9pZHMsIHJvb3RfcmVmZXJlbmNlcztcbiAgICAgICAgaWYgKGluY2x1ZGVfZGVmYXVsdHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5jbHVkZV9kZWZhdWx0cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdF9pZHMgPSBbXTtcbiAgICAgICAgcmVmMSA9IHRoaXMuX3Jvb3RzO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByID0gcmVmMVtqXTtcbiAgICAgICAgICAgIHJvb3RfaWRzLnB1c2goci5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdF9yZWZlcmVuY2VzID0gb2JqZWN0XzEudmFsdWVzKHRoaXMuX2FsbF9tb2RlbHMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpdGxlJzogdGhpcy5fdGl0bGUsXG4gICAgICAgICAgICAncm9vdHMnOiB7XG4gICAgICAgICAgICAgICAgJ3Jvb3RfaWRzJzogcm9vdF9pZHMsXG4gICAgICAgICAgICAgICAgJ3JlZmVyZW5jZXMnOiBEb2N1bWVudC5fcmVmZXJlbmNlc19qc29uKHJvb3RfcmVmZXJlbmNlcywgaW5jbHVkZV9kZWZhdWx0cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIERvY3VtZW50LmZyb21fanNvbl9zdHJpbmcgPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIganNvbjtcbiAgICAgICAgaWYgKHMgPT09IG51bGwgfHwgKHMgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkpTT04gc3RyaW5nIGlzIFwiICsgKHR5cGVvZiBzKSk7XG4gICAgICAgIH1cbiAgICAgICAganNvbiA9IEpTT04ucGFyc2Uocyk7XG4gICAgICAgIHJldHVybiBEb2N1bWVudC5mcm9tX2pzb24oanNvbik7XG4gICAgfTtcbiAgICBEb2N1bWVudC5mcm9tX2pzb24gPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICB2YXIgZG9jLCBpc19kZXYsIGosIGxlbiwgcHlfdmVyc2lvbiwgciwgcmVmZXJlbmNlcywgcmVmZXJlbmNlc19qc29uLCByb290X2lkcywgcm9vdHNfanNvbiwgdmVyc2lvbnNfc3RyaW5nO1xuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiQ3JlYXRpbmcgRG9jdW1lbnQgZnJvbSBKU09OXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJKU09OIG9iamVjdCBoYXMgd3JvbmcgdHlwZSBcIiArICh0eXBlb2YganNvbikpO1xuICAgICAgICB9XG4gICAgICAgIHB5X3ZlcnNpb24gPSBqc29uWyd2ZXJzaW9uJ107XG4gICAgICAgIGlzX2RldiA9IHB5X3ZlcnNpb24uaW5kZXhPZignKycpICE9PSAtMSB8fCBweV92ZXJzaW9uLmluZGV4T2YoJy0nKSAhPT0gLTE7XG4gICAgICAgIHZlcnNpb25zX3N0cmluZyA9IFwiTGlicmFyeSB2ZXJzaW9uczogSlMgKFwiICsgdmVyc2lvbl8xLnZlcnNpb24gKyBcIikgIC8gIFB5dGhvbiAoXCIgKyBweV92ZXJzaW9uICsgXCIpXCI7XG4gICAgICAgIGlmICghaXNfZGV2ICYmIHZlcnNpb25fMS52ZXJzaW9uICE9PSBweV92ZXJzaW9uKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJKUy9QeXRob24gdmVyc2lvbiBtaXNtYXRjaFwiKTtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIud2Fybih2ZXJzaW9uc19zdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1Zyh2ZXJzaW9uc19zdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJvb3RzX2pzb24gPSBqc29uWydyb290cyddO1xuICAgICAgICByb290X2lkcyA9IHJvb3RzX2pzb25bJ3Jvb3RfaWRzJ107XG4gICAgICAgIHJlZmVyZW5jZXNfanNvbiA9IHJvb3RzX2pzb25bJ3JlZmVyZW5jZXMnXTtcbiAgICAgICAgcmVmZXJlbmNlcyA9IERvY3VtZW50Ll9pbnN0YW50aWF0ZV9yZWZlcmVuY2VzX2pzb24ocmVmZXJlbmNlc19qc29uLCB7fSk7XG4gICAgICAgIERvY3VtZW50Ll9pbml0aWFsaXplX3JlZmVyZW5jZXNfanNvbihyZWZlcmVuY2VzX2pzb24sIHt9LCByZWZlcmVuY2VzKTtcbiAgICAgICAgZG9jID0gbmV3IERvY3VtZW50KCk7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJvb3RfaWRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByID0gcm9vdF9pZHNbal07XG4gICAgICAgICAgICBkb2MuYWRkX3Jvb3QocmVmZXJlbmNlc1tyXSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jLnNldF90aXRsZShqc29uWyd0aXRsZSddKTtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5yZXBsYWNlX3dpdGhfanNvbiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHZhciByZXBsYWNlbWVudDtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBEb2N1bWVudC5mcm9tX2pzb24oanNvbik7XG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudC5kZXN0cnVjdGl2ZWx5X21vdmUodGhpcyk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlX2pzb25fcGF0Y2hfc3RyaW5nID0gZnVuY3Rpb24gKGV2ZW50cykge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5jcmVhdGVfanNvbl9wYXRjaChldmVudHMpKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVfanNvbl9wYXRjaCA9IGZ1bmN0aW9uIChldmVudHMpIHtcbiAgICAgICAgdmFyIGV2ZW50LCBqLCBqc29uX2V2ZW50cywgbGVuLCByZWZlcmVuY2VzLCByZXN1bHQ7XG4gICAgICAgIHJlZmVyZW5jZXMgPSB7fTtcbiAgICAgICAganNvbl9ldmVudHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gZXZlbnRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBldmVudCA9IGV2ZW50c1tqXTtcbiAgICAgICAgICAgIGlmIChldmVudC5kb2N1bWVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIud2FybihcIkNhbm5vdCBjcmVhdGUgYSBwYXRjaCB1c2luZyBldmVudHMgZnJvbSBhIGRpZmZlcmVudCBkb2N1bWVudCwgZXZlbnQgaGFkIFwiLCBldmVudC5kb2N1bWVudCwgXCIgd2UgYXJlIFwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIGEgcGF0Y2ggdXNpbmcgZXZlbnRzIGZyb20gYSBkaWZmZXJlbnQgZG9jdW1lbnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqc29uX2V2ZW50cy5wdXNoKGV2ZW50Lmpzb24ocmVmZXJlbmNlcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgPSB7XG4gICAgICAgICAgICBldmVudHM6IGpzb25fZXZlbnRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlczogRG9jdW1lbnQuX3JlZmVyZW5jZXNfanNvbihvYmplY3RfMS52YWx1ZXMocmVmZXJlbmNlcykpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuYXBwbHlfanNvbl9wYXRjaF9zdHJpbmcgPSBmdW5jdGlvbiAocGF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlfanNvbl9wYXRjaChKU09OLnBhcnNlKHBhdGNoKSk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuYXBwbHlfanNvbl9wYXRjaCA9IGZ1bmN0aW9uIChwYXRjaCwgc2V0dGVyX2lkKSB7XG4gICAgICAgIHZhciBhdHRyLCBjb2x1bW5fc291cmNlLCBjb2x1bW5fc291cmNlX2lkLCBkYXRhLCBldmVudF9qc29uLCBldmVudHNfanNvbiwgaWQsIGosIGwsIGxlbiwgbGVuMSwgbW9kZWxfaWQsIG1vZGVsX3R5cGUsIG5ld19yZWZlcmVuY2VzLCBvYmoxLCBvbGRfcmVmZXJlbmNlcywgcGF0Y2hlZF9pZCwgcGF0Y2hlZF9vYmosIHBhdGNoZXMsIHJlZjEsIHJlZmVyZW5jZXMsIHJlZmVyZW5jZXNfanNvbiwgcmVzdWx0cywgcm9sbG92ZXIsIHJvb3RfaWQsIHJvb3Rfb2JqLCBzaGFwZXMsIHZhbHVlO1xuICAgICAgICByZWZlcmVuY2VzX2pzb24gPSBwYXRjaFsncmVmZXJlbmNlcyddO1xuICAgICAgICBldmVudHNfanNvbiA9IHBhdGNoWydldmVudHMnXTtcbiAgICAgICAgcmVmZXJlbmNlcyA9IERvY3VtZW50Ll9pbnN0YW50aWF0ZV9yZWZlcmVuY2VzX2pzb24ocmVmZXJlbmNlc19qc29uLCB0aGlzLl9hbGxfbW9kZWxzKTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gZXZlbnRzX2pzb24ubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGV2ZW50X2pzb24gPSBldmVudHNfanNvbltqXTtcbiAgICAgICAgICAgIGlmICgnbW9kZWwnIGluIGV2ZW50X2pzb24pIHtcbiAgICAgICAgICAgICAgICBtb2RlbF9pZCA9IGV2ZW50X2pzb25bJ21vZGVsJ11bJ2lkJ107XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsX2lkIGluIHRoaXMuX2FsbF9tb2RlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlc1ttb2RlbF9pZF0gPSB0aGlzLl9hbGxfbW9kZWxzW21vZGVsX2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1vZGVsX2lkIGluIHJlZmVyZW5jZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJHb3QgYW4gZXZlbnQgZm9yIHVua25vd24gbW9kZWwgXCIsIGV2ZW50X2pzb25bJ21vZGVsJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXZlbnQgbW9kZWwgd2Fzbid0IGtub3duXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9sZF9yZWZlcmVuY2VzID0ge307XG4gICAgICAgIG5ld19yZWZlcmVuY2VzID0ge307XG4gICAgICAgIGZvciAoaWQgaW4gcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgdmFsdWUgPSByZWZlcmVuY2VzW2lkXTtcbiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLl9hbGxfbW9kZWxzKSB7XG4gICAgICAgICAgICAgICAgb2xkX3JlZmVyZW5jZXNbaWRdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdfcmVmZXJlbmNlc1tpZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBEb2N1bWVudC5faW5pdGlhbGl6ZV9yZWZlcmVuY2VzX2pzb24ocmVmZXJlbmNlc19qc29uLCBvbGRfcmVmZXJlbmNlcywgbmV3X3JlZmVyZW5jZXMpO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobCA9IDAsIGxlbjEgPSBldmVudHNfanNvbi5sZW5ndGg7IGwgPCBsZW4xOyBsKyspIHtcbiAgICAgICAgICAgIGV2ZW50X2pzb24gPSBldmVudHNfanNvbltsXTtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnRfanNvbi5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTW9kZWxDaGFuZ2VkJzpcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hlZF9pZCA9IGV2ZW50X2pzb25bJ21vZGVsJ11bJ2lkJ107XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBhdGNoZWRfaWQgaW4gdGhpcy5fYWxsX21vZGVscykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBwYXRjaCB0byBcIiArIHBhdGNoZWRfaWQgKyBcIiB3aGljaCBpcyBub3QgaW4gdGhlIGRvY3VtZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZWRfb2JqID0gdGhpcy5fYWxsX21vZGVsc1twYXRjaGVkX2lkXTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGV2ZW50X2pzb25bJ2F0dHInXTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxfdHlwZSA9IGV2ZW50X2pzb25bJ21vZGVsJ11bJ3R5cGUnXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIgPT09ICdkYXRhJyAmJiBtb2RlbF90eXBlID09PSAnQ29sdW1uRGF0YVNvdXJjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjEgPSBzZXJpYWxpemF0aW9uXzEuZGVjb2RlX2NvbHVtbl9kYXRhKGV2ZW50X2pzb25bJ25ldyddKSwgZGF0YSA9IHJlZjFbMF0sIHNoYXBlcyA9IHJlZjFbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocGF0Y2hlZF9vYmouc2V0dih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NoYXBlczogc2hhcGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXJfaWQ6IHNldHRlcl9pZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBEb2N1bWVudC5fcmVzb2x2ZV9yZWZzKGV2ZW50X2pzb25bJ25ldyddLCBvbGRfcmVmZXJlbmNlcywgbmV3X3JlZmVyZW5jZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHBhdGNoZWRfb2JqLnNldHYoKG9iajEgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoxW1wiXCIgKyBhdHRyXSA9IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iajEpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyX2lkOiBzZXR0ZXJfaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdDb2x1bW5zU3RyZWFtZWQnOlxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5fc291cmNlX2lkID0gZXZlbnRfanNvblsnY29sdW1uX3NvdXJjZSddWydpZCddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShjb2x1bW5fc291cmNlX2lkIGluIHRoaXMuX2FsbF9tb2RlbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3RyZWFtIHRvIFwiICsgY29sdW1uX3NvdXJjZV9pZCArIFwiIHdoaWNoIGlzIG5vdCBpbiB0aGUgZG9jdW1lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX3NvdXJjZSA9IHRoaXMuX2FsbF9tb2RlbHNbY29sdW1uX3NvdXJjZV9pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGNvbHVtbl9zb3VyY2UgaW5zdGFuY2VvZiBjb2x1bW5fZGF0YV9zb3VyY2VfMS5Db2x1bW5EYXRhU291cmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN0cmVhbSB0byBub24tQ29sdW1uRGF0YVNvdXJjZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZXZlbnRfanNvblsnZGF0YSddO1xuICAgICAgICAgICAgICAgICAgICByb2xsb3ZlciA9IGV2ZW50X2pzb25bJ3JvbGxvdmVyJ107XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjb2x1bW5fc291cmNlLnN0cmVhbShkYXRhLCByb2xsb3ZlcikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdDb2x1bW5zUGF0Y2hlZCc6XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9zb3VyY2VfaWQgPSBldmVudF9qc29uWydjb2x1bW5fc291cmNlJ11bJ2lkJ107XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGNvbHVtbl9zb3VyY2VfaWQgaW4gdGhpcy5fYWxsX21vZGVscykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwYXRjaCBcIiArIGNvbHVtbl9zb3VyY2VfaWQgKyBcIiB3aGljaCBpcyBub3QgaW4gdGhlIGRvY3VtZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9zb3VyY2UgPSB0aGlzLl9hbGxfbW9kZWxzW2NvbHVtbl9zb3VyY2VfaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShjb2x1bW5fc291cmNlIGluc3RhbmNlb2YgY29sdW1uX2RhdGFfc291cmNlXzEuQ29sdW1uRGF0YVNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwYXRjaCBub24tQ29sdW1uRGF0YVNvdXJjZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRjaGVzID0gZXZlbnRfanNvblsncGF0Y2hlcyddO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY29sdW1uX3NvdXJjZS5wYXRjaChwYXRjaGVzKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1Jvb3RBZGRlZCc6XG4gICAgICAgICAgICAgICAgICAgIHJvb3RfaWQgPSBldmVudF9qc29uWydtb2RlbCddWydpZCddO1xuICAgICAgICAgICAgICAgICAgICByb290X29iaiA9IHJlZmVyZW5jZXNbcm9vdF9pZF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmFkZF9yb290KHJvb3Rfb2JqLCBzZXR0ZXJfaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUm9vdFJlbW92ZWQnOlxuICAgICAgICAgICAgICAgICAgICByb290X2lkID0gZXZlbnRfanNvblsnbW9kZWwnXVsnaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdF9vYmogPSByZWZlcmVuY2VzW3Jvb3RfaWRdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5yZW1vdmVfcm9vdChyb290X29iaiwgc2V0dGVyX2lkKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RpdGxlQ2hhbmdlZCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnNldF90aXRsZShldmVudF9qc29uWyd0aXRsZSddLCBzZXR0ZXJfaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwYXRjaCBldmVudCBcIiArIEpTT04uc3RyaW5naWZ5KGV2ZW50X2pzb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIHJldHVybiBEb2N1bWVudDtcbn0pKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfY3JlYXRlX3ZpZXcsIF9nZXRfc2Vzc2lvbiwgX2hhbmRsZV9ub3RlYm9va19jb21tcywgX2luaXRfY29tbXMsIF9yZW5kZXJfZG9jdW1lbnRfdG9fZWxlbWVudCwgX3Nlc3Npb25zLCBfdXBkYXRlX2NvbW1zX2NhbGxiYWNrLCBhZGRfZG9jdW1lbnRfZnJvbV9zZXNzaW9uLCBhZGRfbW9kZWxfZnJvbV9zZXNzaW9uLCBhZGRfbW9kZWxfc3RhdGljLCBmaWxsX3JlbmRlcl9pdGVtX2Zyb21fc2NyaXB0X3RhZztcbnZhciBiYXNlID0gcmVxdWlyZShcIi4vYmFzZVwiKTtcbnZhciBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9jb3JlL2xvZ2dpbmdcIik7XG52YXIgZG9jdW1lbnRfMSA9IHJlcXVpcmUoXCIuL2RvY3VtZW50XCIpO1xudmFyIGRvbV8xID0gcmVxdWlyZShcIi4vY29yZS9kb21cIik7XG5leHBvcnRzLkJPS0VIX1JPT1QgPSBcImJrLXJvb3RcIjtcbl9oYW5kbGVfbm90ZWJvb2tfY29tbXMgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgdmFyIGRhdGE7XG4gICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcImhhbmRsaW5nIG5vdGVib29rIGNvbW1zXCIpO1xuICAgIGRhdGEgPSBKU09OLnBhcnNlKG1zZy5jb250ZW50LmRhdGEpO1xuICAgIGlmICgnZXZlbnRzJyBpbiBkYXRhICYmICdyZWZlcmVuY2VzJyBpbiBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5X2pzb25fcGF0Y2goZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdkb2MnIGluIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZV93aXRoX2pzb24oZGF0YVsnZG9jJ10pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGFuZGxpbmcgbm90ZWJvb2sgY29tbXMgbWVzc2FnZTogXCIsIG1zZyk7XG4gICAgfVxufTtcbl91cGRhdGVfY29tbXNfY2FsbGJhY2sgPSBmdW5jdGlvbiAodGFyZ2V0LCBkb2MsIGNvbW0pIHtcbiAgICBpZiAodGFyZ2V0ID09PSBjb21tLnRhcmdldF9uYW1lKSB7XG4gICAgICAgIHJldHVybiBjb21tLm9uX21zZyhfaGFuZGxlX25vdGVib29rX2NvbW1zLmJpbmQoZG9jKSk7XG4gICAgfVxufTtcbl9pbml0X2NvbW1zID0gZnVuY3Rpb24gKHRhcmdldCwgZG9jKSB7XG4gICAgdmFyIGNvbW1fbWFuYWdlciwgZSwgaWQsIHByb21pc2UsIHJlZiwgdXBkYXRlX2NvbW1zO1xuICAgIGlmICgodHlwZW9mIEp1cHl0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgSnVweXRlciAhPT0gbnVsbCkgJiYgKEp1cHl0ZXIubm90ZWJvb2sua2VybmVsICE9IG51bGwpKSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuaW5mbyhcIlJlZ2lzdGVyaW5nIEp1cHl0ZXIgY29tbXMgZm9yIHRhcmdldCBcIiArIHRhcmdldCk7XG4gICAgICAgIGNvbW1fbWFuYWdlciA9IEp1cHl0ZXIubm90ZWJvb2sua2VybmVsLmNvbW1fbWFuYWdlcjtcbiAgICAgICAgdXBkYXRlX2NvbW1zID0gZnVuY3Rpb24gKGNvbW0pIHtcbiAgICAgICAgICAgIHJldHVybiBfdXBkYXRlX2NvbW1zX2NhbGxiYWNrKHRhcmdldCwgZG9jLCBjb21tKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVmID0gY29tbV9tYW5hZ2VyLmNvbW1zO1xuICAgICAgICBmb3IgKGlkIGluIHJlZikge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHJlZltpZF07XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4odXBkYXRlX2NvbW1zKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1fbWFuYWdlci5yZWdpc3Rlcl90YXJnZXQodGFyZ2V0LCBmdW5jdGlvbiAoY29tbSwgbXNnKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5pbmZvKFwiUmVnaXN0ZXJpbmcgSnVweXRlciBjb21tcyBmb3IgdGFyZ2V0IFwiICsgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbS5vbl9tc2coX2hhbmRsZV9ub3RlYm9va19jb21tcy5iaW5kKGRvYykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICAgICAgZSA9IGVycm9yMTtcbiAgICAgICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJKdXB5dGVyIGNvbW1zIGZhaWxlZCB0byByZWdpc3Rlci4gcHVzaF9ub3RlYm9vaygpIHdpbGwgbm90IGZ1bmN0aW9uLiAoZXhjZXB0aW9uIHJlcG9ydGVkOiBcIiArIGUgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ0p1cHl0ZXIgbm90ZWJvb2tzIGNvbW1zIG5vdCBhdmFpbGFibGUuIHB1c2hfbm90ZWJvb2soKSB3aWxsIG5vdCBmdW5jdGlvbicpO1xuICAgIH1cbn07XG5fY3JlYXRlX3ZpZXcgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICB2YXIgdmlldztcbiAgICB2aWV3ID0gbmV3IG1vZGVsLmRlZmF1bHRfdmlldyh7XG4gICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgcGFyZW50OiBudWxsXG4gICAgfSk7XG4gICAgYmFzZS5pbmRleFttb2RlbC5pZF0gPSB2aWV3O1xuICAgIHJldHVybiB2aWV3O1xufTtcbl9yZW5kZXJfZG9jdW1lbnRfdG9fZWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBkb2N1bWVudCwgdXNlX2Zvcl90aXRsZSkge1xuICAgIHZhciBpLCBsZW4sIG1vZGVsLCByZWYsIHJlbmRlcl9tb2RlbCwgdW5yZW5kZXJfbW9kZWwsIHZpZXdzO1xuICAgIHZpZXdzID0ge307XG4gICAgcmVuZGVyX21vZGVsID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHZhciB2aWV3O1xuICAgICAgICB2aWV3ID0gX2NyZWF0ZV92aWV3KG1vZGVsKTtcbiAgICAgICAgdmlldy5yZW5kZXJUbyhlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHZpZXdzW21vZGVsLmlkXSA9IHZpZXc7XG4gICAgfTtcbiAgICB1bnJlbmRlcl9tb2RlbCA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICB2YXIgdmlldztcbiAgICAgICAgaWYgKG1vZGVsLmlkIGluIHZpZXdzKSB7XG4gICAgICAgICAgICB2aWV3ID0gdmlld3NbbW9kZWwuaWRdO1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZCh2aWV3LmVsKTtcbiAgICAgICAgICAgIGRlbGV0ZSB2aWV3c1ttb2RlbC5pZF07XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlIGJhc2UuaW5kZXhbbW9kZWwuaWRdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZWYgPSBkb2N1bWVudC5yb290cygpO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtb2RlbCA9IHJlZltpXTtcbiAgICAgICAgcmVuZGVyX21vZGVsKG1vZGVsKTtcbiAgICB9XG4gICAgaWYgKHVzZV9mb3JfdGl0bGUpIHtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LnRpdGxlID0gZG9jdW1lbnQudGl0bGUoKTtcbiAgICB9XG4gICAgZG9jdW1lbnQub25fY2hhbmdlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBkb2N1bWVudF8xLlJvb3RBZGRlZEV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyX21vZGVsKGV2ZW50Lm1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudCBpbnN0YW5jZW9mIGRvY3VtZW50XzEuUm9vdFJlbW92ZWRFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHVucmVuZGVyX21vZGVsKGV2ZW50Lm1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1c2VfZm9yX3RpdGxlICYmIGV2ZW50IGluc3RhbmNlb2YgZG9jdW1lbnRfMS5UaXRsZUNoYW5nZWRFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudC50aXRsZSA9IGV2ZW50LnRpdGxlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZpZXdzO1xufTtcbmFkZF9tb2RlbF9zdGF0aWMgPSBmdW5jdGlvbiAoZWxlbWVudCwgbW9kZWxfaWQsIGRvYykge1xuICAgIHZhciBtb2RlbCwgdmlldztcbiAgICBtb2RlbCA9IGRvYy5nZXRfbW9kZWxfYnlfaWQobW9kZWxfaWQpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsIFwiICsgbW9kZWxfaWQgKyBcIiB3YXMgbm90IGluIGRvY3VtZW50IFwiICsgZG9jKTtcbiAgICB9XG4gICAgdmlldyA9IF9jcmVhdGVfdmlldyhtb2RlbCk7XG4gICAgcmV0dXJuIHZpZXcucmVuZGVyVG8oZWxlbWVudCwgdHJ1ZSk7XG59O1xuZXhwb3J0cy5hZGRfZG9jdW1lbnRfc3RhdGljID0gZnVuY3Rpb24gKGVsZW1lbnQsIGRvYywgdXNlX2Zvcl90aXRsZSkge1xuICAgIHJldHVybiBfcmVuZGVyX2RvY3VtZW50X3RvX2VsZW1lbnQoZWxlbWVudCwgZG9jLCB1c2VfZm9yX3RpdGxlKTtcbn07XG5leHBvcnRzLmFkZF9kb2N1bWVudF9zdGFuZGFsb25lID0gZnVuY3Rpb24gKGRvY3VtZW50LCBlbGVtZW50LCB1c2VfZm9yX3RpdGxlKSB7XG4gICAgaWYgKHVzZV9mb3JfdGl0bGUgPT0gbnVsbCkge1xuICAgICAgICB1c2VfZm9yX3RpdGxlID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBfcmVuZGVyX2RvY3VtZW50X3RvX2VsZW1lbnQoZWxlbWVudCwgZG9jdW1lbnQsIHVzZV9mb3JfdGl0bGUpO1xufTtcbl9zZXNzaW9ucyA9IHt9O1xuX2dldF9zZXNzaW9uID0gZnVuY3Rpb24gKHdlYnNvY2tldF91cmwsIHNlc3Npb25faWQsIGFyZ3Nfc3RyaW5nKSB7XG4gICAgdmFyIHN1YnNlc3Npb25zO1xuICAgIGlmICh3ZWJzb2NrZXRfdXJsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB3ZWJzb2NrZXRfdXJsXCIpO1xuICAgIH1cbiAgICBpZiAoISh3ZWJzb2NrZXRfdXJsIGluIF9zZXNzaW9ucykpIHtcbiAgICAgICAgX3Nlc3Npb25zW3dlYnNvY2tldF91cmxdID0ge307XG4gICAgfVxuICAgIHN1YnNlc3Npb25zID0gX3Nlc3Npb25zW3dlYnNvY2tldF91cmxdO1xuICAgIGlmICghKHNlc3Npb25faWQgaW4gc3Vic2Vzc2lvbnMpKSB7XG4gICAgICAgIHN1YnNlc3Npb25zW3Nlc3Npb25faWRdID0gY2xpZW50XzEucHVsbF9zZXNzaW9uKHdlYnNvY2tldF91cmwsIHNlc3Npb25faWQsIGFyZ3Nfc3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1YnNlc3Npb25zW3Nlc3Npb25faWRdO1xufTtcbmFkZF9kb2N1bWVudF9mcm9tX3Nlc3Npb24gPSBmdW5jdGlvbiAoZWxlbWVudCwgd2Vic29ja2V0X3VybCwgc2Vzc2lvbl9pZCwgdXNlX2Zvcl90aXRsZSkge1xuICAgIHZhciBhcmdzX3N0cmluZywgcHJvbWlzZTtcbiAgICBhcmdzX3N0cmluZyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyKDEpO1xuICAgIHByb21pc2UgPSBfZ2V0X3Nlc3Npb24od2Vic29ja2V0X3VybCwgc2Vzc2lvbl9pZCwgYXJnc19zdHJpbmcpO1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIF9yZW5kZXJfZG9jdW1lbnRfdG9fZWxlbWVudChlbGVtZW50LCBzZXNzaW9uLmRvY3VtZW50LCB1c2VfZm9yX3RpdGxlKTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBsb2FkIEJva2VoIHNlc3Npb24gXCIgKyBzZXNzaW9uX2lkICsgXCI6IFwiICsgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbn07XG5hZGRfbW9kZWxfZnJvbV9zZXNzaW9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIHdlYnNvY2tldF91cmwsIG1vZGVsX2lkLCBzZXNzaW9uX2lkKSB7XG4gICAgdmFyIGFyZ3Nfc3RyaW5nLCBwcm9taXNlO1xuICAgIGFyZ3Nfc3RyaW5nID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgcHJvbWlzZSA9IF9nZXRfc2Vzc2lvbih3ZWJzb2NrZXRfdXJsLCBzZXNzaW9uX2lkLCBhcmdzX3N0cmluZyk7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICB2YXIgbW9kZWwsIHZpZXc7XG4gICAgICAgIG1vZGVsID0gc2Vzc2lvbi5kb2N1bWVudC5nZXRfbW9kZWxfYnlfaWQobW9kZWxfaWQpO1xuICAgICAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkIG5vdCBmaW5kIG1vZGVsIFwiICsgbW9kZWxfaWQgKyBcIiBpbiBzZXNzaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcgPSBfY3JlYXRlX3ZpZXcobW9kZWwpO1xuICAgICAgICByZXR1cm4gdmlldy5yZW5kZXJUbyhlbGVtZW50LCB0cnVlKTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBsb2FkIEJva2VoIHNlc3Npb24gXCIgKyBzZXNzaW9uX2lkICsgXCI6IFwiICsgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbn07XG5leHBvcnRzLmluamVjdF9jc3MgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgZWxlbWVudCA9IGRvbV8xLmxpbmsoe1xuICAgICAgICBocmVmOiB1cmwsXG4gICAgICAgIHJlbDogXCJzdHlsZXNoZWV0XCIsXG4gICAgICAgIHR5cGU6IFwidGV4dC9jc3NcIlxuICAgIH0pO1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xufTtcbmV4cG9ydHMuaW5qZWN0X3Jhd19jc3MgPSBmdW5jdGlvbiAoY3NzKSB7XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgZWxlbWVudCA9IGRvbV8xLnN0eWxlKHt9LCBjc3MpO1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xufTtcbmZpbGxfcmVuZGVyX2l0ZW1fZnJvbV9zY3JpcHRfdGFnID0gZnVuY3Rpb24gKHNjcmlwdCwgaXRlbSkge1xuICAgIHZhciBpbmZvO1xuICAgIGluZm8gPSBzY3JpcHQuZGF0YXNldDtcbiAgICBpZiAoKGluZm8uYm9rZWhMb2dMZXZlbCAhPSBudWxsKSAmJiBpbmZvLmJva2VoTG9nTGV2ZWwubGVuZ3RoID4gMCkge1xuICAgICAgICBsb2dnaW5nXzEuc2V0X2xvZ19sZXZlbChpbmZvLmJva2VoTG9nTGV2ZWwpO1xuICAgIH1cbiAgICBpZiAoKGluZm8uYm9rZWhEb2NJZCAhPSBudWxsKSAmJiBpbmZvLmJva2VoRG9jSWQubGVuZ3RoID4gMCkge1xuICAgICAgICBpdGVtWydkb2NpZCddID0gaW5mby5ib2tlaERvY0lkO1xuICAgIH1cbiAgICBpZiAoKGluZm8uYm9rZWhNb2RlbElkICE9IG51bGwpICYmIGluZm8uYm9rZWhNb2RlbElkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaXRlbVsnbW9kZWxpZCddID0gaW5mby5ib2tlaE1vZGVsSWQ7XG4gICAgfVxuICAgIGlmICgoaW5mby5ib2tlaFNlc3Npb25JZCAhPSBudWxsKSAmJiBpbmZvLmJva2VoU2Vzc2lvbklkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaXRlbVsnc2Vzc2lvbmlkJ10gPSBpbmZvLmJva2VoU2Vzc2lvbklkO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci5pbmZvKFwiV2lsbCBpbmplY3QgQm9rZWggc2NyaXB0IHRhZyB3aXRoIHBhcmFtcyBcIiArIChKU09OLnN0cmluZ2lmeShpdGVtKSkpO1xufTtcbmV4cG9ydHMuZW1iZWRfaXRlbXMgPSBmdW5jdGlvbiAoZG9jc19qc29uLCByZW5kZXJfaXRlbXMsIGFwcF9wYXRoLCBhYnNvbHV0ZV91cmwpIHtcbiAgICB2YXIgY2hpbGQsIGNvbnRhaW5lciwgZG9jaWQsIGRvY3MsIGVsZW0sIGVsZW1lbnRfaWQsIGksIGl0ZW0sIGxlbiwgbG9jLCBwcm9taXNlLCBwcm90b2NvbCwgcmVzdWx0cywgdXNlX2Zvcl90aXRsZSwgd2Vic29ja2V0X3VybDtcbiAgICBwcm90b2NvbCA9ICd3czonO1xuICAgIGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICAgIHByb3RvY29sID0gJ3dzczonO1xuICAgIH1cbiAgICBpZiAoYWJzb2x1dGVfdXJsICE9IG51bGwpIHtcbiAgICAgICAgbG9jID0gbmV3IFVSTChhYnNvbHV0ZV91cmwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9jID0gd2luZG93LmxvY2F0aW9uO1xuICAgIH1cbiAgICBpZiAoYXBwX3BhdGggIT0gbnVsbCkge1xuICAgICAgICBpZiAoYXBwX3BhdGggPT09IFwiL1wiKSB7XG4gICAgICAgICAgICBhcHBfcGF0aCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFwcF9wYXRoID0gbG9jLnBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgJycpO1xuICAgIH1cbiAgICB3ZWJzb2NrZXRfdXJsID0gcHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3QgKyBhcHBfcGF0aCArICcvd3MnO1xuICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJlbWJlZDogY29tcHV0ZWQgd3MgdXJsOiBcIiArIHdlYnNvY2tldF91cmwpO1xuICAgIGRvY3MgPSB7fTtcbiAgICBmb3IgKGRvY2lkIGluIGRvY3NfanNvbikge1xuICAgICAgICBkb2NzW2RvY2lkXSA9IGRvY3VtZW50XzEuRG9jdW1lbnQuZnJvbV9qc29uKGRvY3NfanNvbltkb2NpZF0pO1xuICAgIH1cbiAgICByZXN1bHRzID0gW107XG4gICAgZm9yIChpID0gMCwgbGVuID0gcmVuZGVyX2l0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSByZW5kZXJfaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtLm5vdGVib29rX2NvbW1zX3RhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBfaW5pdF9jb21tcyhpdGVtLm5vdGVib29rX2NvbW1zX3RhcmdldCwgZG9jc1tkb2NpZF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRfaWQgPSBpdGVtWydlbGVtZW50aWQnXTtcbiAgICAgICAgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRfaWQpO1xuICAgICAgICBpZiAoZWxlbSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciByZW5kZXJpbmcgQm9rZWggbW9kZWw6IGNvdWxkIG5vdCBmaW5kIHRhZyB3aXRoIGlkOiBcIiArIGVsZW1lbnRfaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhlbGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcmVuZGVyaW5nIEJva2VoIG1vZGVsOiBlbGVtZW50IHdpdGggaWQgJ1wiICsgZWxlbWVudF9pZCArIFwiJyBtdXN0IGJlIHVuZGVyIDxib2R5PlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbS50YWdOYW1lID09PSBcIlNDUklQVFwiKSB7XG4gICAgICAgICAgICBmaWxsX3JlbmRlcl9pdGVtX2Zyb21fc2NyaXB0X3RhZyhlbGVtLCBpdGVtKTtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvbV8xLmRpdih7XG4gICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBleHBvcnRzLkJPS0VIX1JPT1RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9tXzEucmVwbGFjZVdpdGgoZWxlbSwgY29udGFpbmVyKTtcbiAgICAgICAgICAgIGNoaWxkID0gZG9tXzEuZGl2KCk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgZWxlbSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIHVzZV9mb3JfdGl0bGUgPSAoaXRlbS51c2VfZm9yX3RpdGxlICE9IG51bGwpICYmIGl0ZW0udXNlX2Zvcl90aXRsZTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgICAgIGlmIChpdGVtLm1vZGVsaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uZG9jaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFkZF9tb2RlbF9zdGF0aWMoZWxlbSwgaXRlbS5tb2RlbGlkLCBkb2NzW2l0ZW0uZG9jaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uc2Vzc2lvbmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gYWRkX21vZGVsX2Zyb21fc2Vzc2lvbihlbGVtLCB3ZWJzb2NrZXRfdXJsLCBpdGVtLm1vZGVsaWQsIGl0ZW0uc2Vzc2lvbmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHJlbmRlcmluZyBCb2tlaCBtb2RlbCBcIiArIGl0ZW1bJ21vZGVsaWQnXSArIFwiIHRvIGVsZW1lbnQgXCIgKyBlbGVtZW50X2lkICsgXCI6IG5vIGRvY3VtZW50IElEIG9yIHNlc3Npb24gSUQgc3BlY2lmaWVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGl0ZW0uZG9jaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuYWRkX2RvY3VtZW50X3N0YXRpYyhlbGVtLCBkb2NzW2l0ZW0uZG9jaWRdLCB1c2VfZm9yX3RpdGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uc2Vzc2lvbmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gYWRkX2RvY3VtZW50X2Zyb21fc2Vzc2lvbihlbGVtLCB3ZWJzb2NrZXRfdXJsLCBpdGVtLnNlc3Npb25pZCwgdXNlX2Zvcl90aXRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciByZW5kZXJpbmcgQm9rZWggZG9jdW1lbnQgdG8gZWxlbWVudCBcIiArIGVsZW1lbnRfaWQgKyBcIjogbm8gZG9jdW1lbnQgSUQgb3Igc2Vzc2lvbiBJRCBzcGVjaWZpZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21pc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKFwiQm9rZWggaXRlbXMgd2VyZSByZW5kZXJlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS5sb2coXCJFcnJvciByZW5kZXJpbmcgQm9rZWggaXRlbXMgXCIsIGVycm9yKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xucmVxdWlyZShcIi4vcG9seWZpbGxcIik7XG52YXIgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb25fMS52ZXJzaW9uO1xudmFyIGVtYmVkID0gcmVxdWlyZShcIi4vZW1iZWRcIik7XG5leHBvcnRzLmVtYmVkID0gZW1iZWQ7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vY29yZS9sb2dnaW5nXCIpO1xuZXhwb3J0cy5sb2dnZXIgPSBsb2dnaW5nXzEubG9nZ2VyO1xuZXhwb3J0cy5zZXRfbG9nX2xldmVsID0gbG9nZ2luZ18xLnNldF9sb2dfbGV2ZWw7XG52YXIgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL2NvcmUvc2V0dGluZ3NcIik7XG5leHBvcnRzLnNldHRpbmdzID0gc2V0dGluZ3NfMS5zZXR0aW5ncztcbnZhciBiYXNlXzEgPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuZXhwb3J0cy5Nb2RlbHMgPSBiYXNlXzEuTW9kZWxzO1xuZXhwb3J0cy5pbmRleCA9IGJhc2VfMS5pbmRleDtcbnZhciBkb2N1bWVudF8xID0gcmVxdWlyZShcIi4vZG9jdW1lbnRcIik7XG5leHBvcnRzLmRvY3VtZW50cyA9IGRvY3VtZW50XzEuZG9jdW1lbnRzO1xudmFyIHNhZmVseV8xID0gcmVxdWlyZShcIi4vc2FmZWx5XCIpO1xuZXhwb3J0cy5zYWZlbHkgPSBzYWZlbHlfMS5zYWZlbHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgaGFzX3Byb3BzXzEgPSByZXF1aXJlKFwiLi9jb3JlL2hhc19wcm9wc1wiKTtcbnZhciBwID0gcmVxdWlyZShcIi4vY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWwvdHlwZXNcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWwvb2JqZWN0XCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2NvcmUvbG9nZ2luZ1wiKTtcbmV4cG9ydHMuTW9kZWwgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTW9kZWwsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIE1vZGVsKCkge1xuICAgICAgICByZXR1cm4gTW9kZWwuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1vZGVsLnByb3RvdHlwZS50eXBlID0gXCJNb2RlbFwiO1xuICAgIE1vZGVsLmRlZmluZSh7XG4gICAgICAgIHRhZ3M6IFtwLkFycmF5LCBbXV0sXG4gICAgICAgIG5hbWU6IFtwLlN0cmluZ10sXG4gICAgICAgIGpzX3Byb3BlcnR5X2NhbGxiYWNrczogW3AuQW55LCB7fV0sXG4gICAgICAgIGpzX2V2ZW50X2NhbGxiYWNrczogW3AuQW55LCB7fV0sXG4gICAgICAgIHN1YnNjcmliZWRfZXZlbnRzOiBbcC5BcnJheSwgW11dXG4gICAgfSk7XG4gICAgTW9kZWwucHJvdG90eXBlLmNvbm5lY3Rfc2lnbmFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGF0dHIsIGNhbGxiYWNrcywgY2IsIGV2dCwgaSwgbGVuLCByZWYxLCByZWYyLCByZWYzO1xuICAgICAgICBNb2RlbC5fX3N1cGVyX18uY29ubmVjdF9zaWduYWxzLmNhbGwodGhpcyk7XG4gICAgICAgIHJlZjEgPSB0aGlzLmpzX3Byb3BlcnR5X2NhbGxiYWNrcztcbiAgICAgICAgZm9yIChldnQgaW4gcmVmMSkge1xuICAgICAgICAgICAgY2FsbGJhY2tzID0gcmVmMVtldnRdO1xuICAgICAgICAgICAgcmVmMiA9IGV2dC5zcGxpdCgnOicpLCBldnQgPSByZWYyWzBdLCBhdHRyID0gKHJlZjMgPSByZWYyWzFdKSAhPSBudWxsID8gcmVmMyA6IG51bGw7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5wcm9wZXJ0aWVzW2F0dHJdW2V2dF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYi5leGVjdXRlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCh0aGlzW2V2dF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYi5leGVjdXRlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMucHJvcGVydGllcy5qc19ldmVudF9jYWxsYmFja3MuY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlX2V2ZW50X2NhbGxiYWNrcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5wcm9wZXJ0aWVzLnN1YnNjcmliZWRfZXZlbnRzLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZV9ldmVudF9jYWxsYmFja3M7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLl9wcm9jZXNzX2V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjYWxsYmFjaywgaSwgbGVuLCByZWYxLCByZWYyO1xuICAgICAgICBpZiAoZXZlbnQuaXNfYXBwbGljYWJsZV90byh0aGlzKSkge1xuICAgICAgICAgICAgZXZlbnQgPSBldmVudC5fY3VzdG9taXplX2V2ZW50KHRoaXMpO1xuICAgICAgICAgICAgcmVmMiA9IChyZWYxID0gdGhpcy5qc19ldmVudF9jYWxsYmFja3NbZXZlbnQuZXZlbnRfbmFtZV0pICE9IG51bGwgPyByZWYxIDogW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSByZWYyW2ldO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmV4ZWN1dGUoZXZlbnQsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmliZWRfZXZlbnRzLnNvbWUoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbSA9PT0gZXZlbnQuZXZlbnRfbmFtZTtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuZXZlbnRfbWFuYWdlci5zZW5kX2V2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnRyaWdnZXJfZXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHJlZjE7XG4gICAgICAgIHJldHVybiAocmVmMSA9IHRoaXMuZG9jdW1lbnQpICE9IG51bGwgPyByZWYxLmV2ZW50X21hbmFnZXIudHJpZ2dlcihldmVudC5zZXRfbW9kZWxfaWQodGhpcy5pZCkpIDogdm9pZCAwO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLl91cGRhdGVfZXZlbnRfY2FsbGJhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oJ1dBUk5JTkc6IERvY3VtZW50IG5vdCBkZWZpbmVkIGZvciB1cGRhdGluZyBldmVudCBjYWxsYmFja3MnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5ldmVudF9tYW5hZ2VyLnN1YnNjcmliZWRfbW9kZWxzLnB1c2godGhpcy5pZCk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuX2RvY19hdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFvYmplY3RfMS5pc0VtcHR5KHRoaXMuanNfZXZlbnRfY2FsbGJhY2tzKSB8fCAhb2JqZWN0XzEuaXNFbXB0eSh0aGlzLnN1YnNjcmliZWRfZXZlbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZV9ldmVudF9jYWxsYmFja3MoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICBpZiAoc2VsZWN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZXMoKS5maWx0ZXIoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWYgaW5zdGFuY2VvZiBzZWxlY3RvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNTdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VzKCkuZmlsdGVyKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmLm5hbWUgPT09IHNlbGVjdG9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlbGVjdG9yXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuc2VsZWN0X29uZSA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSB0aGlzLnNlbGVjdChzZWxlY3Rvcik7XG4gICAgICAgIHN3aXRjaCAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvdW5kIG1vcmUgdGhhbiBvbmUgb2JqZWN0IG1hdGNoaW5nIGdpdmVuIHNlbGVjdG9yXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTW9kZWw7XG59KShoYXNfcHJvcHNfMS5IYXNQcm9wcyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgc2lkZV9wYW5lbF8xID0gcmVxdWlyZShcImNvcmUvbGF5b3V0L3NpZGVfcGFuZWxcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuLi9yZW5kZXJlcnMvcmVuZGVyZXJcIik7XG5leHBvcnRzLkFubm90YXRpb25WaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFubm90YXRpb25WaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBbm5vdGF0aW9uVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEFubm90YXRpb25WaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUuX2dldF9wYW5lbF9vZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB4LCB5O1xuICAgICAgICB4ID0gdGhpcy5tb2RlbC5wYW5lbC5fbGVmdC52YWx1ZTtcbiAgICAgICAgeSA9IHRoaXMubW9kZWwucGFuZWwuX2JvdHRvbS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiAteVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQW5ub3RhdGlvblZpZXcucHJvdG90eXBlLl9nZXRfc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgcmV0dXJuIEFubm90YXRpb25WaWV3O1xufSkocmVuZGVyZXJfMS5SZW5kZXJlclZpZXcpO1xuZXhwb3J0cy5Bbm5vdGF0aW9uID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFubm90YXRpb24sIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFubm90YXRpb24oKSB7XG4gICAgICAgIHJldHVybiBBbm5vdGF0aW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBbm5vdGF0aW9uLnByb3RvdHlwZS50eXBlID0gJ0Fubm90YXRpb24nO1xuICAgIEFubm90YXRpb24ucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuQW5ub3RhdGlvblZpZXc7XG4gICAgQW5ub3RhdGlvbi5kZWZpbmUoe1xuICAgICAgICBwbG90OiBbcC5JbnN0YW5jZV1cbiAgICB9KTtcbiAgICBBbm5vdGF0aW9uLm92ZXJyaWRlKHtcbiAgICAgICAgbGV2ZWw6ICdhbm5vdGF0aW9uJ1xuICAgIH0pO1xuICAgIEFubm90YXRpb24ucHJvdG90eXBlLmFkZF9wYW5lbCA9IGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgIHRoaXMucGFuZWwgPSBuZXcgc2lkZV9wYW5lbF8xLlNpZGVQYW5lbCh7XG4gICAgICAgICAgICBzaWRlOiBzaWRlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhbmVsLmF0dGFjaF9kb2N1bWVudCh0aGlzLmRvY3VtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWwgPSAnb3ZlcmxheSc7XG4gICAgfTtcbiAgICByZXR1cm4gQW5ub3RhdGlvbjtcbn0pKHJlbmRlcmVyXzEuUmVuZGVyZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL2Fubm90YXRpb25cIik7XG52YXIgYXJyb3dfaGVhZF8xID0gcmVxdWlyZShcIi4vYXJyb3dfaGVhZFwiKTtcbnZhciBjb2x1bW5fZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuLi9zb3VyY2VzL2NvbHVtbl9kYXRhX3NvdXJjZVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBtYXRoXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL21hdGhcIik7XG5leHBvcnRzLkFycm93VmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBcnJvd1ZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFycm93VmlldygpIHtcbiAgICAgICAgcmV0dXJuIEFycm93Vmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQXJyb3dWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgQXJyb3dWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnNvdXJjZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNvdXJjZSA9IG5ldyBjb2x1bW5fZGF0YV9zb3VyY2VfMS5Db2x1bW5EYXRhU291cmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLnBsb3RfbW9kZWwuY2FudmFzO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRfZGF0YSh0aGlzLm1vZGVsLnNvdXJjZSk7XG4gICAgfTtcbiAgICBBcnJvd1ZpZXcucHJvdG90eXBlLmNvbm5lY3Rfc2lnbmFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQXJyb3dWaWV3Ll9fc3VwZXJfXy5jb25uZWN0X3NpZ25hbHMuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wbG90X3ZpZXcucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuc291cmNlLnN0cmVhbWluZywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0X2RhdGEodGhpcy5tb2RlbC5zb3VyY2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuc291cmNlLnBhdGNoaW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRfZGF0YSh0aGlzLm1vZGVsLnNvdXJjZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuc291cmNlLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0X2RhdGEodGhpcy5tb2RlbC5zb3VyY2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFycm93Vmlldy5wcm90b3R5cGUuc2V0X2RhdGEgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIEFycm93Vmlldy5fX3N1cGVyX18uc2V0X2RhdGEuY2FsbCh0aGlzLCBzb3VyY2UpO1xuICAgICAgICB0aGlzLnZpc3VhbHMud2FybV9jYWNoZShzb3VyY2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5wbG90X3ZpZXcucmVxdWVzdF9yZW5kZXIoKTtcbiAgICB9O1xuICAgIEFycm93Vmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW5kLCBzdGFydCwgeF9uYW1lLCB5X25hbWU7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnN0YXJ0X3VuaXRzID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5wbG90X3ZpZXcubWFwX3RvX3NjcmVlbih0aGlzLl94X3N0YXJ0LCB0aGlzLl95X3N0YXJ0LCB4X25hbWUgPSB0aGlzLm1vZGVsLnhfcmFuZ2VfbmFtZSwgeV9uYW1lID0gdGhpcy5tb2RlbC55X3JhbmdlX25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBbdGhpcy5jYW52YXMudl92eF90b19zeCh0aGlzLl94X3N0YXJ0KSwgdGhpcy5jYW52YXMudl92eV90b19zeSh0aGlzLl95X3N0YXJ0KV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwuZW5kX3VuaXRzID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMucGxvdF92aWV3Lm1hcF90b19zY3JlZW4odGhpcy5feF9lbmQsIHRoaXMuX3lfZW5kLCB4X25hbWUgPSB0aGlzLm1vZGVsLnhfcmFuZ2VfbmFtZSwgeV9uYW1lID0gdGhpcy5tb2RlbC55X3JhbmdlX25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kID0gW3RoaXMuY2FudmFzLnZfdnhfdG9fc3godGhpcy5feF9lbmQpLCB0aGlzLmNhbnZhcy52X3Z5X3RvX3N5KHRoaXMuX3lfZW5kKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzdGFydCwgZW5kXTtcbiAgICB9O1xuICAgIEFycm93Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3R4LCByZWY7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzX3ZpZXcuY3R4O1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICByZWYgPSB0aGlzLl9tYXBfZGF0YSgpLCB0aGlzLnN0YXJ0ID0gcmVmWzBdLCB0aGlzLmVuZCA9IHJlZlsxXTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fycm93X2hlYWQoY3R4LCBcInJlbmRlclwiLCB0aGlzLm1vZGVsLmVuZCwgdGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fycm93X2hlYWQoY3R4LCBcInJlbmRlclwiLCB0aGlzLm1vZGVsLnN0YXJ0LCB0aGlzLmVuZCwgdGhpcy5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucmVjdCgwLCAwLCB0aGlzLmNhbnZhcy5fd2lkdGgudmFsdWUsIHRoaXMuY2FudmFzLl9oZWlnaHQudmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fYXJyb3dfaGVhZChjdHgsIFwiY2xpcFwiLCB0aGlzLm1vZGVsLmVuZCwgdGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fycm93X2hlYWQoY3R4LCBcImNsaXBcIiwgdGhpcy5tb2RlbC5zdGFydCwgdGhpcy5lbmQsIHRoaXMuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgdGhpcy5fYXJyb3dfYm9keShjdHgpO1xuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIEFycm93Vmlldy5wcm90b3R5cGUuX2Fycm93X2JvZHkgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBpLCBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIGlmICghdGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRoaXMuX3hfc3RhcnQubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy5zdGFydFswXVtpXSwgdGhpcy5zdGFydFsxXVtpXSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHRoaXMuZW5kWzBdW2ldLCB0aGlzLmVuZFsxXVtpXSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnN0cm9rZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEFycm93Vmlldy5wcm90b3R5cGUuX2Fycm93X2hlYWQgPSBmdW5jdGlvbiAoY3R4LCBhY3Rpb24sIGhlYWQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIGFuZ2xlLCBpLCBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRoaXMuX3hfc3RhcnQubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5QSSAvIDIgKyBtYXRoXzEuYXRhbjIoW3N0YXJ0WzBdW2ldLCBzdGFydFsxXVtpXV0sIFtlbmRbMF1baV0sIGVuZFsxXVtpXV0pO1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoZW5kWzBdW2ldLCBlbmRbMV1baV0pO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09PSBcInJlbmRlclwiKSB7XG4gICAgICAgICAgICAgICAgaGVhZC5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJjbGlwXCIpIHtcbiAgICAgICAgICAgICAgICBoZWFkLmNsaXAoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChjdHgucmVzdG9yZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIHJldHVybiBBcnJvd1ZpZXc7XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvblZpZXcpO1xuZXhwb3J0cy5BcnJvdyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBcnJvdywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQXJyb3coKSB7XG4gICAgICAgIHJldHVybiBBcnJvdy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQXJyb3cucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuQXJyb3dWaWV3O1xuICAgIEFycm93LnByb3RvdHlwZS50eXBlID0gJ0Fycm93JztcbiAgICBBcnJvdy5taXhpbnMoWydsaW5lJ10pO1xuICAgIEFycm93LmRlZmluZSh7XG4gICAgICAgIHhfc3RhcnQ6IFtwLk51bWJlclNwZWNdLFxuICAgICAgICB5X3N0YXJ0OiBbcC5OdW1iZXJTcGVjXSxcbiAgICAgICAgc3RhcnRfdW5pdHM6IFtwLlN0cmluZywgJ2RhdGEnXSxcbiAgICAgICAgc3RhcnQ6IFtwLkluc3RhbmNlLCBudWxsXSxcbiAgICAgICAgeF9lbmQ6IFtwLk51bWJlclNwZWNdLFxuICAgICAgICB5X2VuZDogW3AuTnVtYmVyU3BlY10sXG4gICAgICAgIGVuZF91bml0czogW3AuU3RyaW5nLCAnZGF0YSddLFxuICAgICAgICBlbmQ6IFtwLkluc3RhbmNlLCBuZXcgYXJyb3dfaGVhZF8xLk9wZW5IZWFkKHt9KV0sXG4gICAgICAgIHNvdXJjZTogW3AuSW5zdGFuY2VdLFxuICAgICAgICB4X3JhbmdlX25hbWU6IFtwLlN0cmluZywgJ2RlZmF1bHQnXSxcbiAgICAgICAgeV9yYW5nZV9uYW1lOiBbcC5TdHJpbmcsICdkZWZhdWx0J11cbiAgICB9KTtcbiAgICByZXR1cm4gQXJyb3c7XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvbik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYW5ub3RhdGlvbl8xID0gcmVxdWlyZShcIi4vYW5ub3RhdGlvblwiKTtcbnZhciB2aXN1YWxzXzEgPSByZXF1aXJlKFwiY29yZS92aXN1YWxzXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5BcnJvd0hlYWQgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQXJyb3dIZWFkLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBcnJvd0hlYWQoKSB7XG4gICAgICAgIHJldHVybiBBcnJvd0hlYWQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFycm93SGVhZC5wcm90b3R5cGUudHlwZSA9ICdBcnJvd0hlYWQnO1xuICAgIEFycm93SGVhZC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIEFycm93SGVhZC5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXN1YWxzID0gbmV3IHZpc3VhbHNfMS5WaXN1YWxzKHRoaXMpO1xuICAgIH07XG4gICAgQXJyb3dIZWFkLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQXJyb3dIZWFkLnByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24gKGN0eCwgaSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBBcnJvd0hlYWQ7XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvbik7XG5leHBvcnRzLk9wZW5IZWFkID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE9wZW5IZWFkLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBPcGVuSGVhZCgpIHtcbiAgICAgICAgcmV0dXJuIE9wZW5IZWFkLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBPcGVuSGVhZC5wcm90b3R5cGUudHlwZSA9ICdPcGVuSGVhZCc7XG4gICAgT3BlbkhlYWQucHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbiAoY3R4LCBpKSB7XG4gICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgY3R4Lm1vdmVUbygwLjUgKiB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XG4gICAgICAgIGN0eC5saW5lVG8oMC41ICogdGhpcy5zaXplLCAtMik7XG4gICAgICAgIGN0eC5saW5lVG8oLTAuNSAqIHRoaXMuc2l6ZSwgLTIpO1xuICAgICAgICBjdHgubGluZVRvKC0wLjUgKiB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgMCk7XG4gICAgICAgIHJldHVybiBjdHgubGluZVRvKDAuNSAqIHRoaXMuc2l6ZSwgdGhpcy5zaXplKTtcbiAgICB9O1xuICAgIE9wZW5IZWFkLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKDAuNSAqIHRoaXMuc2l6ZSwgdGhpcy5zaXplKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oMCwgMCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKC0wLjUgKiB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPcGVuSGVhZC5taXhpbnMoWydsaW5lJ10pO1xuICAgIE9wZW5IZWFkLmRlZmluZSh7XG4gICAgICAgIHNpemU6IFtwLk51bWJlciwgMjVdXG4gICAgfSk7XG4gICAgcmV0dXJuIE9wZW5IZWFkO1xufSkoZXhwb3J0cy5BcnJvd0hlYWQpO1xuZXhwb3J0cy5Ob3JtYWxIZWFkID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE5vcm1hbEhlYWQsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIE5vcm1hbEhlYWQoKSB7XG4gICAgICAgIHJldHVybiBOb3JtYWxIZWFkLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBOb3JtYWxIZWFkLnByb3RvdHlwZS50eXBlID0gJ05vcm1hbEhlYWQnO1xuICAgIE5vcm1hbEhlYWQucHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbiAoY3R4LCBpKSB7XG4gICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgY3R4Lm1vdmVUbygwLjUgKiB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XG4gICAgICAgIGN0eC5saW5lVG8oMC41ICogdGhpcy5zaXplLCAtMik7XG4gICAgICAgIGN0eC5saW5lVG8oLTAuNSAqIHRoaXMuc2l6ZSwgLTIpO1xuICAgICAgICBjdHgubGluZVRvKC0wLjUgKiB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XG4gICAgICAgIHJldHVybiBjdHgubGluZVRvKDAuNSAqIHRoaXMuc2l6ZSwgdGhpcy5zaXplKTtcbiAgICB9O1xuICAgIE5vcm1hbEhlYWQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGkpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5maWxsLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgIHRoaXMuX25vcm1hbChjdHgsIGkpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgdGhpcy5fbm9ybWFsKGN0eCwgaSk7XG4gICAgICAgICAgICByZXR1cm4gY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOb3JtYWxIZWFkLnByb3RvdHlwZS5fbm9ybWFsID0gZnVuY3Rpb24gKGN0eCwgaSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oMC41ICogdGhpcy5zaXplLCB0aGlzLnNpemUpO1xuICAgICAgICBjdHgubGluZVRvKDAsIDApO1xuICAgICAgICBjdHgubGluZVRvKC0wLjUgKiB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XG4gICAgICAgIHJldHVybiBjdHguY2xvc2VQYXRoKCk7XG4gICAgfTtcbiAgICBOb3JtYWxIZWFkLm1peGlucyhbJ2xpbmUnLCAnZmlsbCddKTtcbiAgICBOb3JtYWxIZWFkLmRlZmluZSh7XG4gICAgICAgIHNpemU6IFtwLk51bWJlciwgMjVdXG4gICAgfSk7XG4gICAgTm9ybWFsSGVhZC5vdmVycmlkZSh7XG4gICAgICAgIGZpbGxfY29sb3I6ICdibGFjaydcbiAgICB9KTtcbiAgICByZXR1cm4gTm9ybWFsSGVhZDtcbn0pKGV4cG9ydHMuQXJyb3dIZWFkKTtcbmV4cG9ydHMuVmVlSGVhZCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChWZWVIZWFkLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBWZWVIZWFkKCkge1xuICAgICAgICByZXR1cm4gVmVlSGVhZC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVmVlSGVhZC5wcm90b3R5cGUudHlwZSA9ICdWZWVIZWFkJztcbiAgICBWZWVIZWFkLnByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24gKGN0eCwgaSkge1xuICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIGN0eC5tb3ZlVG8oMC41ICogdGhpcy5zaXplLCB0aGlzLnNpemUpO1xuICAgICAgICBjdHgubGluZVRvKDAuNSAqIHRoaXMuc2l6ZSwgLTIpO1xuICAgICAgICBjdHgubGluZVRvKC0wLjUgKiB0aGlzLnNpemUsIC0yKTtcbiAgICAgICAgY3R4LmxpbmVUbygtMC41ICogdGhpcy5zaXplLCB0aGlzLnNpemUpO1xuICAgICAgICBjdHgubGluZVRvKDAsIDAuNSAqIHRoaXMuc2l6ZSk7XG4gICAgICAgIHJldHVybiBjdHgubGluZVRvKDAuNSAqIHRoaXMuc2l6ZSwgdGhpcy5zaXplKTtcbiAgICB9O1xuICAgIFZlZUhlYWQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGkpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5maWxsLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgIHRoaXMuX3ZlZShjdHgsIGkpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgdGhpcy5fdmVlKGN0eCwgaSk7XG4gICAgICAgICAgICByZXR1cm4gY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWZWVIZWFkLnByb3RvdHlwZS5fdmVlID0gZnVuY3Rpb24gKGN0eCwgaSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oMC41ICogdGhpcy5zaXplLCB0aGlzLnNpemUpO1xuICAgICAgICBjdHgubGluZVRvKDAsIDApO1xuICAgICAgICBjdHgubGluZVRvKC0wLjUgKiB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgMC41ICogdGhpcy5zaXplKTtcbiAgICAgICAgcmV0dXJuIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9O1xuICAgIFZlZUhlYWQubWl4aW5zKFsnbGluZScsICdmaWxsJ10pO1xuICAgIFZlZUhlYWQuZGVmaW5lKHtcbiAgICAgICAgc2l6ZTogW3AuTnVtYmVyLCAyNV1cbiAgICB9KTtcbiAgICBWZWVIZWFkLm92ZXJyaWRlKHtcbiAgICAgICAgZmlsbF9jb2xvcjogJ2JsYWNrJ1xuICAgIH0pO1xuICAgIHJldHVybiBWZWVIZWFkO1xufSkoZXhwb3J0cy5BcnJvd0hlYWQpO1xuZXhwb3J0cy5UZWVIZWFkID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRlZUhlYWQsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRlZUhlYWQoKSB7XG4gICAgICAgIHJldHVybiBUZWVIZWFkLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUZWVIZWFkLnByb3RvdHlwZS50eXBlID0gJ1RlZUhlYWQnO1xuICAgIFRlZUhlYWQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGkpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oMC41ICogdGhpcy5zaXplLCAwKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oLTAuNSAqIHRoaXMuc2l6ZSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZWVIZWFkLm1peGlucyhbJ2xpbmUnXSk7XG4gICAgVGVlSGVhZC5kZWZpbmUoe1xuICAgICAgICBzaXplOiBbcC5OdW1iZXIsIDI1XVxuICAgIH0pO1xuICAgIHJldHVybiBUZWVIZWFkO1xufSkoZXhwb3J0cy5BcnJvd0hlYWQpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL2Fubm90YXRpb25cIik7XG52YXIgY29sdW1uX2RhdGFfc291cmNlXzEgPSByZXF1aXJlKFwiLi4vc291cmNlcy9jb2x1bW5fZGF0YV9zb3VyY2VcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkJhbmRWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEJhbmRWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBCYW5kVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEJhbmRWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCYW5kVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIEJhbmRWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLnNldF9kYXRhKHRoaXMubW9kZWwuc291cmNlKTtcbiAgICB9O1xuICAgIEJhbmRWaWV3LnByb3RvdHlwZS5jb25uZWN0X3NpZ25hbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIEJhbmRWaWV3Ll9fc3VwZXJfXy5jb25uZWN0X3NpZ25hbHMuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuc291cmNlLnN0cmVhbWluZywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0X2RhdGEodGhpcy5tb2RlbC5zb3VyY2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuc291cmNlLnBhdGNoaW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRfZGF0YSh0aGlzLm1vZGVsLnNvdXJjZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuc291cmNlLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0X2RhdGEodGhpcy5tb2RlbC5zb3VyY2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhbmRWaWV3LnByb3RvdHlwZS5zZXRfZGF0YSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgQmFuZFZpZXcuX19zdXBlcl9fLnNldF9kYXRhLmNhbGwodGhpcywgc291cmNlKTtcbiAgICAgICAgdGhpcy52aXN1YWxzLndhcm1fY2FjaGUoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3LnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgfTtcbiAgICBCYW5kVmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2Jhc2VfdngsIF9sb3dlciwgX2xvd2VyX3Z4LCBfdXBwZXIsIF91cHBlcl92eCwgYmFzZV9zY2FsZSwgaSwgaiwgbGltaXRfc2NhbGUsIHJlZiwgeF9zY2FsZSwgeV9zY2FsZTtcbiAgICAgICAgeF9zY2FsZSA9IHRoaXMucGxvdF92aWV3LmZyYW1lLnhzY2FsZXNbdGhpcy5tb2RlbC54X3JhbmdlX25hbWVdO1xuICAgICAgICB5X3NjYWxlID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueXNjYWxlc1t0aGlzLm1vZGVsLnlfcmFuZ2VfbmFtZV07XG4gICAgICAgIGxpbWl0X3NjYWxlID0gdGhpcy5tb2RlbC5kaW1lbnNpb24gPT09IFwiaGVpZ2h0XCIgPyB5X3NjYWxlIDogeF9zY2FsZTtcbiAgICAgICAgYmFzZV9zY2FsZSA9IHRoaXMubW9kZWwuZGltZW5zaW9uID09PSBcImhlaWdodFwiID8geF9zY2FsZSA6IHlfc2NhbGU7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmxvd2VyLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgX2xvd2VyX3Z4ID0gbGltaXRfc2NhbGUudl9jb21wdXRlKHRoaXMuX2xvd2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9sb3dlcl92eCA9IHRoaXMuX2xvd2VyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnVwcGVyLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgX3VwcGVyX3Z4ID0gbGltaXRfc2NhbGUudl9jb21wdXRlKHRoaXMuX3VwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF91cHBlcl92eCA9IHRoaXMuX3VwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmJhc2UudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICBfYmFzZV92eCA9IGJhc2Vfc2NhbGUudl9jb21wdXRlKHRoaXMuX2Jhc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2Jhc2VfdnggPSB0aGlzLl9iYXNlO1xuICAgICAgICB9XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwuX25vcm1hbHMoKSwgaSA9IHJlZlswXSwgaiA9IHJlZlsxXTtcbiAgICAgICAgX2xvd2VyID0gW19sb3dlcl92eCwgX2Jhc2VfdnhdO1xuICAgICAgICBfdXBwZXIgPSBbX3VwcGVyX3Z4LCBfYmFzZV92eF07XG4gICAgICAgIHRoaXMuX2xvd2VyX3N4ID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcy52X3Z4X3RvX3N4KF9sb3dlcltpXSk7XG4gICAgICAgIHRoaXMuX2xvd2VyX3N5ID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcy52X3Z5X3RvX3N5KF9sb3dlcltqXSk7XG4gICAgICAgIHRoaXMuX3VwcGVyX3N4ID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcy52X3Z4X3RvX3N4KF91cHBlcltpXSk7XG4gICAgICAgIHJldHVybiB0aGlzLl91cHBlcl9zeSA9IHRoaXMucGxvdF9tb2RlbC5jYW52YXMudl92eV90b19zeShfdXBwZXJbal0pO1xuICAgIH07XG4gICAgQmFuZFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN0eCwgaSwgaywgbCwgbSwgbiwgcmVmLCByZWYxLCByZWYyLCByZWYzO1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcF9kYXRhKCk7XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMuX2xvd2VyX3N4WzBdLCB0aGlzLl9sb3dlcl9zeVswXSk7XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYgPSB0aGlzLl9sb3dlcl9zeC5sZW5ndGg7IDAgPD0gcmVmID8gayA8IHJlZiA6IGsgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLl9sb3dlcl9zeFtpXSwgdGhpcy5fbG93ZXJfc3lbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGwgPSByZWYxID0gdGhpcy5fdXBwZXJfc3gubGVuZ3RoIC0gMTsgcmVmMSA8PSAwID8gbCA8PSAwIDogbCA+PSAwOyBpID0gcmVmMSA8PSAwID8gKytsIDogLS1sKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHRoaXMuX3VwcGVyX3N4W2ldLCB0aGlzLl91cHBlcl9zeVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmZpbGwuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLl9sb3dlcl9zeFswXSwgdGhpcy5fbG93ZXJfc3lbMF0pO1xuICAgICAgICBmb3IgKGkgPSBtID0gMCwgcmVmMiA9IHRoaXMuX2xvd2VyX3N4Lmxlbmd0aDsgMCA8PSByZWYyID8gbSA8IHJlZjIgOiBtID4gcmVmMjsgaSA9IDAgPD0gcmVmMiA/ICsrbSA6IC0tbSkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLl9sb3dlcl9zeFtpXSwgdGhpcy5fbG93ZXJfc3lbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8odGhpcy5fdXBwZXJfc3hbMF0sIHRoaXMuX3VwcGVyX3N5WzBdKTtcbiAgICAgICAgZm9yIChpID0gbiA9IDAsIHJlZjMgPSB0aGlzLl91cHBlcl9zeC5sZW5ndGg7IDAgPD0gcmVmMyA/IG4gPCByZWYzIDogbiA+IHJlZjM7IGkgPSAwIDw9IHJlZjMgPyArK24gOiAtLW4pIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5fdXBwZXJfc3hbaV0sIHRoaXMuX3VwcGVyX3N5W2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQmFuZFZpZXc7XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvblZpZXcpO1xuZXhwb3J0cy5CYW5kID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEJhbmQsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEJhbmQoKSB7XG4gICAgICAgIHJldHVybiBCYW5kLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCYW5kLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkJhbmRWaWV3O1xuICAgIEJhbmQucHJvdG90eXBlLnR5cGUgPSAnQmFuZCc7XG4gICAgQmFuZC5taXhpbnMoWydsaW5lJywgJ2ZpbGwnXSk7XG4gICAgQmFuZC5kZWZpbmUoe1xuICAgICAgICBsb3dlcjogW3AuRGlzdGFuY2VTcGVjXSxcbiAgICAgICAgdXBwZXI6IFtwLkRpc3RhbmNlU3BlY10sXG4gICAgICAgIGJhc2U6IFtwLkRpc3RhbmNlU3BlY10sXG4gICAgICAgIGRpbWVuc2lvbjogW3AuRGltZW5zaW9uLCAnaGVpZ2h0J10sXG4gICAgICAgIHNvdXJjZTogW1xuICAgICAgICAgICAgcC5JbnN0YW5jZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY29sdW1uX2RhdGFfc291cmNlXzEuQ29sdW1uRGF0YVNvdXJjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICB4X3JhbmdlX25hbWU6IFtwLlN0cmluZywgJ2RlZmF1bHQnXSxcbiAgICAgICAgeV9yYW5nZV9uYW1lOiBbcC5TdHJpbmcsICdkZWZhdWx0J11cbiAgICB9KTtcbiAgICBCYW5kLm92ZXJyaWRlKHtcbiAgICAgICAgZmlsbF9jb2xvcjogXCIjZmZmOWJhXCIsXG4gICAgICAgIGZpbGxfYWxwaGE6IDAuNCxcbiAgICAgICAgbGluZV9jb2xvcjogXCIjY2NjY2NjXCIsXG4gICAgICAgIGxpbmVfYWxwaGE6IDAuM1xuICAgIH0pO1xuICAgIEJhbmQucHJvdG90eXBlLl9ub3JtYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgaiwgcmVmLCByZWYxO1xuICAgICAgICBpZiAodGhpcy5kaW1lbnNpb24gPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICByZWYgPSBbMSwgMF0sIGkgPSByZWZbMF0sIGogPSByZWZbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYxID0gWzAsIDFdLCBpID0gcmVmMVswXSwgaiA9IHJlZjFbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtpLCBqXTtcbiAgICB9O1xuICAgIHJldHVybiBCYW5kO1xufSkoYW5ub3RhdGlvbl8xLkFubm90YXRpb24pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL2Fubm90YXRpb25cIik7XG52YXIgc2lnbmFsaW5nXzEgPSByZXF1aXJlKFwiY29yZS9zaWduYWxpbmdcIik7XG52YXIgZG9tXzEgPSByZXF1aXJlKFwiY29yZS9kb21cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdHlwZXNcIik7XG5leHBvcnRzLkJveEFubm90YXRpb25WaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEJveEFubm90YXRpb25WaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBCb3hBbm5vdGF0aW9uVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEJveEFubm90YXRpb25WaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCb3hBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIEJveEFubm90YXRpb25WaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMucGxvdF92aWV3LmNhbnZhc19vdmVybGF5cy5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKFwiYmstc2hhZGluZ1wiKTtcbiAgICAgICAgcmV0dXJuIGRvbV8xLmhpZGUodGhpcy5lbCk7XG4gICAgfTtcbiAgICBCb3hBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUuY29ubmVjdF9zaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBCb3hBbm5vdGF0aW9uVmlldy5fX3N1cGVyX18uY29ubmVjdF9zaWduYWxzLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnJlbmRlcl9tb2RlID09PSAnY3NzJykge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5kYXRhX3VwZGF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5jaGFuZ2UsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucGxvdF92aWV3LnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5kYXRhX3VwZGF0ZSwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wbG90X3ZpZXcucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCb3hBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FudmFzLCBmcmFtZSwgc2JvdHRvbSwgc2xlZnQsIHNyaWdodCwgc3RvcCwgeHNjYWxlLCB5c2NhbGU7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC52aXNpYmxlICYmIHRoaXMubW9kZWwucmVuZGVyX21vZGUgPT09ICdjc3MnKSB7XG4gICAgICAgICAgICBkb21fMS5oaWRlKHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0aGlzLm1vZGVsLmxlZnQgPT0gbnVsbCkgJiYgKHRoaXMubW9kZWwucmlnaHQgPT0gbnVsbCkgJiYgKHRoaXMubW9kZWwudG9wID09IG51bGwpICYmICh0aGlzLm1vZGVsLmJvdHRvbSA9PSBudWxsKSkge1xuICAgICAgICAgICAgZG9tXzEuaGlkZSh0aGlzLmVsKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZyYW1lID0gdGhpcy5wbG90X21vZGVsLmZyYW1lO1xuICAgICAgICBjYW52YXMgPSB0aGlzLnBsb3RfbW9kZWwuY2FudmFzO1xuICAgICAgICB4c2NhbGUgPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS54c2NhbGVzW3RoaXMubW9kZWwueF9yYW5nZV9uYW1lXTtcbiAgICAgICAgeXNjYWxlID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueXNjYWxlc1t0aGlzLm1vZGVsLnlfcmFuZ2VfbmFtZV07XG4gICAgICAgIHNsZWZ0ID0gY2FudmFzLnZ4X3RvX3N4KHRoaXMuX2NhbGNfZGltKHRoaXMubW9kZWwubGVmdCwgdGhpcy5tb2RlbC5sZWZ0X3VuaXRzLCB4c2NhbGUsIGZyYW1lLmhfcmFuZ2Uuc3RhcnQpKTtcbiAgICAgICAgc3JpZ2h0ID0gY2FudmFzLnZ4X3RvX3N4KHRoaXMuX2NhbGNfZGltKHRoaXMubW9kZWwucmlnaHQsIHRoaXMubW9kZWwucmlnaHRfdW5pdHMsIHhzY2FsZSwgZnJhbWUuaF9yYW5nZS5lbmQpKTtcbiAgICAgICAgc2JvdHRvbSA9IGNhbnZhcy52eV90b19zeSh0aGlzLl9jYWxjX2RpbSh0aGlzLm1vZGVsLmJvdHRvbSwgdGhpcy5tb2RlbC5ib3R0b21fdW5pdHMsIHlzY2FsZSwgZnJhbWUudl9yYW5nZS5zdGFydCkpO1xuICAgICAgICBzdG9wID0gY2FudmFzLnZ5X3RvX3N5KHRoaXMuX2NhbGNfZGltKHRoaXMubW9kZWwudG9wLCB0aGlzLm1vZGVsLnRvcF91bml0cywgeXNjYWxlLCBmcmFtZS52X3JhbmdlLmVuZCkpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5yZW5kZXJfbW9kZSA9PT0gJ2NzcycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jc3NfYm94KHNsZWZ0LCBzcmlnaHQsIHNib3R0b20sIHN0b3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc19ib3goc2xlZnQsIHNyaWdodCwgc2JvdHRvbSwgc3RvcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJveEFubm90YXRpb25WaWV3LnByb3RvdHlwZS5fY3NzX2JveCA9IGZ1bmN0aW9uIChzbGVmdCwgc3JpZ2h0LCBzYm90dG9tLCBzdG9wKSB7XG4gICAgICAgIHZhciBsZCwgc2gsIHN3O1xuICAgICAgICBzdyA9IE1hdGguYWJzKHNyaWdodCAtIHNsZWZ0KTtcbiAgICAgICAgc2ggPSBNYXRoLmFicyhzYm90dG9tIC0gc3RvcCk7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IHNsZWZ0ICsgXCJweFwiO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gc3cgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gc3RvcCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5oZWlnaHQgPSBzaCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5ib3JkZXJXaWR0aCA9IHRoaXMubW9kZWwubGluZV93aWR0aC52YWx1ZSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5ib3JkZXJDb2xvciA9IHRoaXMubW9kZWwubGluZV9jb2xvci52YWx1ZTtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLm1vZGVsLmZpbGxfY29sb3IudmFsdWU7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUub3BhY2l0eSA9IHRoaXMubW9kZWwuZmlsbF9hbHBoYS52YWx1ZTtcbiAgICAgICAgbGQgPSB0aGlzLm1vZGVsLmxpbmVfZGFzaDtcbiAgICAgICAgaWYgKHR5cGVzXzEuaXNBcnJheShsZCkpIHtcbiAgICAgICAgICAgIGxkID0gbGQubGVuZ3RoIDwgMiA/IFwic29saWRcIiA6IFwiZGFzaGVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVzXzEuaXNTdHJpbmcobGQpKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmJvcmRlclN0eWxlID0gbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbV8xLnNob3codGhpcy5lbCk7XG4gICAgfTtcbiAgICBCb3hBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUuX2NhbnZhc19ib3ggPSBmdW5jdGlvbiAoc2xlZnQsIHNyaWdodCwgc2JvdHRvbSwgc3RvcCkge1xuICAgICAgICB2YXIgY3R4O1xuICAgICAgICBjdHggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3Qoc2xlZnQsIHN0b3AsIHNyaWdodCAtIHNsZWZ0LCBzYm90dG9tIC0gc3RvcCk7XG4gICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92YWx1ZShjdHgpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIEJveEFubm90YXRpb25WaWV3LnByb3RvdHlwZS5fY2FsY19kaW0gPSBmdW5jdGlvbiAoZGltLCBkaW1fdW5pdHMsIHNjYWxlLCBmcmFtZV9leHRyZW1hKSB7XG4gICAgICAgIHZhciB2ZGltO1xuICAgICAgICBpZiAoZGltICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChkaW1fdW5pdHMgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgICAgIHZkaW0gPSBzY2FsZS5jb21wdXRlKGRpbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ZGltID0gZGltO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmRpbSA9IGZyYW1lX2V4dHJlbWE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZkaW07XG4gICAgfTtcbiAgICByZXR1cm4gQm94QW5ub3RhdGlvblZpZXc7XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvblZpZXcpO1xuZXhwb3J0cy5Cb3hBbm5vdGF0aW9uID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEJveEFubm90YXRpb24sIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEJveEFubm90YXRpb24oKSB7XG4gICAgICAgIHJldHVybiBCb3hBbm5vdGF0aW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCb3hBbm5vdGF0aW9uLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkJveEFubm90YXRpb25WaWV3O1xuICAgIEJveEFubm90YXRpb24ucHJvdG90eXBlLnR5cGUgPSAnQm94QW5ub3RhdGlvbic7XG4gICAgQm94QW5ub3RhdGlvbi5taXhpbnMoWydsaW5lJywgJ2ZpbGwnXSk7XG4gICAgQm94QW5ub3RhdGlvbi5kZWZpbmUoe1xuICAgICAgICByZW5kZXJfbW9kZTogW3AuUmVuZGVyTW9kZSwgJ2NhbnZhcyddLFxuICAgICAgICB4X3JhbmdlX25hbWU6IFtwLlN0cmluZywgJ2RlZmF1bHQnXSxcbiAgICAgICAgeV9yYW5nZV9uYW1lOiBbcC5TdHJpbmcsICdkZWZhdWx0J10sXG4gICAgICAgIHRvcDogW3AuTnVtYmVyLCBudWxsXSxcbiAgICAgICAgdG9wX3VuaXRzOiBbcC5TcGF0aWFsVW5pdHMsICdkYXRhJ10sXG4gICAgICAgIGJvdHRvbTogW3AuTnVtYmVyLCBudWxsXSxcbiAgICAgICAgYm90dG9tX3VuaXRzOiBbcC5TcGF0aWFsVW5pdHMsICdkYXRhJ10sXG4gICAgICAgIGxlZnQ6IFtwLk51bWJlciwgbnVsbF0sXG4gICAgICAgIGxlZnRfdW5pdHM6IFtwLlNwYXRpYWxVbml0cywgJ2RhdGEnXSxcbiAgICAgICAgcmlnaHQ6IFtwLk51bWJlciwgbnVsbF0sXG4gICAgICAgIHJpZ2h0X3VuaXRzOiBbcC5TcGF0aWFsVW5pdHMsICdkYXRhJ11cbiAgICB9KTtcbiAgICBCb3hBbm5vdGF0aW9uLm92ZXJyaWRlKHtcbiAgICAgICAgZmlsbF9jb2xvcjogJyNmZmY5YmEnLFxuICAgICAgICBmaWxsX2FscGhhOiAwLjQsXG4gICAgICAgIGxpbmVfY29sb3I6ICcjY2NjY2NjJyxcbiAgICAgICAgbGluZV9hbHBoYTogMC4zXG4gICAgfSk7XG4gICAgQm94QW5ub3RhdGlvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBCb3hBbm5vdGF0aW9uLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhX3VwZGF0ZSA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgXCJkYXRhX3VwZGF0ZVwiKTtcbiAgICB9O1xuICAgIEJveEFubm90YXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIGJvdHRvbSwgbGVmdCwgcmlnaHQsIHRvcDtcbiAgICAgICAgbGVmdCA9IGFyZy5sZWZ0LCByaWdodCA9IGFyZy5yaWdodCwgdG9wID0gYXJnLnRvcCwgYm90dG9tID0gYXJnLmJvdHRvbTtcbiAgICAgICAgdGhpcy5zZXR2KHtcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgIGJvdHRvbTogYm90dG9tXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YV91cGRhdGUuZW1pdCgpO1xuICAgIH07XG4gICAgcmV0dXJuIEJveEFubm90YXRpb247XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvbik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMT05HX0RJTV9NQVhfU0NBTEFSLCBMT05HX0RJTV9NSU5fU0NBTEFSLCBTSE9SVF9ESU0sIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBhbm5vdGF0aW9uXzEgPSByZXF1aXJlKFwiLi9hbm5vdGF0aW9uXCIpO1xudmFyIGJhc2ljX3RpY2tlcl8xID0gcmVxdWlyZShcIi4uL3RpY2tlcnMvYmFzaWNfdGlja2VyXCIpO1xudmFyIGJhc2ljX3RpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi4vZm9ybWF0dGVycy9iYXNpY190aWNrX2Zvcm1hdHRlclwiKTtcbnZhciBsaW5lYXJfY29sb3JfbWFwcGVyXzEgPSByZXF1aXJlKFwiLi4vbWFwcGVycy9saW5lYXJfY29sb3JfbWFwcGVyXCIpO1xudmFyIGxpbmVhcl9zY2FsZV8xID0gcmVxdWlyZShcIi4uL3NjYWxlcy9saW5lYXJfc2NhbGVcIik7XG52YXIgbG9nX3NjYWxlXzEgPSByZXF1aXJlKFwiLi4vc2NhbGVzL2xvZ19zY2FsZVwiKTtcbnZhciByYW5nZTFkXzEgPSByZXF1aXJlKFwiLi4vcmFuZ2VzL3JhbmdlMWRcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgdGV4dF91dGlsID0gcmVxdWlyZShcImNvcmUvdXRpbC90ZXh0XCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9vYmplY3RcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdHlwZXNcIik7XG5TSE9SVF9ESU0gPSAyNTtcbkxPTkdfRElNX01JTl9TQ0FMQVIgPSAwLjM7XG5MT05HX0RJTV9NQVhfU0NBTEFSID0gMC44O1xuZXhwb3J0cy5Db2xvckJhclZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ29sb3JCYXJWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDb2xvckJhclZpZXcoKSB7XG4gICAgICAgIHJldHVybiBDb2xvckJhclZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvbG9yQmFyVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIENvbG9yQmFyVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0X2NhbnZhc19pbWFnZSgpO1xuICAgIH07XG4gICAgQ29sb3JCYXJWaWV3LnByb3RvdHlwZS5jb25uZWN0X3NpZ25hbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIENvbG9yQmFyVmlldy5fX3N1cGVyX18uY29ubmVjdF9zaWduYWxzLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnByb3BlcnRpZXMudmlzaWJsZS5jaGFuZ2UsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC50aWNrZXIuY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wbG90X3ZpZXcucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuZm9ybWF0dGVyLmNoYW5nZSwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucGxvdF92aWV3LnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmNvbG9yX21hcHBlciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuY29sb3JfbWFwcGVyLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldF9jYW52YXNfaW1hZ2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wbG90X3ZpZXcucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2xvckJhclZpZXcucHJvdG90eXBlLl9nZXRfcGFuZWxfb2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgeCA9IHRoaXMubW9kZWwucGFuZWwuX2xlZnQudmFsdWU7XG4gICAgICAgIHkgPSB0aGlzLm1vZGVsLnBhbmVsLl90b3AudmFsdWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogLXlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvbG9yQmFyVmlldy5wcm90b3R5cGUuX2dldF9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmJveCwgc2lkZTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuY29sb3JfbWFwcGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBiYm94ID0gdGhpcy5jb21wdXRlX2xlZ2VuZF9kaW1lbnNpb25zKCk7XG4gICAgICAgIHNpZGUgPSB0aGlzLm1vZGVsLnBhbmVsLnNpZGU7XG4gICAgICAgIGlmIChzaWRlID09PSAnYWJvdmUnIHx8IHNpZGUgPT09ICdiZWxvdycpIHtcbiAgICAgICAgICAgIHJldHVybiBiYm94LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lkZSA9PT0gJ2xlZnQnIHx8IHNpZGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiBiYm94LndpZHRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2xvckJhclZpZXcucHJvdG90eXBlLl9zZXRfY2FudmFzX2ltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVmLCBidWY4LCBjYW52YXMsIGNtYXAsIGgsIGltYWdlX2N0eCwgaW1hZ2VfZGF0YSwgaywgcGFsZXR0ZSwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZXN1bHRzLCB3O1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5jb2xvcl9tYXBwZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhbGV0dGUgPSB0aGlzLm1vZGVsLmNvbG9yX21hcHBlci5wYWxldHRlO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgcGFsZXR0ZSA9IHBhbGV0dGUuc2xpY2UoMCkucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICAgICAgICAgICAgcmVmID0gWzEsIHBhbGV0dGUubGVuZ3RoXSwgdyA9IHJlZlswXSwgaCA9IHJlZlsxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJob3Jpem9udGFsXCI6XG4gICAgICAgICAgICAgICAgcmVmMSA9IFtwYWxldHRlLmxlbmd0aCwgMV0sIHcgPSByZWYxWzBdLCBoID0gcmVmMVsxXTtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgcmVmMiA9IFt3LCBoXSwgY2FudmFzLndpZHRoID0gcmVmMlswXSwgY2FudmFzLmhlaWdodCA9IHJlZjJbMV07XG4gICAgICAgIGltYWdlX2N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpbWFnZV9kYXRhID0gaW1hZ2VfY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3LCBoKTtcbiAgICAgICAgY21hcCA9IG5ldyBsaW5lYXJfY29sb3JfbWFwcGVyXzEuTGluZWFyQ29sb3JNYXBwZXIoe1xuICAgICAgICAgICAgcGFsZXR0ZTogcGFsZXR0ZVxuICAgICAgICB9KTtcbiAgICAgICAgYnVmID0gY21hcC52X21hcF9zY3JlZW4oKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCByZWYzID0gcGFsZXR0ZS5sZW5ndGg7IDAgPD0gcmVmMyA/IGsgPCByZWYzIDogayA+IHJlZjM7IDAgPD0gcmVmMyA/IGsrKyA6IGstLSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5hcHBseSh0aGlzKSk7XG4gICAgICAgIGJ1ZjggPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgICAgICBpbWFnZV9kYXRhLmRhdGEuc2V0KGJ1ZjgpO1xuICAgICAgICBpbWFnZV9jdHgucHV0SW1hZ2VEYXRhKGltYWdlX2RhdGEsIDAsIDApO1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZSA9IGNhbnZhcztcbiAgICB9O1xuICAgIENvbG9yQmFyVmlldy5wcm90b3R5cGUuY29tcHV0ZV9sZWdlbmRfZGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGltYWdlX2RpbWVuc2lvbnMsIGltYWdlX2hlaWdodCwgaW1hZ2Vfd2lkdGgsIGxhYmVsX2V4dGVudCwgbGVnZW5kX2hlaWdodCwgbGVnZW5kX3dpZHRoLCBwYWRkaW5nLCByZWYsIHRpY2tfZXh0ZW50LCB0aXRsZV9leHRlbnQ7XG4gICAgICAgIGltYWdlX2RpbWVuc2lvbnMgPSB0aGlzLm1vZGVsLl9jb21wdXRlZF9pbWFnZV9kaW1lbnNpb25zKCk7XG4gICAgICAgIHJlZiA9IFtpbWFnZV9kaW1lbnNpb25zLmhlaWdodCwgaW1hZ2VfZGltZW5zaW9ucy53aWR0aF0sIGltYWdlX2hlaWdodCA9IHJlZlswXSwgaW1hZ2Vfd2lkdGggPSByZWZbMV07XG4gICAgICAgIGxhYmVsX2V4dGVudCA9IHRoaXMuX2dldF9sYWJlbF9leHRlbnQoKTtcbiAgICAgICAgdGl0bGVfZXh0ZW50ID0gdGhpcy5tb2RlbC5fdGl0bGVfZXh0ZW50KCk7XG4gICAgICAgIHRpY2tfZXh0ZW50ID0gdGhpcy5tb2RlbC5fdGlja19leHRlbnQoKTtcbiAgICAgICAgcGFkZGluZyA9IHRoaXMubW9kZWwucGFkZGluZztcbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVsLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgICAgICAgICBsZWdlbmRfaGVpZ2h0ID0gaW1hZ2VfaGVpZ2h0ICsgdGl0bGVfZXh0ZW50ICsgcGFkZGluZyAqIDI7XG4gICAgICAgICAgICAgICAgbGVnZW5kX3dpZHRoID0gaW1hZ2Vfd2lkdGggKyB0aWNrX2V4dGVudCArIGxhYmVsX2V4dGVudCArIHBhZGRpbmcgKiAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImhvcml6b250YWxcIjpcbiAgICAgICAgICAgICAgICBsZWdlbmRfaGVpZ2h0ID0gaW1hZ2VfaGVpZ2h0ICsgdGl0bGVfZXh0ZW50ICsgdGlja19leHRlbnQgKyBsYWJlbF9leHRlbnQgKyBwYWRkaW5nICogMjtcbiAgICAgICAgICAgICAgICBsZWdlbmRfd2lkdGggPSBpbWFnZV93aWR0aCArIHBhZGRpbmcgKiAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IGxlZ2VuZF9oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogbGVnZW5kX3dpZHRoXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDb2xvckJhclZpZXcucHJvdG90eXBlLmNvbXB1dGVfbGVnZW5kX2xvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaF9yYW5nZSwgbGVnZW5kX2RpbWVuc2lvbnMsIGxlZ2VuZF9oZWlnaHQsIGxlZ2VuZF9tYXJnaW4sIGxlZ2VuZF93aWR0aCwgbG9jYXRpb24sIHJlZiwgc3gsIHN5LCB2X3JhbmdlLCB4LCB5O1xuICAgICAgICBsZWdlbmRfZGltZW5zaW9ucyA9IHRoaXMuY29tcHV0ZV9sZWdlbmRfZGltZW5zaW9ucygpO1xuICAgICAgICByZWYgPSBbbGVnZW5kX2RpbWVuc2lvbnMuaGVpZ2h0LCBsZWdlbmRfZGltZW5zaW9ucy53aWR0aF0sIGxlZ2VuZF9oZWlnaHQgPSByZWZbMF0sIGxlZ2VuZF93aWR0aCA9IHJlZlsxXTtcbiAgICAgICAgbGVnZW5kX21hcmdpbiA9IHRoaXMubW9kZWwubWFyZ2luO1xuICAgICAgICBsb2NhdGlvbiA9IHRoaXMubW9kZWwubG9jYXRpb247XG4gICAgICAgIGhfcmFuZ2UgPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS5oX3JhbmdlO1xuICAgICAgICB2X3JhbmdlID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUudl9yYW5nZTtcbiAgICAgICAgaWYgKHR5cGVzXzEuaXNTdHJpbmcobG9jYXRpb24pKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wX2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICB4ID0gaF9yYW5nZS5zdGFydCArIGxlZ2VuZF9tYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIHkgPSB2X3JhbmdlLmVuZCAtIGxlZ2VuZF9tYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcF9jZW50ZXInOlxuICAgICAgICAgICAgICAgICAgICB4ID0gKGhfcmFuZ2UuZW5kICsgaF9yYW5nZS5zdGFydCkgLyAyIC0gbGVnZW5kX3dpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHZfcmFuZ2UuZW5kIC0gbGVnZW5kX21hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wX3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgeCA9IGhfcmFuZ2UuZW5kIC0gbGVnZW5kX21hcmdpbiAtIGxlZ2VuZF93aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHZfcmFuZ2UuZW5kIC0gbGVnZW5kX21hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyX3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgeCA9IGhfcmFuZ2UuZW5kIC0gbGVnZW5kX21hcmdpbiAtIGxlZ2VuZF93aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgeSA9ICh2X3JhbmdlLmVuZCArIHZfcmFuZ2Uuc3RhcnQpIC8gMiArIGxlZ2VuZF9oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b21fcmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICB4ID0gaF9yYW5nZS5lbmQgLSBsZWdlbmRfbWFyZ2luIC0gbGVnZW5kX3dpZHRoO1xuICAgICAgICAgICAgICAgICAgICB5ID0gdl9yYW5nZS5zdGFydCArIGxlZ2VuZF9tYXJnaW4gKyBsZWdlbmRfaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b21fY2VudGVyJzpcbiAgICAgICAgICAgICAgICAgICAgeCA9IChoX3JhbmdlLmVuZCArIGhfcmFuZ2Uuc3RhcnQpIC8gMiAtIGxlZ2VuZF93aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB2X3JhbmdlLnN0YXJ0ICsgbGVnZW5kX21hcmdpbiArIGxlZ2VuZF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbV9sZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgeCA9IGhfcmFuZ2Uuc3RhcnQgKyBsZWdlbmRfbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICB5ID0gdl9yYW5nZS5zdGFydCArIGxlZ2VuZF9tYXJnaW4gKyBsZWdlbmRfaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXJfbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIHggPSBoX3JhbmdlLnN0YXJ0ICsgbGVnZW5kX21hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgeSA9ICh2X3JhbmdlLmVuZCArIHZfcmFuZ2Uuc3RhcnQpIC8gMiArIGxlZ2VuZF9oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgICAgICB4ID0gKGhfcmFuZ2UuZW5kICsgaF9yYW5nZS5zdGFydCkgLyAyIC0gbGVnZW5kX3dpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgeSA9ICh2X3JhbmdlLmVuZCArIHZfcmFuZ2Uuc3RhcnQpIC8gMiArIGxlZ2VuZF9oZWlnaHQgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNBcnJheShsb2NhdGlvbikgJiYgbG9jYXRpb24ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB4ID0gbG9jYXRpb25bMF0sIHkgPSBsb2NhdGlvblsxXTtcbiAgICAgICAgfVxuICAgICAgICBzeCA9IHRoaXMucGxvdF92aWV3LmNhbnZhcy52eF90b19zeCh4KTtcbiAgICAgICAgc3kgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXMudnlfdG9fc3koeSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzeDogc3gsXG4gICAgICAgICAgICBzeTogc3lcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvbG9yQmFyVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3R4LCBmcmFtZV9vZmZzZXQsIGltYWdlX29mZnNldCwgbG9jYXRpb24sIHBhbmVsX29mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm1vZGVsLnZpc2libGUgfHwgKHRoaXMubW9kZWwuY29sb3JfbWFwcGVyID09IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzX3ZpZXcuY3R4O1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5wYW5lbCAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYW5lbF9vZmZzZXQgPSB0aGlzLl9nZXRfcGFuZWxfb2Zmc2V0KCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBhbmVsX29mZnNldC54LCBwYW5lbF9vZmZzZXQueSk7XG4gICAgICAgICAgICBmcmFtZV9vZmZzZXQgPSB0aGlzLl9nZXRfZnJhbWVfb2Zmc2V0KCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGZyYW1lX29mZnNldC54LCBmcmFtZV9vZmZzZXQueSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9jYXRpb24gPSB0aGlzLmNvbXB1dGVfbGVnZW5kX2xvY2F0aW9uKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUobG9jYXRpb24uc3gsIGxvY2F0aW9uLnN5KTtcbiAgICAgICAgdGhpcy5fZHJhd19iYm94KGN0eCk7XG4gICAgICAgIGltYWdlX29mZnNldCA9IHRoaXMuX2dldF9pbWFnZV9vZmZzZXQoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShpbWFnZV9vZmZzZXQueCwgaW1hZ2Vfb2Zmc2V0LnkpO1xuICAgICAgICB0aGlzLl9kcmF3X2ltYWdlKGN0eCk7XG4gICAgICAgIGlmICgodGhpcy5tb2RlbC5jb2xvcl9tYXBwZXIubG93ICE9IG51bGwpICYmICh0aGlzLm1vZGVsLmNvbG9yX21hcHBlci5oaWdoICE9IG51bGwpKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3X21ham9yX3RpY2tzKGN0eCk7XG4gICAgICAgICAgICB0aGlzLl9kcmF3X21pbm9yX3RpY2tzKGN0eCk7XG4gICAgICAgICAgICB0aGlzLl9kcmF3X21ham9yX2xhYmVscyhjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnRpdGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3X3RpdGxlKGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBDb2xvckJhclZpZXcucHJvdG90eXBlLl9kcmF3X2Jib3ggPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBiYm94O1xuICAgICAgICBiYm94ID0gdGhpcy5jb21wdXRlX2xlZ2VuZF9kaW1lbnNpb25zKCk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMuYmFja2dyb3VuZF9maWxsLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5iYWNrZ3JvdW5kX2ZpbGwuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMuYm9yZGVyX2xpbmUuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLnNldF92YWx1ZShjdHgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QoMCwgMCwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgQ29sb3JCYXJWaWV3LnByb3RvdHlwZS5fZHJhd19pbWFnZSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIGltYWdlO1xuICAgICAgICBpbWFnZSA9IHRoaXMubW9kZWwuX2NvbXB1dGVkX2ltYWdlX2RpbWVuc2lvbnMoKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnNldEltYWdlU21vb3RoaW5nRW5hYmxlZChmYWxzZSk7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMubW9kZWwuc2NhbGVfYWxwaGE7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMuYmFyX2xpbmUuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmJhcl9saW5lLnNldF92YWx1ZShjdHgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QoMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBDb2xvckJhclZpZXcucHJvdG90eXBlLl9kcmF3X21ham9yX3RpY2tzID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgaSwgaW1hZ2UsIGssIG54LCBueSwgcmVmLCByZWYxLCByZWYyLCByZWYzLCBzeCwgc3ksIHRpbiwgdG91dCwgeF9vZmZzZXQsIHlfb2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMudmlzdWFscy5tYWpvcl90aWNrX2xpbmUuZG9pdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwuX25vcm1hbHMoKSwgbnggPSByZWZbMF0sIG55ID0gcmVmWzFdO1xuICAgICAgICBpbWFnZSA9IHRoaXMubW9kZWwuX2NvbXB1dGVkX2ltYWdlX2RpbWVuc2lvbnMoKTtcbiAgICAgICAgcmVmMSA9IFtpbWFnZS53aWR0aCAqIG54LCBpbWFnZS5oZWlnaHQgKiBueV0sIHhfb2Zmc2V0ID0gcmVmMVswXSwgeV9vZmZzZXQgPSByZWYxWzFdO1xuICAgICAgICByZWYyID0gdGhpcy5tb2RlbC5fdGlja19jb29yZGluYXRlcygpLm1ham9yLCBzeCA9IHJlZjJbMF0sIHN5ID0gcmVmMlsxXTtcbiAgICAgICAgdGluID0gdGhpcy5tb2RlbC5tYWpvcl90aWNrX2luO1xuICAgICAgICB0b3V0ID0gdGhpcy5tb2RlbC5tYWpvcl90aWNrX291dDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh4X29mZnNldCwgeV9vZmZzZXQpO1xuICAgICAgICB0aGlzLnZpc3VhbHMubWFqb3JfdGlja19saW5lLnNldF92YWx1ZShjdHgpO1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmMyA9IHN4Lmxlbmd0aDsgMCA8PSByZWYzID8gayA8IHJlZjMgOiBrID4gcmVmMzsgaSA9IDAgPD0gcmVmMyA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhNYXRoLnJvdW5kKHN4W2ldICsgbnggKiB0b3V0KSwgTWF0aC5yb3VuZChzeVtpXSArIG55ICogdG91dCkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhNYXRoLnJvdW5kKHN4W2ldIC0gbnggKiB0aW4pLCBNYXRoLnJvdW5kKHN5W2ldIC0gbnkgKiB0aW4pKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIENvbG9yQmFyVmlldy5wcm90b3R5cGUuX2RyYXdfbWlub3JfdGlja3MgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBpLCBpbWFnZSwgaywgbngsIG55LCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHN4LCBzeSwgdGluLCB0b3V0LCB4X29mZnNldCwgeV9vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy52aXN1YWxzLm1pbm9yX3RpY2tfbGluZS5kb2l0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5fbm9ybWFscygpLCBueCA9IHJlZlswXSwgbnkgPSByZWZbMV07XG4gICAgICAgIGltYWdlID0gdGhpcy5tb2RlbC5fY29tcHV0ZWRfaW1hZ2VfZGltZW5zaW9ucygpO1xuICAgICAgICByZWYxID0gW2ltYWdlLndpZHRoICogbngsIGltYWdlLmhlaWdodCAqIG55XSwgeF9vZmZzZXQgPSByZWYxWzBdLCB5X29mZnNldCA9IHJlZjFbMV07XG4gICAgICAgIHJlZjIgPSB0aGlzLm1vZGVsLl90aWNrX2Nvb3JkaW5hdGVzKCkubWlub3IsIHN4ID0gcmVmMlswXSwgc3kgPSByZWYyWzFdO1xuICAgICAgICB0aW4gPSB0aGlzLm1vZGVsLm1pbm9yX3RpY2tfaW47XG4gICAgICAgIHRvdXQgPSB0aGlzLm1vZGVsLm1pbm9yX3RpY2tfb3V0O1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHhfb2Zmc2V0LCB5X29mZnNldCk7XG4gICAgICAgIHRoaXMudmlzdWFscy5taW5vcl90aWNrX2xpbmUuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYzID0gc3gubGVuZ3RoOyAwIDw9IHJlZjMgPyBrIDwgcmVmMyA6IGsgPiByZWYzOyBpID0gMCA8PSByZWYzID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKE1hdGgucm91bmQoc3hbaV0gKyBueCAqIHRvdXQpLCBNYXRoLnJvdW5kKHN5W2ldICsgbnkgKiB0b3V0KSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKE1hdGgucm91bmQoc3hbaV0gLSBueCAqIHRpbiksIE1hdGgucm91bmQoc3lbaV0gLSBueSAqIHRpbikpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgQ29sb3JCYXJWaWV3LnByb3RvdHlwZS5fZHJhd19tYWpvcl9sYWJlbHMgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRfbGFiZWxzLCBpLCBpbWFnZSwgaywgbGFiZWxzLCBueCwgbnksIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgc3RhbmRvZmYsIHN4LCBzeSwgeF9vZmZzZXQsIHhfc3RhbmRvZmYsIHlfb2Zmc2V0LCB5X3N0YW5kb2ZmO1xuICAgICAgICBpZiAoIXRoaXMudmlzdWFscy5tYWpvcl9sYWJlbF90ZXh0LmRvaXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLl9ub3JtYWxzKCksIG54ID0gcmVmWzBdLCBueSA9IHJlZlsxXTtcbiAgICAgICAgaW1hZ2UgPSB0aGlzLm1vZGVsLl9jb21wdXRlZF9pbWFnZV9kaW1lbnNpb25zKCk7XG4gICAgICAgIHJlZjEgPSBbaW1hZ2Uud2lkdGggKiBueCwgaW1hZ2UuaGVpZ2h0ICogbnldLCB4X29mZnNldCA9IHJlZjFbMF0sIHlfb2Zmc2V0ID0gcmVmMVsxXTtcbiAgICAgICAgc3RhbmRvZmYgPSB0aGlzLm1vZGVsLmxhYmVsX3N0YW5kb2ZmICsgdGhpcy5tb2RlbC5fdGlja19leHRlbnQoKTtcbiAgICAgICAgcmVmMiA9IFtzdGFuZG9mZiAqIG54LCBzdGFuZG9mZiAqIG55XSwgeF9zdGFuZG9mZiA9IHJlZjJbMF0sIHlfc3RhbmRvZmYgPSByZWYyWzFdO1xuICAgICAgICByZWYzID0gdGhpcy5tb2RlbC5fdGlja19jb29yZGluYXRlcygpLm1ham9yLCBzeCA9IHJlZjNbMF0sIHN5ID0gcmVmM1sxXTtcbiAgICAgICAgbGFiZWxzID0gdGhpcy5tb2RlbC5fdGlja19jb29yZGluYXRlcygpLm1ham9yX2xhYmVscztcbiAgICAgICAgZm9ybWF0dGVkX2xhYmVscyA9IHRoaXMubW9kZWwuZm9ybWF0dGVyLmRvRm9ybWF0KGxhYmVscywgbnVsbCk7XG4gICAgICAgIHRoaXMudmlzdWFscy5tYWpvcl9sYWJlbF90ZXh0LnNldF92YWx1ZShjdHgpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHhfb2Zmc2V0ICsgeF9zdGFuZG9mZiwgeV9vZmZzZXQgKyB5X3N0YW5kb2ZmKTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZjQgPSBzeC5sZW5ndGg7IDAgPD0gcmVmNCA/IGsgPCByZWY0IDogayA+IHJlZjQ7IGkgPSAwIDw9IHJlZjQgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChmb3JtYXR0ZWRfbGFiZWxzW2ldLCBNYXRoLnJvdW5kKHN4W2ldICsgbnggKiB0aGlzLm1vZGVsLmxhYmVsX3N0YW5kb2ZmKSwgTWF0aC5yb3VuZChzeVtpXSArIG55ICogdGhpcy5tb2RlbC5sYWJlbF9zdGFuZG9mZikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgQ29sb3JCYXJWaWV3LnByb3RvdHlwZS5fZHJhd190aXRsZSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpc3VhbHMudGl0bGVfdGV4dC5kb2l0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy52aXN1YWxzLnRpdGxlX3RleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLm1vZGVsLnRpdGxlLCAwLCAtdGhpcy5tb2RlbC50aXRsZV9zdGFuZG9mZik7XG4gICAgICAgIHJldHVybiBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgQ29sb3JCYXJWaWV3LnByb3RvdHlwZS5fZ2V0X2xhYmVsX2V4dGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN0eCwgZm9ybWF0dGVkX2xhYmVscywgbGFiZWwsIGxhYmVsX2V4dGVudCwgbWFqb3JfbGFiZWxzO1xuICAgICAgICBtYWpvcl9sYWJlbHMgPSB0aGlzLm1vZGVsLl90aWNrX2Nvb3JkaW5hdGVzKCkubWFqb3JfbGFiZWxzO1xuICAgICAgICBpZiAoKHRoaXMubW9kZWwuY29sb3JfbWFwcGVyLmxvdyAhPSBudWxsKSAmJiAodGhpcy5tb2RlbC5jb2xvcl9tYXBwZXIuaGlnaCAhPSBudWxsKSAmJiAhb2JqZWN0XzEuaXNFbXB0eShtYWpvcl9sYWJlbHMpKSB7XG4gICAgICAgICAgICBjdHggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLm1ham9yX2xhYmVsX3RleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkX2xhYmVscyA9IHRoaXMubW9kZWwuZm9ybWF0dGVyLmRvRm9ybWF0KG1ham9yX2xhYmVscyk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsX2V4dGVudCA9IGFycmF5XzEubWF4KChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaywgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuID0gZm9ybWF0dGVkX2xhYmVscy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gZm9ybWF0dGVkX2xhYmVsc1trXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4Lm1lYXN1cmVUZXh0KGxhYmVsLnRvU3RyaW5nKCkpLndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImhvcml6b250YWxcIjpcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxfZXh0ZW50ID0gdGV4dF91dGlsLmdldF90ZXh0X2hlaWdodCh0aGlzLnZpc3VhbHMubWFqb3JfbGFiZWxfdGV4dC5mb250X3ZhbHVlKCkpLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhYmVsX2V4dGVudCArPSB0aGlzLm1vZGVsLmxhYmVsX3N0YW5kb2ZmO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsX2V4dGVudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVsX2V4dGVudDtcbiAgICB9O1xuICAgIENvbG9yQmFyVmlldy5wcm90b3R5cGUuX2dldF9mcmFtZV9vZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmcmFtZSwgcGFuZWwsIHJlZiwgeG9mZiwgeW9mZjtcbiAgICAgICAgcmVmID0gWzAsIDBdLCB4b2ZmID0gcmVmWzBdLCB5b2ZmID0gcmVmWzFdO1xuICAgICAgICBwYW5lbCA9IHRoaXMubW9kZWwucGFuZWw7XG4gICAgICAgIGZyYW1lID0gdGhpcy5wbG90X3ZpZXcuZnJhbWU7XG4gICAgICAgIHN3aXRjaCAocGFuZWwuc2lkZSkge1xuICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgIHlvZmYgPSBNYXRoLmFicyhwYW5lbC5fdG9wLnZhbHVlIC0gZnJhbWUuX3RvcC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYWJvdmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJiZWxvd1wiOlxuICAgICAgICAgICAgICAgIHhvZmYgPSBNYXRoLmFicyhmcmFtZS5fbGVmdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHhvZmYsXG4gICAgICAgICAgICB5OiB5b2ZmXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDb2xvckJhclZpZXcucHJvdG90eXBlLl9nZXRfaW1hZ2Vfb2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgeCA9IHRoaXMubW9kZWwucGFkZGluZztcbiAgICAgICAgeSA9IHRoaXMubW9kZWwucGFkZGluZyArIHRoaXMubW9kZWwuX3RpdGxlX2V4dGVudCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb2xvckJhclZpZXc7XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvblZpZXcpO1xuZXhwb3J0cy5Db2xvckJhciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDb2xvckJhciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ29sb3JCYXIoKSB7XG4gICAgICAgIHJldHVybiBDb2xvckJhci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ29sb3JCYXIucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuQ29sb3JCYXJWaWV3O1xuICAgIENvbG9yQmFyLnByb3RvdHlwZS50eXBlID0gJ0NvbG9yQmFyJztcbiAgICBDb2xvckJhci5taXhpbnMoWyd0ZXh0Om1ham9yX2xhYmVsXycsICd0ZXh0OnRpdGxlXycsICdsaW5lOm1ham9yX3RpY2tfJywgJ2xpbmU6bWlub3JfdGlja18nLCAnbGluZTpib3JkZXJfJywgJ2xpbmU6YmFyXycsICdmaWxsOmJhY2tncm91bmRfJ10pO1xuICAgIENvbG9yQmFyLmRlZmluZSh7XG4gICAgICAgIGxvY2F0aW9uOiBbcC5BbnksICd0b3BfcmlnaHQnXSxcbiAgICAgICAgb3JpZW50YXRpb246IFtwLk9yaWVudGF0aW9uLCAndmVydGljYWwnXSxcbiAgICAgICAgdGl0bGU6IFtwLlN0cmluZ10sXG4gICAgICAgIHRpdGxlX3N0YW5kb2ZmOiBbcC5OdW1iZXIsIDJdLFxuICAgICAgICBoZWlnaHQ6IFtwLkFueSwgJ2F1dG8nXSxcbiAgICAgICAgd2lkdGg6IFtwLkFueSwgJ2F1dG8nXSxcbiAgICAgICAgc2NhbGVfYWxwaGE6IFtwLk51bWJlciwgMS4wXSxcbiAgICAgICAgdGlja2VyOiBbXG4gICAgICAgICAgICBwLkluc3RhbmNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBiYXNpY190aWNrZXJfMS5CYXNpY1RpY2tlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBmb3JtYXR0ZXI6IFtcbiAgICAgICAgICAgIHAuSW5zdGFuY2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGJhc2ljX3RpY2tfZm9ybWF0dGVyXzEuQmFzaWNUaWNrRm9ybWF0dGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGNvbG9yX21hcHBlcjogW3AuSW5zdGFuY2VdLFxuICAgICAgICBsYWJlbF9zdGFuZG9mZjogW3AuTnVtYmVyLCA1XSxcbiAgICAgICAgbWFyZ2luOiBbcC5OdW1iZXIsIDMwXSxcbiAgICAgICAgcGFkZGluZzogW3AuTnVtYmVyLCAxMF0sXG4gICAgICAgIG1ham9yX3RpY2tfaW46IFtwLk51bWJlciwgNV0sXG4gICAgICAgIG1ham9yX3RpY2tfb3V0OiBbcC5OdW1iZXIsIDBdLFxuICAgICAgICBtaW5vcl90aWNrX2luOiBbcC5OdW1iZXIsIDBdLFxuICAgICAgICBtaW5vcl90aWNrX291dDogW3AuTnVtYmVyLCAwXVxuICAgIH0pO1xuICAgIENvbG9yQmFyLm92ZXJyaWRlKHtcbiAgICAgICAgYmFja2dyb3VuZF9maWxsX2NvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgYmFja2dyb3VuZF9maWxsX2FscGhhOiAwLjk1LFxuICAgICAgICBiYXJfbGluZV9jb2xvcjogbnVsbCxcbiAgICAgICAgYm9yZGVyX2xpbmVfY29sb3I6IG51bGwsXG4gICAgICAgIG1ham9yX2xhYmVsX3RleHRfYWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgIG1ham9yX2xhYmVsX3RleHRfYmFzZWxpbmU6IFwibWlkZGxlXCIsXG4gICAgICAgIG1ham9yX2xhYmVsX3RleHRfZm9udF9zaXplOiBcIjhwdFwiLFxuICAgICAgICBtYWpvcl90aWNrX2xpbmVfY29sb3I6IFwiI2ZmZmZmZlwiLFxuICAgICAgICBtaW5vcl90aWNrX2xpbmVfY29sb3I6IG51bGwsXG4gICAgICAgIHRpdGxlX3RleHRfZm9udF9zaXplOiBcIjEwcHRcIixcbiAgICAgICAgdGl0bGVfdGV4dF9mb250X3N0eWxlOiBcIml0YWxpY1wiXG4gICAgfSk7XG4gICAgQ29sb3JCYXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIENvbG9yQmFyLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgQ29sb3JCYXIucHJvdG90eXBlLl9ub3JtYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgaiwgcmVmLCByZWYxO1xuICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgcmVmID0gWzEsIDBdLCBpID0gcmVmWzBdLCBqID0gcmVmWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmMSA9IFswLCAxXSwgaSA9IHJlZjFbMF0sIGogPSByZWYxWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbaSwgal07XG4gICAgfTtcbiAgICBDb2xvckJhci5wcm90b3R5cGUuX3RpdGxlX2V4dGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZvbnRfdmFsdWUsIHRpdGxlX2V4dGVudDtcbiAgICAgICAgZm9udF92YWx1ZSA9IHRoaXMudGl0bGVfdGV4dF9mb250ICsgXCIgXCIgKyB0aGlzLnRpdGxlX3RleHRfZm9udF9zaXplICsgXCIgXCIgKyB0aGlzLnRpdGxlX3RleHRfZm9udF9zdHlsZTtcbiAgICAgICAgdGl0bGVfZXh0ZW50ID0gdGhpcy50aXRsZSA/IHRleHRfdXRpbC5nZXRfdGV4dF9oZWlnaHQoZm9udF92YWx1ZSkuaGVpZ2h0ICsgdGhpcy50aXRsZV9zdGFuZG9mZiA6IDA7XG4gICAgICAgIHJldHVybiB0aXRsZV9leHRlbnQ7XG4gICAgfTtcbiAgICBDb2xvckJhci5wcm90b3R5cGUuX3RpY2tfZXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGlja19leHRlbnQ7XG4gICAgICAgIGlmICgodGhpcy5jb2xvcl9tYXBwZXIubG93ICE9IG51bGwpICYmICh0aGlzLmNvbG9yX21hcHBlci5oaWdoICE9IG51bGwpKSB7XG4gICAgICAgICAgICB0aWNrX2V4dGVudCA9IGFycmF5XzEubWF4KFt0aGlzLm1ham9yX3RpY2tfb3V0LCB0aGlzLm1pbm9yX3RpY2tfb3V0XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aWNrX2V4dGVudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpY2tfZXh0ZW50O1xuICAgIH07XG4gICAgQ29sb3JCYXIucHJvdG90eXBlLl9jb21wdXRlZF9pbWFnZV9kaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKlxuICAgICAgICBIZXVyaXN0aWNzIHRvIGRldGVybWluZSBDb2xvckJhciBpbWFnZSBkaW1lbnNpb25zIGlmIHNldCB0byBcImF1dG9cIlxuICAgICAgICBcbiAgICAgICAgTm90ZTogUmV0dXJucyB0aGUgaGVpZ2h0L3dpZHRoIHZhbHVlcyBmb3IgdGhlIENvbG9yQmFyJ3Mgc2NhbGUgaW1hZ2UsIG5vdFxuICAgICAgICB0aGUgZGltZW5zaW9ucyBvZiB0aGUgZW50aXJlIENvbG9yQmFyLlxuICAgICAgICBcbiAgICAgICAgSWYgdGhlIHNob3J0IGRpbWVuc2lvbiAodGhlIHdpZHRoIG9mIGEgdmVydGljYWwgYmFyIG9yIGhlaWdodCBvZiBhXG4gICAgICAgIGhvcml6b250YWwgYmFyKSBpcyBzZXQgdG8gXCJhdXRvXCIsIHRoZSByZXN1bHRpbmcgZGltZW5zaW9uIHdpbGwgYmUgc2V0IHRvXG4gICAgICAgIDI1IHB4LlxuICAgICAgICBcbiAgICAgICAgRm9yIGEgQ29sb3JCYXIgaW4gYSBzaWRlIHBhbmVsIHdpdGggdGhlIGxvbmcgZGltZW5zaW9uICh0aGUgaGVpZ2h0IG9mIGFcbiAgICAgICAgdmVydGljYWwgYmFyIG9yIHdpZHRoIG9mIGEgaG9yaXpvbnRhbCBiYXIpIHNldCB0byBcImF1dG9cIiwgdGhlXG4gICAgICAgIHJlc3VsdGluZyBkaW1lbnNpb24gd2lsbCBiZSBhcyBsb25nIGFzIHRoZSBhZGphY2VudCBmcmFtZSBlZGdlLCBzbyB0aGF0IHRoZVxuICAgICAgICBiYXIgXCJmaXRzXCIgdG8gdGhlIHBsb3QuXG4gICAgICAgIFxuICAgICAgICBGb3IgYSBDb2xvckJhciBpbiB0aGUgcGxvdCBmcmFtZSB3aXRoIHRoZSBsb25nIGRpbWVuc2lvbiBzZXQgdG8gXCJhdXRvXCIsIHRoZVxuICAgICAgICByZXN1bHRpbmcgZGltZW5zaW9uIHdpbGwgYmUgdGhlIGdyZWF0ZXIgb2Y6XG4gICAgICAgICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBjb2xvciBwYWxldHRlICogMjVweFxuICAgICAgICAgICogVGhlIHBhcmFsbGVsIGZyYW1lIGRpbWVuc2lvbiAqIDAuMzBcbiAgICAgICAgICAgIChpLmUgdGhlIGZyYW1lIGhlaWdodCBmb3IgYSB2ZXJ0aWNhbCBDb2xvckJhcilcbiAgICAgICAgQnV0IG5vdCBncmVhdGVyIHRoYW46XG4gICAgICAgICAgKiBUaGUgcGFyYWxsZWwgZnJhbWUgZGltZW5zaW9uICogMC44MFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGZyYW1lX2hlaWdodCwgZnJhbWVfd2lkdGgsIGhlaWdodCwgdGl0bGVfZXh0ZW50LCB3aWR0aDtcbiAgICAgICAgZnJhbWVfaGVpZ2h0ID0gdGhpcy5wbG90LnBsb3RfY2FudmFzLmZyYW1lLl9oZWlnaHQudmFsdWU7XG4gICAgICAgIGZyYW1lX3dpZHRoID0gdGhpcy5wbG90LnBsb3RfY2FudmFzLmZyYW1lLl93aWR0aC52YWx1ZTtcbiAgICAgICAgdGl0bGVfZXh0ZW50ID0gdGhpcy5fdGl0bGVfZXh0ZW50KCk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFuZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gZnJhbWVfaGVpZ2h0IC0gMiAqIHRoaXMucGFkZGluZyAtIHRpdGxlX2V4dGVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGFycmF5XzEubWF4KFt0aGlzLmNvbG9yX21hcHBlci5wYWxldHRlLmxlbmd0aCAqIFNIT1JUX0RJTSwgZnJhbWVfaGVpZ2h0ICogTE9OR19ESU1fTUlOX1NDQUxBUl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gYXJyYXlfMS5taW4oW2hlaWdodCwgZnJhbWVfaGVpZ2h0ICogTE9OR19ESU1fTUFYX1NDQUxBUiAtIDIgKiB0aGlzLnBhZGRpbmcgLSB0aXRsZV9leHRlbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdpZHRoID0gdGhpcy53aWR0aCA9PT0gJ2F1dG8nID8gU0hPUlRfRElNIDogdGhpcy53aWR0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJob3Jpem9udGFsXCI6XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgPT09ICdhdXRvJyA/IFNIT1JUX0RJTSA6IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLndpZHRoID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFuZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBmcmFtZV93aWR0aCAtIDIgKiB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGFycmF5XzEubWF4KFt0aGlzLmNvbG9yX21hcHBlci5wYWxldHRlLmxlbmd0aCAqIFNIT1JUX0RJTSwgZnJhbWVfd2lkdGggKiBMT05HX0RJTV9NSU5fU0NBTEFSXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGFycmF5XzEubWluKFt3aWR0aCwgZnJhbWVfd2lkdGggKiBMT05HX0RJTV9NQVhfU0NBTEFSIC0gMiAqIHRoaXMucGFkZGluZ10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcImhlaWdodFwiOiBoZWlnaHQsXG4gICAgICAgICAgICBcIndpZHRoXCI6IHdpZHRoXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDb2xvckJhci5wcm90b3R5cGUuX3RpY2tfY29vcmRpbmF0ZV9zY2FsZSA9IGZ1bmN0aW9uIChzY2FsZV9sZW5ndGgpIHtcbiAgICAgICAgLypcbiAgICAgICAgQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHNjYWxlIGluc3RhbmNlIHRoYXQgbWFwcyB0aGUgYGNvbG9yX21hcHBlcmAgcmFuZ2VcbiAgICAgICAgKGxvdyB0byBoaWdoKSB0byBhIHNjcmVlbiBzcGFjZSByYW5nZSBlcXVhbCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBDb2xvckJhcidzXG4gICAgICAgIHNjYWxlIGltYWdlLiBUaGUgc2NhbGUgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHRpY2sgY29vcmRpbmF0ZXMgaW4gc2NyZWVuXG4gICAgICAgIGNvb3JkaW5hdGVzIGZvciBwbG90dGluZyBwdXJwb3Nlcy5cbiAgICAgICAgXG4gICAgICAgIE5vdGU6IHRoZSB0eXBlIG9mIGNvbG9yX21hcHBlciBoYXMgdG8gbWF0Y2ggdGhlIHR5cGUgb2Ygc2NhbGUgKGkuZS5cbiAgICAgICAgYSBMaW5lYXJDb2xvck1hcHBlciB3aWxsIHJlcXVpcmUgYSBjb3JyZXNwb25kaW5nIExpbmVhclNjYWxlIGluc3RhbmNlKS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciByYW5nZXMsIHNjYWxlO1xuICAgICAgICByYW5nZXMgPSB7XG4gICAgICAgICAgICAnc291cmNlX3JhbmdlJzogbmV3IHJhbmdlMWRfMS5SYW5nZTFkKHtcbiAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5jb2xvcl9tYXBwZXIubG93LFxuICAgICAgICAgICAgICAgIGVuZDogdGhpcy5jb2xvcl9tYXBwZXIuaGlnaFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAndGFyZ2V0X3JhbmdlJzogbmV3IHJhbmdlMWRfMS5SYW5nZTFkKHtcbiAgICAgICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgICAgICBlbmQ6IHNjYWxlX2xlbmd0aFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoICh0aGlzLmNvbG9yX21hcHBlci50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiTGluZWFyQ29sb3JNYXBwZXJcIjpcbiAgICAgICAgICAgICAgICBzY2FsZSA9IG5ldyBsaW5lYXJfc2NhbGVfMS5MaW5lYXJTY2FsZShyYW5nZXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkxvZ0NvbG9yTWFwcGVyXCI6XG4gICAgICAgICAgICAgICAgc2NhbGUgPSBuZXcgbG9nX3NjYWxlXzEuTG9nU2NhbGUocmFuZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBDb2xvckJhci5wcm90b3R5cGUuX3RpY2tfY29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb29yZCwgZW5kLCBpLCBpaSwgaW1hZ2VfZGltZW5zaW9ucywgaiwgaywgbCwgbWFqb3JfY29vcmRzLCBtYWpvcl9sYWJlbHMsIG1ham9ycywgbWlub3JfY29vcmRzLCBtaW5vcnMsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgc2NhbGUsIHNjYWxlX2xlbmd0aCwgc3RhcnQsIHRpY2tzO1xuICAgICAgICBpbWFnZV9kaW1lbnNpb25zID0gdGhpcy5fY29tcHV0ZWRfaW1hZ2VfZGltZW5zaW9ucygpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgICAgICAgICAgIHNjYWxlX2xlbmd0aCA9IGltYWdlX2RpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImhvcml6b250YWxcIjpcbiAgICAgICAgICAgICAgICBzY2FsZV9sZW5ndGggPSBpbWFnZV9kaW1lbnNpb25zLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHNjYWxlID0gdGhpcy5fdGlja19jb29yZGluYXRlX3NjYWxlKHNjYWxlX2xlbmd0aCk7XG4gICAgICAgIHJlZiA9IHRoaXMuX25vcm1hbHMoKSwgaSA9IHJlZlswXSwgaiA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IFt0aGlzLmNvbG9yX21hcHBlci5sb3csIHRoaXMuY29sb3JfbWFwcGVyLmhpZ2hdLCBzdGFydCA9IHJlZjFbMF0sIGVuZCA9IHJlZjFbMV07XG4gICAgICAgIHRpY2tzID0gdGhpcy50aWNrZXIuZ2V0X3RpY2tzKHN0YXJ0LCBlbmQsIG51bGwsIG51bGwsIHRoaXMudGlja2VyLmRlc2lyZWRfbnVtX3RpY2tzKTtcbiAgICAgICAgbWFqb3JzID0gdGlja3MubWFqb3I7XG4gICAgICAgIG1pbm9ycyA9IHRpY2tzLm1pbm9yO1xuICAgICAgICBtYWpvcl9jb29yZHMgPSBbW10sIFtdXTtcbiAgICAgICAgbWlub3JfY29vcmRzID0gW1tdLCBbXV07XG4gICAgICAgIGZvciAoaWkgPSBrID0gMCwgcmVmMiA9IG1ham9ycy5sZW5ndGg7IDAgPD0gcmVmMiA/IGsgPCByZWYyIDogayA+IHJlZjI7IGlpID0gMCA8PSByZWYyID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBpZiAobWFqb3JzW2lpXSA8IHN0YXJ0IHx8IG1ham9yc1tpaV0gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ham9yX2Nvb3Jkc1tpXS5wdXNoKG1ham9yc1tpaV0pO1xuICAgICAgICAgICAgbWFqb3JfY29vcmRzW2pdLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpaSA9IGwgPSAwLCByZWYzID0gbWlub3JzLmxlbmd0aDsgMCA8PSByZWYzID8gbCA8IHJlZjMgOiBsID4gcmVmMzsgaWkgPSAwIDw9IHJlZjMgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgIGlmIChtaW5vcnNbaWldIDwgc3RhcnQgfHwgbWlub3JzW2lpXSA+IGVuZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWlub3JfY29vcmRzW2ldLnB1c2gobWlub3JzW2lpXSk7XG4gICAgICAgICAgICBtaW5vcl9jb29yZHNbal0ucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICBtYWpvcl9sYWJlbHMgPSBtYWpvcl9jb29yZHNbaV0uc2xpY2UoMCk7XG4gICAgICAgIG1ham9yX2Nvb3Jkc1tpXSA9IHNjYWxlLnZfY29tcHV0ZShtYWpvcl9jb29yZHNbaV0pO1xuICAgICAgICBtaW5vcl9jb29yZHNbaV0gPSBzY2FsZS52X2NvbXB1dGUobWlub3JfY29vcmRzW2ldKTtcbiAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIG1ham9yX2Nvb3Jkc1tpXSA9IG5ldyBGbG9hdDY0QXJyYXkoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuLCBtLCByZWY0LCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlZjQgPSBtYWpvcl9jb29yZHNbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobSA9IDAsIGxlbiA9IHJlZjQubGVuZ3RoOyBtIDwgbGVuOyBtKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmQgPSByZWY0W21dO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc2NhbGVfbGVuZ3RoIC0gY29vcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgbWlub3JfY29vcmRzW2ldID0gbmV3IEZsb2F0NjRBcnJheSgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBsZW4sIG0sIHJlZjQsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVmNCA9IG1pbm9yX2Nvb3Jkc1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChtID0gMCwgbGVuID0gcmVmNC5sZW5ndGg7IG0gPCBsZW47IG0rKykge1xuICAgICAgICAgICAgICAgICAgICBjb29yZCA9IHJlZjRbbV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChzY2FsZV9sZW5ndGggLSBjb29yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwibWFqb3JcIjogbWFqb3JfY29vcmRzLFxuICAgICAgICAgICAgXCJtaW5vclwiOiBtaW5vcl9jb29yZHMsXG4gICAgICAgICAgICBcIm1ham9yX2xhYmVsc1wiOiBtYWpvcl9sYWJlbHNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb2xvckJhcjtcbn0pKGFubm90YXRpb25fMS5Bbm5vdGF0aW9uKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL2Fubm90YXRpb25cIik7XG5leHBvcnRzLkFubm90YXRpb24gPSBhbm5vdGF0aW9uXzEuQW5ub3RhdGlvbjtcbnZhciBhcnJvd18xID0gcmVxdWlyZShcIi4vYXJyb3dcIik7XG5leHBvcnRzLkFycm93ID0gYXJyb3dfMS5BcnJvdztcbnZhciBhcnJvd19oZWFkXzEgPSByZXF1aXJlKFwiLi9hcnJvd19oZWFkXCIpO1xuZXhwb3J0cy5BcnJvd0hlYWQgPSBhcnJvd19oZWFkXzEuQXJyb3dIZWFkO1xudmFyIGFycm93X2hlYWRfMiA9IHJlcXVpcmUoXCIuL2Fycm93X2hlYWRcIik7XG5leHBvcnRzLk9wZW5IZWFkID0gYXJyb3dfaGVhZF8yLk9wZW5IZWFkO1xudmFyIGFycm93X2hlYWRfMyA9IHJlcXVpcmUoXCIuL2Fycm93X2hlYWRcIik7XG5leHBvcnRzLk5vcm1hbEhlYWQgPSBhcnJvd19oZWFkXzMuTm9ybWFsSGVhZDtcbnZhciBhcnJvd19oZWFkXzQgPSByZXF1aXJlKFwiLi9hcnJvd19oZWFkXCIpO1xuZXhwb3J0cy5UZWVIZWFkID0gYXJyb3dfaGVhZF80LlRlZUhlYWQ7XG52YXIgYXJyb3dfaGVhZF81ID0gcmVxdWlyZShcIi4vYXJyb3dfaGVhZFwiKTtcbmV4cG9ydHMuVmVlSGVhZCA9IGFycm93X2hlYWRfNS5WZWVIZWFkO1xudmFyIGJhbmRfMSA9IHJlcXVpcmUoXCIuL2JhbmRcIik7XG5leHBvcnRzLkJhbmQgPSBiYW5kXzEuQmFuZDtcbnZhciBib3hfYW5ub3RhdGlvbl8xID0gcmVxdWlyZShcIi4vYm94X2Fubm90YXRpb25cIik7XG5leHBvcnRzLkJveEFubm90YXRpb24gPSBib3hfYW5ub3RhdGlvbl8xLkJveEFubm90YXRpb247XG52YXIgY29sb3JfYmFyXzEgPSByZXF1aXJlKFwiLi9jb2xvcl9iYXJcIik7XG5leHBvcnRzLkNvbG9yQmFyID0gY29sb3JfYmFyXzEuQ29sb3JCYXI7XG52YXIgbGFiZWxfMSA9IHJlcXVpcmUoXCIuL2xhYmVsXCIpO1xuZXhwb3J0cy5MYWJlbCA9IGxhYmVsXzEuTGFiZWw7XG52YXIgbGFiZWxfc2V0XzEgPSByZXF1aXJlKFwiLi9sYWJlbF9zZXRcIik7XG5leHBvcnRzLkxhYmVsU2V0ID0gbGFiZWxfc2V0XzEuTGFiZWxTZXQ7XG52YXIgbGVnZW5kXzEgPSByZXF1aXJlKFwiLi9sZWdlbmRcIik7XG5leHBvcnRzLkxlZ2VuZCA9IGxlZ2VuZF8xLkxlZ2VuZDtcbnZhciBsZWdlbmRfaXRlbV8xID0gcmVxdWlyZShcIi4vbGVnZW5kX2l0ZW1cIik7XG5leHBvcnRzLkxlZ2VuZEl0ZW0gPSBsZWdlbmRfaXRlbV8xLkxlZ2VuZEl0ZW07XG52YXIgcG9seV9hbm5vdGF0aW9uXzEgPSByZXF1aXJlKFwiLi9wb2x5X2Fubm90YXRpb25cIik7XG5leHBvcnRzLlBvbHlBbm5vdGF0aW9uID0gcG9seV9hbm5vdGF0aW9uXzEuUG9seUFubm90YXRpb247XG52YXIgc3Bhbl8xID0gcmVxdWlyZShcIi4vc3BhblwiKTtcbmV4cG9ydHMuU3BhbiA9IHNwYW5fMS5TcGFuO1xudmFyIHRleHRfYW5ub3RhdGlvbl8xID0gcmVxdWlyZShcIi4vdGV4dF9hbm5vdGF0aW9uXCIpO1xuZXhwb3J0cy5UZXh0QW5ub3RhdGlvbiA9IHRleHRfYW5ub3RhdGlvbl8xLlRleHRBbm5vdGF0aW9uO1xudmFyIHRpdGxlXzEgPSByZXF1aXJlKFwiLi90aXRsZVwiKTtcbmV4cG9ydHMuVGl0bGUgPSB0aXRsZV8xLlRpdGxlO1xudmFyIHRvb2x0aXBfMSA9IHJlcXVpcmUoXCIuL3Rvb2x0aXBcIik7XG5leHBvcnRzLlRvb2x0aXAgPSB0b29sdGlwXzEuVG9vbHRpcDtcbnZhciB3aGlza2VyXzEgPSByZXF1aXJlKFwiLi93aGlza2VyXCIpO1xuZXhwb3J0cy5XaGlza2VyID0gd2hpc2tlcl8xLldoaXNrZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgdGV4dF9hbm5vdGF0aW9uXzEgPSByZXF1aXJlKFwiLi90ZXh0X2Fubm90YXRpb25cIik7XG52YXIgZG9tXzEgPSByZXF1aXJlKFwiY29yZS9kb21cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkxhYmVsVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMYWJlbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExhYmVsVmlldygpIHtcbiAgICAgICAgcmV0dXJuIExhYmVsVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGFiZWxWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgTGFiZWxWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcztcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzdWFscy53YXJtX2NhY2hlKG51bGwpO1xuICAgIH07XG4gICAgTGFiZWxWaWV3LnByb3RvdHlwZS5fZ2V0X3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHgsIGhlaWdodCwgc2lkZSwgd2lkdGg7XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgdGhpcy52aXN1YWxzLnRleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIHNpZGUgPSB0aGlzLm1vZGVsLnBhbmVsLnNpZGU7XG4gICAgICAgIGlmIChzaWRlID09PSBcImFib3ZlXCIgfHwgc2lkZSA9PT0gXCJiZWxvd1wiKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBjdHgubWVhc3VyZVRleHQodGhpcy5tb2RlbC50ZXh0KS5hc2NlbnQ7XG4gICAgICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWRlID09PSAnbGVmdCcgfHwgc2lkZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGhpcy5tb2RlbC50ZXh0KS53aWR0aDtcbiAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGFiZWxWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbmdsZSwgY3R4LCBwYW5lbF9vZmZzZXQsIHN4LCBzeSwgdngsIHZ5LCB4c2NhbGUsIHlzY2FsZTtcbiAgICAgICAgaWYgKCF0aGlzLm1vZGVsLnZpc2libGUgJiYgdGhpcy5tb2RlbC5yZW5kZXJfbW9kZSA9PT0gJ2NzcycpIHtcbiAgICAgICAgICAgIGRvbV8xLmhpZGUodGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm1vZGVsLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB4c2NhbGUgPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS54c2NhbGVzW3RoaXMubW9kZWwueF9yYW5nZV9uYW1lXTtcbiAgICAgICAgeXNjYWxlID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueXNjYWxlc1t0aGlzLm1vZGVsLnlfcmFuZ2VfbmFtZV07XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVsLmFuZ2xlX3VuaXRzKSB7XG4gICAgICAgICAgICBjYXNlIFwicmFkXCI6XG4gICAgICAgICAgICAgICAgYW5nbGUgPSAtMSAqIHRoaXMubW9kZWwuYW5nbGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVnXCI6XG4gICAgICAgICAgICAgICAgYW5nbGUgPSAtMSAqIHRoaXMubW9kZWwuYW5nbGUgKiBNYXRoLlBJIC8gMTgwLjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwueF91bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHZ4ID0geHNjYWxlLmNvbXB1dGUodGhpcy5tb2RlbC54KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZ4ID0gdGhpcy5tb2RlbC54O1xuICAgICAgICB9XG4gICAgICAgIHN4ID0gdGhpcy5jYW52YXMudnhfdG9fc3godngpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC55X3VuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgdnkgPSB5c2NhbGUuY29tcHV0ZSh0aGlzLm1vZGVsLnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdnkgPSB0aGlzLm1vZGVsLnk7XG4gICAgICAgIH1cbiAgICAgICAgc3kgPSB0aGlzLmNhbnZhcy52eV90b19zeSh2eSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnBhbmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhbmVsX29mZnNldCA9IHRoaXMuX2dldF9wYW5lbF9vZmZzZXQoKTtcbiAgICAgICAgICAgIHN4ICs9IHBhbmVsX29mZnNldC54O1xuICAgICAgICAgICAgc3kgKz0gcGFuZWxfb2Zmc2V0Lnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwucmVuZGVyX21vZGUgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzX3RleHQoY3R4LCB0aGlzLm1vZGVsLnRleHQsIHN4ICsgdGhpcy5tb2RlbC54X29mZnNldCwgc3kgLSB0aGlzLm1vZGVsLnlfb2Zmc2V0LCBhbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3NzX3RleHQoY3R4LCB0aGlzLm1vZGVsLnRleHQsIHN4ICsgdGhpcy5tb2RlbC54X29mZnNldCwgc3kgLSB0aGlzLm1vZGVsLnlfb2Zmc2V0LCBhbmdsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBMYWJlbFZpZXc7XG59KSh0ZXh0X2Fubm90YXRpb25fMS5UZXh0QW5ub3RhdGlvblZpZXcpO1xuZXhwb3J0cy5MYWJlbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMYWJlbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGFiZWwoKSB7XG4gICAgICAgIHJldHVybiBMYWJlbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGFiZWwucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuTGFiZWxWaWV3O1xuICAgIExhYmVsLnByb3RvdHlwZS50eXBlID0gJ0xhYmVsJztcbiAgICBMYWJlbC5taXhpbnMoWyd0ZXh0JywgJ2xpbmU6Ym9yZGVyXycsICdmaWxsOmJhY2tncm91bmRfJ10pO1xuICAgIExhYmVsLmRlZmluZSh7XG4gICAgICAgIHg6IFtwLk51bWJlcl0sXG4gICAgICAgIHhfdW5pdHM6IFtwLlNwYXRpYWxVbml0cywgJ2RhdGEnXSxcbiAgICAgICAgeTogW3AuTnVtYmVyXSxcbiAgICAgICAgeV91bml0czogW3AuU3BhdGlhbFVuaXRzLCAnZGF0YSddLFxuICAgICAgICB0ZXh0OiBbcC5TdHJpbmddLFxuICAgICAgICBhbmdsZTogW3AuQW5nbGUsIDBdLFxuICAgICAgICBhbmdsZV91bml0czogW3AuQW5nbGVVbml0cywgJ3JhZCddLFxuICAgICAgICB4X29mZnNldDogW3AuTnVtYmVyLCAwXSxcbiAgICAgICAgeV9vZmZzZXQ6IFtwLk51bWJlciwgMF0sXG4gICAgICAgIHhfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddLFxuICAgICAgICB5X3JhbmdlX25hbWU6IFtwLlN0cmluZywgJ2RlZmF1bHQnXSxcbiAgICAgICAgcmVuZGVyX21vZGU6IFtwLlJlbmRlck1vZGUsICdjYW52YXMnXVxuICAgIH0pO1xuICAgIExhYmVsLm92ZXJyaWRlKHtcbiAgICAgICAgYmFja2dyb3VuZF9maWxsX2NvbG9yOiBudWxsLFxuICAgICAgICBib3JkZXJfbGluZV9jb2xvcjogbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiBMYWJlbDtcbn0pKHRleHRfYW5ub3RhdGlvbl8xLlRleHRBbm5vdGF0aW9uKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0ZXh0X2Fubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL3RleHRfYW5ub3RhdGlvblwiKTtcbnZhciBjb2x1bW5fZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuLi9zb3VyY2VzL2NvbHVtbl9kYXRhX3NvdXJjZVwiKTtcbnZhciBkb21fMSA9IHJlcXVpcmUoXCJjb3JlL2RvbVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90eXBlc1wiKTtcbmV4cG9ydHMuTGFiZWxTZXRWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExhYmVsU2V0Vmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGFiZWxTZXRWaWV3KCkge1xuICAgICAgICByZXR1cm4gTGFiZWxTZXRWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMYWJlbFNldFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgaSwgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgICBMYWJlbFNldFZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zZXRfZGF0YSh0aGlzLm1vZGVsLnNvdXJjZSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnJlbmRlcl9tb2RlID09PSAnY3NzJykge1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRoaXMuX3RleHQubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpdGxlX2RpdiA9IGRvbV8xLmRpdih7XG4gICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogJ2JrLWFubm90YXRpb24tY2hpbGQnLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMudGl0bGVfZGl2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGFiZWxTZXRWaWV3LnByb3RvdHlwZS5jb25uZWN0X3NpZ25hbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIExhYmVsU2V0Vmlldy5fX3N1cGVyX18uY29ubmVjdF9zaWduYWxzLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnJlbmRlcl9tb2RlID09PSAnY3NzJykge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfZGF0YSh0aGlzLm1vZGVsLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnNvdXJjZS5zdHJlYW1pbmcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldF9kYXRhKHRoaXMubW9kZWwuc291cmNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuc291cmNlLnBhdGNoaW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfZGF0YSh0aGlzLm1vZGVsLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5zb3VyY2UuY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfZGF0YSh0aGlzLm1vZGVsLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0X2RhdGEodGhpcy5tb2RlbC5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5zb3VyY2Uuc3RyZWFtaW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfZGF0YSh0aGlzLm1vZGVsLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3LnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnNvdXJjZS5wYXRjaGluZywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0X2RhdGEodGhpcy5tb2RlbC5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuc291cmNlLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0X2RhdGEodGhpcy5tb2RlbC5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExhYmVsU2V0Vmlldy5wcm90b3R5cGUuc2V0X2RhdGEgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIExhYmVsU2V0Vmlldy5fX3N1cGVyX18uc2V0X2RhdGEuY2FsbCh0aGlzLCBzb3VyY2UpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXN1YWxzLndhcm1fY2FjaGUoc291cmNlKTtcbiAgICB9O1xuICAgIExhYmVsU2V0Vmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3gsIHN5LCB2eCwgdnksIHhzY2FsZSwgeXNjYWxlO1xuICAgICAgICB4c2NhbGUgPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS54c2NhbGVzW3RoaXMubW9kZWwueF9yYW5nZV9uYW1lXTtcbiAgICAgICAgeXNjYWxlID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueXNjYWxlc1t0aGlzLm1vZGVsLnlfcmFuZ2VfbmFtZV07XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnhfdW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICB2eCA9IHhzY2FsZS52X2NvbXB1dGUodGhpcy5feCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2eCA9IHRoaXMuX3guc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3ggPSB0aGlzLmNhbnZhcy52X3Z4X3RvX3N4KHZ4KTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwueV91bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHZ5ID0geXNjYWxlLnZfY29tcHV0ZSh0aGlzLl95KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZ5ID0gdGhpcy5feS5zbGljZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBzeSA9IHRoaXMuY2FudmFzLnZfdnlfdG9fc3kodnkpO1xuICAgICAgICByZXR1cm4gW3N4LCBzeV07XG4gICAgfTtcbiAgICBMYWJlbFNldFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN0eCwgaSwgaiwgaywgcmVmLCByZWYxLCByZWYyLCByZXN1bHRzLCByZXN1bHRzMSwgc3gsIHN5O1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwudmlzaWJsZSAmJiB0aGlzLm1vZGVsLnJlbmRlcl9tb2RlID09PSAnY3NzJykge1xuICAgICAgICAgICAgZG9tXzEuaGlkZSh0aGlzLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubW9kZWwudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgcmVmID0gdGhpcy5fbWFwX2RhdGEoKSwgc3ggPSByZWZbMF0sIHN5ID0gcmVmWzFdO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5yZW5kZXJfbW9kZSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYxID0gdGhpcy5fdGV4dC5sZW5ndGg7IDAgPD0gcmVmMSA/IGogPCByZWYxIDogaiA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5fdl9jYW52YXNfdGV4dChjdHgsIGksIHRoaXMuX3RleHRbaV0sIHN4W2ldICsgdGhpcy5feF9vZmZzZXRbaV0sIHN5W2ldIC0gdGhpcy5feV9vZmZzZXRbaV0sIHRoaXMuX2FuZ2xlW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHMxID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmMiA9IHRoaXMuX3RleHQubGVuZ3RoOyAwIDw9IHJlZjIgPyBrIDwgcmVmMiA6IGsgPiByZWYyOyBpID0gMCA8PSByZWYyID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0czEucHVzaCh0aGlzLl92X2Nzc190ZXh0KGN0eCwgaSwgdGhpcy5fdGV4dFtpXSwgc3hbaV0gKyB0aGlzLl94X29mZnNldFtpXSwgc3lbaV0gLSB0aGlzLl95X29mZnNldFtpXSwgdGhpcy5fYW5nbGVbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGFiZWxTZXRWaWV3LnByb3RvdHlwZS5fZ2V0X3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHgsIGhlaWdodCwgc2lkZSwgd2lkdGg7XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgdGhpcy52aXN1YWxzLnRleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIHNpZGUgPSB0aGlzLm1vZGVsLnBhbmVsLnNpZGU7XG4gICAgICAgIGlmIChzaWRlID09PSBcImFib3ZlXCIgfHwgc2lkZSA9PT0gXCJiZWxvd1wiKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBjdHgubWVhc3VyZVRleHQodGhpcy5fdGV4dFswXSkuYXNjZW50O1xuICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lkZSA9PT0gJ2xlZnQnIHx8IHNpZGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRoaXMuX3RleHRbMF0pLndpZHRoO1xuICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYWJlbFNldFZpZXcucHJvdG90eXBlLl92X2NhbnZhc190ZXh0ID0gZnVuY3Rpb24gKGN0eCwgaSwgdGV4dCwgc3gsIHN5LCBhbmdsZSkge1xuICAgICAgICB2YXIgYmJveF9kaW1zO1xuICAgICAgICB0aGlzLnZpc3VhbHMudGV4dC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIGJib3hfZGltcyA9IHRoaXMuX2NhbGN1bGF0ZV9ib3VuZGluZ19ib3hfZGltZW5zaW9ucyhjdHgsIHRleHQpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoc3gsIHN5KTtcbiAgICAgICAgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgIGN0eC5yZWN0KGJib3hfZGltc1swXSwgYmJveF9kaW1zWzFdLCBiYm94X2RpbXNbMl0sIGJib3hfZGltc1szXSk7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMuYmFja2dyb3VuZF9maWxsLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5iYWNrZ3JvdW5kX2ZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5ib3JkZXJfbGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy50ZXh0LmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy50ZXh0LnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIExhYmVsU2V0Vmlldy5wcm90b3R5cGUuX3ZfY3NzX3RleHQgPSBmdW5jdGlvbiAoY3R4LCBpLCB0ZXh0LCBzeCwgc3ksIGFuZ2xlKSB7XG4gICAgICAgIHZhciBiYm94X2RpbXMsIGVsLCBsZCwgbGluZV9kYXNoO1xuICAgICAgICBlbCA9IHRoaXMuZWwuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnZpc3VhbHMudGV4dC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIGJib3hfZGltcyA9IHRoaXMuX2NhbGN1bGF0ZV9ib3VuZGluZ19ib3hfZGltZW5zaW9ucyhjdHgsIHRleHQpO1xuICAgICAgICBsZCA9IHRoaXMudmlzdWFscy5ib3JkZXJfbGluZS5saW5lX2Rhc2gudmFsdWUoKTtcbiAgICAgICAgaWYgKHR5cGVzXzEuaXNBcnJheShsZCkpIHtcbiAgICAgICAgICAgIGxpbmVfZGFzaCA9IGxkLmxlbmd0aCA8IDIgPyBcInNvbGlkXCIgOiBcImRhc2hlZFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlc18xLmlzU3RyaW5nKGxkKSkge1xuICAgICAgICAgICAgbGluZV9kYXNoID0gbGQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgdGhpcy52aXN1YWxzLmJhY2tncm91bmRfZmlsbC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgZWwuc3R5bGUubGVmdCA9IChzeCArIGJib3hfZGltc1swXSkgKyBcInB4XCI7XG4gICAgICAgIGVsLnN0eWxlLnRvcCA9IChzeSArIGJib3hfZGltc1sxXSkgKyBcInB4XCI7XG4gICAgICAgIGVsLnN0eWxlLmNvbG9yID0gXCJcIiArICh0aGlzLnZpc3VhbHMudGV4dC50ZXh0X2NvbG9yLnZhbHVlKCkpO1xuICAgICAgICBlbC5zdHlsZS5vcGFjaXR5ID0gXCJcIiArICh0aGlzLnZpc3VhbHMudGV4dC50ZXh0X2FscGhhLnZhbHVlKCkpO1xuICAgICAgICBlbC5zdHlsZS5mb250ID0gXCJcIiArICh0aGlzLnZpc3VhbHMudGV4dC5mb250X3ZhbHVlKCkpO1xuICAgICAgICBlbC5zdHlsZS5saW5lSGVpZ2h0ID0gXCJub3JtYWxcIjtcbiAgICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSBcInJvdGF0ZShcIiArIGFuZ2xlICsgXCJyYWQpXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5iYWNrZ3JvdW5kX2ZpbGwuZG9pdCkge1xuICAgICAgICAgICAgZWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJcIiArICh0aGlzLnZpc3VhbHMuYmFja2dyb3VuZF9maWxsLmNvbG9yX3ZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMuYm9yZGVyX2xpbmUuZG9pdCkge1xuICAgICAgICAgICAgZWwuc3R5bGUuYm9yZGVyU3R5bGUgPSBcIlwiICsgbGluZV9kYXNoO1xuICAgICAgICAgICAgZWwuc3R5bGUuYm9yZGVyV2lkdGggPSAodGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLmxpbmVfd2lkdGgudmFsdWUoKSkgKyBcInB4XCI7XG4gICAgICAgICAgICBlbC5zdHlsZS5ib3JkZXJDb2xvciA9IFwiXCIgKyAodGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLmNvbG9yX3ZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb21fMS5zaG93KGVsKTtcbiAgICB9O1xuICAgIHJldHVybiBMYWJlbFNldFZpZXc7XG59KSh0ZXh0X2Fubm90YXRpb25fMS5UZXh0QW5ub3RhdGlvblZpZXcpO1xuZXhwb3J0cy5MYWJlbFNldCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMYWJlbFNldCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGFiZWxTZXQoKSB7XG4gICAgICAgIHJldHVybiBMYWJlbFNldC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGFiZWxTZXQucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuTGFiZWxTZXRWaWV3O1xuICAgIExhYmVsU2V0LnByb3RvdHlwZS50eXBlID0gJ0xhYmVsJztcbiAgICBMYWJlbFNldC5taXhpbnMoWyd0ZXh0JywgJ2xpbmU6Ym9yZGVyXycsICdmaWxsOmJhY2tncm91bmRfJ10pO1xuICAgIExhYmVsU2V0LmRlZmluZSh7XG4gICAgICAgIHg6IFtwLk51bWJlclNwZWNdLFxuICAgICAgICB5OiBbcC5OdW1iZXJTcGVjXSxcbiAgICAgICAgeF91bml0czogW3AuU3BhdGlhbFVuaXRzLCAnZGF0YSddLFxuICAgICAgICB5X3VuaXRzOiBbcC5TcGF0aWFsVW5pdHMsICdkYXRhJ10sXG4gICAgICAgIHRleHQ6IFtcbiAgICAgICAgICAgIHAuU3RyaW5nU3BlYywge1xuICAgICAgICAgICAgICAgIGZpZWxkOiBcInRleHRcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBhbmdsZTogW3AuQW5nbGVTcGVjLCAwXSxcbiAgICAgICAgeF9vZmZzZXQ6IFtcbiAgICAgICAgICAgIHAuTnVtYmVyU3BlYywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHlfb2Zmc2V0OiBbXG4gICAgICAgICAgICBwLk51bWJlclNwZWMsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzb3VyY2U6IFtcbiAgICAgICAgICAgIHAuSW5zdGFuY2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvbHVtbl9kYXRhX3NvdXJjZV8xLkNvbHVtbkRhdGFTb3VyY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgeF9yYW5nZV9uYW1lOiBbcC5TdHJpbmcsICdkZWZhdWx0J10sXG4gICAgICAgIHlfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddLFxuICAgICAgICByZW5kZXJfbW9kZTogW3AuUmVuZGVyTW9kZSwgJ2NhbnZhcyddXG4gICAgfSk7XG4gICAgTGFiZWxTZXQub3ZlcnJpZGUoe1xuICAgICAgICBiYWNrZ3JvdW5kX2ZpbGxfY29sb3I6IG51bGwsXG4gICAgICAgIGJvcmRlcl9saW5lX2NvbG9yOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIExhYmVsU2V0O1xufSkodGV4dF9hbm5vdGF0aW9uXzEuVGV4dEFubm90YXRpb24pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL2Fubm90YXRpb25cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgdGV4dF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC90ZXh0XCIpO1xudmFyIGJib3hfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYmJveFwiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvb2JqZWN0XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xuZXhwb3J0cy5MZWdlbmRWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExlZ2VuZFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExlZ2VuZFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBMZWdlbmRWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMZWdlbmRWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIExlZ2VuZFZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIExlZ2VuZFZpZXcucHJvdG90eXBlLmNvbm5lY3Rfc2lnbmFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgTGVnZW5kVmlldy5fX3N1cGVyX18uY29ubmVjdF9zaWduYWxzLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLnZpc2libGUuY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wbG90X3ZpZXcucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuICAgIExlZ2VuZFZpZXcucHJvdG90eXBlLmNvbXB1dGVfbGVnZW5kX2Jib3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHgsIGdseXBoX2hlaWdodCwgZ2x5cGhfd2lkdGgsIGhfcmFuZ2UsIGksIGxhYmVsX2hlaWdodCwgbGFiZWxfc3RhbmRvZmYsIGxhYmVsX3dpZHRoLCBsZWdlbmRfaGVpZ2h0LCBsZWdlbmRfbWFyZ2luLCBsZWdlbmRfbmFtZXMsIGxlZ2VuZF9wYWRkaW5nLCBsZWdlbmRfc3BhY2luZywgbGVnZW5kX3dpZHRoLCBsZW4sIGxvY2F0aW9uLCBtYXhfbGFiZWxfd2lkdGgsIG5hbWUsIHBhbmVsLCByZWYsIHJlZjEsIHJlZjIsIHZfcmFuZ2UsIHdpZHRoLCB4LCB5O1xuICAgICAgICBsZWdlbmRfbmFtZXMgPSB0aGlzLm1vZGVsLmdldF9sZWdlbmRfbmFtZXMoKTtcbiAgICAgICAgZ2x5cGhfaGVpZ2h0ID0gdGhpcy5tb2RlbC5nbHlwaF9oZWlnaHQ7XG4gICAgICAgIGdseXBoX3dpZHRoID0gdGhpcy5tb2RlbC5nbHlwaF93aWR0aDtcbiAgICAgICAgbGFiZWxfaGVpZ2h0ID0gdGhpcy5tb2RlbC5sYWJlbF9oZWlnaHQ7XG4gICAgICAgIGxhYmVsX3dpZHRoID0gdGhpcy5tb2RlbC5sYWJlbF93aWR0aDtcbiAgICAgICAgdGhpcy5tYXhfbGFiZWxfaGVpZ2h0ID0gYXJyYXlfMS5tYXgoW3RleHRfMS5nZXRfdGV4dF9oZWlnaHQodGhpcy52aXN1YWxzLmxhYmVsX3RleHQuZm9udF92YWx1ZSgpKS5oZWlnaHQsIGxhYmVsX2hlaWdodCwgZ2x5cGhfaGVpZ2h0XSk7XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy52aXN1YWxzLmxhYmVsX3RleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIHRoaXMudGV4dF93aWR0aHMgPSB7fTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbGVnZW5kX25hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBuYW1lID0gbGVnZW5kX25hbWVzW2ldO1xuICAgICAgICAgICAgdGhpcy50ZXh0X3dpZHRoc1tuYW1lXSA9IGFycmF5XzEubWF4KFtjdHgubWVhc3VyZVRleHQobmFtZSkud2lkdGgsIGxhYmVsX3dpZHRoXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgbWF4X2xhYmVsX3dpZHRoID0gYXJyYXlfMS5tYXgob2JqZWN0XzEudmFsdWVzKHRoaXMudGV4dF93aWR0aHMpKTtcbiAgICAgICAgbGVnZW5kX21hcmdpbiA9IHRoaXMubW9kZWwubWFyZ2luO1xuICAgICAgICBsZWdlbmRfcGFkZGluZyA9IHRoaXMubW9kZWwucGFkZGluZztcbiAgICAgICAgbGVnZW5kX3NwYWNpbmcgPSB0aGlzLm1vZGVsLnNwYWNpbmc7XG4gICAgICAgIGxhYmVsX3N0YW5kb2ZmID0gdGhpcy5tb2RlbC5sYWJlbF9zdGFuZG9mZjtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgICAgbGVnZW5kX2hlaWdodCA9IGxlZ2VuZF9uYW1lcy5sZW5ndGggKiB0aGlzLm1heF9sYWJlbF9oZWlnaHQgKyAobGVnZW5kX25hbWVzLmxlbmd0aCAtIDEpICogbGVnZW5kX3NwYWNpbmcgKyAyICogbGVnZW5kX3BhZGRpbmc7XG4gICAgICAgICAgICBsZWdlbmRfd2lkdGggPSBtYXhfbGFiZWxfd2lkdGggKyBnbHlwaF93aWR0aCArIGxhYmVsX3N0YW5kb2ZmICsgMiAqIGxlZ2VuZF9wYWRkaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVnZW5kX3dpZHRoID0gMiAqIGxlZ2VuZF9wYWRkaW5nICsgKGxlZ2VuZF9uYW1lcy5sZW5ndGggLSAxKSAqIGxlZ2VuZF9zcGFjaW5nO1xuICAgICAgICAgICAgcmVmID0gdGhpcy50ZXh0X3dpZHRocztcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHJlZltuYW1lXTtcbiAgICAgICAgICAgICAgICBsZWdlbmRfd2lkdGggKz0gYXJyYXlfMS5tYXgoW3dpZHRoLCBsYWJlbF93aWR0aF0pICsgZ2x5cGhfd2lkdGggKyBsYWJlbF9zdGFuZG9mZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlZ2VuZF9oZWlnaHQgPSB0aGlzLm1heF9sYWJlbF9oZWlnaHQgKyAyICogbGVnZW5kX3BhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcGFuZWwgPSAocmVmMSA9IHRoaXMubW9kZWwucGFuZWwpICE9IG51bGwgPyByZWYxIDogdGhpcy5wbG90X3ZpZXcuZnJhbWU7XG4gICAgICAgIGhfcmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogcGFuZWwuX2xlZnQudmFsdWUsXG4gICAgICAgICAgICBlbmQ6IHBhbmVsLl9yaWdodC52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICB2X3JhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHBhbmVsLl9ib3R0b20udmFsdWUsXG4gICAgICAgICAgICBlbmQ6IHBhbmVsLl90b3AudmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgbG9jYXRpb24gPSB0aGlzLm1vZGVsLmxvY2F0aW9uO1xuICAgICAgICBpZiAodHlwZXNfMS5pc1N0cmluZyhsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0b3BfbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIHggPSBoX3JhbmdlLnN0YXJ0ICsgbGVnZW5kX21hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHZfcmFuZ2UuZW5kIC0gbGVnZW5kX21hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wX2NlbnRlcic6XG4gICAgICAgICAgICAgICAgICAgIHggPSAoaF9yYW5nZS5lbmQgKyBoX3JhbmdlLnN0YXJ0KSAvIDIgLSBsZWdlbmRfd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICB5ID0gdl9yYW5nZS5lbmQgLSBsZWdlbmRfbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd0b3BfcmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICB4ID0gaF9yYW5nZS5lbmQgLSBsZWdlbmRfbWFyZ2luIC0gbGVnZW5kX3dpZHRoO1xuICAgICAgICAgICAgICAgICAgICB5ID0gdl9yYW5nZS5lbmQgLSBsZWdlbmRfbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXJfcmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICB4ID0gaF9yYW5nZS5lbmQgLSBsZWdlbmRfbWFyZ2luIC0gbGVnZW5kX3dpZHRoO1xuICAgICAgICAgICAgICAgICAgICB5ID0gKHZfcmFuZ2UuZW5kICsgdl9yYW5nZS5zdGFydCkgLyAyICsgbGVnZW5kX2hlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbV9yaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIHggPSBoX3JhbmdlLmVuZCAtIGxlZ2VuZF9tYXJnaW4gLSBsZWdlbmRfd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB2X3JhbmdlLnN0YXJ0ICsgbGVnZW5kX21hcmdpbiArIGxlZ2VuZF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbV9jZW50ZXInOlxuICAgICAgICAgICAgICAgICAgICB4ID0gKGhfcmFuZ2UuZW5kICsgaF9yYW5nZS5zdGFydCkgLyAyIC0gbGVnZW5kX3dpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHZfcmFuZ2Uuc3RhcnQgKyBsZWdlbmRfbWFyZ2luICsgbGVnZW5kX2hlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tX2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICB4ID0gaF9yYW5nZS5zdGFydCArIGxlZ2VuZF9tYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIHkgPSB2X3JhbmdlLnN0YXJ0ICsgbGVnZW5kX21hcmdpbiArIGxlZ2VuZF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcl9sZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgeCA9IGhfcmFuZ2Uuc3RhcnQgKyBsZWdlbmRfbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICB5ID0gKHZfcmFuZ2UuZW5kICsgdl9yYW5nZS5zdGFydCkgLyAyICsgbGVnZW5kX2hlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgICAgIHggPSAoaF9yYW5nZS5lbmQgKyBoX3JhbmdlLnN0YXJ0KSAvIDIgLSBsZWdlbmRfd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICB5ID0gKHZfcmFuZ2UuZW5kICsgdl9yYW5nZS5zdGFydCkgLyAyICsgbGVnZW5kX2hlaWdodCAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc0FycmF5KGxvY2F0aW9uKSAmJiBsb2NhdGlvbi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHggPSBsb2NhdGlvblswXSwgeSA9IGxvY2F0aW9uWzFdO1xuICAgICAgICAgICAgaWYgKChyZWYyID0gcGFuZWwuc2lkZSkgPT09IFwibGVmdFwiIHx8IHJlZjIgPT09IFwicmlnaHRcIiB8fCByZWYyID09PSBcImFib3ZlXCIgfHwgcmVmMiA9PT0gXCJiZWxvd1wiKSB7XG4gICAgICAgICAgICAgICAgeCArPSBoX3JhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgIHkgKz0gdl9yYW5nZS5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ICs9IGhfcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgeSArPSB2X3JhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXMudnhfdG9fc3goeCk7XG4gICAgICAgIHkgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXMudnlfdG9fc3koeSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHdpZHRoOiBsZWdlbmRfd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGxlZ2VuZF9oZWlnaHRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExlZ2VuZFZpZXcucHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoZWlnaHQsIHJlZiwgd2lkdGgsIHgsIHk7XG4gICAgICAgIHJlZiA9IHRoaXMuY29tcHV0ZV9sZWdlbmRfYmJveCgpLCB4ID0gcmVmLngsIHkgPSByZWYueSwgd2lkdGggPSByZWYud2lkdGgsIGhlaWdodCA9IHJlZi5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBuZXcgYmJveF8xLkJCb3goe1xuICAgICAgICAgICAgeDA6IHgsXG4gICAgICAgICAgICB5MDogeSxcbiAgICAgICAgICAgIHgxOiB4ICsgd2lkdGgsXG4gICAgICAgICAgICB5MTogeSArIGhlaWdodFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExlZ2VuZFZpZXcucHJvdG90eXBlLm9uX2hpdCA9IGZ1bmN0aW9uIChzeCwgc3kpIHtcbiAgICAgICAgdmFyIGJib3gsIGZpZWxkLCBnbHlwaF9oZWlnaHQsIGdseXBoX3dpZHRoLCBoLCBpLCBpdGVtLCBqLCBrLCBsLCBsYWJlbCwgbGFiZWxfc3RhbmRvZmYsIGxhYmVscywgbGVnZW5kX2Jib3gsIGxlZ2VuZF9zcGFjaW5nLCBsZW4sIGxlbjEsIGxlbjIsIGxlbjMsIHIsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgdmVydGljYWwsIHcsIHgxLCB4MiwgeG9mZnNldCwgeTEsIHkyLCB5b2Zmc2V0O1xuICAgICAgICBnbHlwaF9oZWlnaHQgPSB0aGlzLm1vZGVsLmdseXBoX2hlaWdodDtcbiAgICAgICAgZ2x5cGhfd2lkdGggPSB0aGlzLm1vZGVsLmdseXBoX3dpZHRoO1xuICAgICAgICBsZWdlbmRfc3BhY2luZyA9IHRoaXMubW9kZWwuc3BhY2luZztcbiAgICAgICAgbGFiZWxfc3RhbmRvZmYgPSB0aGlzLm1vZGVsLmxhYmVsX3N0YW5kb2ZmO1xuICAgICAgICB4b2Zmc2V0ID0geW9mZnNldCA9IHRoaXMubW9kZWwucGFkZGluZztcbiAgICAgICAgbGVnZW5kX2Jib3ggPSB0aGlzLmNvbXB1dGVfbGVnZW5kX2Jib3goKTtcbiAgICAgICAgdmVydGljYWwgPSB0aGlzLm1vZGVsLm9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCI7XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwuaXRlbXM7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IHJlZltpXTtcbiAgICAgICAgICAgIGxhYmVscyA9IGl0ZW0uZ2V0X2xhYmVsc19saXN0X2Zyb21fbGFiZWxfcHJvcCgpO1xuICAgICAgICAgICAgZmllbGQgPSBpdGVtLmdldF9maWVsZF9mcm9tX2xhYmVsX3Byb3AoKTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSBsYWJlbHMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbHNbal07XG4gICAgICAgICAgICAgICAgeDEgPSBsZWdlbmRfYmJveC54ICsgeG9mZnNldDtcbiAgICAgICAgICAgICAgICB5MSA9IGxlZ2VuZF9iYm94LnkgKyB5b2Zmc2V0O1xuICAgICAgICAgICAgICAgIHgyID0geDEgKyBnbHlwaF93aWR0aDtcbiAgICAgICAgICAgICAgICB5MiA9IHkxICsgZ2x5cGhfaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgICAgICByZWYxID0gW2xlZ2VuZF9iYm94LndpZHRoIC0gMiAqIHRoaXMubW9kZWwucGFkZGluZywgdGhpcy5tYXhfbGFiZWxfaGVpZ2h0XSwgdyA9IHJlZjFbMF0sIGggPSByZWYxWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmMiA9IFt0aGlzLnRleHRfd2lkdGhzW2xhYmVsXSArIGdseXBoX3dpZHRoICsgbGFiZWxfc3RhbmRvZmYsIHRoaXMubWF4X2xhYmVsX2hlaWdodF0sIHcgPSByZWYyWzBdLCBoID0gcmVmMlsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmJveCA9IG5ldyBiYm94XzEuQkJveCh7XG4gICAgICAgICAgICAgICAgICAgIHgwOiB4MSxcbiAgICAgICAgICAgICAgICAgICAgeTA6IHkxLFxuICAgICAgICAgICAgICAgICAgICB4MTogeDEgKyB3LFxuICAgICAgICAgICAgICAgICAgICB5MTogeTEgKyBoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGJib3guY29udGFpbnMoc3gsIHN5KSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwuY2xpY2tfcG9saWN5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaGlkZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjMgPSBpdGVtLnJlbmRlcmVycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBsZW4yID0gcmVmMy5sZW5ndGg7IGsgPCBsZW4yOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHJlZjNba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIudmlzaWJsZSA9ICFyLnZpc2libGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm11dGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY0ID0gaXRlbS5yZW5kZXJlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gMCwgbGVuMyA9IHJlZjQubGVuZ3RoOyBsIDwgbGVuMzsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSByZWY0W2xdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLm11dGVkID0gIXIubXV0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgeW9mZnNldCArPSB0aGlzLm1heF9sYWJlbF9oZWlnaHQgKyBsZWdlbmRfc3BhY2luZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHhvZmZzZXQgKz0gdGhpcy50ZXh0X3dpZHRoc1tsYWJlbF0gKyBnbHlwaF93aWR0aCArIGxhYmVsX3N0YW5kb2ZmICsgbGVnZW5kX3NwYWNpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIExlZ2VuZFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJib3gsIGN0eDtcbiAgICAgICAgaWYgKCF0aGlzLm1vZGVsLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbC5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdHggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgIGJib3ggPSB0aGlzLmNvbXB1dGVfbGVnZW5kX2Jib3goKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5fZHJhd19sZWdlbmRfYm94KGN0eCwgYmJveCk7XG4gICAgICAgIHRoaXMuX2RyYXdfbGVnZW5kX2l0ZW1zKGN0eCwgYmJveCk7XG4gICAgICAgIHJldHVybiBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgTGVnZW5kVmlldy5wcm90b3R5cGUuX2RyYXdfbGVnZW5kX2JveCA9IGZ1bmN0aW9uIChjdHgsIGJib3gpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucmVjdChiYm94LngsIGJib3gueSwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xuICAgICAgICB0aGlzLnZpc3VhbHMuYmFja2dyb3VuZF9maWxsLnNldF92YWx1ZShjdHgpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5ib3JkZXJfbGluZS5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgIHJldHVybiBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExlZ2VuZFZpZXcucHJvdG90eXBlLl9kcmF3X2xlZ2VuZF9pdGVtcyA9IGZ1bmN0aW9uIChjdHgsIGJib3gpIHtcbiAgICAgICAgdmFyIGFjdGl2ZSwgZmllbGQsIGdseXBoX2hlaWdodCwgZ2x5cGhfd2lkdGgsIGgsIGksIGl0ZW0sIGosIGssIGxhYmVsLCBsYWJlbF9zdGFuZG9mZiwgbGFiZWxzLCBsZWdlbmRfc3BhY2luZywgbGVuLCBsZW4xLCBsZW4yLCByLCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHZlcnRpY2FsLCB2aWV3LCB3LCB4MSwgeDIsIHhvZmZzZXQsIHkxLCB5MiwgeW9mZnNldDtcbiAgICAgICAgZ2x5cGhfaGVpZ2h0ID0gdGhpcy5tb2RlbC5nbHlwaF9oZWlnaHQ7XG4gICAgICAgIGdseXBoX3dpZHRoID0gdGhpcy5tb2RlbC5nbHlwaF93aWR0aDtcbiAgICAgICAgbGVnZW5kX3NwYWNpbmcgPSB0aGlzLm1vZGVsLnNwYWNpbmc7XG4gICAgICAgIGxhYmVsX3N0YW5kb2ZmID0gdGhpcy5tb2RlbC5sYWJlbF9zdGFuZG9mZjtcbiAgICAgICAgeG9mZnNldCA9IHlvZmZzZXQgPSB0aGlzLm1vZGVsLnBhZGRpbmc7XG4gICAgICAgIHZlcnRpY2FsID0gdGhpcy5tb2RlbC5vcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiO1xuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLml0ZW1zO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSByZWZbaV07XG4gICAgICAgICAgICBsYWJlbHMgPSBpdGVtLmdldF9sYWJlbHNfbGlzdF9mcm9tX2xhYmVsX3Byb3AoKTtcbiAgICAgICAgICAgIGZpZWxkID0gaXRlbS5nZXRfZmllbGRfZnJvbV9sYWJlbF9wcm9wKCk7XG4gICAgICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwuY2xpY2tfcG9saWN5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImhpZGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheV8xLmFsbChpdGVtLnJlbmRlcmVycywgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gci52aXNpYmxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtdXRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlfMS5hbGwoaXRlbS5yZW5kZXJlcnMsIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFyLm11dGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSBsYWJlbHMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbHNbal07XG4gICAgICAgICAgICAgICAgeDEgPSBiYm94LnggKyB4b2Zmc2V0O1xuICAgICAgICAgICAgICAgIHkxID0gYmJveC55ICsgeW9mZnNldDtcbiAgICAgICAgICAgICAgICB4MiA9IHgxICsgZ2x5cGhfd2lkdGg7XG4gICAgICAgICAgICAgICAgeTIgPSB5MSArIGdseXBoX2hlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgeW9mZnNldCArPSB0aGlzLm1heF9sYWJlbF9oZWlnaHQgKyBsZWdlbmRfc3BhY2luZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHhvZmZzZXQgKz0gdGhpcy50ZXh0X3dpZHRoc1tsYWJlbF0gKyBnbHlwaF93aWR0aCArIGxhYmVsX3N0YW5kb2ZmICsgbGVnZW5kX3NwYWNpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5sYWJlbF90ZXh0LnNldF92YWx1ZShjdHgpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChsYWJlbCwgeDIgKyBsYWJlbF9zdGFuZG9mZiwgeTEgKyB0aGlzLm1heF9sYWJlbF9oZWlnaHQgLyAyLjApO1xuICAgICAgICAgICAgICAgIHJlZjEgPSBpdGVtLnJlbmRlcmVycztcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBsZW4yID0gcmVmMS5sZW5ndGg7IGsgPCBsZW4yOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHJlZjFba107XG4gICAgICAgICAgICAgICAgICAgIHZpZXcgPSB0aGlzLnBsb3Rfdmlldy5yZW5kZXJlcl92aWV3c1tyLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kcmF3X2xlZ2VuZChjdHgsIHgxLCB4MiwgeTEsIHkyLCBmaWVsZCwgbGFiZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjIgPSBbYmJveC53aWR0aCAtIDIgKiB0aGlzLm1vZGVsLnBhZGRpbmcsIHRoaXMubWF4X2xhYmVsX2hlaWdodF0sIHcgPSByZWYyWzBdLCBoID0gcmVmMlsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjMgPSBbdGhpcy50ZXh0X3dpZHRoc1tsYWJlbF0gKyBnbHlwaF93aWR0aCArIGxhYmVsX3N0YW5kb2ZmLCB0aGlzLm1heF9sYWJlbF9oZWlnaHRdLCB3ID0gcmVmM1swXSwgaCA9IHJlZjNbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgucmVjdCh4MSwgeTEsIHcsIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMuaW5hY3RpdmVfZmlsbC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMZWdlbmRWaWV3LnByb3RvdHlwZS5fZ2V0X3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiYm94LCBzaWRlO1xuICAgICAgICBiYm94ID0gdGhpcy5jb21wdXRlX2xlZ2VuZF9iYm94KCk7XG4gICAgICAgIHNpZGUgPSB0aGlzLm1vZGVsLnBhbmVsLnNpZGU7XG4gICAgICAgIGlmIChzaWRlID09PSAnYWJvdmUnIHx8IHNpZGUgPT09ICdiZWxvdycpIHtcbiAgICAgICAgICAgIHJldHVybiBiYm94LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lkZSA9PT0gJ2xlZnQnIHx8IHNpZGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiBiYm94LndpZHRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTGVnZW5kVmlldztcbn0pKGFubm90YXRpb25fMS5Bbm5vdGF0aW9uVmlldyk7XG5leHBvcnRzLkxlZ2VuZCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMZWdlbmQsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExlZ2VuZCgpIHtcbiAgICAgICAgcmV0dXJuIExlZ2VuZC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGVnZW5kLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkxlZ2VuZFZpZXc7XG4gICAgTGVnZW5kLnByb3RvdHlwZS50eXBlID0gJ0xlZ2VuZCc7XG4gICAgTGVnZW5kLnByb3RvdHlwZS5jdXJzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWNrX3BvbGljeSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwicG9pbnRlclwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMZWdlbmQucHJvdG90eXBlLmdldF9sZWdlbmRfbmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLCBpdGVtLCBsYWJlbHMsIGxlZ2VuZF9uYW1lcywgbGVuLCByZWY7XG4gICAgICAgIGxlZ2VuZF9uYW1lcyA9IFtdO1xuICAgICAgICByZWYgPSB0aGlzLml0ZW1zO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSByZWZbaV07XG4gICAgICAgICAgICBsYWJlbHMgPSBpdGVtLmdldF9sYWJlbHNfbGlzdF9mcm9tX2xhYmVsX3Byb3AoKTtcbiAgICAgICAgICAgIGxlZ2VuZF9uYW1lcyA9IGxlZ2VuZF9uYW1lcy5jb25jYXQobGFiZWxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVnZW5kX25hbWVzO1xuICAgIH07XG4gICAgTGVnZW5kLm1peGlucyhbJ3RleHQ6bGFiZWxfJywgJ2ZpbGw6aW5hY3RpdmVfJywgJ2xpbmU6Ym9yZGVyXycsICdmaWxsOmJhY2tncm91bmRfJ10pO1xuICAgIExlZ2VuZC5kZWZpbmUoe1xuICAgICAgICBvcmllbnRhdGlvbjogW3AuT3JpZW50YXRpb24sICd2ZXJ0aWNhbCddLFxuICAgICAgICBsb2NhdGlvbjogW3AuQW55LCAndG9wX3JpZ2h0J10sXG4gICAgICAgIGxhYmVsX3N0YW5kb2ZmOiBbcC5OdW1iZXIsIDVdLFxuICAgICAgICBnbHlwaF9oZWlnaHQ6IFtwLk51bWJlciwgMjBdLFxuICAgICAgICBnbHlwaF93aWR0aDogW3AuTnVtYmVyLCAyMF0sXG4gICAgICAgIGxhYmVsX2hlaWdodDogW3AuTnVtYmVyLCAyMF0sXG4gICAgICAgIGxhYmVsX3dpZHRoOiBbcC5OdW1iZXIsIDIwXSxcbiAgICAgICAgbWFyZ2luOiBbcC5OdW1iZXIsIDEwXSxcbiAgICAgICAgcGFkZGluZzogW3AuTnVtYmVyLCAxMF0sXG4gICAgICAgIHNwYWNpbmc6IFtwLk51bWJlciwgM10sXG4gICAgICAgIGl0ZW1zOiBbcC5BcnJheSwgW11dLFxuICAgICAgICBjbGlja19wb2xpY3k6IFtwLkFueSwgXCJub25lXCJdXG4gICAgfSk7XG4gICAgTGVnZW5kLm92ZXJyaWRlKHtcbiAgICAgICAgYm9yZGVyX2xpbmVfY29sb3I6IFwiI2U1ZTVlNVwiLFxuICAgICAgICBib3JkZXJfbGluZV9hbHBoYTogMC41LFxuICAgICAgICBib3JkZXJfbGluZV93aWR0aDogMSxcbiAgICAgICAgYmFja2dyb3VuZF9maWxsX2NvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgYmFja2dyb3VuZF9maWxsX2FscGhhOiAwLjk1LFxuICAgICAgICBpbmFjdGl2ZV9maWxsX2NvbG9yOiBcIndoaXRlXCIsXG4gICAgICAgIGluYWN0aXZlX2ZpbGxfYWxwaGE6IDAuOSxcbiAgICAgICAgbGFiZWxfdGV4dF9mb250X3NpemU6IFwiMTBwdFwiLFxuICAgICAgICBsYWJlbF90ZXh0X2Jhc2VsaW5lOiBcIm1pZGRsZVwiXG4gICAgfSk7XG4gICAgcmV0dXJuIExlZ2VuZDtcbn0pKGFubm90YXRpb25fMS5Bbm5vdGF0aW9uKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJpbmQgPSBmdW5jdGlvbiAoZm4sIG1lKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKVxuICAgICAgICByZXR1cm4gaTtcbn0gcmV0dXJuIC0xOyB9O1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbnZhciBjb2x1bW5fZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbHMvc291cmNlcy9jb2x1bW5fZGF0YV9zb3VyY2VcIik7XG5leHBvcnRzLkxlZ2VuZEl0ZW0gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTGVnZW5kSXRlbSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGVnZW5kSXRlbSgpIHtcbiAgICAgICAgdGhpcy5nZXRfbGFiZWxzX2xpc3RfZnJvbV9sYWJlbF9wcm9wID0gYmluZCh0aGlzLmdldF9sYWJlbHNfbGlzdF9mcm9tX2xhYmVsX3Byb3AsIHRoaXMpO1xuICAgICAgICB0aGlzLmdldF9maWVsZF9mcm9tX2xhYmVsX3Byb3AgPSBiaW5kKHRoaXMuZ2V0X2ZpZWxkX2Zyb21fbGFiZWxfcHJvcCwgdGhpcyk7XG4gICAgICAgIHJldHVybiBMZWdlbmRJdGVtLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMZWdlbmRJdGVtLnByb3RvdHlwZS50eXBlID0gXCJMZWdlbmRJdGVtXCI7XG4gICAgTGVnZW5kSXRlbS5wcm90b3R5cGUuX2NoZWNrX2RhdGFfc291cmNlc19vbl9yZW5kZXJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaWVsZCwgaSwgbGVuLCByLCByZWYsIHNvdXJjZTtcbiAgICAgICAgZmllbGQgPSB0aGlzLmdldF9maWVsZF9mcm9tX2xhYmVsX3Byb3AoKTtcbiAgICAgICAgaWYgKGZpZWxkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVycy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlID0gdGhpcy5yZW5kZXJlcnNbMF0uZGF0YV9zb3VyY2U7XG4gICAgICAgICAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWYgPSB0aGlzLnJlbmRlcmVycztcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHJlZltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIuZGF0YV9zb3VyY2UgIT09IHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgTGVnZW5kSXRlbS5wcm90b3R5cGUuX2NoZWNrX2ZpZWxkX2xhYmVsX29uX2RhdGFfc291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmllbGQsIHNvdXJjZTtcbiAgICAgICAgZmllbGQgPSB0aGlzLmdldF9maWVsZF9mcm9tX2xhYmVsX3Byb3AoKTtcbiAgICAgICAgaWYgKGZpZWxkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVycy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlID0gdGhpcy5yZW5kZXJlcnNbMF0uZGF0YV9zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSAhPSBudWxsKSAmJiBpbmRleE9mLmNhbGwoc291cmNlLmNvbHVtbnMoKSwgZmllbGQpIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIExlZ2VuZEl0ZW0ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRhdGFfc291cmNlX3ZhbGlkYXRpb24sIGZpZWxkX3ZhbGlkYXRpb247XG4gICAgICAgIExlZ2VuZEl0ZW0uX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIGRhdGFfc291cmNlX3ZhbGlkYXRpb24gPSB0aGlzLl9jaGVja19kYXRhX3NvdXJjZXNfb25fcmVuZGVyZXJzKCk7XG4gICAgICAgIGlmICghZGF0YV9zb3VyY2VfdmFsaWRhdGlvbikge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIk5vbiBtYXRjaGluZyBkYXRhIHNvdXJjZXMgb24gbGVnZW5kIGl0ZW0gcmVuZGVyZXJzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkX3ZhbGlkYXRpb24gPSB0aGlzLl9jaGVja19maWVsZF9sYWJlbF9vbl9kYXRhX3NvdXJjZSgpO1xuICAgICAgICBpZiAoIWZpZWxkX3ZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLmVycm9yKFwiQmFkIGNvbHVtbiBuYW1lIG9uIGxhYmVsOiBcIiArIHRoaXMubGFiZWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMZWdlbmRJdGVtLmRlZmluZSh7XG4gICAgICAgIGxhYmVsOiBbcC5TdHJpbmdTcGVjLCBudWxsXSxcbiAgICAgICAgcmVuZGVyZXJzOiBbcC5BcnJheSwgW11dXG4gICAgfSk7XG4gICAgTGVnZW5kSXRlbS5wcm90b3R5cGUuZ2V0X2ZpZWxkX2Zyb21fbGFiZWxfcHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCh0aGlzLmxhYmVsICE9IG51bGwpICYmICh0aGlzLmxhYmVsLmZpZWxkICE9IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbC5maWVsZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGVnZW5kSXRlbS5wcm90b3R5cGUuZ2V0X2xhYmVsc19saXN0X2Zyb21fbGFiZWxfcHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEsIGZpZWxkLCBzb3VyY2U7XG4gICAgICAgIGlmICgodGhpcy5sYWJlbCAhPSBudWxsKSAmJiAodGhpcy5sYWJlbC52YWx1ZSAhPSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmxhYmVsLnZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZCA9IHRoaXMuZ2V0X2ZpZWxkX2Zyb21fbGFiZWxfcHJvcCgpO1xuICAgICAgICBpZiAoZmllbGQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyZXJzWzBdICYmICh0aGlzLnJlbmRlcmVyc1swXS5kYXRhX3NvdXJjZSAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMucmVuZGVyZXJzWzBdLmRhdGFfc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIk5vIHNvdXJjZSBmb3VuZFwiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBjb2x1bW5fZGF0YV9zb3VyY2VfMS5Db2x1bW5EYXRhU291cmNlKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHNvdXJjZS5nZXRfY29sdW1uKGZpZWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheV8xLnVuaXEoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiSW52YWxpZCBmaWVsZFwiXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgcmV0dXJuIExlZ2VuZEl0ZW07XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBhbm5vdGF0aW9uXzEgPSByZXF1aXJlKFwiLi9hbm5vdGF0aW9uXCIpO1xudmFyIHNpZ25hbGluZ18xID0gcmVxdWlyZShcImNvcmUvc2lnbmFsaW5nXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5Qb2x5QW5ub3RhdGlvblZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUG9seUFubm90YXRpb25WaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBQb2x5QW5ub3RhdGlvblZpZXcoKSB7XG4gICAgICAgIHJldHVybiBQb2x5QW5ub3RhdGlvblZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFBvbHlBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUuY29ubmVjdF9zaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBQb2x5QW5ub3RhdGlvblZpZXcuX19zdXBlcl9fLmNvbm5lY3Rfc2lnbmFscy5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5jaGFuZ2UsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuZGF0YV91cGRhdGUsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgIH07XG4gICAgUG9seUFubm90YXRpb25WaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBjYW52YXMsIGksIGosIHJlZiwgc3gsIHN5LCB2eCwgdnksIHhzLCB5cztcbiAgICAgICAgaWYgKCF0aGlzLm1vZGVsLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB4cyA9IHRoaXMubW9kZWwueHM7XG4gICAgICAgIHlzID0gdGhpcy5tb2RlbC55cztcbiAgICAgICAgaWYgKHhzLmxlbmd0aCAhPT0geXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeHMubGVuZ3RoIDwgMyB8fCB5cy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXM7XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHhzLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC54c191bml0cyA9PT0gJ3NjcmVlbicpIHtcbiAgICAgICAgICAgICAgICB2eCA9IHhzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwueXNfdW5pdHMgPT09ICdzY3JlZW4nKSB7XG4gICAgICAgICAgICAgICAgdnkgPSB5c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN4ID0gY2FudmFzLnZ4X3RvX3N4KHZ4KTtcbiAgICAgICAgICAgIHN5ID0gY2FudmFzLnZ5X3RvX3N5KHZ5KTtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3gsIHN5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oc3gsIHN5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmZpbGwuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFBvbHlBbm5vdGF0aW9uVmlldztcbn0pKGFubm90YXRpb25fMS5Bbm5vdGF0aW9uVmlldyk7XG5leHBvcnRzLlBvbHlBbm5vdGF0aW9uID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFBvbHlBbm5vdGF0aW9uLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBQb2x5QW5ub3RhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBvbHlBbm5vdGF0aW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQb2x5QW5ub3RhdGlvbi5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5Qb2x5QW5ub3RhdGlvblZpZXc7XG4gICAgUG9seUFubm90YXRpb24ucHJvdG90eXBlLnR5cGUgPSBcIlBvbHlBbm5vdGF0aW9uXCI7XG4gICAgUG9seUFubm90YXRpb24ubWl4aW5zKFsnbGluZScsICdmaWxsJ10pO1xuICAgIFBvbHlBbm5vdGF0aW9uLmRlZmluZSh7XG4gICAgICAgIHhzOiBbcC5BcnJheSwgW11dLFxuICAgICAgICB4c191bml0czogW3AuU3BhdGlhbFVuaXRzLCAnZGF0YSddLFxuICAgICAgICB5czogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgeXNfdW5pdHM6IFtwLlNwYXRpYWxVbml0cywgJ2RhdGEnXSxcbiAgICAgICAgeF9yYW5nZV9uYW1lOiBbcC5TdHJpbmcsICdkZWZhdWx0J10sXG4gICAgICAgIHlfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddXG4gICAgfSk7XG4gICAgUG9seUFubm90YXRpb24ub3ZlcnJpZGUoe1xuICAgICAgICBmaWxsX2NvbG9yOiBcIiNmZmY5YmFcIixcbiAgICAgICAgZmlsbF9hbHBoYTogMC40LFxuICAgICAgICBsaW5lX2NvbG9yOiBcIiNjY2NjY2NcIixcbiAgICAgICAgbGluZV9hbHBoYTogMC4zXG4gICAgfSk7XG4gICAgUG9seUFubm90YXRpb24ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgUG9seUFubm90YXRpb24uX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFfdXBkYXRlID0gbmV3IHNpZ25hbGluZ18xLlNpZ25hbCh0aGlzLCBcImRhdGFfdXBkYXRlXCIpO1xuICAgIH07XG4gICAgUG9seUFubm90YXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIHhzLCB5cztcbiAgICAgICAgeHMgPSBhcmcueHMsIHlzID0gYXJnLnlzO1xuICAgICAgICB0aGlzLnNldHYoe1xuICAgICAgICAgICAgeHM6IHhzLFxuICAgICAgICAgICAgeXM6IHlzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YV91cGRhdGUuZW1pdCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFBvbHlBbm5vdGF0aW9uO1xufSkoYW5ub3RhdGlvbl8xLkFubm90YXRpb24pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL2Fubm90YXRpb25cIik7XG52YXIgZG9tXzEgPSByZXF1aXJlKFwiY29yZS9kb21cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLlNwYW5WaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFNwYW5WaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTcGFuVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFNwYW5WaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTcGFuVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIFNwYW5WaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMucGxvdF92aWV3LmNhbnZhc19vdmVybGF5cy5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgcmV0dXJuIGRvbV8xLmhpZGUodGhpcy5lbCk7XG4gICAgfTtcbiAgICBTcGFuVmlldy5wcm90b3R5cGUuY29ubmVjdF9zaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBTcGFuVmlldy5fX3N1cGVyX18uY29ubmVjdF9zaWduYWxzLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmZvcl9ob3Zlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnByb3BlcnRpZXMuY29tcHV0ZWRfbG9jYXRpb24uY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RyYXdfc3BhbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5yZW5kZXJfbW9kZSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5jaGFuZ2UsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wbG90X3ZpZXcucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnByb3BlcnRpZXMubG9jYXRpb24uY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucGxvdF92aWV3LnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLmxvY2F0aW9uLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZHJhd19zcGFuKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNwYW5WaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC52aXNpYmxlICYmIHRoaXMubW9kZWwucmVuZGVyX21vZGUgPT09ICdjc3MnKSB7XG4gICAgICAgICAgICBkb21fMS5oaWRlKHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyYXdfc3BhbigpO1xuICAgIH07XG4gICAgU3BhblZpZXcucHJvdG90eXBlLl9kcmF3X3NwYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYW52YXMsIGN0eCwgZnJhbWUsIGhlaWdodCwgbG9jLCBzbGVmdCwgc3RvcCwgd2lkdGgsIHhzY2FsZSwgeXNjYWxlO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5mb3JfaG92ZXIpIHtcbiAgICAgICAgICAgIGxvYyA9IHRoaXMubW9kZWwuY29tcHV0ZWRfbG9jYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2MgPSB0aGlzLm1vZGVsLmxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgZG9tXzEuaGlkZSh0aGlzLmVsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcztcbiAgICAgICAgeHNjYWxlID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueHNjYWxlc1t0aGlzLm1vZGVsLnhfcmFuZ2VfbmFtZV07XG4gICAgICAgIHlzY2FsZSA9IHRoaXMucGxvdF92aWV3LmZyYW1lLnlzY2FsZXNbdGhpcy5tb2RlbC55X3JhbmdlX25hbWVdO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5kaW1lbnNpb24gPT09ICd3aWR0aCcpIHtcbiAgICAgICAgICAgIHN0b3AgPSBjYW52YXMudnlfdG9fc3kodGhpcy5fY2FsY19kaW0obG9jLCB5c2NhbGUpKTtcbiAgICAgICAgICAgIHNsZWZ0ID0gY2FudmFzLnZ4X3RvX3N4KGZyYW1lLl9sZWZ0LnZhbHVlKTtcbiAgICAgICAgICAgIHdpZHRoID0gZnJhbWUuX3dpZHRoLnZhbHVlO1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5tb2RlbC5wcm9wZXJ0aWVzLmxpbmVfd2lkdGgudmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AgPSBjYW52YXMudnlfdG9fc3koZnJhbWUuX3RvcC52YWx1ZSk7XG4gICAgICAgICAgICBzbGVmdCA9IGNhbnZhcy52eF90b19zeCh0aGlzLl9jYWxjX2RpbShsb2MsIHhzY2FsZSkpO1xuICAgICAgICAgICAgd2lkdGggPSB0aGlzLm1vZGVsLnByb3BlcnRpZXMubGluZV93aWR0aC52YWx1ZSgpO1xuICAgICAgICAgICAgaGVpZ2h0ID0gZnJhbWUuX2hlaWdodC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbC5yZW5kZXJfbW9kZSA9PT0gXCJjc3NcIikge1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS50b3AgPSBzdG9wICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5sZWZ0ID0gc2xlZnQgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuekluZGV4ID0gMTAwMDtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5tb2RlbC5wcm9wZXJ0aWVzLmxpbmVfY29sb3IudmFsdWUoKTtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUub3BhY2l0eSA9IHRoaXMubW9kZWwucHJvcGVydGllcy5saW5lX2FscGhhLnZhbHVlKCk7XG4gICAgICAgICAgICByZXR1cm4gZG9tXzEuc2hvdyh0aGlzLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1vZGVsLnJlbmRlcl9tb2RlID09PSBcImNhbnZhc1wiKSB7XG4gICAgICAgICAgICBjdHggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHNsZWZ0LCBzdG9wKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLmRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiKSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhzbGVmdCArIHdpZHRoLCBzdG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oc2xlZnQsIHN0b3AgKyBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNwYW5WaWV3LnByb3RvdHlwZS5fY2FsY19kaW0gPSBmdW5jdGlvbiAobG9jYXRpb24sIHNjYWxlKSB7XG4gICAgICAgIHZhciB2ZGltO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5sb2NhdGlvbl91bml0cyA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICB2ZGltID0gc2NhbGUuY29tcHV0ZShsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ZGltID0gbG9jYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZkaW07XG4gICAgfTtcbiAgICByZXR1cm4gU3BhblZpZXc7XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvblZpZXcpO1xuZXhwb3J0cy5TcGFuID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFNwYW4sIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFNwYW4oKSB7XG4gICAgICAgIHJldHVybiBTcGFuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTcGFuLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlNwYW5WaWV3O1xuICAgIFNwYW4ucHJvdG90eXBlLnR5cGUgPSAnU3Bhbic7XG4gICAgU3Bhbi5taXhpbnMoWydsaW5lJ10pO1xuICAgIFNwYW4uZGVmaW5lKHtcbiAgICAgICAgcmVuZGVyX21vZGU6IFtwLlJlbmRlck1vZGUsICdjYW52YXMnXSxcbiAgICAgICAgeF9yYW5nZV9uYW1lOiBbcC5TdHJpbmcsICdkZWZhdWx0J10sXG4gICAgICAgIHlfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddLFxuICAgICAgICBsb2NhdGlvbjogW3AuTnVtYmVyLCBudWxsXSxcbiAgICAgICAgbG9jYXRpb25fdW5pdHM6IFtwLlNwYXRpYWxVbml0cywgJ2RhdGEnXSxcbiAgICAgICAgZGltZW5zaW9uOiBbcC5EaW1lbnNpb24sICd3aWR0aCddXG4gICAgfSk7XG4gICAgU3Bhbi5vdmVycmlkZSh7XG4gICAgICAgIGxpbmVfY29sb3I6ICdibGFjaydcbiAgICB9KTtcbiAgICBTcGFuLmludGVybmFsKHtcbiAgICAgICAgZm9yX2hvdmVyOiBbcC5Cb29sZWFuLCBmYWxzZV0sXG4gICAgICAgIGNvbXB1dGVkX2xvY2F0aW9uOiBbcC5OdW1iZXIsIG51bGxdXG4gICAgfSk7XG4gICAgcmV0dXJuIFNwYW47XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvbik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYW5ub3RhdGlvbl8xID0gcmVxdWlyZShcIi4vYW5ub3RhdGlvblwiKTtcbnZhciBkb21fMSA9IHJlcXVpcmUoXCJjb3JlL2RvbVwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90eXBlc1wiKTtcbnZhciB0ZXh0XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3RleHRcIik7XG5leHBvcnRzLlRleHRBbm5vdGF0aW9uVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUZXh0QW5ub3RhdGlvblZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRleHRBbm5vdGF0aW9uVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFRleHRBbm5vdGF0aW9uVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGV4dEFubm90YXRpb25WaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgVGV4dEFubm90YXRpb25WaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcztcbiAgICAgICAgdGhpcy5mcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucmVuZGVyX21vZGUgPT09ICdjc3MnKSB7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2JrLWFubm90YXRpb24nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5jYW52YXNfb3ZlcmxheXMuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUuY29ubmVjdF9zaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBUZXh0QW5ub3RhdGlvblZpZXcuX19zdXBlcl9fLmNvbm5lY3Rfc2lnbmFscy5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5yZW5kZXJfbW9kZSA9PT0gJ2NzcycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5jaGFuZ2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLmNoYW5nZSwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wbG90X3ZpZXcucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0QW5ub3RhdGlvblZpZXcucHJvdG90eXBlLl9jYWxjdWxhdGVfdGV4dF9kaW1lbnNpb25zID0gZnVuY3Rpb24gKGN0eCwgdGV4dCkge1xuICAgICAgICB2YXIgaGVpZ2h0LCB3aWR0aDtcbiAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgICAgIGhlaWdodCA9IHRleHRfMS5nZXRfdGV4dF9oZWlnaHQodGhpcy52aXN1YWxzLnRleHQuZm9udF92YWx1ZSgpKS5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBbd2lkdGgsIGhlaWdodF07XG4gICAgfTtcbiAgICBUZXh0QW5ub3RhdGlvblZpZXcucHJvdG90eXBlLl9jYWxjdWxhdGVfYm91bmRpbmdfYm94X2RpbWVuc2lvbnMgPSBmdW5jdGlvbiAoY3R4LCB0ZXh0KSB7XG4gICAgICAgIHZhciBoZWlnaHQsIHJlZiwgd2lkdGgsIHhfb2Zmc2V0LCB5X29mZnNldDtcbiAgICAgICAgcmVmID0gdGhpcy5fY2FsY3VsYXRlX3RleHRfZGltZW5zaW9ucyhjdHgsIHRleHQpLCB3aWR0aCA9IHJlZlswXSwgaGVpZ2h0ID0gcmVmWzFdO1xuICAgICAgICBzd2l0Y2ggKGN0eC50ZXh0QWxpZ24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHhfb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgeF9vZmZzZXQgPSAtd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHhfb2Zmc2V0ID0gLXdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoY3R4LnRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICB5X29mZnNldCA9IDAuMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgeV9vZmZzZXQgPSAtMC41ICogaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB5X29mZnNldCA9IC0xLjAgKiBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbHBoYWJldGljJzpcbiAgICAgICAgICAgICAgICB5X29mZnNldCA9IC0wLjggKiBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdoYW5naW5nJzpcbiAgICAgICAgICAgICAgICB5X29mZnNldCA9IC0wLjE3ICogaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaWRlb2dyYXBoaWMnOlxuICAgICAgICAgICAgICAgIHlfb2Zmc2V0ID0gLTAuODMgKiBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4X29mZnNldCwgeV9vZmZzZXQsIHdpZHRoLCBoZWlnaHRdO1xuICAgIH07XG4gICAgVGV4dEFubm90YXRpb25WaWV3LnByb3RvdHlwZS5fZ2V0X3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHg7XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgdGhpcy52aXN1YWxzLnRleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIHJldHVybiBjdHgubWVhc3VyZVRleHQodGhpcy5tb2RlbC50ZXh0KS5hc2NlbnQ7XG4gICAgfTtcbiAgICBUZXh0QW5ub3RhdGlvblZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUZXh0QW5ub3RhdGlvblZpZXcucHJvdG90eXBlLl9jYW52YXNfdGV4dCA9IGZ1bmN0aW9uIChjdHgsIHRleHQsIHN4LCBzeSwgYW5nbGUpIHtcbiAgICAgICAgdmFyIGJib3hfZGltcztcbiAgICAgICAgdGhpcy52aXN1YWxzLnRleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIGJib3hfZGltcyA9IHRoaXMuX2NhbGN1bGF0ZV9ib3VuZGluZ19ib3hfZGltZW5zaW9ucyhjdHgsIHRleHQpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoc3gsIHN5KTtcbiAgICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgICAgICBjdHgucm90YXRlKGFuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucmVjdChiYm94X2RpbXNbMF0sIGJib3hfZGltc1sxXSwgYmJveF9kaW1zWzJdLCBiYm94X2RpbXNbM10pO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmJhY2tncm91bmRfZmlsbC5kb2l0KSB7XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHMuYmFja2dyb3VuZF9maWxsLnNldF92YWx1ZShjdHgpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5ib3JkZXJfbGluZS5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXN1YWxzLnRleHQuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLnRleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBUZXh0QW5ub3RhdGlvblZpZXcucHJvdG90eXBlLl9jc3NfdGV4dCA9IGZ1bmN0aW9uIChjdHgsIHRleHQsIHN4LCBzeSwgYW5nbGUpIHtcbiAgICAgICAgdmFyIGJib3hfZGltcywgbGQsIGxpbmVfZGFzaDtcbiAgICAgICAgZG9tXzEuaGlkZSh0aGlzLmVsKTtcbiAgICAgICAgdGhpcy52aXN1YWxzLnRleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIGJib3hfZGltcyA9IHRoaXMuX2NhbGN1bGF0ZV9ib3VuZGluZ19ib3hfZGltZW5zaW9ucyhjdHgsIHRleHQpO1xuICAgICAgICBsZCA9IHRoaXMudmlzdWFscy5ib3JkZXJfbGluZS5saW5lX2Rhc2gudmFsdWUoKTtcbiAgICAgICAgaWYgKHR5cGVzXzEuaXNBcnJheShsZCkpIHtcbiAgICAgICAgICAgIGlmIChsZC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgbGluZV9kYXNoID0gXCJzb2xpZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZV9kYXNoID0gXCJkYXNoZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZXNfMS5pc1N0cmluZyhsZCkpIHtcbiAgICAgICAgICAgIGxpbmVfZGFzaCA9IGxkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzdWFscy5ib3JkZXJfbGluZS5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgdGhpcy52aXN1YWxzLmJhY2tncm91bmRfZmlsbC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IChzeCArIGJib3hfZGltc1swXSkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gKHN5ICsgYmJveF9kaW1zWzFdKSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5jb2xvciA9IFwiXCIgKyAodGhpcy52aXN1YWxzLnRleHQudGV4dF9jb2xvci52YWx1ZSgpKTtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5vcGFjaXR5ID0gXCJcIiArICh0aGlzLnZpc3VhbHMudGV4dC50ZXh0X2FscGhhLnZhbHVlKCkpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLmZvbnQgPSBcIlwiICsgKHRoaXMudmlzdWFscy50ZXh0LmZvbnRfdmFsdWUoKSk7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUubGluZUhlaWdodCA9IFwibm9ybWFsXCI7XG4gICAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS50cmFuc2Zvcm0gPSBcInJvdGF0ZShcIiArIGFuZ2xlICsgXCJyYWQpXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5iYWNrZ3JvdW5kX2ZpbGwuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIlwiICsgKHRoaXMudmlzdWFscy5iYWNrZ3JvdW5kX2ZpbGwuY29sb3JfdmFsdWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5ib3JkZXJfbGluZS5kb2l0KSB7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmJvcmRlclN0eWxlID0gXCJcIiArIGxpbmVfZGFzaDtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuYm9yZGVyV2lkdGggPSAodGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLmxpbmVfd2lkdGgudmFsdWUoKSkgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmJvcmRlckNvbG9yID0gXCJcIiArICh0aGlzLnZpc3VhbHMuYm9yZGVyX2xpbmUuY29sb3JfdmFsdWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIHJldHVybiBkb21fMS5zaG93KHRoaXMuZWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFRleHRBbm5vdGF0aW9uVmlldztcbn0pKGFubm90YXRpb25fMS5Bbm5vdGF0aW9uVmlldyk7XG5leHBvcnRzLlRleHRBbm5vdGF0aW9uID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRleHRBbm5vdGF0aW9uLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUZXh0QW5ub3RhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFRleHRBbm5vdGF0aW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUZXh0QW5ub3RhdGlvbi5wcm90b3R5cGUudHlwZSA9ICdUZXh0QW5ub3RhdGlvbic7XG4gICAgVGV4dEFubm90YXRpb24ucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuVGV4dEFubm90YXRpb25WaWV3O1xuICAgIHJldHVybiBUZXh0QW5ub3RhdGlvbjtcbn0pKGFubm90YXRpb25fMS5Bbm5vdGF0aW9uKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0ZXh0X2Fubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL3RleHRfYW5ub3RhdGlvblwiKTtcbnZhciBkb21fMSA9IHJlcXVpcmUoXCJjb3JlL2RvbVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBWaXN1YWxzID0gcmVxdWlyZShcImNvcmUvdmlzdWFsc1wiKTtcbmV4cG9ydHMuVGl0bGVWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRpdGxlVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVGl0bGVWaWV3KCkge1xuICAgICAgICByZXR1cm4gVGl0bGVWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUaXRsZVZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgY3R4O1xuICAgICAgICBUaXRsZVZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy52aXN1YWxzLnRleHQgPSBuZXcgVmlzdWFscy5UZXh0KHRoaXMubW9kZWwpO1xuICAgICAgICBjdHggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMubW9kZWwucGFuZWwuYXBwbHlfbGFiZWxfdGV4dF9oZXVyaXN0aWNzKGN0eCwgJ2p1c3RpZmllZCcpO1xuICAgICAgICB0aGlzLm1vZGVsLnRleHRfYmFzZWxpbmUgPSBjdHgudGV4dEJhc2VsaW5lO1xuICAgICAgICB0aGlzLm1vZGVsLnRleHRfYWxpZ24gPSB0aGlzLm1vZGVsLmFsaWduO1xuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIFRpdGxlVmlldy5wcm90b3R5cGUuX2dldF9jb21wdXRlZF9sb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhlaWdodCwgcmVmLCBzeCwgc3ksIHZ4LCB2eSwgd2lkdGg7XG4gICAgICAgIHJlZiA9IHRoaXMuX2NhbGN1bGF0ZV90ZXh0X2RpbWVuc2lvbnModGhpcy5wbG90X3ZpZXcuY2FudmFzX3ZpZXcuY3R4LCB0aGlzLnRleHQpLCB3aWR0aCA9IHJlZlswXSwgaGVpZ2h0ID0gcmVmWzFdO1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwucGFuZWwuc2lkZSkge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgdnggPSAwO1xuICAgICAgICAgICAgICAgIHZ5ID0gdGhpcy5fZ2V0X3RleHRfbG9jYXRpb24odGhpcy5tb2RlbC5hbGlnbiwgdGhpcy5mcmFtZS52X3JhbmdlKSArIHRoaXMubW9kZWwub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHZ4ID0gdGhpcy5jYW52YXMuX3JpZ2h0LnZhbHVlIC0gMTtcbiAgICAgICAgICAgICAgICB2eSA9IHRoaXMuY2FudmFzLl9oZWlnaHQudmFsdWUgLSB0aGlzLl9nZXRfdGV4dF9sb2NhdGlvbih0aGlzLm1vZGVsLmFsaWduLCB0aGlzLmZyYW1lLnZfcmFuZ2UpIC0gdGhpcy5tb2RlbC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhYm92ZSc6XG4gICAgICAgICAgICAgICAgdnggPSB0aGlzLl9nZXRfdGV4dF9sb2NhdGlvbih0aGlzLm1vZGVsLmFsaWduLCB0aGlzLmZyYW1lLmhfcmFuZ2UpICsgdGhpcy5tb2RlbC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgdnkgPSB0aGlzLmNhbnZhcy5fdG9wLnZhbHVlIC0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiZWxvdyc6XG4gICAgICAgICAgICAgICAgdnggPSB0aGlzLl9nZXRfdGV4dF9sb2NhdGlvbih0aGlzLm1vZGVsLmFsaWduLCB0aGlzLmZyYW1lLmhfcmFuZ2UpICsgdGhpcy5tb2RlbC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgdnkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHN4ID0gdGhpcy5jYW52YXMudnhfdG9fc3godngpO1xuICAgICAgICBzeSA9IHRoaXMuY2FudmFzLnZ5X3RvX3N5KHZ5KTtcbiAgICAgICAgcmV0dXJuIFtzeCwgc3ldO1xuICAgIH07XG4gICAgVGl0bGVWaWV3LnByb3RvdHlwZS5fZ2V0X3RleHRfbG9jYXRpb24gPSBmdW5jdGlvbiAoYWxpZ25tZW50LCByYW5nZSkge1xuICAgICAgICB2YXIgdGV4dF9sb2NhdGlvbjtcbiAgICAgICAgc3dpdGNoIChhbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHRleHRfbG9jYXRpb24gPSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgdGV4dF9sb2NhdGlvbiA9IChyYW5nZS5lbmQgKyByYW5nZS5zdGFydCkgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHRleHRfbG9jYXRpb24gPSByYW5nZS5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHRfbG9jYXRpb247XG4gICAgfTtcbiAgICBUaXRsZVZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFuZ2xlLCBjdHgsIHJlZiwgc3gsIHN5O1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwudmlzaWJsZSAmJiB0aGlzLm1vZGVsLnJlbmRlcl9tb2RlID09PSAnY3NzJykge1xuICAgICAgICAgICAgZG9tXzEuaGlkZSh0aGlzLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubW9kZWwudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFuZ2xlID0gdGhpcy5tb2RlbC5wYW5lbC5nZXRfbGFiZWxfYW5nbGVfaGV1cmlzdGljKCdwYXJhbGxlbCcpO1xuICAgICAgICByZWYgPSB0aGlzLl9nZXRfY29tcHV0ZWRfbG9jYXRpb24oKSwgc3ggPSByZWZbMF0sIHN5ID0gcmVmWzFdO1xuICAgICAgICBjdHggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnRleHQgPT09IFwiXCIgfHwgdGhpcy5tb2RlbC50ZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwucmVuZGVyX21vZGUgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzX3RleHQoY3R4LCB0aGlzLm1vZGVsLnRleHQsIHN4LCBzeSwgYW5nbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nzc190ZXh0KGN0eCwgdGhpcy5tb2RlbC50ZXh0LCBzeCwgc3ksIGFuZ2xlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGl0bGVWaWV3LnByb3RvdHlwZS5fZ2V0X3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHgsIHRleHQ7XG4gICAgICAgIHRleHQgPSB0aGlzLm1vZGVsLnRleHQ7XG4gICAgICAgIGlmICh0ZXh0ID09PSBcIlwiIHx8IHRleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzX3ZpZXcuY3R4O1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLnRleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gY3R4Lm1lYXN1cmVUZXh0KHRleHQpLmFzY2VudCArIDEwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGl0bGVWaWV3O1xufSkodGV4dF9hbm5vdGF0aW9uXzEuVGV4dEFubm90YXRpb25WaWV3KTtcbmV4cG9ydHMuVGl0bGUgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVGl0bGUsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRpdGxlKCkge1xuICAgICAgICByZXR1cm4gVGl0bGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRpdGxlLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlRpdGxlVmlldztcbiAgICBUaXRsZS5wcm90b3R5cGUudHlwZSA9ICdUaXRsZSc7XG4gICAgVGl0bGUubWl4aW5zKFsnbGluZTpib3JkZXJfJywgJ2ZpbGw6YmFja2dyb3VuZF8nXSk7XG4gICAgVGl0bGUuZGVmaW5lKHtcbiAgICAgICAgdGV4dDogW3AuU3RyaW5nXSxcbiAgICAgICAgdGV4dF9mb250OiBbcC5Gb250LCAnaGVsdmV0aWNhJ10sXG4gICAgICAgIHRleHRfZm9udF9zaXplOiBbcC5Gb250U2l6ZVNwZWMsICcxMHB0J10sXG4gICAgICAgIHRleHRfZm9udF9zdHlsZTogW3AuRm9udFN0eWxlLCAnYm9sZCddLFxuICAgICAgICB0ZXh0X2NvbG9yOiBbcC5Db2xvclNwZWMsICcjNDQ0NDQ0J10sXG4gICAgICAgIHRleHRfYWxwaGE6IFtwLk51bWJlclNwZWMsIDEuMF0sXG4gICAgICAgIGFsaWduOiBbcC5UZXh0QWxpZ24sICdsZWZ0J10sXG4gICAgICAgIG9mZnNldDogW3AuTnVtYmVyLCAwXSxcbiAgICAgICAgcmVuZGVyX21vZGU6IFtwLlJlbmRlck1vZGUsICdjYW52YXMnXVxuICAgIH0pO1xuICAgIFRpdGxlLm92ZXJyaWRlKHtcbiAgICAgICAgYmFja2dyb3VuZF9maWxsX2NvbG9yOiBudWxsLFxuICAgICAgICBib3JkZXJfbGluZV9jb2xvcjogbnVsbFxuICAgIH0pO1xuICAgIFRpdGxlLmludGVybmFsKHtcbiAgICAgICAgdGV4dF9hbGlnbjogW3AuVGV4dEFsaWduLCAnbGVmdCddLFxuICAgICAgICB0ZXh0X2Jhc2VsaW5lOiBbcC5UZXh0QmFzZWxpbmUsICdib3R0b20nXVxuICAgIH0pO1xuICAgIHJldHVybiBUaXRsZTtcbn0pKHRleHRfYW5ub3RhdGlvbl8xLlRleHRBbm5vdGF0aW9uKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBhbm5vdGF0aW9uXzEgPSByZXF1aXJlKFwiLi9hbm5vdGF0aW9uXCIpO1xudmFyIGRvbV8xID0gcmVxdWlyZShcImNvcmUvZG9tXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5Ub29sdGlwVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUb29sdGlwVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVG9vbHRpcFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBUb29sdGlwVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVG9vbHRpcFZpZXcucHJvdG90eXBlLmNsYXNzTmFtZSA9IFwiYmstdG9vbHRpcFwiO1xuICAgIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgVG9vbHRpcFZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wbG90X3ZpZXcuY2FudmFzX292ZXJsYXlzLmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnpJbmRleCA9IDEwMTA7XG4gICAgICAgIHJldHVybiBkb21fMS5oaWRlKHRoaXMuZWwpO1xuICAgIH07XG4gICAgVG9vbHRpcFZpZXcucHJvdG90eXBlLmNvbm5lY3Rfc2lnbmFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgVG9vbHRpcFZpZXcuX19zdXBlcl9fLmNvbm5lY3Rfc2lnbmFscy5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMubW9kZWwucHJvcGVydGllcy5kYXRhLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RyYXdfdGlwcygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyYXdfdGlwcygpO1xuICAgIH07XG4gICAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl9kcmF3X3RpcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnJvd19zaXplLCBhdHRhY2htZW50LCBib3R0b20sIGNvbnRlbnQsIGRhdGEsIGhlaWdodCwgaSwgbGVmdCwgbGVuLCBzaWRlLCBzeCwgc3ksIHRpcCwgdG9wLCB2YWwsIHZ4LCB2eSwgd2lkdGg7XG4gICAgICAgIGRhdGEgPSB0aGlzLm1vZGVsLmRhdGE7XG4gICAgICAgIGRvbV8xLmVtcHR5KHRoaXMuZWwpO1xuICAgICAgICBkb21fMS5oaWRlKHRoaXMuZWwpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5jdXN0b20pIHtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcImJrLXRvb2x0aXAtY3VzdG9tXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwiYmstdG9vbHRpcC1jdXN0b21cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFsID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHZ4ID0gdmFsWzBdLCB2eSA9IHZhbFsxXSwgY29udGVudCA9IHZhbFsyXTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLmlubmVyX29ubHkgJiYgIXRoaXMucGxvdF92aWV3LmZyYW1lLmNvbnRhaW5zKHZ4LCB2eSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpcCA9IGRvbV8xLmRpdih7fSwgY29udGVudCk7XG4gICAgICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRpcCk7XG4gICAgICAgIH1cbiAgICAgICAgc3ggPSB0aGlzLnBsb3Rfdmlldy5tb2RlbC5jYW52YXMudnhfdG9fc3godngpO1xuICAgICAgICBzeSA9IHRoaXMucGxvdF92aWV3Lm1vZGVsLmNhbnZhcy52eV90b19zeSh2eSk7XG4gICAgICAgIGF0dGFjaG1lbnQgPSB0aGlzLm1vZGVsLmF0dGFjaG1lbnQ7XG4gICAgICAgIHN3aXRjaCAoYXR0YWNobWVudCkge1xuICAgICAgICAgICAgY2FzZSBcImhvcml6b250YWxcIjpcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHRoaXMucGxvdF92aWV3LmZyYW1lLl93aWR0aC52YWx1ZTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUuX2xlZnQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHZ4IC0gbGVmdCA8IHdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgICAgICBzaWRlID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZGUgPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUuX2hlaWdodC52YWx1ZTtcbiAgICAgICAgICAgICAgICBib3R0b20gPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS5fYm90dG9tLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh2eSAtIGJvdHRvbSA8IGhlaWdodCAvIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lkZSA9ICdiZWxvdyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaWRlID0gJ2Fib3ZlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHNpZGUgPSBhdHRhY2htZW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcImJrLXJpZ2h0XCIpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJiay1sZWZ0XCIpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJiay1hYm92ZVwiKTtcbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwiYmstYmVsb3dcIik7XG4gICAgICAgIGFycm93X3NpemUgPSAxMDtcbiAgICAgICAgZG9tXzEuc2hvdyh0aGlzLmVsKTtcbiAgICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJiay1sZWZ0XCIpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBzeCArICh0aGlzLmVsLm9mZnNldFdpZHRoIC0gdGhpcy5lbC5jbGllbnRXaWR0aCkgKyBhcnJvd19zaXplO1xuICAgICAgICAgICAgICAgIHRvcCA9IHN5IC0gdGhpcy5lbC5vZmZzZXRIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJiay1yaWdodFwiKTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gc3ggLSB0aGlzLmVsLm9mZnNldFdpZHRoIC0gYXJyb3dfc2l6ZTtcbiAgICAgICAgICAgICAgICB0b3AgPSBzeSAtIHRoaXMuZWwub2Zmc2V0SGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhYm92ZVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcImJrLWFib3ZlXCIpO1xuICAgICAgICAgICAgICAgIHRvcCA9IHN5ICsgKHRoaXMuZWwub2Zmc2V0SGVpZ2h0IC0gdGhpcy5lbC5jbGllbnRIZWlnaHQpICsgYXJyb3dfc2l6ZTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5yb3VuZChzeCAtIHRoaXMuZWwub2Zmc2V0V2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJiZWxvd1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcImJrLWJlbG93XCIpO1xuICAgICAgICAgICAgICAgIHRvcCA9IHN5IC0gdGhpcy5lbC5vZmZzZXRIZWlnaHQgLSBhcnJvd19zaXplO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLnJvdW5kKHN4IC0gdGhpcy5lbC5vZmZzZXRXaWR0aCAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnNob3dfYXJyb3cpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcImJrLXRvb2x0aXAtYXJyb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWwuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRvbV8xLmhpZGUodGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUb29sdGlwVmlldztcbn0pKGFubm90YXRpb25fMS5Bbm5vdGF0aW9uVmlldyk7XG5leHBvcnRzLlRvb2x0aXAgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9vbHRpcCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVG9vbHRpcCgpIHtcbiAgICAgICAgcmV0dXJuIFRvb2x0aXAuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvb2x0aXAucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuVG9vbHRpcFZpZXc7XG4gICAgVG9vbHRpcC5wcm90b3R5cGUudHlwZSA9ICdUb29sdGlwJztcbiAgICBUb29sdGlwLmRlZmluZSh7XG4gICAgICAgIGF0dGFjaG1lbnQ6IFtwLlN0cmluZywgJ2hvcml6b250YWwnXSxcbiAgICAgICAgaW5uZXJfb25seTogW3AuQm9vbCwgdHJ1ZV0sXG4gICAgICAgIHNob3dfYXJyb3c6IFtwLkJvb2wsIHRydWVdXG4gICAgfSk7XG4gICAgVG9vbHRpcC5vdmVycmlkZSh7XG4gICAgICAgIGxldmVsOiAnb3ZlcmxheSdcbiAgICB9KTtcbiAgICBUb29sdGlwLmludGVybmFsKHtcbiAgICAgICAgZGF0YTogW3AuQW55LCBbXV0sXG4gICAgICAgIGN1c3RvbTogW3AuQW55XVxuICAgIH0pO1xuICAgIFRvb2x0aXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhID0gW107XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodngsIHZ5LCBjb250ZW50KSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBkYXRhLnB1c2goW3Z4LCB2eSwgY29udGVudF0pO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmRhdGEuY2hhbmdlLmVtaXQoKTtcbiAgICB9O1xuICAgIHJldHVybiBUb29sdGlwO1xufSkoYW5ub3RhdGlvbl8xLkFubm90YXRpb24pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL2Fubm90YXRpb25cIik7XG52YXIgY29sdW1uX2RhdGFfc291cmNlXzEgPSByZXF1aXJlKFwiLi4vc291cmNlcy9jb2x1bW5fZGF0YV9zb3VyY2VcIik7XG52YXIgYXJyb3dfaGVhZF8xID0gcmVxdWlyZShcIi4vYXJyb3dfaGVhZFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuV2hpc2tlclZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoV2hpc2tlclZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFdoaXNrZXJWaWV3KCkge1xuICAgICAgICByZXR1cm4gV2hpc2tlclZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFdoaXNrZXJWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgV2hpc2tlclZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0X2RhdGEodGhpcy5tb2RlbC5zb3VyY2UpO1xuICAgIH07XG4gICAgV2hpc2tlclZpZXcucHJvdG90eXBlLmNvbm5lY3Rfc2lnbmFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgV2hpc2tlclZpZXcuX19zdXBlcl9fLmNvbm5lY3Rfc2lnbmFscy5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5zb3VyY2Uuc3RyZWFtaW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRfZGF0YSh0aGlzLm1vZGVsLnNvdXJjZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5zb3VyY2UucGF0Y2hpbmcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldF9kYXRhKHRoaXMubW9kZWwuc291cmNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5zb3VyY2UuY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRfZGF0YSh0aGlzLm1vZGVsLnNvdXJjZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV2hpc2tlclZpZXcucHJvdG90eXBlLnNldF9kYXRhID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBXaGlza2VyVmlldy5fX3N1cGVyX18uc2V0X2RhdGEuY2FsbCh0aGlzLCBzb3VyY2UpO1xuICAgICAgICB0aGlzLnZpc3VhbHMud2FybV9jYWNoZShzb3VyY2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5wbG90X3ZpZXcucmVxdWVzdF9yZW5kZXIoKTtcbiAgICB9O1xuICAgIFdoaXNrZXJWaWV3LnByb3RvdHlwZS5fbWFwX2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYmFzZV92eCwgX2xvd2VyLCBfbG93ZXJfdngsIF91cHBlciwgX3VwcGVyX3Z4LCBiYXNlX3NjYWxlLCBpLCBqLCBsaW1pdF9zY2FsZSwgcmVmLCB4X3NjYWxlLCB5X3NjYWxlO1xuICAgICAgICB4X3NjYWxlID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueHNjYWxlc1t0aGlzLm1vZGVsLnhfcmFuZ2VfbmFtZV07XG4gICAgICAgIHlfc2NhbGUgPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS55c2NhbGVzW3RoaXMubW9kZWwueV9yYW5nZV9uYW1lXTtcbiAgICAgICAgbGltaXRfc2NhbGUgPSB0aGlzLm1vZGVsLmRpbWVuc2lvbiA9PT0gXCJoZWlnaHRcIiA/IHlfc2NhbGUgOiB4X3NjYWxlO1xuICAgICAgICBiYXNlX3NjYWxlID0gdGhpcy5tb2RlbC5kaW1lbnNpb24gPT09IFwiaGVpZ2h0XCIgPyB4X3NjYWxlIDogeV9zY2FsZTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwubG93ZXIudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICBfbG93ZXJfdnggPSBsaW1pdF9zY2FsZS52X2NvbXB1dGUodGhpcy5fbG93ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2xvd2VyX3Z4ID0gdGhpcy5fbG93ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwudXBwZXIudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICBfdXBwZXJfdnggPSBsaW1pdF9zY2FsZS52X2NvbXB1dGUodGhpcy5fdXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3VwcGVyX3Z4ID0gdGhpcy5fdXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwuYmFzZS51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIF9iYXNlX3Z4ID0gYmFzZV9zY2FsZS52X2NvbXB1dGUodGhpcy5fYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfYmFzZV92eCA9IHRoaXMuX2Jhc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5fbm9ybWFscygpLCBpID0gcmVmWzBdLCBqID0gcmVmWzFdO1xuICAgICAgICBfbG93ZXIgPSBbX2xvd2VyX3Z4LCBfYmFzZV92eF07XG4gICAgICAgIF91cHBlciA9IFtfdXBwZXJfdngsIF9iYXNlX3Z4XTtcbiAgICAgICAgdGhpcy5fbG93ZXJfc3ggPSB0aGlzLnBsb3RfbW9kZWwuY2FudmFzLnZfdnhfdG9fc3goX2xvd2VyW2ldKTtcbiAgICAgICAgdGhpcy5fbG93ZXJfc3kgPSB0aGlzLnBsb3RfbW9kZWwuY2FudmFzLnZfdnlfdG9fc3koX2xvd2VyW2pdKTtcbiAgICAgICAgdGhpcy5fdXBwZXJfc3ggPSB0aGlzLnBsb3RfbW9kZWwuY2FudmFzLnZfdnhfdG9fc3goX3VwcGVyW2ldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwcGVyX3N5ID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcy52X3Z5X3RvX3N5KF91cHBlcltqXSk7XG4gICAgfTtcbiAgICBXaGlza2VyVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW5nbGUsIGN0eCwgaSwgaywgbCwgbSwgcmVmLCByZWYxLCByZWYyLCByZXN1bHRzO1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcF9kYXRhKCk7XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYgPSB0aGlzLl9sb3dlcl9zeC5sZW5ndGg7IDAgPD0gcmVmID8gayA8IHJlZiA6IGsgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLl9sb3dlcl9zeFtpXSwgdGhpcy5fbG93ZXJfc3lbaV0pO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5fdXBwZXJfc3hbaV0sIHRoaXMuX3VwcGVyX3N5W2ldKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYW5nbGUgPSB0aGlzLm1vZGVsLmRpbWVuc2lvbiA9PT0gXCJoZWlnaHRcIiA/IDAgOiBNYXRoLlBJIC8gMjtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwubG93ZXJfaGVhZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBsID0gMCwgcmVmMSA9IHRoaXMuX2xvd2VyX3N4Lmxlbmd0aDsgMCA8PSByZWYxID8gbCA8IHJlZjEgOiBsID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLl9sb3dlcl9zeFtpXSwgdGhpcy5fbG93ZXJfc3lbaV0pO1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoYW5nbGUgKyBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLmxvd2VyX2hlYWQucmVuZGVyKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbC51cHBlcl9oZWFkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IG0gPSAwLCByZWYyID0gdGhpcy5fdXBwZXJfc3gubGVuZ3RoOyAwIDw9IHJlZjIgPyBtIDwgcmVmMiA6IG0gPiByZWYyOyBpID0gMCA8PSByZWYyID8gKyttIDogLS1tKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMuX3VwcGVyX3N4W2ldLCB0aGlzLl91cHBlcl9zeVtpXSk7XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC51cHBlcl9oZWFkLnJlbmRlcihjdHgsIGkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjdHgucmVzdG9yZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gV2hpc2tlclZpZXc7XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvblZpZXcpO1xuZXhwb3J0cy5XaGlza2VyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFdoaXNrZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFdoaXNrZXIoKSB7XG4gICAgICAgIHJldHVybiBXaGlza2VyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBXaGlza2VyLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLldoaXNrZXJWaWV3O1xuICAgIFdoaXNrZXIucHJvdG90eXBlLnR5cGUgPSAnV2hpc2tlcic7XG4gICAgV2hpc2tlci5taXhpbnMoWydsaW5lJ10pO1xuICAgIFdoaXNrZXIuZGVmaW5lKHtcbiAgICAgICAgbG93ZXI6IFtwLkRpc3RhbmNlU3BlY10sXG4gICAgICAgIGxvd2VyX2hlYWQ6IFtcbiAgICAgICAgICAgIHAuSW5zdGFuY2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFycm93X2hlYWRfMS5UZWVIZWFkKHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IFwidW5kZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogMTBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgdXBwZXI6IFtwLkRpc3RhbmNlU3BlY10sXG4gICAgICAgIHVwcGVyX2hlYWQ6IFtcbiAgICAgICAgICAgIHAuSW5zdGFuY2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFycm93X2hlYWRfMS5UZWVIZWFkKHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IFwidW5kZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogMTBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgYmFzZTogW3AuRGlzdGFuY2VTcGVjXSxcbiAgICAgICAgZGltZW5zaW9uOiBbcC5EaW1lbnNpb24sICdoZWlnaHQnXSxcbiAgICAgICAgc291cmNlOiBbXG4gICAgICAgICAgICBwLkluc3RhbmNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb2x1bW5fZGF0YV9zb3VyY2VfMS5Db2x1bW5EYXRhU291cmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHhfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddLFxuICAgICAgICB5X3JhbmdlX25hbWU6IFtwLlN0cmluZywgJ2RlZmF1bHQnXVxuICAgIH0pO1xuICAgIFdoaXNrZXIub3ZlcnJpZGUoe1xuICAgICAgICBsZXZlbDogJ3VuZGVybGF5J1xuICAgIH0pO1xuICAgIFdoaXNrZXIucHJvdG90eXBlLl9ub3JtYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgaiwgcmVmLCByZWYxO1xuICAgICAgICBpZiAodGhpcy5kaW1lbnNpb24gPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICByZWYgPSBbMSwgMF0sIGkgPSByZWZbMF0sIGogPSByZWZbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYxID0gWzAsIDFdLCBpID0gcmVmMVswXSwgaiA9IHJlZjFbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtpLCBqXTtcbiAgICB9O1xuICAgIHJldHVybiBXaGlza2VyO1xufSkoYW5ub3RhdGlvbl8xLkFubm90YXRpb24pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHNpZGVfcGFuZWxfMSA9IHJlcXVpcmUoXCJjb3JlL2xheW91dC9zaWRlX3BhbmVsXCIpO1xudmFyIGd1aWRlX3JlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi4vcmVuZGVyZXJzL2d1aWRlX3JlbmRlcmVyXCIpO1xudmFyIHJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi4vcmVuZGVyZXJzL3JlbmRlcmVyXCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL2xvZ2dpbmdcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdHlwZXNcIik7XG5leHBvcnRzLkF4aXNWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEF4aXNWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBeGlzVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEF4aXNWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBeGlzVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIEF4aXNWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3hfcmFuZ2VfbmFtZSA9IHRoaXMubW9kZWwueF9yYW5nZV9uYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy5feV9yYW5nZV9uYW1lID0gdGhpcy5tb2RlbC55X3JhbmdlX25hbWU7XG4gICAgfTtcbiAgICBBeGlzVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3R4O1xuICAgICAgICBpZiAodGhpcy5tb2RlbC52aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5fZHJhd19ydWxlKGN0eCk7XG4gICAgICAgIHRoaXMuX2RyYXdfbWFqb3JfdGlja3MoY3R4KTtcbiAgICAgICAgdGhpcy5fZHJhd19taW5vcl90aWNrcyhjdHgpO1xuICAgICAgICB0aGlzLl9kcmF3X21ham9yX2xhYmVscyhjdHgpO1xuICAgICAgICB0aGlzLl9kcmF3X2F4aXNfbGFiZWwoY3R4KTtcbiAgICAgICAgcmV0dXJuIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBBeGlzVmlldy5wcm90b3R5cGUuY29ubmVjdF9zaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBBeGlzVmlldy5fX3N1cGVyX18uY29ubmVjdF9zaWduYWxzLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5jaGFuZ2UsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgIH07XG4gICAgQXhpc1ZpZXcucHJvdG90eXBlLl9nZXRfc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpY2tfZXh0ZW50KCkgKyB0aGlzLl90aWNrX2xhYmVsX2V4dGVudCgpICsgdGhpcy5fYXhpc19sYWJlbF9leHRlbnQoKTtcbiAgICB9O1xuICAgIEF4aXNWaWV3LnByb3RvdHlwZS5fZHJhd19ydWxlID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgY29vcmRzLCBpLCBrLCBueCwgbnksIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgc3gsIHN5LCB4LCB4b2ZmLCB5LCB5b2ZmO1xuICAgICAgICBpZiAoIXRoaXMudmlzdWFscy5heGlzX2xpbmUuZG9pdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlZiA9IGNvb3JkcyA9IHRoaXMubW9kZWwucnVsZV9jb29yZHMsIHggPSByZWZbMF0sIHkgPSByZWZbMV07XG4gICAgICAgIHJlZjEgPSB0aGlzLnBsb3Rfdmlldy5tYXBfdG9fc2NyZWVuKHgsIHksIHRoaXMuX3hfcmFuZ2VfbmFtZSwgdGhpcy5feV9yYW5nZV9uYW1lKSwgc3ggPSByZWYxWzBdLCBzeSA9IHJlZjFbMV07XG4gICAgICAgIHJlZjIgPSB0aGlzLm1vZGVsLm5vcm1hbHMsIG54ID0gcmVmMlswXSwgbnkgPSByZWYyWzFdO1xuICAgICAgICByZWYzID0gdGhpcy5tb2RlbC5vZmZzZXRzLCB4b2ZmID0gcmVmM1swXSwgeW9mZiA9IHJlZjNbMV07XG4gICAgICAgIHRoaXMudmlzdWFscy5heGlzX2xpbmUuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhNYXRoLnJvdW5kKHN4WzBdICsgbnggKiB4b2ZmKSwgTWF0aC5yb3VuZChzeVswXSArIG55ICogeW9mZikpO1xuICAgICAgICBmb3IgKGkgPSBrID0gMSwgcmVmNCA9IHN4Lmxlbmd0aDsgMSA8PSByZWY0ID8gayA8IHJlZjQgOiBrID4gcmVmNDsgaSA9IDEgPD0gcmVmNCA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhNYXRoLnJvdW5kKHN4W2ldICsgbnggKiB4b2ZmKSwgTWF0aC5yb3VuZChzeVtpXSArIG55ICogeW9mZikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdHguc3Ryb2tlKCk7XG4gICAgfTtcbiAgICBBeGlzVmlldy5wcm90b3R5cGUuX2RyYXdfbWFqb3JfdGlja3MgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBjb29yZHMsIGksIGssIG54LCBueSwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZXN1bHRzLCBzeCwgc3ksIHRpbiwgdG91dCwgeCwgeG9mZiwgeSwgeW9mZjtcbiAgICAgICAgaWYgKCF0aGlzLnZpc3VhbHMubWFqb3JfdGlja19saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb29yZHMgPSB0aGlzLm1vZGVsLnRpY2tfY29vcmRzO1xuICAgICAgICByZWYgPSBjb29yZHMubWFqb3IsIHggPSByZWZbMF0sIHkgPSByZWZbMV07XG4gICAgICAgIHJlZjEgPSB0aGlzLnBsb3Rfdmlldy5tYXBfdG9fc2NyZWVuKHgsIHksIHRoaXMuX3hfcmFuZ2VfbmFtZSwgdGhpcy5feV9yYW5nZV9uYW1lKSwgc3ggPSByZWYxWzBdLCBzeSA9IHJlZjFbMV07XG4gICAgICAgIHJlZjIgPSB0aGlzLm1vZGVsLm5vcm1hbHMsIG54ID0gcmVmMlswXSwgbnkgPSByZWYyWzFdO1xuICAgICAgICByZWYzID0gdGhpcy5tb2RlbC5vZmZzZXRzLCB4b2ZmID0gcmVmM1swXSwgeW9mZiA9IHJlZjNbMV07XG4gICAgICAgIHRpbiA9IHRoaXMubW9kZWwubWFqb3JfdGlja19pbjtcbiAgICAgICAgdG91dCA9IHRoaXMubW9kZWwubWFqb3JfdGlja19vdXQ7XG4gICAgICAgIHRoaXMudmlzdWFscy5tYWpvcl90aWNrX2xpbmUuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZjQgPSBzeC5sZW5ndGg7IDAgPD0gcmVmNCA/IGsgPCByZWY0IDogayA+IHJlZjQ7IGkgPSAwIDw9IHJlZjQgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oTWF0aC5yb3VuZChzeFtpXSArIG54ICogdG91dCArIG54ICogeG9mZiksIE1hdGgucm91bmQoc3lbaV0gKyBueSAqIHRvdXQgKyBueSAqIHlvZmYpKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oTWF0aC5yb3VuZChzeFtpXSAtIG54ICogdGluICsgbnggKiB4b2ZmKSwgTWF0aC5yb3VuZChzeVtpXSAtIG55ICogdGluICsgbnkgKiB5b2ZmKSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnN0cm9rZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEF4aXNWaWV3LnByb3RvdHlwZS5fZHJhd19taW5vcl90aWNrcyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIGNvb3JkcywgaSwgaywgbngsIG55LCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHJlc3VsdHMsIHN4LCBzeSwgdGluLCB0b3V0LCB4LCB4b2ZmLCB5LCB5b2ZmO1xuICAgICAgICBpZiAoIXRoaXMudmlzdWFscy5taW5vcl90aWNrX2xpbmUuZG9pdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvb3JkcyA9IHRoaXMubW9kZWwudGlja19jb29yZHM7XG4gICAgICAgIHJlZiA9IGNvb3Jkcy5taW5vciwgeCA9IHJlZlswXSwgeSA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IHRoaXMucGxvdF92aWV3Lm1hcF90b19zY3JlZW4oeCwgeSwgdGhpcy5feF9yYW5nZV9uYW1lLCB0aGlzLl95X3JhbmdlX25hbWUpLCBzeCA9IHJlZjFbMF0sIHN5ID0gcmVmMVsxXTtcbiAgICAgICAgcmVmMiA9IHRoaXMubW9kZWwubm9ybWFscywgbnggPSByZWYyWzBdLCBueSA9IHJlZjJbMV07XG4gICAgICAgIHJlZjMgPSB0aGlzLm1vZGVsLm9mZnNldHMsIHhvZmYgPSByZWYzWzBdLCB5b2ZmID0gcmVmM1sxXTtcbiAgICAgICAgdGluID0gdGhpcy5tb2RlbC5taW5vcl90aWNrX2luO1xuICAgICAgICB0b3V0ID0gdGhpcy5tb2RlbC5taW5vcl90aWNrX291dDtcbiAgICAgICAgdGhpcy52aXN1YWxzLm1pbm9yX3RpY2tfbGluZS5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmNCA9IHN4Lmxlbmd0aDsgMCA8PSByZWY0ID8gayA8IHJlZjQgOiBrID4gcmVmNDsgaSA9IDAgPD0gcmVmNCA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhNYXRoLnJvdW5kKHN4W2ldICsgbnggKiB0b3V0ICsgbnggKiB4b2ZmKSwgTWF0aC5yb3VuZChzeVtpXSArIG55ICogdG91dCArIG55ICogeW9mZikpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhNYXRoLnJvdW5kKHN4W2ldIC0gbnggKiB0aW4gKyBueCAqIHhvZmYpLCBNYXRoLnJvdW5kKHN5W2ldIC0gbnkgKiB0aW4gKyBueSAqIHlvZmYpKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChjdHguc3Ryb2tlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgQXhpc1ZpZXcucHJvdG90eXBlLl9kcmF3X21ham9yX2xhYmVscyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIGFuZ2xlLCBjb29yZHMsIGRpbSwgaSwgaywgbGFiZWxzLCBueCwgbnksIG9yaWVudCwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZXN1bHRzLCBzaWRlLCBzdGFuZG9mZiwgc3gsIHN5LCB4LCB4b2ZmLCB5LCB5b2ZmO1xuICAgICAgICBjb29yZHMgPSB0aGlzLm1vZGVsLnRpY2tfY29vcmRzO1xuICAgICAgICByZWYgPSBjb29yZHMubWFqb3IsIHggPSByZWZbMF0sIHkgPSByZWZbMV07XG4gICAgICAgIHJlZjEgPSB0aGlzLnBsb3Rfdmlldy5tYXBfdG9fc2NyZWVuKHgsIHksIHRoaXMuX3hfcmFuZ2VfbmFtZSwgdGhpcy5feV9yYW5nZV9uYW1lKSwgc3ggPSByZWYxWzBdLCBzeSA9IHJlZjFbMV07XG4gICAgICAgIHJlZjIgPSB0aGlzLm1vZGVsLm5vcm1hbHMsIG54ID0gcmVmMlswXSwgbnkgPSByZWYyWzFdO1xuICAgICAgICByZWYzID0gdGhpcy5tb2RlbC5vZmZzZXRzLCB4b2ZmID0gcmVmM1swXSwgeW9mZiA9IHJlZjNbMV07XG4gICAgICAgIGRpbSA9IHRoaXMubW9kZWwuZGltZW5zaW9uO1xuICAgICAgICBzaWRlID0gdGhpcy5tb2RlbC5wYW5lbF9zaWRlO1xuICAgICAgICBvcmllbnQgPSB0aGlzLm1vZGVsLm1ham9yX2xhYmVsX29yaWVudGF0aW9uO1xuICAgICAgICBpZiAodHlwZXNfMS5pc1N0cmluZyhvcmllbnQpKSB7XG4gICAgICAgICAgICBhbmdsZSA9IHRoaXMubW9kZWwucGFuZWwuZ2V0X2xhYmVsX2FuZ2xlX2hldXJpc3RpYyhvcmllbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYW5nbGUgPSAtb3JpZW50O1xuICAgICAgICB9XG4gICAgICAgIHN0YW5kb2ZmID0gdGhpcy5fdGlja19leHRlbnQoKSArIHRoaXMubW9kZWwubWFqb3JfbGFiZWxfc3RhbmRvZmY7XG4gICAgICAgIGxhYmVscyA9IHRoaXMubW9kZWwuY29tcHV0ZV9sYWJlbHMoY29vcmRzLm1ham9yW2RpbV0pO1xuICAgICAgICB0aGlzLnZpc3VhbHMubWFqb3JfbGFiZWxfdGV4dC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgdGhpcy5tb2RlbC5wYW5lbC5hcHBseV9sYWJlbF90ZXh0X2hldXJpc3RpY3MoY3R4LCBvcmllbnQpO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWY0ID0gc3gubGVuZ3RoOyAwIDw9IHJlZjQgPyBrIDwgcmVmNCA6IGsgPiByZWY0OyBpID0gMCA8PSByZWY0ID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHN4W2ldICsgbnggKiBzdGFuZG9mZiArIG54ICogeG9mZiwgc3lbaV0gKyBueSAqIHN0YW5kb2ZmICsgbnkgKiB5b2ZmKTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobGFiZWxzW2ldLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKC1hbmdsZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC50cmFuc2xhdGUoLXN4W2ldIC0gbnggKiBzdGFuZG9mZiArIG54ICogeG9mZiwgLXN5W2ldIC0gbnkgKiBzdGFuZG9mZiArIG55ICogeW9mZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5maWxsVGV4dChsYWJlbHNbaV0sIE1hdGgucm91bmQoc3hbaV0gKyBueCAqIHN0YW5kb2ZmICsgbnggKiB4b2ZmKSwgTWF0aC5yb3VuZChzeVtpXSArIG55ICogc3RhbmRvZmYgKyBueSAqIHlvZmYpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBBeGlzVmlldy5wcm90b3R5cGUuX2RyYXdfYXhpc19sYWJlbCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIGFuZ2xlLCBsYWJlbCwgbngsIG55LCBvcmllbnQsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgc2lkZSwgc3RhbmRvZmYsIHN4LCBzeSwgeCwgeG9mZiwgeSwgeW9mZjtcbiAgICAgICAgbGFiZWwgPSB0aGlzLm1vZGVsLmF4aXNfbGFiZWw7XG4gICAgICAgIGlmIChsYWJlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5ydWxlX2Nvb3JkcywgeCA9IHJlZlswXSwgeSA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IHRoaXMucGxvdF92aWV3Lm1hcF90b19zY3JlZW4oeCwgeSwgdGhpcy5feF9yYW5nZV9uYW1lLCB0aGlzLl95X3JhbmdlX25hbWUpLCBzeCA9IHJlZjFbMF0sIHN5ID0gcmVmMVsxXTtcbiAgICAgICAgcmVmMiA9IHRoaXMubW9kZWwubm9ybWFscywgbnggPSByZWYyWzBdLCBueSA9IHJlZjJbMV07XG4gICAgICAgIHJlZjMgPSB0aGlzLm1vZGVsLm9mZnNldHMsIHhvZmYgPSByZWYzWzBdLCB5b2ZmID0gcmVmM1sxXTtcbiAgICAgICAgc2lkZSA9IHRoaXMubW9kZWwucGFuZWxfc2lkZTtcbiAgICAgICAgb3JpZW50ID0gJ3BhcmFsbGVsJztcbiAgICAgICAgYW5nbGUgPSB0aGlzLm1vZGVsLnBhbmVsLmdldF9sYWJlbF9hbmdsZV9oZXVyaXN0aWMob3JpZW50KTtcbiAgICAgICAgc3RhbmRvZmYgPSB0aGlzLl90aWNrX2V4dGVudCgpICsgdGhpcy5fdGlja19sYWJlbF9leHRlbnQoKSArIHRoaXMubW9kZWwuYXhpc19sYWJlbF9zdGFuZG9mZjtcbiAgICAgICAgc3ggPSAoc3hbMF0gKyBzeFtzeC5sZW5ndGggLSAxXSkgLyAyO1xuICAgICAgICBzeSA9IChzeVswXSArIHN5W3N5Lmxlbmd0aCAtIDFdKSAvIDI7XG4gICAgICAgIHRoaXMudmlzdWFscy5heGlzX2xhYmVsX3RleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIHRoaXMubW9kZWwucGFuZWwuYXBwbHlfbGFiZWxfdGV4dF9oZXVyaXN0aWNzKGN0eCwgb3JpZW50KTtcbiAgICAgICAgeCA9IHN4ICsgbnggKiBzdGFuZG9mZiArIG54ICogeG9mZjtcbiAgICAgICAgeSA9IHN5ICsgbnkgKiBzdGFuZG9mZiArIG55ICogeW9mZjtcbiAgICAgICAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQobGFiZWwsIDAsIDApO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSgtYW5nbGUpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC50cmFuc2xhdGUoLXgsIC15KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjdHguZmlsbFRleHQobGFiZWwsIHgsIHkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBeGlzVmlldy5wcm90b3R5cGUuX3RpY2tfZXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5tYWpvcl90aWNrX291dDtcbiAgICB9O1xuICAgIEF4aXNWaWV3LnByb3RvdHlwZS5fdGlja19sYWJlbF9leHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbmdsZSwgYywgY29vcmRzLCBjdHgsIGRpbSwgZXh0ZW50LCBoLCBoZmFjdG9yLCBoc2NhbGUsIGksIGssIGxhYmVscywgb3JpZW50LCByZWYsIHMsIHNpZGUsIHZhbCwgdywgd2ZhY3RvcjtcbiAgICAgICAgZXh0ZW50ID0gMDtcbiAgICAgICAgY3R4ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzX3ZpZXcuY3R4O1xuICAgICAgICBkaW0gPSB0aGlzLm1vZGVsLmRpbWVuc2lvbjtcbiAgICAgICAgY29vcmRzID0gdGhpcy5tb2RlbC50aWNrX2Nvb3Jkcy5tYWpvcjtcbiAgICAgICAgc2lkZSA9IHRoaXMubW9kZWwucGFuZWxfc2lkZTtcbiAgICAgICAgb3JpZW50ID0gdGhpcy5tb2RlbC5tYWpvcl9sYWJlbF9vcmllbnRhdGlvbjtcbiAgICAgICAgbGFiZWxzID0gdGhpcy5tb2RlbC5jb21wdXRlX2xhYmVscyhjb29yZHNbZGltXSk7XG4gICAgICAgIHRoaXMudmlzdWFscy5tYWpvcl9sYWJlbF90ZXh0LnNldF92YWx1ZShjdHgpO1xuICAgICAgICBpZiAodHlwZXNfMS5pc1N0cmluZyhvcmllbnQpKSB7XG4gICAgICAgICAgICBoc2NhbGUgPSAxO1xuICAgICAgICAgICAgYW5nbGUgPSB0aGlzLm1vZGVsLnBhbmVsLmdldF9sYWJlbF9hbmdsZV9oZXVyaXN0aWMob3JpZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhzY2FsZSA9IDI7XG4gICAgICAgICAgICBhbmdsZSA9IC1vcmllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgYW5nbGUgPSBNYXRoLmFicyhhbmdsZSk7XG4gICAgICAgIGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHMgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIGlmIChzaWRlID09PSBcImFib3ZlXCIgfHwgc2lkZSA9PT0gXCJiZWxvd1wiKSB7XG4gICAgICAgICAgICB3ZmFjdG9yID0gcztcbiAgICAgICAgICAgIGhmYWN0b3IgPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2ZhY3RvciA9IGM7XG4gICAgICAgICAgICBoZmFjdG9yID0gcztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmID0gbGFiZWxzLmxlbmd0aDsgMCA8PSByZWYgPyBrIDwgcmVmIDogayA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBpZiAobGFiZWxzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHcgPSBjdHgubWVhc3VyZVRleHQobGFiZWxzW2ldKS53aWR0aCAqIDEuMTtcbiAgICAgICAgICAgIGggPSBjdHgubWVhc3VyZVRleHQobGFiZWxzW2ldKS5hc2NlbnQgKiAwLjk7XG4gICAgICAgICAgICB2YWwgPSB3ICogd2ZhY3RvciArIChoIC8gaHNjYWxlKSAqIGhmYWN0b3I7XG4gICAgICAgICAgICBpZiAodmFsID4gZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50ID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHRlbnQgPiAwKSB7XG4gICAgICAgICAgICBleHRlbnQgKz0gdGhpcy5tb2RlbC5tYWpvcl9sYWJlbF9zdGFuZG9mZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZW50O1xuICAgIH07XG4gICAgQXhpc1ZpZXcucHJvdG90eXBlLl9heGlzX2xhYmVsX2V4dGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFuZ2xlLCBheGlzX2xhYmVsLCBjLCBjdHgsIGV4dGVudCwgaCwgb3JpZW50LCBzLCBzaWRlLCB3O1xuICAgICAgICBleHRlbnQgPSAwO1xuICAgICAgICBzaWRlID0gdGhpcy5tb2RlbC5wYW5lbF9zaWRlO1xuICAgICAgICBheGlzX2xhYmVsID0gdGhpcy5tb2RlbC5heGlzX2xhYmVsO1xuICAgICAgICBvcmllbnQgPSAncGFyYWxsZWwnO1xuICAgICAgICBjdHggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgIHRoaXMudmlzdWFscy5heGlzX2xhYmVsX3RleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIGFuZ2xlID0gTWF0aC5hYnModGhpcy5tb2RlbC5wYW5lbC5nZXRfbGFiZWxfYW5nbGVfaGV1cmlzdGljKG9yaWVudCkpO1xuICAgICAgICBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBzID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICBpZiAoYXhpc19sYWJlbCkge1xuICAgICAgICAgICAgZXh0ZW50ICs9IHRoaXMubW9kZWwuYXhpc19sYWJlbF9zdGFuZG9mZjtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5heGlzX2xhYmVsX3RleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICB3ID0gY3R4Lm1lYXN1cmVUZXh0KGF4aXNfbGFiZWwpLndpZHRoICogMS4xO1xuICAgICAgICAgICAgaCA9IGN0eC5tZWFzdXJlVGV4dChheGlzX2xhYmVsKS5hc2NlbnQgKiAwLjk7XG4gICAgICAgICAgICBpZiAoc2lkZSA9PT0gXCJhYm92ZVwiIHx8IHNpZGUgPT09IFwiYmVsb3dcIikge1xuICAgICAgICAgICAgICAgIGV4dGVudCArPSB3ICogcyArIGggKiBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50ICs9IHcgKiBjICsgaCAqIHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dGVudDtcbiAgICB9O1xuICAgIHJldHVybiBBeGlzVmlldztcbn0pKHJlbmRlcmVyXzEuUmVuZGVyZXJWaWV3KTtcbmV4cG9ydHMuQXhpcyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBeGlzLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBeGlzKCkge1xuICAgICAgICByZXR1cm4gQXhpcy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQXhpcy5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5BeGlzVmlldztcbiAgICBBeGlzLnByb3RvdHlwZS50eXBlID0gJ0F4aXMnO1xuICAgIEF4aXMubWl4aW5zKFsnbGluZTpheGlzXycsICdsaW5lOm1ham9yX3RpY2tfJywgJ2xpbmU6bWlub3JfdGlja18nLCAndGV4dDptYWpvcl9sYWJlbF8nLCAndGV4dDpheGlzX2xhYmVsXyddKTtcbiAgICBBeGlzLmRlZmluZSh7XG4gICAgICAgIGJvdW5kczogW3AuQW55LCAnYXV0byddLFxuICAgICAgICB0aWNrZXI6IFtwLkluc3RhbmNlLCBudWxsXSxcbiAgICAgICAgZm9ybWF0dGVyOiBbcC5JbnN0YW5jZSwgbnVsbF0sXG4gICAgICAgIHhfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddLFxuICAgICAgICB5X3JhbmdlX25hbWU6IFtwLlN0cmluZywgJ2RlZmF1bHQnXSxcbiAgICAgICAgYXhpc19sYWJlbDogW3AuU3RyaW5nLCAnJ10sXG4gICAgICAgIGF4aXNfbGFiZWxfc3RhbmRvZmY6IFtwLkludCwgNV0sXG4gICAgICAgIG1ham9yX2xhYmVsX3N0YW5kb2ZmOiBbcC5JbnQsIDVdLFxuICAgICAgICBtYWpvcl9sYWJlbF9vcmllbnRhdGlvbjogW3AuQW55LCBcImhvcml6b250YWxcIl0sXG4gICAgICAgIG1ham9yX2xhYmVsX292ZXJyaWRlczogW3AuQW55LCB7fV0sXG4gICAgICAgIG1ham9yX3RpY2tfaW46IFtwLk51bWJlciwgMl0sXG4gICAgICAgIG1ham9yX3RpY2tfb3V0OiBbcC5OdW1iZXIsIDZdLFxuICAgICAgICBtaW5vcl90aWNrX2luOiBbcC5OdW1iZXIsIDBdLFxuICAgICAgICBtaW5vcl90aWNrX291dDogW3AuTnVtYmVyLCA0XVxuICAgIH0pO1xuICAgIEF4aXMub3ZlcnJpZGUoe1xuICAgICAgICBheGlzX2xpbmVfY29sb3I6ICdibGFjaycsXG4gICAgICAgIG1ham9yX3RpY2tfbGluZV9jb2xvcjogJ2JsYWNrJyxcbiAgICAgICAgbWlub3JfdGlja19saW5lX2NvbG9yOiAnYmxhY2snLFxuICAgICAgICBtYWpvcl9sYWJlbF90ZXh0X2ZvbnRfc2l6ZTogXCI4cHRcIixcbiAgICAgICAgbWFqb3JfbGFiZWxfdGV4dF9hbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgbWFqb3JfbGFiZWxfdGV4dF9iYXNlbGluZTogXCJhbHBoYWJldGljXCIsXG4gICAgICAgIGF4aXNfbGFiZWxfdGV4dF9mb250X3NpemU6IFwiMTBwdFwiLFxuICAgICAgICBheGlzX2xhYmVsX3RleHRfZm9udF9zdHlsZTogXCJpdGFsaWNcIlxuICAgIH0pO1xuICAgIEF4aXMuaW50ZXJuYWwoe1xuICAgICAgICBwYW5lbF9zaWRlOiBbcC5BbnldXG4gICAgfSk7XG4gICAgQXhpcy5wcm90b3R5cGUuY29tcHV0ZV9sYWJlbHMgPSBmdW5jdGlvbiAodGlja3MpIHtcbiAgICAgICAgdmFyIGksIGssIGxhYmVscywgcmVmO1xuICAgICAgICBsYWJlbHMgPSB0aGlzLmZvcm1hdHRlci5kb0Zvcm1hdCh0aWNrcywgdGhpcyk7XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYgPSB0aWNrcy5sZW5ndGg7IDAgPD0gcmVmID8gayA8IHJlZiA6IGsgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgaWYgKHRpY2tzW2ldIGluIHRoaXMubWFqb3JfbGFiZWxfb3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzW2ldID0gdGhpcy5tYWpvcl9sYWJlbF9vdmVycmlkZXNbdGlja3NbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfTtcbiAgICBBeGlzLmdldHRlcnMoe1xuICAgICAgICBjb21wdXRlZF9ib3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wdXRlZF9ib3VuZHMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcnVsZV9jb29yZHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydWxlX2Nvb3JkcygpO1xuICAgICAgICB9LFxuICAgICAgICB0aWNrX2Nvb3JkczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpY2tfY29vcmRzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJhbmdlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JhbmdlcygpO1xuICAgICAgICB9LFxuICAgICAgICBub3JtYWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYW5lbC5fbm9ybWFscztcbiAgICAgICAgfSxcbiAgICAgICAgZGltZW5zaW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYW5lbC5fZGltO1xuICAgICAgICB9LFxuICAgICAgICBvZmZzZXRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0cygpO1xuICAgICAgICB9LFxuICAgICAgICBsb2M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRfbG9jKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBBeGlzLnByb3RvdHlwZS5hZGRfcGFuZWwgPSBmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICB0aGlzLnBhbmVsID0gbmV3IHNpZGVfcGFuZWxfMS5TaWRlUGFuZWwoe1xuICAgICAgICAgICAgc2lkZTogc2lkZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYW5lbC5hdHRhY2hfZG9jdW1lbnQodGhpcy5kb2N1bWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhbmVsX3NpZGUgPSBzaWRlO1xuICAgIH07XG4gICAgQXhpcy5wcm90b3R5cGUuX29mZnNldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmcmFtZSwgcmVmLCBzaWRlLCB4b2ZmLCB5b2ZmO1xuICAgICAgICBzaWRlID0gdGhpcy5wYW5lbF9zaWRlO1xuICAgICAgICByZWYgPSBbMCwgMF0sIHhvZmYgPSByZWZbMF0sIHlvZmYgPSByZWZbMV07XG4gICAgICAgIGZyYW1lID0gdGhpcy5wbG90LnBsb3RfY2FudmFzLmZyYW1lO1xuICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJiZWxvd1wiOlxuICAgICAgICAgICAgICAgIHlvZmYgPSBNYXRoLmFicyh0aGlzLnBhbmVsLl90b3AudmFsdWUgLSBmcmFtZS5fYm90dG9tLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhYm92ZVwiOlxuICAgICAgICAgICAgICAgIHlvZmYgPSBNYXRoLmFicyh0aGlzLnBhbmVsLl9ib3R0b20udmFsdWUgLSBmcmFtZS5fdG9wLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgIHhvZmYgPSBNYXRoLmFicyh0aGlzLnBhbmVsLl9sZWZ0LnZhbHVlIC0gZnJhbWUuX3JpZ2h0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICAgICAgeG9mZiA9IE1hdGguYWJzKHRoaXMucGFuZWwuX3JpZ2h0LnZhbHVlIC0gZnJhbWUuX2xlZnQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeG9mZiwgeW9mZl07XG4gICAgfTtcbiAgICBBeGlzLnByb3RvdHlwZS5fcmFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZnJhbWUsIGksIGosIHJhbmdlcztcbiAgICAgICAgaSA9IHRoaXMuZGltZW5zaW9uO1xuICAgICAgICBqID0gKGkgKyAxKSAlIDI7XG4gICAgICAgIGZyYW1lID0gdGhpcy5wbG90LnBsb3RfY2FudmFzLmZyYW1lO1xuICAgICAgICByYW5nZXMgPSBbZnJhbWUueF9yYW5nZXNbdGhpcy54X3JhbmdlX25hbWVdLCBmcmFtZS55X3Jhbmdlc1t0aGlzLnlfcmFuZ2VfbmFtZV1dO1xuICAgICAgICByZXR1cm4gW3Jhbmdlc1tpXSwgcmFuZ2VzW2pdXTtcbiAgICB9O1xuICAgIEF4aXMucHJvdG90eXBlLl9jb21wdXRlZF9ib3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjcm9zc19yYW5nZSwgZW5kLCByYW5nZSwgcmFuZ2VfYm91bmRzLCByZWYsIHJlZjEsIHN0YXJ0LCB1c2VyX2JvdW5kcztcbiAgICAgICAgcmVmID0gdGhpcy5yYW5nZXMsIHJhbmdlID0gcmVmWzBdLCBjcm9zc19yYW5nZSA9IHJlZlsxXTtcbiAgICAgICAgdXNlcl9ib3VuZHMgPSAocmVmMSA9IHRoaXMuYm91bmRzKSAhPSBudWxsID8gcmVmMSA6ICdhdXRvJztcbiAgICAgICAgcmFuZ2VfYm91bmRzID0gW3JhbmdlLm1pbiwgcmFuZ2UubWF4XTtcbiAgICAgICAgaWYgKHVzZXJfYm91bmRzID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHJldHVybiByYW5nZV9ib3VuZHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVzXzEuaXNBcnJheSh1c2VyX2JvdW5kcykpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh1c2VyX2JvdW5kc1swXSAtIHVzZXJfYm91bmRzWzFdKSA+IE1hdGguYWJzKHJhbmdlX2JvdW5kc1swXSAtIHJhbmdlX2JvdW5kc1sxXSkpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KE1hdGgubWluKHVzZXJfYm91bmRzWzBdLCB1c2VyX2JvdW5kc1sxXSksIHJhbmdlX2JvdW5kc1swXSk7XG4gICAgICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oTWF0aC5tYXgodXNlcl9ib3VuZHNbMF0sIHVzZXJfYm91bmRzWzFdKSwgcmFuZ2VfYm91bmRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4odXNlcl9ib3VuZHNbMF0sIHVzZXJfYm91bmRzWzFdKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBNYXRoLm1heCh1c2VyX2JvdW5kc1swXSwgdXNlcl9ib3VuZHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtzdGFydCwgZW5kXTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmVycm9yKFwidXNlciBib3VuZHMgJ1wiICsgdXNlcl9ib3VuZHMgKyBcIicgbm90IHVuZGVyc3Rvb2RcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQXhpcy5wcm90b3R5cGUuX3J1bGVfY29vcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29vcmRzLCBjcm9zc19yYW5nZSwgZW5kLCBpLCBqLCByYW5nZSwgcmVmLCByZWYxLCBzdGFydCwgeHMsIHlzO1xuICAgICAgICBpID0gdGhpcy5kaW1lbnNpb247XG4gICAgICAgIGogPSAoaSArIDEpICUgMjtcbiAgICAgICAgcmVmID0gdGhpcy5yYW5nZXMsIHJhbmdlID0gcmVmWzBdLCBjcm9zc19yYW5nZSA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IHRoaXMuY29tcHV0ZWRfYm91bmRzLCBzdGFydCA9IHJlZjFbMF0sIGVuZCA9IHJlZjFbMV07XG4gICAgICAgIHhzID0gbmV3IEFycmF5KDIpO1xuICAgICAgICB5cyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgY29vcmRzID0gW3hzLCB5c107XG4gICAgICAgIGNvb3Jkc1tpXVswXSA9IE1hdGgubWF4KHN0YXJ0LCByYW5nZS5taW4pO1xuICAgICAgICBjb29yZHNbaV1bMV0gPSBNYXRoLm1pbihlbmQsIHJhbmdlLm1heCk7XG4gICAgICAgIGlmIChjb29yZHNbaV1bMF0gPiBjb29yZHNbaV1bMV0pIHtcbiAgICAgICAgICAgIGNvb3Jkc1tpXVswXSA9IGNvb3Jkc1tpXVsxXSA9IDAgLyAwO1xuICAgICAgICB9XG4gICAgICAgIGNvb3Jkc1tqXVswXSA9IHRoaXMubG9jO1xuICAgICAgICBjb29yZHNbal1bMV0gPSB0aGlzLmxvYztcbiAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9O1xuICAgIEF4aXMucHJvdG90eXBlLl90aWNrX2Nvb3JkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvb3JkcywgY3Jvc3NfcmFuZ2UsIGVuZCwgaSwgaWksIGosIGssIGwsIG0sIG1ham9ycywgbWlub3JfY29vcmRzLCBtaW5vcl94cywgbWlub3JfeXMsIG1pbm9ycywgcmFuZ2UsIHJhbmdlX21heCwgcmFuZ2VfbWluLCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHJlZjUsIHN0YXJ0LCB0aWNrcywgeHMsIHlzO1xuICAgICAgICBpID0gdGhpcy5kaW1lbnNpb247XG4gICAgICAgIGogPSAoaSArIDEpICUgMjtcbiAgICAgICAgcmVmID0gdGhpcy5yYW5nZXMsIHJhbmdlID0gcmVmWzBdLCBjcm9zc19yYW5nZSA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IHRoaXMuY29tcHV0ZWRfYm91bmRzLCBzdGFydCA9IHJlZjFbMF0sIGVuZCA9IHJlZjFbMV07XG4gICAgICAgIHRpY2tzID0gdGhpcy50aWNrZXIuZ2V0X3RpY2tzKHN0YXJ0LCBlbmQsIHJhbmdlLCB0aGlzLmxvYywge30pO1xuICAgICAgICBtYWpvcnMgPSB0aWNrcy5tYWpvcjtcbiAgICAgICAgbWlub3JzID0gdGlja3MubWlub3I7XG4gICAgICAgIHhzID0gW107XG4gICAgICAgIHlzID0gW107XG4gICAgICAgIGNvb3JkcyA9IFt4cywgeXNdO1xuICAgICAgICBtaW5vcl94cyA9IFtdO1xuICAgICAgICBtaW5vcl95cyA9IFtdO1xuICAgICAgICBtaW5vcl9jb29yZHMgPSBbbWlub3JfeHMsIG1pbm9yX3lzXTtcbiAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IFwiRmFjdG9yUmFuZ2VcIikge1xuICAgICAgICAgICAgZm9yIChpaSA9IGsgPSAwLCByZWYyID0gbWFqb3JzLmxlbmd0aDsgMCA8PSByZWYyID8gayA8IHJlZjIgOiBrID4gcmVmMjsgaWkgPSAwIDw9IHJlZjIgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgICAgICBjb29yZHNbaV0ucHVzaChtYWpvcnNbaWldKTtcbiAgICAgICAgICAgICAgICBjb29yZHNbal0ucHVzaCh0aGlzLmxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYzID0gW3JhbmdlLm1pbiwgcmFuZ2UubWF4XSwgcmFuZ2VfbWluID0gcmVmM1swXSwgcmFuZ2VfbWF4ID0gcmVmM1sxXTtcbiAgICAgICAgICAgIGZvciAoaWkgPSBsID0gMCwgcmVmNCA9IG1ham9ycy5sZW5ndGg7IDAgPD0gcmVmNCA/IGwgPCByZWY0IDogbCA+IHJlZjQ7IGlpID0gMCA8PSByZWY0ID8gKytsIDogLS1sKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ham9yc1tpaV0gPCByYW5nZV9taW4gfHwgbWFqb3JzW2lpXSA+IHJhbmdlX21heCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29vcmRzW2ldLnB1c2gobWFqb3JzW2lpXSk7XG4gICAgICAgICAgICAgICAgY29vcmRzW2pdLnB1c2godGhpcy5sb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpaSA9IG0gPSAwLCByZWY1ID0gbWlub3JzLmxlbmd0aDsgMCA8PSByZWY1ID8gbSA8IHJlZjUgOiBtID4gcmVmNTsgaWkgPSAwIDw9IHJlZjUgPyArK20gOiAtLW0pIHtcbiAgICAgICAgICAgICAgICBpZiAobWlub3JzW2lpXSA8IHJhbmdlX21pbiB8fCBtaW5vcnNbaWldID4gcmFuZ2VfbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtaW5vcl9jb29yZHNbaV0ucHVzaChtaW5vcnNbaWldKTtcbiAgICAgICAgICAgICAgICBtaW5vcl9jb29yZHNbal0ucHVzaCh0aGlzLmxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwibWFqb3JcIjogY29vcmRzLFxuICAgICAgICAgICAgXCJtaW5vclwiOiBtaW5vcl9jb29yZHNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEF4aXMucHJvdG90eXBlLl9nZXRfbG9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2VuZCwgY3Jvc3NfcmFuZ2UsIGNzdGFydCwgcmFuZ2UsIHJlZiwgc2lkZTtcbiAgICAgICAgcmVmID0gdGhpcy5yYW5nZXMsIHJhbmdlID0gcmVmWzBdLCBjcm9zc19yYW5nZSA9IHJlZlsxXTtcbiAgICAgICAgY3N0YXJ0ID0gY3Jvc3NfcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIGNlbmQgPSBjcm9zc19yYW5nZS5lbmQ7XG4gICAgICAgIHNpZGUgPSB0aGlzLnBhbmVsX3NpZGU7XG4gICAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBjYXNlICdiZWxvdyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzX3JhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnYWJvdmUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcm9zc19yYW5nZS5lbmQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBeGlzO1xufSkoZ3VpZGVfcmVuZGVyZXJfMS5HdWlkZVJlbmRlcmVyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBheGlzXzEgPSByZXF1aXJlKFwiLi9heGlzXCIpO1xudmFyIGNhdGVnb3JpY2FsX3RpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi4vZm9ybWF0dGVycy9jYXRlZ29yaWNhbF90aWNrX2Zvcm1hdHRlclwiKTtcbnZhciBjYXRlZ29yaWNhbF90aWNrZXJfMSA9IHJlcXVpcmUoXCIuLi90aWNrZXJzL2NhdGVnb3JpY2FsX3RpY2tlclwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xuZXhwb3J0cy5DYXRlZ29yaWNhbEF4aXNWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENhdGVnb3JpY2FsQXhpc1ZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENhdGVnb3JpY2FsQXhpc1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiBDYXRlZ29yaWNhbEF4aXNWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gQ2F0ZWdvcmljYWxBeGlzVmlldztcbn0pKGF4aXNfMS5BeGlzVmlldyk7XG5leHBvcnRzLkNhdGVnb3JpY2FsQXhpcyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDYXRlZ29yaWNhbEF4aXMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENhdGVnb3JpY2FsQXhpcygpIHtcbiAgICAgICAgcmV0dXJuIENhdGVnb3JpY2FsQXhpcy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2F0ZWdvcmljYWxBeGlzLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkNhdGVnb3JpY2FsQXhpc1ZpZXc7XG4gICAgQ2F0ZWdvcmljYWxBeGlzLnByb3RvdHlwZS50eXBlID0gJ0NhdGVnb3JpY2FsQXhpcyc7XG4gICAgQ2F0ZWdvcmljYWxBeGlzLm92ZXJyaWRlKHtcbiAgICAgICAgdGlja2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNhdGVnb3JpY2FsX3RpY2tlcl8xLkNhdGVnb3JpY2FsVGlja2VyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjYXRlZ29yaWNhbF90aWNrX2Zvcm1hdHRlcl8xLkNhdGVnb3JpY2FsVGlja0Zvcm1hdHRlcigpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgQ2F0ZWdvcmljYWxBeGlzLnByb3RvdHlwZS5fY29tcHV0ZWRfYm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3Jvc3NfcmFuZ2UsIHJhbmdlLCByYW5nZV9ib3VuZHMsIHJlZiwgcmVmMSwgdXNlcl9ib3VuZHM7XG4gICAgICAgIHJlZiA9IHRoaXMucmFuZ2VzLCByYW5nZSA9IHJlZlswXSwgY3Jvc3NfcmFuZ2UgPSByZWZbMV07XG4gICAgICAgIHVzZXJfYm91bmRzID0gKHJlZjEgPSB0aGlzLmJvdW5kcykgIT0gbnVsbCA/IHJlZjEgOiAnYXV0byc7XG4gICAgICAgIHJhbmdlX2JvdW5kcyA9IFtyYW5nZS5taW4sIHJhbmdlLm1heF07XG4gICAgICAgIGlmICh1c2VyX2JvdW5kcyAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJDYXRlZ29yaWNhbCBBeGVzIG9ubHkgc3VwcG9ydCB1c2VyX2JvdW5kcz0nYXV0bycsIGlnbm9yaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZV9ib3VuZHM7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0ZWdvcmljYWxBeGlzO1xufSkoYXhpc18xLkF4aXMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGF4aXNfMSA9IHJlcXVpcmUoXCIuL2F4aXNcIik7XG5leHBvcnRzLkNvbnRpbnVvdXNBeGlzID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENvbnRpbnVvdXNBeGlzLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDb250aW51b3VzQXhpcygpIHtcbiAgICAgICAgcmV0dXJuIENvbnRpbnVvdXNBeGlzLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDb250aW51b3VzQXhpcy5wcm90b3R5cGUudHlwZSA9ICdDb250aW51b3VzQXhpcyc7XG4gICAgcmV0dXJuIENvbnRpbnVvdXNBeGlzO1xufSkoYXhpc18xLkF4aXMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGxpbmVhcl9heGlzXzEgPSByZXF1aXJlKFwiLi9saW5lYXJfYXhpc1wiKTtcbnZhciBkYXRldGltZV90aWNrX2Zvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4uL2Zvcm1hdHRlcnMvZGF0ZXRpbWVfdGlja19mb3JtYXR0ZXJcIik7XG52YXIgZGF0ZXRpbWVfdGlja2VyXzEgPSByZXF1aXJlKFwiLi4vdGlja2Vycy9kYXRldGltZV90aWNrZXJcIik7XG5leHBvcnRzLkRhdGV0aW1lQXhpc1ZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRGF0ZXRpbWVBeGlzVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRGF0ZXRpbWVBeGlzVmlldygpIHtcbiAgICAgICAgcmV0dXJuIERhdGV0aW1lQXhpc1ZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBEYXRldGltZUF4aXNWaWV3O1xufSkobGluZWFyX2F4aXNfMS5MaW5lYXJBeGlzVmlldyk7XG5leHBvcnRzLkRhdGV0aW1lQXhpcyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEYXRldGltZUF4aXMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERhdGV0aW1lQXhpcygpIHtcbiAgICAgICAgcmV0dXJuIERhdGV0aW1lQXhpcy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGF0ZXRpbWVBeGlzLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkRhdGV0aW1lQXhpc1ZpZXc7XG4gICAgRGF0ZXRpbWVBeGlzLnByb3RvdHlwZS50eXBlID0gJ0RhdGV0aW1lQXhpcyc7XG4gICAgRGF0ZXRpbWVBeGlzLm92ZXJyaWRlKHtcbiAgICAgICAgdGlja2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGRhdGV0aW1lX3RpY2tlcl8xLkRhdGV0aW1lVGlja2VyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBkYXRldGltZV90aWNrX2Zvcm1hdHRlcl8xLkRhdGV0aW1lVGlja0Zvcm1hdHRlcigpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIERhdGV0aW1lQXhpcztcbn0pKGxpbmVhcl9heGlzXzEuTGluZWFyQXhpcyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBheGlzXzEgPSByZXF1aXJlKFwiLi9heGlzXCIpO1xuZXhwb3J0cy5BeGlzID0gYXhpc18xLkF4aXM7XG52YXIgY2F0ZWdvcmljYWxfYXhpc18xID0gcmVxdWlyZShcIi4vY2F0ZWdvcmljYWxfYXhpc1wiKTtcbmV4cG9ydHMuQ2F0ZWdvcmljYWxBeGlzID0gY2F0ZWdvcmljYWxfYXhpc18xLkNhdGVnb3JpY2FsQXhpcztcbnZhciBjb250aW51b3VzX2F4aXNfMSA9IHJlcXVpcmUoXCIuL2NvbnRpbnVvdXNfYXhpc1wiKTtcbmV4cG9ydHMuQ29udGludW91c0F4aXMgPSBjb250aW51b3VzX2F4aXNfMS5Db250aW51b3VzQXhpcztcbnZhciBkYXRldGltZV9heGlzXzEgPSByZXF1aXJlKFwiLi9kYXRldGltZV9heGlzXCIpO1xuZXhwb3J0cy5EYXRldGltZUF4aXMgPSBkYXRldGltZV9heGlzXzEuRGF0ZXRpbWVBeGlzO1xudmFyIGxpbmVhcl9heGlzXzEgPSByZXF1aXJlKFwiLi9saW5lYXJfYXhpc1wiKTtcbmV4cG9ydHMuTGluZWFyQXhpcyA9IGxpbmVhcl9heGlzXzEuTGluZWFyQXhpcztcbnZhciBsb2dfYXhpc18xID0gcmVxdWlyZShcIi4vbG9nX2F4aXNcIik7XG5leHBvcnRzLkxvZ0F4aXMgPSBsb2dfYXhpc18xLkxvZ0F4aXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYXhpc18xID0gcmVxdWlyZShcIi4vYXhpc1wiKTtcbnZhciBjb250aW51b3VzX2F4aXNfMSA9IHJlcXVpcmUoXCIuL2NvbnRpbnVvdXNfYXhpc1wiKTtcbnZhciBiYXNpY190aWNrX2Zvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4uL2Zvcm1hdHRlcnMvYmFzaWNfdGlja19mb3JtYXR0ZXJcIik7XG52YXIgYmFzaWNfdGlja2VyXzEgPSByZXF1aXJlKFwiLi4vdGlja2Vycy9iYXNpY190aWNrZXJcIik7XG5leHBvcnRzLkxpbmVhckF4aXNWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExpbmVhckF4aXNWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMaW5lYXJBeGlzVmlldygpIHtcbiAgICAgICAgcmV0dXJuIExpbmVhckF4aXNWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gTGluZWFyQXhpc1ZpZXc7XG59KShheGlzXzEuQXhpc1ZpZXcpO1xuZXhwb3J0cy5MaW5lYXJBeGlzID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExpbmVhckF4aXMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExpbmVhckF4aXMoKSB7XG4gICAgICAgIHJldHVybiBMaW5lYXJBeGlzLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMaW5lYXJBeGlzLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkxpbmVhckF4aXNWaWV3O1xuICAgIExpbmVhckF4aXMucHJvdG90eXBlLnR5cGUgPSAnTGluZWFyQXhpcyc7XG4gICAgTGluZWFyQXhpcy5vdmVycmlkZSh7XG4gICAgICAgIHRpY2tlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBiYXNpY190aWNrZXJfMS5CYXNpY1RpY2tlcigpO1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYmFzaWNfdGlja19mb3JtYXR0ZXJfMS5CYXNpY1RpY2tGb3JtYXR0ZXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBMaW5lYXJBeGlzO1xufSkoY29udGludW91c19heGlzXzEuQ29udGludW91c0F4aXMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGF4aXNfMSA9IHJlcXVpcmUoXCIuL2F4aXNcIik7XG52YXIgY29udGludW91c19heGlzXzEgPSByZXF1aXJlKFwiLi9jb250aW51b3VzX2F4aXNcIik7XG52YXIgbG9nX3RpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi4vZm9ybWF0dGVycy9sb2dfdGlja19mb3JtYXR0ZXJcIik7XG52YXIgbG9nX3RpY2tlcl8xID0gcmVxdWlyZShcIi4uL3RpY2tlcnMvbG9nX3RpY2tlclwiKTtcbmV4cG9ydHMuTG9nQXhpc1ZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTG9nQXhpc1ZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExvZ0F4aXNWaWV3KCkge1xuICAgICAgICByZXR1cm4gTG9nQXhpc1ZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBMb2dBeGlzVmlldztcbn0pKGF4aXNfMS5BeGlzVmlldyk7XG5leHBvcnRzLkxvZ0F4aXMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTG9nQXhpcywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTG9nQXhpcygpIHtcbiAgICAgICAgcmV0dXJuIExvZ0F4aXMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExvZ0F4aXMucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuTG9nQXhpc1ZpZXc7XG4gICAgTG9nQXhpcy5wcm90b3R5cGUudHlwZSA9ICdMb2dBeGlzJztcbiAgICBMb2dBeGlzLm92ZXJyaWRlKHtcbiAgICAgICAgdGlja2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxvZ190aWNrZXJfMS5Mb2dUaWNrZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxvZ190aWNrX2Zvcm1hdHRlcl8xLkxvZ1RpY2tGb3JtYXR0ZXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBMb2dBeGlzO1xufSkoY29udGludW91c19heGlzXzEuQ29udGludW91c0F4aXMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBzbGljZSA9IFtdLnNsaWNlO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9vYmplY3RcIik7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbFwiKTtcbmV4cG9ydHMuQ3VzdG9tSlMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ3VzdG9tSlMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEN1c3RvbUpTKCkge1xuICAgICAgICByZXR1cm4gQ3VzdG9tSlMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEN1c3RvbUpTLnByb3RvdHlwZS50eXBlID0gJ0N1c3RvbUpTJztcbiAgICBDdXN0b21KUy5kZWZpbmUoe1xuICAgICAgICBhcmdzOiBbcC5BbnksIHt9XSxcbiAgICAgICAgY29kZTogW3AuU3RyaW5nLCAnJ11cbiAgICB9KTtcbiAgICBDdXN0b21KUy5nZXR0ZXJzKHtcbiAgICAgICAgdmFsdWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFrZV92YWx1ZXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuYzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21ha2VfZnVuYygpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgQ3VzdG9tSlMucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoY2Jfb2JqLCBjYl9kYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmMuYXBwbHkoY2Jfb2JqLCB0aGlzLnZhbHVlcy5jb25jYXQoY2Jfb2JqLCBjYl9kYXRhLCByZXF1aXJlLCB7fSkpO1xuICAgIH07XG4gICAgQ3VzdG9tSlMucHJvdG90eXBlLl9tYWtlX3ZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdF8xLnZhbHVlcyh0aGlzLmFyZ3MpO1xuICAgIH07XG4gICAgQ3VzdG9tSlMucHJvdG90eXBlLl9tYWtlX2Z1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKGZ1bmMsIGFyZ3MsIGN0b3IpIHtcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlID0gZnVuYy5wcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBuZXcgY3RvciwgcmVzdWx0ID0gZnVuYy5hcHBseShjaGlsZCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCA/IHJlc3VsdCA6IGNoaWxkO1xuICAgICAgICB9KShGdW5jdGlvbiwgc2xpY2UuY2FsbChPYmplY3Qua2V5cyh0aGlzLmFyZ3MpKS5jb25jYXQoW1wiY2Jfb2JqXCJdLCBbXCJjYl9kYXRhXCJdLCBbXCJyZXF1aXJlXCJdLCBbXCJleHBvcnRzXCJdLCBbdGhpcy5jb2RlXSksIGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ3VzdG9tSlM7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGN1c3RvbWpzXzEgPSByZXF1aXJlKFwiLi9jdXN0b21qc1wiKTtcbmV4cG9ydHMuQ3VzdG9tSlMgPSBjdXN0b21qc18xLkN1c3RvbUpTO1xudmFyIG9wZW5fdXJsXzEgPSByZXF1aXJlKFwiLi9vcGVuX3VybFwiKTtcbmV4cG9ydHMuT3BlblVSTCA9IG9wZW5fdXJsXzEuT3BlblVSTDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHNlbGVjdGlvbl8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9zZWxlY3Rpb25cIik7XG52YXIgdGVtcGxhdGluZ18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90ZW1wbGF0aW5nXCIpO1xuZXhwb3J0cy5PcGVuVVJMID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE9wZW5VUkwsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIE9wZW5VUkwoKSB7XG4gICAgICAgIHJldHVybiBPcGVuVVJMLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBPcGVuVVJMLnByb3RvdHlwZS50eXBlID0gJ09wZW5VUkwnO1xuICAgIE9wZW5VUkwuZGVmaW5lKHtcbiAgICAgICAgdXJsOiBbcC5TdHJpbmcsICdodHRwOi8vJ11cbiAgICB9KTtcbiAgICBPcGVuVVJMLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKGRhdGFfc291cmNlKSB7XG4gICAgICAgIHZhciBpLCBqLCBsZW4sIHJlZiwgdXJsO1xuICAgICAgICByZWYgPSBzZWxlY3Rpb25fMS5nZXRfaW5kaWNlcyhkYXRhX3NvdXJjZSk7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IHJlZltqXTtcbiAgICAgICAgICAgIHVybCA9IHRlbXBsYXRpbmdfMS5yZXBsYWNlX3BsYWNlaG9sZGVycyh0aGlzLnVybCwgZGF0YV9zb3VyY2UsIGkpO1xuICAgICAgICAgICAgd2luZG93Lm9wZW4odXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBPcGVuVVJMO1xufSkobW9kZWxfMS5Nb2RlbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgbGF5b3V0X2NhbnZhc18xID0gcmVxdWlyZShcImNvcmUvbGF5b3V0L2xheW91dF9jYW52YXNcIik7XG52YXIgZG9tX3ZpZXdfMSA9IHJlcXVpcmUoXCJjb3JlL2RvbV92aWV3XCIpO1xudmFyIHNvbHZlcl8xID0gcmVxdWlyZShcImNvcmUvbGF5b3V0L3NvbHZlclwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGRvbV8xID0gcmVxdWlyZShcImNvcmUvZG9tXCIpO1xudmFyIGNhbnZhc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC9jYW52YXNcIik7XG52YXIgY2FudmFzMnN2ZyA9IHJlcXVpcmUoXCJjYW52YXMyc3ZnXCIpO1xuaWYgKHdpbmRvdy5DYW52YXNQaXhlbEFycmF5ICE9IG51bGwpIHtcbiAgICBDYW52YXNQaXhlbEFycmF5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgIHZhciBpLCBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRoaXMubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzW2ldID0gYXJyW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xufVxuZXhwb3J0cy5DYW52YXNWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENhbnZhc1ZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENhbnZhc1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiBDYW52YXNWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDYW52YXNWaWV3LnByb3RvdHlwZS5jbGFzc05hbWUgPSBcImJrLWNhbnZhcy13cmFwcGVyXCI7XG4gICAgQ2FudmFzVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIENhbnZhc1ZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5tYXBfZWwgPSB0aGlzLm1vZGVsLm1hcCA/IHRoaXMuZWwuYXBwZW5kQ2hpbGQoZG9tXzEuZGl2KHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJiay1jYW52YXMtbWFwXCJcbiAgICAgICAgfSkpIDogbnVsbDtcbiAgICAgICAgdGhpcy5ldmVudHNfZWwgPSB0aGlzLmVsLmFwcGVuZENoaWxkKGRvbV8xLmRpdih7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiYmstY2FudmFzLWV2ZW50c1wiXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5vdmVybGF5c19lbCA9IHRoaXMuZWwuYXBwZW5kQ2hpbGQoZG9tXzEuZGl2KHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJiay1jYW52YXMtb3ZlcmxheXNcIlxuICAgICAgICB9KSk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5vdXRwdXRfYmFja2VuZCkge1xuICAgICAgICAgICAgY2FzZSBcImNhbnZhc1wiOlxuICAgICAgICAgICAgY2FzZSBcIndlYmdsXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNfZWwgPSB0aGlzLmVsLmFwcGVuZENoaWxkKGRvbV8xLmNhbnZhcyh7XG4gICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogXCJiay1jYW52YXNcIlxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHggPSB0aGlzLmNhbnZhc19lbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN2Z1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2N0eCA9IG5ldyBjYW52YXMyc3ZnKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNfZWwgPSB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuX2N0eC5nZXRTdmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdHggPSB0aGlzLmdldF9jdHgoKTtcbiAgICAgICAgY2FudmFzXzEuZml4dXBfY3R4KHRoaXMuY3R4KTtcbiAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJDYW52YXNWaWV3IGluaXRpYWxpemVkXCIpO1xuICAgIH07XG4gICAgQ2FudmFzVmlldy5wcm90b3R5cGUuZ2V0X2N0eCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eDtcbiAgICB9O1xuICAgIENhbnZhc1ZpZXcucHJvdG90eXBlLmdldF9jYW52YXNfZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzX2VsO1xuICAgIH07XG4gICAgQ2FudmFzVmlldy5wcm90b3R5cGUucHJlcGFyZV9jYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoZWlnaHQsIHBpeGVsX3JhdGlvLCB3aWR0aDtcbiAgICAgICAgd2lkdGggPSB0aGlzLm1vZGVsLl93aWR0aC52YWx1ZTtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5tb2RlbC5faGVpZ2h0LnZhbHVlO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICBwaXhlbF9yYXRpbyA9IGNhbnZhc18xLmdldF9zY2FsZV9yYXRpbyh0aGlzLmN0eCwgdGhpcy5tb2RlbC51c2VfaGlkcGksIHRoaXMubW9kZWwub3V0cHV0X2JhY2tlbmQpO1xuICAgICAgICB0aGlzLm1vZGVsLnBpeGVsX3JhdGlvID0gcGl4ZWxfcmF0aW87XG4gICAgICAgIHRoaXMuY2FudmFzX2VsLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgICAgIHRoaXMuY2FudmFzX2VsLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5jYW52YXNfZWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoICogcGl4ZWxfcmF0aW8pO1xuICAgICAgICB0aGlzLmNhbnZhc19lbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCAqIHBpeGVsX3JhdGlvKTtcbiAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJSZW5kZXJpbmcgQ2FudmFzVmlldyB3aXRoIHdpZHRoOiBcIiArIHdpZHRoICsgXCIsIGhlaWdodDogXCIgKyBoZWlnaHQgKyBcIiwgcGl4ZWwgcmF0aW86IFwiICsgcGl4ZWxfcmF0aW8pO1xuICAgIH07XG4gICAgQ2FudmFzVmlldy5wcm90b3R5cGUuc2V0X2RpbXMgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBoZWlnaHQsIHdpZHRoO1xuICAgICAgICB3aWR0aCA9IGFyZ1swXSwgaGVpZ2h0ID0gYXJnWzFdO1xuICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0aGlzLl93aWR0aF9jb25zdHJhaW50ICE9IG51bGwpICYmIHRoaXMuc29sdmVyLmhhc19jb25zdHJhaW50KHRoaXMuX3dpZHRoX2NvbnN0cmFpbnQpKSB7XG4gICAgICAgICAgICB0aGlzLnNvbHZlci5yZW1vdmVfY29uc3RyYWludCh0aGlzLl93aWR0aF9jb25zdHJhaW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRoaXMuX2hlaWdodF9jb25zdHJhaW50ICE9IG51bGwpICYmIHRoaXMuc29sdmVyLmhhc19jb25zdHJhaW50KHRoaXMuX2hlaWdodF9jb25zdHJhaW50KSkge1xuICAgICAgICAgICAgdGhpcy5zb2x2ZXIucmVtb3ZlX2NvbnN0cmFpbnQodGhpcy5faGVpZ2h0X2NvbnN0cmFpbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dpZHRoX2NvbnN0cmFpbnQgPSBzb2x2ZXJfMS5FUSh0aGlzLm1vZGVsLl93aWR0aCwgLXdpZHRoKTtcbiAgICAgICAgdGhpcy5zb2x2ZXIuYWRkX2NvbnN0cmFpbnQodGhpcy5fd2lkdGhfY29uc3RyYWludCk7XG4gICAgICAgIHRoaXMuX2hlaWdodF9jb25zdHJhaW50ID0gc29sdmVyXzEuRVEodGhpcy5tb2RlbC5faGVpZ2h0LCAtaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5zb2x2ZXIuYWRkX2NvbnN0cmFpbnQodGhpcy5faGVpZ2h0X2NvbnN0cmFpbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5zb2x2ZXIudXBkYXRlX3ZhcmlhYmxlcygpO1xuICAgIH07XG4gICAgcmV0dXJuIENhbnZhc1ZpZXc7XG59KShkb21fdmlld18xLkRPTVZpZXcpO1xuZXhwb3J0cy5DYW52YXMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ2FudmFzLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDYW52YXMoKSB7XG4gICAgICAgIHJldHVybiBDYW52YXMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhbnZhcy5wcm90b3R5cGUudHlwZSA9ICdDYW52YXMnO1xuICAgIENhbnZhcy5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5DYW52YXNWaWV3O1xuICAgIENhbnZhcy5pbnRlcm5hbCh7XG4gICAgICAgIG1hcDogW3AuQm9vbGVhbiwgZmFsc2VdLFxuICAgICAgICBpbml0aWFsX3dpZHRoOiBbcC5OdW1iZXJdLFxuICAgICAgICBpbml0aWFsX2hlaWdodDogW3AuTnVtYmVyXSxcbiAgICAgICAgdXNlX2hpZHBpOiBbcC5Cb29sZWFuLCB0cnVlXSxcbiAgICAgICAgcGl4ZWxfcmF0aW86IFtwLk51bWJlciwgMV0sXG4gICAgICAgIG91dHB1dF9iYWNrZW5kOiBbcC5PdXRwdXRCYWNrZW5kLCBcImNhbnZhc1wiXVxuICAgIH0pO1xuICAgIENhbnZhcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBDYW52YXMuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhbmVsID0gdGhpcztcbiAgICB9O1xuICAgIENhbnZhcy5wcm90b3R5cGUudnhfdG9fc3ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIENhbnZhcy5wcm90b3R5cGUudnlfdG9fc3kgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0LnZhbHVlIC0gKHkgKyAxKTtcbiAgICB9O1xuICAgIENhbnZhcy5wcm90b3R5cGUudl92eF90b19zeCA9IGZ1bmN0aW9uICh4eCkge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheSh4eCk7XG4gICAgfTtcbiAgICBDYW52YXMucHJvdG90eXBlLnZfdnlfdG9fc3kgPSBmdW5jdGlvbiAoeXkpIHtcbiAgICAgICAgdmFyIF95eSwgaGVpZ2h0LCBpZHgsIGosIGxlbiwgeTtcbiAgICAgICAgX3l5ID0gbmV3IEZsb2F0NjRBcnJheSh5eS5sZW5ndGgpO1xuICAgICAgICBoZWlnaHQgPSB0aGlzLl9oZWlnaHQudmFsdWU7XG4gICAgICAgIGZvciAoaWR4ID0gaiA9IDAsIGxlbiA9IHl5Lmxlbmd0aDsgaiA8IGxlbjsgaWR4ID0gKytqKSB7XG4gICAgICAgICAgICB5ID0geXlbaWR4XTtcbiAgICAgICAgICAgIF95eVtpZHhdID0gaGVpZ2h0IC0gKHkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3l5O1xuICAgIH07XG4gICAgQ2FudmFzLnByb3RvdHlwZS5zeF90b192eCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgQ2FudmFzLnByb3RvdHlwZS5zeV90b192eSA9IGZ1bmN0aW9uICh5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQudmFsdWUgLSAoeSArIDEpO1xuICAgIH07XG4gICAgQ2FudmFzLnByb3RvdHlwZS52X3N4X3RvX3Z4ID0gZnVuY3Rpb24gKHh4KSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KHh4KTtcbiAgICB9O1xuICAgIENhbnZhcy5wcm90b3R5cGUudl9zeV90b192eSA9IGZ1bmN0aW9uICh5eSkge1xuICAgICAgICB2YXIgX3l5LCBoZWlnaHQsIGlkeCwgaiwgbGVuLCB5O1xuICAgICAgICBfeXkgPSBuZXcgRmxvYXQ2NEFycmF5KHl5Lmxlbmd0aCk7XG4gICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodC52YWx1ZTtcbiAgICAgICAgZm9yIChpZHggPSBqID0gMCwgbGVuID0geXkubGVuZ3RoOyBqIDwgbGVuOyBpZHggPSArK2opIHtcbiAgICAgICAgICAgIHkgPSB5eVtpZHhdO1xuICAgICAgICAgICAgX3l5W2lkeF0gPSBoZWlnaHQgLSAoeSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfeXk7XG4gICAgfTtcbiAgICBDYW52YXMucHJvdG90eXBlLmdldF9jb25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIENhbnZhcy5fX3N1cGVyX18uZ2V0X2NvbnN0cmFpbnRzLmNhbGwodGhpcykuY29uY2F0KFtzb2x2ZXJfMS5HRSh0aGlzLl90b3ApLCBzb2x2ZXJfMS5HRSh0aGlzLl9ib3R0b20pLCBzb2x2ZXJfMS5HRSh0aGlzLl9sZWZ0KSwgc29sdmVyXzEuR0UodGhpcy5fcmlnaHQpLCBzb2x2ZXJfMS5HRSh0aGlzLl93aWR0aCksIHNvbHZlcl8xLkdFKHRoaXMuX2hlaWdodCksIHNvbHZlcl8xLkVRKHRoaXMuX3dpZHRoLCBbLTEsIHRoaXMuX3JpZ2h0XSksIHNvbHZlcl8xLkVRKHRoaXMuX2hlaWdodCwgWy0xLCB0aGlzLl90b3BdKV0pO1xuICAgIH07XG4gICAgcmV0dXJuIENhbnZhcztcbn0pKGxheW91dF9jYW52YXNfMS5MYXlvdXRDYW52YXMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGNhdGVnb3JpY2FsX3NjYWxlXzEgPSByZXF1aXJlKFwiLi4vc2NhbGVzL2NhdGVnb3JpY2FsX3NjYWxlXCIpO1xudmFyIGxpbmVhcl9zY2FsZV8xID0gcmVxdWlyZShcIi4uL3NjYWxlcy9saW5lYXJfc2NhbGVcIik7XG52YXIgbG9nX3NjYWxlXzEgPSByZXF1aXJlKFwiLi4vc2NhbGVzL2xvZ19zY2FsZVwiKTtcbnZhciByYW5nZTFkXzEgPSByZXF1aXJlKFwiLi4vcmFuZ2VzL3JhbmdlMWRcIik7XG52YXIgZGF0YV9yYW5nZTFkXzEgPSByZXF1aXJlKFwiLi4vcmFuZ2VzL2RhdGFfcmFuZ2UxZFwiKTtcbnZhciBmYWN0b3JfcmFuZ2VfMSA9IHJlcXVpcmUoXCIuLi9yYW5nZXMvZmFjdG9yX3JhbmdlXCIpO1xudmFyIHNvbHZlcl8xID0gcmVxdWlyZShcImNvcmUvbGF5b3V0L3NvbHZlclwiKTtcbnZhciBsYXlvdXRfY2FudmFzXzEgPSByZXF1aXJlKFwiY29yZS9sYXlvdXQvbGF5b3V0X2NhbnZhc1wiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5DYXJ0ZXNpYW5GcmFtZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDYXJ0ZXNpYW5GcmFtZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ2FydGVzaWFuRnJhbWUoKSB7XG4gICAgICAgIHJldHVybiBDYXJ0ZXNpYW5GcmFtZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2FydGVzaWFuRnJhbWUucHJvdG90eXBlLnR5cGUgPSAnQ2FydGVzaWFuRnJhbWUnO1xuICAgIENhcnRlc2lhbkZyYW1lLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIENhcnRlc2lhbkZyYW1lLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnBhbmVsID0gdGhpcztcbiAgICAgICAgdGhpcy5fY29uZmlndXJlX3NjYWxlcygpO1xuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5jaGFuZ2UsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jb25maWd1cmVfc2NhbGVzKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQ2FydGVzaWFuRnJhbWUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHZ4LCB2eSkge1xuICAgICAgICByZXR1cm4gdnggPj0gdGhpcy5fbGVmdC52YWx1ZSAmJiB2eCA8PSB0aGlzLl9yaWdodC52YWx1ZSAmJiB2eSA+PSB0aGlzLl9ib3R0b20udmFsdWUgJiYgdnkgPD0gdGhpcy5fdG9wLnZhbHVlO1xuICAgIH07XG4gICAgQ2FydGVzaWFuRnJhbWUucHJvdG90eXBlLm1hcF90b19zY3JlZW4gPSBmdW5jdGlvbiAoeCwgeSwgY2FudmFzLCB4X25hbWUsIHlfbmFtZSkge1xuICAgICAgICB2YXIgc3gsIHN5LCB2eCwgdnk7XG4gICAgICAgIGlmICh4X25hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgeF9uYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5X25hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgeV9uYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgICAgIHZ4ID0gdGhpcy54c2NhbGVzW3hfbmFtZV0udl9jb21wdXRlKHgpO1xuICAgICAgICBzeCA9IGNhbnZhcy52X3Z4X3RvX3N4KHZ4KTtcbiAgICAgICAgdnkgPSB0aGlzLnlzY2FsZXNbeV9uYW1lXS52X2NvbXB1dGUoeSk7XG4gICAgICAgIHN5ID0gY2FudmFzLnZfdnlfdG9fc3kodnkpO1xuICAgICAgICByZXR1cm4gW3N4LCBzeV07XG4gICAgfTtcbiAgICBDYXJ0ZXNpYW5GcmFtZS5wcm90b3R5cGUuX2dldF9yYW5nZXMgPSBmdW5jdGlvbiAocmFuZ2UsIGV4dHJhX3Jhbmdlcykge1xuICAgICAgICB2YXIgZXh0cmFfcmFuZ2UsIG5hbWUsIHJhbmdlcztcbiAgICAgICAgcmFuZ2VzID0ge307XG4gICAgICAgIHJhbmdlc1snZGVmYXVsdCddID0gcmFuZ2U7XG4gICAgICAgIGlmIChleHRyYV9yYW5nZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChuYW1lIGluIGV4dHJhX3Jhbmdlcykge1xuICAgICAgICAgICAgICAgIGV4dHJhX3JhbmdlID0gZXh0cmFfcmFuZ2VzW25hbWVdO1xuICAgICAgICAgICAgICAgIHJhbmdlc1tuYW1lXSA9IGV4dHJhX3JhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfTtcbiAgICBDYXJ0ZXNpYW5GcmFtZS5wcm90b3R5cGUuX2dldF9zY2FsZXMgPSBmdW5jdGlvbiAoc2NhbGUsIHJhbmdlcywgZnJhbWVfcmFuZ2UpIHtcbiAgICAgICAgdmFyIG5hbWUsIHJhbmdlLCBzLCBzY2FsZXM7XG4gICAgICAgIHNjYWxlcyA9IHt9O1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmFuZ2VzKSB7XG4gICAgICAgICAgICByYW5nZSA9IHJhbmdlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIGRhdGFfcmFuZ2UxZF8xLkRhdGFSYW5nZTFkIHx8IHJhbmdlIGluc3RhbmNlb2YgcmFuZ2UxZF8xLlJhbmdlMWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShzY2FsZSBpbnN0YW5jZW9mIGxvZ19zY2FsZV8xLkxvZ1NjYWxlKSAmJiAhKHNjYWxlIGluc3RhbmNlb2YgbGluZWFyX3NjYWxlXzEuTGluZWFyU2NhbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbmdlIFwiICsgcmFuZ2UudHlwZSArIFwiIGlzIGluY29tcGF0aWJsZSBpcyBTY2FsZSBcIiArIHNjYWxlLnR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2NhbGUgaW5zdGFuY2VvZiBjYXRlZ29yaWNhbF9zY2FsZV8xLkNhdGVnb3JpY2FsU2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UgXCIgKyByYW5nZS50eXBlICsgXCIgaXMgaW5jb21wYXRpYmxlIGlzIFNjYWxlIFwiICsgc2NhbGUudHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgZmFjdG9yX3JhbmdlXzEuRmFjdG9yUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShzY2FsZSBpbnN0YW5jZW9mIGNhdGVnb3JpY2FsX3NjYWxlXzEuQ2F0ZWdvcmljYWxTY2FsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UgXCIgKyByYW5nZS50eXBlICsgXCIgaXMgaW5jb21wYXRpYmxlIGlzIFNjYWxlIFwiICsgc2NhbGUudHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjYWxlIGluc3RhbmNlb2YgbG9nX3NjYWxlXzEuTG9nU2NhbGUgJiYgcmFuZ2UgaW5zdGFuY2VvZiBkYXRhX3JhbmdlMWRfMS5EYXRhUmFuZ2UxZCkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnNjYWxlX2hpbnQgPSBcImxvZ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IHNjYWxlLmNsb25lKCk7XG4gICAgICAgICAgICBzLnNldHYoe1xuICAgICAgICAgICAgICAgIHNvdXJjZV9yYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0X3JhbmdlOiBmcmFtZV9yYW5nZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzY2FsZXNbbmFtZV0gPSBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2FsZXM7XG4gICAgfTtcbiAgICBDYXJ0ZXNpYW5GcmFtZS5wcm90b3R5cGUuX2NvbmZpZ3VyZV9mcmFtZV9yYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2hfcmFuZ2UgPSBuZXcgcmFuZ2UxZF8xLlJhbmdlMWQoe1xuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuX2xlZnQudmFsdWUsXG4gICAgICAgICAgICBlbmQ6IHRoaXMuX2xlZnQudmFsdWUgKyB0aGlzLl93aWR0aC52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZfcmFuZ2UgPSBuZXcgcmFuZ2UxZF8xLlJhbmdlMWQoe1xuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuX2JvdHRvbS52YWx1ZSxcbiAgICAgICAgICAgIGVuZDogdGhpcy5fYm90dG9tLnZhbHVlICsgdGhpcy5faGVpZ2h0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FydGVzaWFuRnJhbWUucHJvdG90eXBlLl9jb25maWd1cmVfc2NhbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb25maWd1cmVfZnJhbWVfcmFuZ2VzKCk7XG4gICAgICAgIHRoaXMuX3hfcmFuZ2VzID0gdGhpcy5fZ2V0X3Jhbmdlcyh0aGlzLnhfcmFuZ2UsIHRoaXMuZXh0cmFfeF9yYW5nZXMpO1xuICAgICAgICB0aGlzLl95X3JhbmdlcyA9IHRoaXMuX2dldF9yYW5nZXModGhpcy55X3JhbmdlLCB0aGlzLmV4dHJhX3lfcmFuZ2VzKTtcbiAgICAgICAgdGhpcy5feHNjYWxlcyA9IHRoaXMuX2dldF9zY2FsZXModGhpcy54X3NjYWxlLCB0aGlzLl94X3JhbmdlcywgdGhpcy5faF9yYW5nZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl95c2NhbGVzID0gdGhpcy5fZ2V0X3NjYWxlcyh0aGlzLnlfc2NhbGUsIHRoaXMuX3lfcmFuZ2VzLCB0aGlzLl92X3JhbmdlKTtcbiAgICB9O1xuICAgIENhcnRlc2lhbkZyYW1lLnByb3RvdHlwZS5fdXBkYXRlX3NjYWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hbWUsIHJlZiwgcmVmMSwgc2NhbGU7XG4gICAgICAgIHRoaXMuX2NvbmZpZ3VyZV9mcmFtZV9yYW5nZXMoKTtcbiAgICAgICAgcmVmID0gdGhpcy5feHNjYWxlcztcbiAgICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICAgICAgc2NhbGUgPSByZWZbbmFtZV07XG4gICAgICAgICAgICBzY2FsZS50YXJnZXRfcmFuZ2UgPSB0aGlzLl9oX3JhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHJlZjEgPSB0aGlzLl95c2NhbGVzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmMSkge1xuICAgICAgICAgICAgc2NhbGUgPSByZWYxW25hbWVdO1xuICAgICAgICAgICAgc2NhbGUudGFyZ2V0X3JhbmdlID0gdGhpcy5fdl9yYW5nZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENhcnRlc2lhbkZyYW1lLmdldHRlcnMoe1xuICAgICAgICBoX3JhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faF9yYW5nZTtcbiAgICAgICAgfSxcbiAgICAgICAgdl9yYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZfcmFuZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIHhfcmFuZ2VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feF9yYW5nZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHlfcmFuZ2VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feV9yYW5nZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHhzY2FsZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl94c2NhbGVzO1xuICAgICAgICB9LFxuICAgICAgICB5c2NhbGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feXNjYWxlcztcbiAgICAgICAgfSxcbiAgICAgICAgeF9tYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJ4X21hcHBlcnMgYXR0ciBpcyBkZXByZWNhdGVkLCB1c2UgeHNjYWxlc1wiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl94c2NhbGVzO1xuICAgICAgICB9LFxuICAgICAgICB5X21hcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIud2FybihcInlfbWFwcGVycyBhdHRyIGlzIGRlcHJlY2F0ZWQsIHVzZSB5c2NhbGVzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3lzY2FsZXM7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBDYXJ0ZXNpYW5GcmFtZS5pbnRlcm5hbCh7XG4gICAgICAgIGV4dHJhX3hfcmFuZ2VzOiBbcC5BbnksIHt9XSxcbiAgICAgICAgZXh0cmFfeV9yYW5nZXM6IFtwLkFueSwge31dLFxuICAgICAgICB4X3JhbmdlOiBbcC5JbnN0YW5jZV0sXG4gICAgICAgIHlfcmFuZ2U6IFtwLkluc3RhbmNlXSxcbiAgICAgICAgeF9zY2FsZTogW3AuSW5zdGFuY2VdLFxuICAgICAgICB5X3NjYWxlOiBbcC5JbnN0YW5jZV1cbiAgICB9KTtcbiAgICBDYXJ0ZXNpYW5GcmFtZS5wcm90b3R5cGUuZ2V0X2NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW3NvbHZlcl8xLkdFKHRoaXMuX3RvcCksIHNvbHZlcl8xLkdFKHRoaXMuX2JvdHRvbSksIHNvbHZlcl8xLkdFKHRoaXMuX2xlZnQpLCBzb2x2ZXJfMS5HRSh0aGlzLl9yaWdodCksIHNvbHZlcl8xLkdFKHRoaXMuX3dpZHRoKSwgc29sdmVyXzEuR0UodGhpcy5faGVpZ2h0KSwgc29sdmVyXzEuRVEodGhpcy5fbGVmdCwgdGhpcy5fd2lkdGgsIFstMSwgdGhpcy5fcmlnaHRdKSwgc29sdmVyXzEuRVEodGhpcy5fYm90dG9tLCB0aGlzLl9oZWlnaHQsIFstMSwgdGhpcy5fdG9wXSldO1xuICAgIH07XG4gICAgcmV0dXJuIENhcnRlc2lhbkZyYW1lO1xufSkobGF5b3V0X2NhbnZhc18xLkxheW91dENhbnZhcyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjYW52YXNfMSA9IHJlcXVpcmUoXCIuL2NhbnZhc1wiKTtcbmV4cG9ydHMuQ2FudmFzID0gY2FudmFzXzEuQ2FudmFzO1xudmFyIGNhcnRlc2lhbl9mcmFtZV8xID0gcmVxdWlyZShcIi4vY2FydGVzaWFuX2ZyYW1lXCIpO1xuZXhwb3J0cy5DYXJ0ZXNpYW5GcmFtZSA9IGNhcnRlc2lhbl9mcmFtZV8xLkNhcnRlc2lhbkZyYW1lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHRpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi90aWNrX2Zvcm1hdHRlclwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90eXBlc1wiKTtcbmV4cG9ydHMuQmFzaWNUaWNrRm9ybWF0dGVyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEJhc2ljVGlja0Zvcm1hdHRlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQmFzaWNUaWNrRm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gQmFzaWNUaWNrRm9ybWF0dGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCYXNpY1RpY2tGb3JtYXR0ZXIucHJvdG90eXBlLnR5cGUgPSAnQmFzaWNUaWNrRm9ybWF0dGVyJztcbiAgICBCYXNpY1RpY2tGb3JtYXR0ZXIuZGVmaW5lKHtcbiAgICAgICAgcHJlY2lzaW9uOiBbcC5BbnksICdhdXRvJ10sXG4gICAgICAgIHVzZV9zY2llbnRpZmljOiBbcC5Cb29sLCB0cnVlXSxcbiAgICAgICAgcG93ZXJfbGltaXRfaGlnaDogW3AuTnVtYmVyLCA1XSxcbiAgICAgICAgcG93ZXJfbGltaXRfbG93OiBbcC5OdW1iZXIsIC0zXVxuICAgIH0pO1xuICAgIEJhc2ljVGlja0Zvcm1hdHRlci5nZXR0ZXJzKHtcbiAgICAgICAgc2NpZW50aWZpY19saW1pdF9sb3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdygxMC4wLCB0aGlzLnBvd2VyX2xpbWl0X2xvdyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNjaWVudGlmaWNfbGltaXRfaGlnaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KDEwLjAsIHRoaXMucG93ZXJfbGltaXRfaGlnaCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBCYXNpY1RpY2tGb3JtYXR0ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgQmFzaWNUaWNrRm9ybWF0dGVyLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0X3ByZWNpc2lvbiA9IDM7XG4gICAgfTtcbiAgICBCYXNpY1RpY2tGb3JtYXR0ZXIucHJvdG90eXBlLmRvRm9ybWF0ID0gZnVuY3Rpb24gKHRpY2tzLCBheGlzKSB7XG4gICAgICAgIHZhciBpLCBpc19vaywgaiwgaywgbCwgbGFiZWxzLCBsZW4sIG0sIG4sIG5lZWRfc2NpLCBvLCBwcmVjaXNpb24sIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgdGljaywgdGlja19hYnMsIHgsIHplcm9fZXBzO1xuICAgICAgICBpZiAodGlja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgemVyb19lcHMgPSAwO1xuICAgICAgICBpZiAodGlja3MubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHplcm9fZXBzID0gTWF0aC5hYnModGlja3NbMV0gLSB0aWNrc1swXSkgLyAxMDAwMDtcbiAgICAgICAgfVxuICAgICAgICBuZWVkX3NjaSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy51c2Vfc2NpZW50aWZpYykge1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gdGlja3MubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aWNrID0gdGlja3Nbal07XG4gICAgICAgICAgICAgICAgdGlja19hYnMgPSBNYXRoLmFicyh0aWNrKTtcbiAgICAgICAgICAgICAgICBpZiAodGlja19hYnMgPiB6ZXJvX2VwcyAmJiAodGlja19hYnMgPj0gdGhpcy5zY2llbnRpZmljX2xpbWl0X2hpZ2ggfHwgdGlja19hYnMgPD0gdGhpcy5zY2llbnRpZmljX2xpbWl0X2xvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVlZF9zY2kgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJlY2lzaW9uID0gdGhpcy5wcmVjaXNpb247XG4gICAgICAgIGlmICgocHJlY2lzaW9uID09IG51bGwpIHx8IHR5cGVzXzEuaXNOdW1iZXIocHJlY2lzaW9uKSkge1xuICAgICAgICAgICAgbGFiZWxzID0gbmV3IEFycmF5KHRpY2tzLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAobmVlZF9zY2kpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmID0gdGlja3MubGVuZ3RoOyAwIDw9IHJlZiA/IGsgPCByZWYgOiBrID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxzW2ldID0gdGlja3NbaV0udG9FeHBvbmVudGlhbChwcmVjaXNpb24gfHwgdm9pZCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBsID0gMCwgcmVmMSA9IHRpY2tzLmxlbmd0aDsgMCA8PSByZWYxID8gbCA8IHJlZjEgOiBsID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbHNbaV0gPSB0aWNrc1tpXS50b0ZpeGVkKHByZWNpc2lvbiB8fCB2b2lkIDApLnJlcGxhY2UoLyhcXC5bMC05XSo/KTArJC8sIFwiJDFcIikucmVwbGFjZSgvXFwuJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlY2lzaW9uID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIGxhYmVscyA9IG5ldyBBcnJheSh0aWNrcy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh4ID0gbSA9IHJlZjIgPSB0aGlzLmxhc3RfcHJlY2lzaW9uOyByZWYyIDw9IDE1ID8gbSA8PSAxNSA6IG0gPj0gMTU7IHggPSByZWYyIDw9IDE1ID8gKyttIDogLS1tKSB7XG4gICAgICAgICAgICAgICAgaXNfb2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZWVkX3NjaSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBuID0gMCwgcmVmMyA9IHRpY2tzLmxlbmd0aDsgMCA8PSByZWYzID8gbiA8IHJlZjMgOiBuID4gcmVmMzsgaSA9IDAgPD0gcmVmMyA/ICsrbiA6IC0tbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzW2ldID0gdGlja3NbaV0udG9FeHBvbmVudGlhbCh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbHNbaV0gPT09IGxhYmVsc1tpIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNfb2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc19vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IG8gPSAwLCByZWY0ID0gdGlja3MubGVuZ3RoOyAwIDw9IHJlZjQgPyBvIDwgcmVmNCA6IG8gPiByZWY0OyBpID0gMCA8PSByZWY0ID8gKytvIDogLS1vKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHNbaV0gPSB0aWNrc1tpXS50b0ZpeGVkKHgpLnJlcGxhY2UoLyhcXC5bMC05XSo/KTArJC8sIFwiJDFcIikucmVwbGFjZSgvXFwuJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsc1tpXSA9PT0gbGFiZWxzW2kgLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc19vayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzX29rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNfb2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0X3ByZWNpc2lvbiA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzaWNUaWNrRm9ybWF0dGVyO1xufSkodGlja19mb3JtYXR0ZXJfMS5UaWNrRm9ybWF0dGVyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0aWNrX2Zvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vdGlja19mb3JtYXR0ZXJcIik7XG5leHBvcnRzLkNhdGVnb3JpY2FsVGlja0Zvcm1hdHRlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDYXRlZ29yaWNhbFRpY2tGb3JtYXR0ZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENhdGVnb3JpY2FsVGlja0Zvcm1hdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIENhdGVnb3JpY2FsVGlja0Zvcm1hdHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2F0ZWdvcmljYWxUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS50eXBlID0gJ0NhdGVnb3JpY2FsVGlja0Zvcm1hdHRlcic7XG4gICAgQ2F0ZWdvcmljYWxUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS5kb0Zvcm1hdCA9IGZ1bmN0aW9uICh0aWNrcywgYXhpcykge1xuICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0ZWdvcmljYWxUaWNrRm9ybWF0dGVyO1xufSkodGlja19mb3JtYXR0ZXJfMS5UaWNrRm9ybWF0dGVyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9hcnJheSwgX3N0cmZ0aW1lLCBfdXMsIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBTUHJpbnRmID0gcmVxdWlyZShcInNwcmludGZcIik7XG52YXIgdHogPSByZXF1aXJlKFwidGltZXpvbmVcIik7XG52YXIgdGlja19mb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL3RpY2tfZm9ybWF0dGVyXCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL2xvZ2dpbmdcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdHlwZXNcIik7XG5fdXMgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKCgodCAvIDEwMDApICUgMSkgKiAxMDAwMDAwKTtcbn07XG5fYXJyYXkgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0eih0LCBcIiVZICVtICVkICVIICVNICVTXCIpLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChlLCAxMCk7XG4gICAgfSk7XG59O1xuX3N0cmZ0aW1lID0gZnVuY3Rpb24gKHQsIGZvcm1hdCkge1xuICAgIHZhciBtaWNyb3NlY29uZF9yZXBsYWNlbWVudF9zdHJpbmc7XG4gICAgaWYgKHR5cGVzXzEuaXNGdW5jdGlvbihmb3JtYXQpKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQodCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtaWNyb3NlY29uZF9yZXBsYWNlbWVudF9zdHJpbmcgPSBTUHJpbnRmLnNwcmludGYoXCIkMSUwNmRcIiwgX3VzKHQpKTtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLygoXnxbXiVdKSglJSkqKSVmLywgbWljcm9zZWNvbmRfcmVwbGFjZW1lbnRfc3RyaW5nKTtcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKFwiJVwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR6KHQsIGZvcm1hdCk7XG4gICAgfVxufTtcbmV4cG9ydHMuRGF0ZXRpbWVUaWNrRm9ybWF0dGVyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERhdGV0aW1lVGlja0Zvcm1hdHRlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRGF0ZXRpbWVUaWNrRm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gRGF0ZXRpbWVUaWNrRm9ybWF0dGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEYXRldGltZVRpY2tGb3JtYXR0ZXIucHJvdG90eXBlLnR5cGUgPSAnRGF0ZXRpbWVUaWNrRm9ybWF0dGVyJztcbiAgICBEYXRldGltZVRpY2tGb3JtYXR0ZXIuZGVmaW5lKHtcbiAgICAgICAgbWljcm9zZWNvbmRzOiBbcC5BcnJheSwgWyclZnVzJ11dLFxuICAgICAgICBtaWxsaXNlY29uZHM6IFtwLkFycmF5LCBbJyUzTm1zJywgJyVTLiUzTnMnXV0sXG4gICAgICAgIHNlY29uZHM6IFtwLkFycmF5LCBbJyVTcyddXSxcbiAgICAgICAgbWluc2VjOiBbcC5BcnJheSwgWyc6JU06JVMnXV0sXG4gICAgICAgIG1pbnV0ZXM6IFtwLkFycmF5LCBbJzolTScsICclTW0nXV0sXG4gICAgICAgIGhvdXJtaW46IFtwLkFycmF5LCBbJyVIOiVNJ11dLFxuICAgICAgICBob3VyczogW3AuQXJyYXksIFsnJUhoJywgJyVIOiVNJ11dLFxuICAgICAgICBkYXlzOiBbcC5BcnJheSwgWyclbS8lZCcsICclYSVkJ11dLFxuICAgICAgICBtb250aHM6IFtwLkFycmF5LCBbJyVtLyVZJywgJyViJXknXV0sXG4gICAgICAgIHllYXJzOiBbcC5BcnJheSwgWyclWSddXVxuICAgIH0pO1xuICAgIERhdGV0aW1lVGlja0Zvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0X29yZGVyID0gWydtaWNyb3NlY29uZHMnLCAnbWlsbGlzZWNvbmRzJywgJ3NlY29uZHMnLCAnbWluc2VjJywgJ21pbnV0ZXMnLCAnaG91cm1pbicsICdob3VycycsICdkYXlzJywgJ21vbnRocycsICd5ZWFycyddO1xuICAgIERhdGV0aW1lVGlja0Zvcm1hdHRlci5wcm90b3R5cGUuc3RyaXBfbGVhZGluZ196ZXJvcyA9IHRydWU7XG4gICAgRGF0ZXRpbWVUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIERhdGV0aW1lVGlja0Zvcm1hdHRlci5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZV93aWR0aF9mb3JtYXRzKCk7XG4gICAgfTtcbiAgICBEYXRldGltZVRpY2tGb3JtYXR0ZXIucHJvdG90eXBlLl91cGRhdGVfd2lkdGhfZm9ybWF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF93aWR0aHMsIG5vdztcbiAgICAgICAgbm93ID0gdHoobmV3IERhdGUoKSk7XG4gICAgICAgIF93aWR0aHMgPSBmdW5jdGlvbiAoZm10X3N0cmluZ3MpIHtcbiAgICAgICAgICAgIHZhciBmbXRfc3RyaW5nLCBzaXplcywgc29ydGVkO1xuICAgICAgICAgICAgc2l6ZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGZtdF9zdHJpbmdzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZtdF9zdHJpbmcgPSBmbXRfc3RyaW5nc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKF9zdHJmdGltZShub3csIGZtdF9zdHJpbmcpLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHNvcnRlZCA9IGFycmF5XzEuc29ydEJ5KGFycmF5XzEuemlwKHNpemVzLCBmbXRfc3RyaW5ncyksIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm10LCBzaXplO1xuICAgICAgICAgICAgICAgIHNpemUgPSBhcmdbMF0sIGZtdCA9IGFyZ1sxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5XzEudW56aXAoc29ydGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoX2Zvcm1hdHMgPSB7XG4gICAgICAgICAgICBtaWNyb3NlY29uZHM6IF93aWR0aHModGhpcy5taWNyb3NlY29uZHMpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBfd2lkdGhzKHRoaXMubWlsbGlzZWNvbmRzKSxcbiAgICAgICAgICAgIHNlY29uZHM6IF93aWR0aHModGhpcy5zZWNvbmRzKSxcbiAgICAgICAgICAgIG1pbnNlYzogX3dpZHRocyh0aGlzLm1pbnNlYyksXG4gICAgICAgICAgICBtaW51dGVzOiBfd2lkdGhzKHRoaXMubWludXRlcyksXG4gICAgICAgICAgICBob3VybWluOiBfd2lkdGhzKHRoaXMuaG91cm1pbiksXG4gICAgICAgICAgICBob3VyczogX3dpZHRocyh0aGlzLmhvdXJzKSxcbiAgICAgICAgICAgIGRheXM6IF93aWR0aHModGhpcy5kYXlzKSxcbiAgICAgICAgICAgIG1vbnRoczogX3dpZHRocyh0aGlzLm1vbnRocyksXG4gICAgICAgICAgICB5ZWFyczogX3dpZHRocyh0aGlzLnllYXJzKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgRGF0ZXRpbWVUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS5fZ2V0X3Jlc29sdXRpb25fc3RyID0gZnVuY3Rpb24gKHJlc29sdXRpb25fc2Vjcywgc3Bhbl9zZWNzKSB7XG4gICAgICAgIHZhciBhZGp1c3RlZF9zZWNzO1xuICAgICAgICBhZGp1c3RlZF9zZWNzID0gcmVzb2x1dGlvbl9zZWNzICogMS4xO1xuICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgICBjYXNlICEoYWRqdXN0ZWRfc2VjcyA8IDFlLTMpOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIm1pY3Jvc2Vjb25kc1wiO1xuICAgICAgICAgICAgY2FzZSAhKGFkanVzdGVkX3NlY3MgPCAxLjApOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kc1wiO1xuICAgICAgICAgICAgY2FzZSAhKGFkanVzdGVkX3NlY3MgPCA2MCk6XG4gICAgICAgICAgICAgICAgaWYgKHNwYW5fc2VjcyA+PSA2MCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtaW5zZWNcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInNlY29uZHNcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICEoYWRqdXN0ZWRfc2VjcyA8IDM2MDApOlxuICAgICAgICAgICAgICAgIGlmIChzcGFuX3NlY3MgPj0gMzYwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJob3VybWluXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtaW51dGVzXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAhKGFkanVzdGVkX3NlY3MgPCAyNCAqIDM2MDApOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImhvdXJzXCI7XG4gICAgICAgICAgICBjYXNlICEoYWRqdXN0ZWRfc2VjcyA8IDMxICogMjQgKiAzNjAwKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJkYXlzXCI7XG4gICAgICAgICAgICBjYXNlICEoYWRqdXN0ZWRfc2VjcyA8IDM2NSAqIDI0ICogMzYwMCk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibW9udGhzXCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBcInllYXJzXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGV0aW1lVGlja0Zvcm1hdHRlci5wcm90b3R5cGUuZG9Gb3JtYXQgPSBmdW5jdGlvbiAodGlja3MsIGF4aXMsIG51bV9sYWJlbHMsIGNoYXJfd2lkdGgsIGZpbGxfcmF0aW8sIHRpY2tlcikge1xuICAgICAgICB2YXIgZXJyb3IsIGZtdCwgZm9ybWF0LCBmb3JtYXRzLCBnb29kX2Zvcm1hdHMsIGh5YnJpZF9oYW5kbGVkLCBpLCBqLCBrLCBsLCBsYWJlbHMsIGxlbiwgbGVuMSwgbmV4dF9mb3JtYXQsIG5leHRfbmR4LCByLCByZWYsIHJlZjEsIHJlZjIsIHJlc29sLCByZXNvbF9uZHgsIHMsIHNwYW4sIHNzLCB0LCB0aW1lX3R1cGxlX25keF9mb3JfcmVzb2wsIHRtLCB3aWR0aHM7XG4gICAgICAgIGlmIChudW1fbGFiZWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIG51bV9sYWJlbHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyX3dpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgIGNoYXJfd2lkdGggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxsX3JhdGlvID09IG51bGwpIHtcbiAgICAgICAgICAgIGZpbGxfcmF0aW8gPSAwLjM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpY2tlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aWNrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBzcGFuID0gTWF0aC5hYnModGlja3NbdGlja3MubGVuZ3RoIC0gMV0gLSB0aWNrc1swXSkgLyAxMDAwLjA7XG4gICAgICAgIGlmICh0aWNrZXIpIHtcbiAgICAgICAgICAgIHIgPSB0aWNrZXIucmVzb2x1dGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHIgPSBzcGFuIC8gKHRpY2tzLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sID0gdGhpcy5fZ2V0X3Jlc29sdXRpb25fc3RyKHIsIHNwYW4pO1xuICAgICAgICByZWYgPSB0aGlzLl93aWR0aF9mb3JtYXRzW3Jlc29sXSwgd2lkdGhzID0gcmVmWzBdLCBmb3JtYXRzID0gcmVmWzFdO1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXRzWzBdO1xuICAgICAgICBpZiAoY2hhcl93aWR0aCkge1xuICAgICAgICAgICAgZ29vZF9mb3JtYXRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmMSA9IHdpZHRocy5sZW5ndGg7IDAgPD0gcmVmMSA/IGogPCByZWYxIDogaiA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGhzW2ldICogdGlja3MubGVuZ3RoIDwgZmlsbF9yYXRpbyAqIGNoYXJfd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZF9mb3JtYXRzLnB1c2godGhpcy5fd2lkdGhfZm9ybWF0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdvb2RfZm9ybWF0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZ29vZF9mb3JtYXRzW2dvb2RfZm9ybWF0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYWJlbHMgPSBbXTtcbiAgICAgICAgcmVzb2xfbmR4ID0gdGhpcy5mb3JtYXRfb3JkZXIuaW5kZXhPZihyZXNvbCk7XG4gICAgICAgIHRpbWVfdHVwbGVfbmR4X2Zvcl9yZXNvbCA9IHt9O1xuICAgICAgICByZWYyID0gdGhpcy5mb3JtYXRfb3JkZXI7XG4gICAgICAgIGZvciAoayA9IDAsIGxlbiA9IHJlZjIubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgIGZtdCA9IHJlZjJba107XG4gICAgICAgICAgICB0aW1lX3R1cGxlX25keF9mb3JfcmVzb2xbZm10XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGltZV90dXBsZV9uZHhfZm9yX3Jlc29sW1wic2Vjb25kc1wiXSA9IDU7XG4gICAgICAgIHRpbWVfdHVwbGVfbmR4X2Zvcl9yZXNvbFtcIm1pbnNlY1wiXSA9IDQ7XG4gICAgICAgIHRpbWVfdHVwbGVfbmR4X2Zvcl9yZXNvbFtcIm1pbnV0ZXNcIl0gPSA0O1xuICAgICAgICB0aW1lX3R1cGxlX25keF9mb3JfcmVzb2xbXCJob3VybWluXCJdID0gMztcbiAgICAgICAgdGltZV90dXBsZV9uZHhfZm9yX3Jlc29sW1wiaG91cnNcIl0gPSAzO1xuICAgICAgICBmb3IgKGwgPSAwLCBsZW4xID0gdGlja3MubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICB0ID0gdGlja3NbbF07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRtID0gX2FycmF5KHQpO1xuICAgICAgICAgICAgICAgIHMgPSBfc3RyZnRpbWUodCwgZm9ybWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycm9yMTtcbiAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJ1bmFibGUgdG8gZm9ybWF0IHRpY2sgZm9yIHRpbWVzdGFtcCB2YWx1ZSBcIiArIHQpO1xuICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIud2FybihcIiAtIFwiICsgZXJyb3IpO1xuICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKFwiRVJSXCIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHlicmlkX2hhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG5leHRfbmR4ID0gcmVzb2xfbmR4O1xuICAgICAgICAgICAgd2hpbGUgKHRtW3RpbWVfdHVwbGVfbmR4X2Zvcl9yZXNvbFt0aGlzLmZvcm1hdF9vcmRlcltuZXh0X25keF1dXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5leHRfbmR4ICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRfbmR4ID09PSB0aGlzLmZvcm1hdF9vcmRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgocmVzb2wgPT09IFwibWluc2VjXCIgfHwgcmVzb2wgPT09IFwiaG91cm1pblwiKSAmJiAhaHlicmlkX2hhbmRsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChyZXNvbCA9PT0gXCJtaW5zZWNcIiAmJiB0bVs0XSA9PT0gMCAmJiB0bVs1XSAhPT0gMCkgfHwgKHJlc29sID09PSBcImhvdXJtaW5cIiAmJiB0bVszXSA9PT0gMCAmJiB0bVs0XSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRfZm9ybWF0ID0gdGhpcy5fd2lkdGhfZm9ybWF0c1t0aGlzLmZvcm1hdF9vcmRlcltyZXNvbF9uZHggLSAxXV1bMV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gX3N0cmZ0aW1lKHQsIG5leHRfZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHlicmlkX2hhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRfZm9ybWF0ID0gdGhpcy5fd2lkdGhfZm9ybWF0c1t0aGlzLmZvcm1hdF9vcmRlcltuZXh0X25keF1dWzFdWzBdO1xuICAgICAgICAgICAgICAgIHMgPSBfc3RyZnRpbWUodCwgbmV4dF9mb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RyaXBfbGVhZGluZ196ZXJvcykge1xuICAgICAgICAgICAgICAgIHNzID0gcy5yZXBsYWNlKC9eMCsvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKHNzICE9PSBzICYmIGlzTmFOKHBhcnNlSW50KHNzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3MgPSAnMCcgKyBzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2goc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2gocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9O1xuICAgIHJldHVybiBEYXRldGltZVRpY2tGb3JtYXR0ZXI7XG59KSh0aWNrX2Zvcm1hdHRlcl8xLlRpY2tGb3JtYXR0ZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBzbGljZSA9IFtdLnNsaWNlO1xudmFyIHRpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi90aWNrX2Zvcm1hdHRlclwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvb2JqZWN0XCIpO1xuZXhwb3J0cy5GdW5jVGlja0Zvcm1hdHRlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChGdW5jVGlja0Zvcm1hdHRlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRnVuY1RpY2tGb3JtYXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiBGdW5jVGlja0Zvcm1hdHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRnVuY1RpY2tGb3JtYXR0ZXIucHJvdG90eXBlLnR5cGUgPSAnRnVuY1RpY2tGb3JtYXR0ZXInO1xuICAgIEZ1bmNUaWNrRm9ybWF0dGVyLmRlZmluZSh7XG4gICAgICAgIGFyZ3M6IFtwLkFueSwge31dLFxuICAgICAgICBjb2RlOiBbcC5TdHJpbmcsICcnXVxuICAgIH0pO1xuICAgIEZ1bmNUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS5fbWFrZV9mdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChmdW5jLCBhcmdzLCBjdG9yKSB7XG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbmV3IGN0b3IsIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY2hpbGQsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChyZXN1bHQpID09PSByZXN1bHQgPyByZXN1bHQgOiBjaGlsZDtcbiAgICAgICAgfSkoRnVuY3Rpb24sIFtcInRpY2tcIl0uY29uY2F0KHNsaWNlLmNhbGwoT2JqZWN0LmtleXModGhpcy5hcmdzKSksIFtcInJlcXVpcmVcIl0sIFt0aGlzLmNvZGVdKSwgZnVuY3Rpb24gKCkgeyB9KTtcbiAgICB9O1xuICAgIEZ1bmNUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS5kb0Zvcm1hdCA9IGZ1bmN0aW9uICh0aWNrcywgYXhpcykge1xuICAgICAgICB2YXIgZnVuYywgdGljaztcbiAgICAgICAgZnVuYyA9IHRoaXMuX21ha2VfZnVuYygpO1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZnVuYy5hcHBseShudWxsLCBbdGlja10uY29uY2F0KHNsaWNlLmNhbGwob2JqZWN0XzEudmFsdWVzKHRoaXMuYXJncykpLCBbcmVxdWlyZV0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBGdW5jVGlja0Zvcm1hdHRlcjtcbn0pKHRpY2tfZm9ybWF0dGVyXzEuVGlja0Zvcm1hdHRlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBiYXNpY190aWNrX2Zvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vYmFzaWNfdGlja19mb3JtYXR0ZXJcIik7XG5leHBvcnRzLkJhc2ljVGlja0Zvcm1hdHRlciA9IGJhc2ljX3RpY2tfZm9ybWF0dGVyXzEuQmFzaWNUaWNrRm9ybWF0dGVyO1xudmFyIGNhdGVnb3JpY2FsX3RpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi9jYXRlZ29yaWNhbF90aWNrX2Zvcm1hdHRlclwiKTtcbmV4cG9ydHMuQ2F0ZWdvcmljYWxUaWNrRm9ybWF0dGVyID0gY2F0ZWdvcmljYWxfdGlja19mb3JtYXR0ZXJfMS5DYXRlZ29yaWNhbFRpY2tGb3JtYXR0ZXI7XG52YXIgZGF0ZXRpbWVfdGlja19mb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2RhdGV0aW1lX3RpY2tfZm9ybWF0dGVyXCIpO1xuZXhwb3J0cy5EYXRldGltZVRpY2tGb3JtYXR0ZXIgPSBkYXRldGltZV90aWNrX2Zvcm1hdHRlcl8xLkRhdGV0aW1lVGlja0Zvcm1hdHRlcjtcbnZhciBmdW5jX3RpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi9mdW5jX3RpY2tfZm9ybWF0dGVyXCIpO1xuZXhwb3J0cy5GdW5jVGlja0Zvcm1hdHRlciA9IGZ1bmNfdGlja19mb3JtYXR0ZXJfMS5GdW5jVGlja0Zvcm1hdHRlcjtcbnZhciBsb2dfdGlja19mb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2xvZ190aWNrX2Zvcm1hdHRlclwiKTtcbmV4cG9ydHMuTG9nVGlja0Zvcm1hdHRlciA9IGxvZ190aWNrX2Zvcm1hdHRlcl8xLkxvZ1RpY2tGb3JtYXR0ZXI7XG52YXIgbWVyY2F0b3JfdGlja19mb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL21lcmNhdG9yX3RpY2tfZm9ybWF0dGVyXCIpO1xuZXhwb3J0cy5NZXJjYXRvclRpY2tGb3JtYXR0ZXIgPSBtZXJjYXRvcl90aWNrX2Zvcm1hdHRlcl8xLk1lcmNhdG9yVGlja0Zvcm1hdHRlcjtcbnZhciBudW1lcmFsX3RpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi9udW1lcmFsX3RpY2tfZm9ybWF0dGVyXCIpO1xuZXhwb3J0cy5OdW1lcmFsVGlja0Zvcm1hdHRlciA9IG51bWVyYWxfdGlja19mb3JtYXR0ZXJfMS5OdW1lcmFsVGlja0Zvcm1hdHRlcjtcbnZhciBwcmludGZfdGlja19mb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL3ByaW50Zl90aWNrX2Zvcm1hdHRlclwiKTtcbmV4cG9ydHMuUHJpbnRmVGlja0Zvcm1hdHRlciA9IHByaW50Zl90aWNrX2Zvcm1hdHRlcl8xLlByaW50ZlRpY2tGb3JtYXR0ZXI7XG52YXIgdGlja19mb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL3RpY2tfZm9ybWF0dGVyXCIpO1xuZXhwb3J0cy5UaWNrRm9ybWF0dGVyID0gdGlja19mb3JtYXR0ZXJfMS5UaWNrRm9ybWF0dGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGJhc2ljX3RpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi9iYXNpY190aWNrX2Zvcm1hdHRlclwiKTtcbnZhciB0aWNrX2Zvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vdGlja19mb3JtYXR0ZXJcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuTG9nVGlja0Zvcm1hdHRlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMb2dUaWNrRm9ybWF0dGVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMb2dUaWNrRm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gTG9nVGlja0Zvcm1hdHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTG9nVGlja0Zvcm1hdHRlci5wcm90b3R5cGUudHlwZSA9ICdMb2dUaWNrRm9ybWF0dGVyJztcbiAgICBMb2dUaWNrRm9ybWF0dGVyLmRlZmluZSh7XG4gICAgICAgIHRpY2tlcjogW3AuSW5zdGFuY2UsIG51bGxdXG4gICAgfSk7XG4gICAgTG9nVGlja0Zvcm1hdHRlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBMb2dUaWNrRm9ybWF0dGVyLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhc2ljX2Zvcm1hdHRlciA9IG5ldyBiYXNpY190aWNrX2Zvcm1hdHRlcl8xLkJhc2ljVGlja0Zvcm1hdHRlcigpO1xuICAgICAgICBpZiAodGhpcy50aWNrZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIud2FybihcIkxvZ1RpY2tGb3JtYXR0ZXIgbm90IGNvbmZpZ3VyZWQgd2l0aCBhIHRpY2tlciwgdXNpbmcgZGVmYXVsdCBiYXNlIG9mIDEwIChsYWJlbHMgd2lsbCBiZSBpbmNvcnJlY3QgaWYgdGlja2VyIGJhc2UgaXMgbm90IDEwKVwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9nVGlja0Zvcm1hdHRlci5wcm90b3R5cGUuZG9Gb3JtYXQgPSBmdW5jdGlvbiAodGlja3MsIGF4aXMpIHtcbiAgICAgICAgdmFyIGJhc2UsIGksIGosIGxhYmVscywgcmVmLCBzbWFsbF9pbnRlcnZhbDtcbiAgICAgICAgaWYgKHRpY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpY2tlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy50aWNrZXIuYmFzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJhc2UgPSAxMDtcbiAgICAgICAgfVxuICAgICAgICBzbWFsbF9pbnRlcnZhbCA9IGZhbHNlO1xuICAgICAgICBsYWJlbHMgPSBuZXcgQXJyYXkodGlja3MubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRpY2tzLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICBsYWJlbHNbaV0gPSBiYXNlICsgXCJeXCIgKyAoTWF0aC5yb3VuZChNYXRoLmxvZyh0aWNrc1tpXSkgLyBNYXRoLmxvZyhiYXNlKSkpO1xuICAgICAgICAgICAgaWYgKChpID4gMCkgJiYgKGxhYmVsc1tpXSA9PT0gbGFiZWxzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgICAgICBzbWFsbF9pbnRlcnZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNtYWxsX2ludGVydmFsKSB7XG4gICAgICAgICAgICBsYWJlbHMgPSB0aGlzLmJhc2ljX2Zvcm1hdHRlci5kb0Zvcm1hdCh0aWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9O1xuICAgIHJldHVybiBMb2dUaWNrRm9ybWF0dGVyO1xufSkodGlja19mb3JtYXR0ZXJfMS5UaWNrRm9ybWF0dGVyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBiYXNpY190aWNrX2Zvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vYmFzaWNfdGlja19mb3JtYXR0ZXJcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgcHJvajRfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvcHJvajRcIik7XG5leHBvcnRzLk1lcmNhdG9yVGlja0Zvcm1hdHRlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChNZXJjYXRvclRpY2tGb3JtYXR0ZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIE1lcmNhdG9yVGlja0Zvcm1hdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIE1lcmNhdG9yVGlja0Zvcm1hdHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWVyY2F0b3JUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS50eXBlID0gJ01lcmNhdG9yVGlja0Zvcm1hdHRlcic7XG4gICAgTWVyY2F0b3JUaWNrRm9ybWF0dGVyLmRlZmluZSh7XG4gICAgICAgIGRpbWVuc2lvbjogW3AuTGF0TG9uXVxuICAgIH0pO1xuICAgIE1lcmNhdG9yVGlja0Zvcm1hdHRlci5wcm90b3R5cGUuZG9Gb3JtYXQgPSBmdW5jdGlvbiAodGlja3MsIGF4aXMpIHtcbiAgICAgICAgdmFyIGksIGosIGssIGxhdCwgbG9uLCBwcm9qX3RpY2tzLCByZWYsIHJlZjEsIHJlZjIsIHJlZjM7XG4gICAgICAgIGlmICh0aGlzLmRpbWVuc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXJjYXRvclRpY2tGb3JtYXR0ZXIuZGltZW5zaW9uIG5vdCBjb25maWd1cmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9qX3RpY2tzID0gbmV3IEFycmF5KHRpY2tzLmxlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLmRpbWVuc2lvbiA9PT0gXCJsb25cIikge1xuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRpY2tzLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgcmVmMSA9IHByb2o0XzEucHJvajQocHJvajRfMS5tZXJjYXRvcikuaW52ZXJzZShbdGlja3NbaV0sIGF4aXMubG9jXSksIGxvbiA9IHJlZjFbMF0sIGxhdCA9IHJlZjFbMV07XG4gICAgICAgICAgICAgICAgcHJval90aWNrc1tpXSA9IGxvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYyID0gdGlja3MubGVuZ3RoOyAwIDw9IHJlZjIgPyBrIDwgcmVmMiA6IGsgPiByZWYyOyBpID0gMCA8PSByZWYyID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICAgICAgcmVmMyA9IHByb2o0XzEucHJvajQocHJvajRfMS5tZXJjYXRvcikuaW52ZXJzZShbYXhpcy5sb2MsIHRpY2tzW2ldXSksIGxvbiA9IHJlZjNbMF0sIGxhdCA9IHJlZjNbMV07XG4gICAgICAgICAgICAgICAgcHJval90aWNrc1tpXSA9IGxhdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWVyY2F0b3JUaWNrRm9ybWF0dGVyLl9fc3VwZXJfXy5kb0Zvcm1hdC5jYWxsKHRoaXMsIHByb2pfdGlja3MsIGF4aXMpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lcmNhdG9yVGlja0Zvcm1hdHRlcjtcbn0pKGJhc2ljX3RpY2tfZm9ybWF0dGVyXzEuQmFzaWNUaWNrRm9ybWF0dGVyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBOdW1icm8gPSByZXF1aXJlKFwibnVtYnJvXCIpO1xudmFyIHRpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi90aWNrX2Zvcm1hdHRlclwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuTnVtZXJhbFRpY2tGb3JtYXR0ZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTnVtZXJhbFRpY2tGb3JtYXR0ZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIE51bWVyYWxUaWNrRm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gTnVtZXJhbFRpY2tGb3JtYXR0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE51bWVyYWxUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS50eXBlID0gJ051bWVyYWxUaWNrRm9ybWF0dGVyJztcbiAgICBOdW1lcmFsVGlja0Zvcm1hdHRlci5kZWZpbmUoe1xuICAgICAgICBmb3JtYXQ6IFtwLlN0cmluZywgJzAsMCddLFxuICAgICAgICBsYW5ndWFnZTogW3AuU3RyaW5nLCAnZW4nXSxcbiAgICAgICAgcm91bmRpbmc6IFtwLlN0cmluZywgJ3JvdW5kJ11cbiAgICB9KTtcbiAgICBOdW1lcmFsVGlja0Zvcm1hdHRlci5wcm90b3R5cGUuZG9Gb3JtYXQgPSBmdW5jdGlvbiAodGlja3MsIGF4aXMpIHtcbiAgICAgICAgdmFyIGZvcm1hdCwgbGFiZWxzLCBsYW5ndWFnZSwgcm91bmRpbmcsIHRpY2s7XG4gICAgICAgIGZvcm1hdCA9IHRoaXMuZm9ybWF0O1xuICAgICAgICBsYW5ndWFnZSA9IHRoaXMubGFuZ3VhZ2U7XG4gICAgICAgIHJvdW5kaW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5yb3VuZGluZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyb3VuZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJuZWFyZXN0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmbG9vclwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyb3VuZGRvd25cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3I7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNlaWxcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicm91bmR1cFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICBsYWJlbHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChOdW1icm8uZm9ybWF0KHRpY2ssIGZvcm1hdCwgbGFuZ3VhZ2UsIHJvdW5kaW5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9O1xuICAgIHJldHVybiBOdW1lcmFsVGlja0Zvcm1hdHRlcjtcbn0pKHRpY2tfZm9ybWF0dGVyXzEuVGlja0Zvcm1hdHRlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgU1ByaW50ZiA9IHJlcXVpcmUoXCJzcHJpbnRmXCIpO1xudmFyIHRpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi90aWNrX2Zvcm1hdHRlclwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuUHJpbnRmVGlja0Zvcm1hdHRlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQcmludGZUaWNrRm9ybWF0dGVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBQcmludGZUaWNrRm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gUHJpbnRmVGlja0Zvcm1hdHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUHJpbnRmVGlja0Zvcm1hdHRlci5wcm90b3R5cGUudHlwZSA9ICdQcmludGZUaWNrRm9ybWF0dGVyJztcbiAgICBQcmludGZUaWNrRm9ybWF0dGVyLmRlZmluZSh7XG4gICAgICAgIGZvcm1hdDogW3AuU3RyaW5nLCAnJXMnXVxuICAgIH0pO1xuICAgIFByaW50ZlRpY2tGb3JtYXR0ZXIucHJvdG90eXBlLmRvRm9ybWF0ID0gZnVuY3Rpb24gKHRpY2tzLCBheGlzKSB7XG4gICAgICAgIHZhciBmb3JtYXQsIGxhYmVscywgdGljaztcbiAgICAgICAgZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gICAgICAgIGxhYmVscyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaSwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKFNQcmludGYuc3ByaW50Zihmb3JtYXQsIHRpY2spKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgIH07XG4gICAgcmV0dXJuIFByaW50ZlRpY2tGb3JtYXR0ZXI7XG59KSh0aWNrX2Zvcm1hdHRlcl8xLlRpY2tGb3JtYXR0ZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxcIik7XG5leHBvcnRzLlRpY2tGb3JtYXR0ZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVGlja0Zvcm1hdHRlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVGlja0Zvcm1hdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIFRpY2tGb3JtYXR0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRpY2tGb3JtYXR0ZXIucHJvdG90eXBlLnR5cGUgPSAnVGlja0Zvcm1hdHRlcic7XG4gICAgVGlja0Zvcm1hdHRlci5wcm90b3R5cGUuZG9Gb3JtYXQgPSBmdW5jdGlvbiAodGlja3MsIGF4aXMpIHsgfTtcbiAgICByZXR1cm4gVGlja0Zvcm1hdHRlcjtcbn0pKG1vZGVsXzEuTW9kZWwpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHh5X2dseXBoXzEgPSByZXF1aXJlKFwiLi94eV9nbHlwaFwiKTtcbnZhciBoaXR0ZXN0ID0gcmVxdWlyZShcImNvcmUvaGl0dGVzdFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBtYXRoXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL21hdGhcIik7XG5leHBvcnRzLkFubnVsYXJXZWRnZVZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQW5udWxhcldlZGdlVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQW5udWxhcldlZGdlVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEFubnVsYXJXZWRnZVZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFubnVsYXJXZWRnZVZpZXcucHJvdG90eXBlLl9tYXBfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGksIGosIHJlZiwgcmVzdWx0cztcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy5pbm5lcl9yYWRpdXMudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICB0aGlzLnNpbm5lcl9yYWRpdXMgPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXIueHNjYWxlLCB0aGlzLl94LCB0aGlzLl9pbm5lcl9yYWRpdXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaW5uZXJfcmFkaXVzID0gdGhpcy5faW5uZXJfcmFkaXVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnByb3BlcnRpZXMub3V0ZXJfcmFkaXVzLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgdGhpcy5zb3V0ZXJfcmFkaXVzID0gdGhpcy5zZGlzdCh0aGlzLnJlbmRlcmVyLnhzY2FsZSwgdGhpcy5feCwgdGhpcy5fb3V0ZXJfcmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc291dGVyX3JhZGl1cyA9IHRoaXMuX291dGVyX3JhZGl1cztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbmdsZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fc3RhcnRfYW5nbGUubGVuZ3RoKTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdGhpcy5fc3RhcnRfYW5nbGUubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLl9hbmdsZVtpXSA9IHRoaXMuX2VuZF9hbmdsZVtpXSAtIHRoaXMuX3N0YXJ0X2FuZ2xlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEFubnVsYXJXZWRnZVZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIF9hbmdsZSwgX3N0YXJ0X2FuZ2xlLCBkaXJlY3Rpb24sIGksIGosIGxlbiwgcmVzdWx0cywgc2lubmVyX3JhZGl1cywgc291dGVyX3JhZGl1cywgc3gsIHN5O1xuICAgICAgICBzeCA9IGFyZy5zeCwgc3kgPSBhcmcuc3ksIF9zdGFydF9hbmdsZSA9IGFyZy5fc3RhcnRfYW5nbGUsIF9hbmdsZSA9IGFyZy5fYW5nbGUsIHNpbm5lcl9yYWRpdXMgPSBhcmcuc2lubmVyX3JhZGl1cywgc291dGVyX3JhZGl1cyA9IGFyZy5zb3V0ZXJfcmFkaXVzO1xuICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLm1vZGVsLnByb3BlcnRpZXMuZGlyZWN0aW9uLnZhbHVlKCk7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IGluZGljZXNbal07XG4gICAgICAgICAgICBpZiAoaXNOYU4oc3hbaV0gKyBzeVtpXSArIHNpbm5lcl9yYWRpdXNbaV0gKyBzb3V0ZXJfcmFkaXVzW2ldICsgX3N0YXJ0X2FuZ2xlW2ldICsgX2FuZ2xlW2ldKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShzeFtpXSwgc3lbaV0pO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShfc3RhcnRfYW5nbGVbaV0pO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhzb3V0ZXJfcmFkaXVzW2ldLCAwKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgc291dGVyX3JhZGl1c1tpXSwgMCwgX2FuZ2xlW2ldLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShfYW5nbGVbaV0pO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhzaW5uZXJfcmFkaXVzW2ldLCAwKTtcbiAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgc2lubmVyX3JhZGl1c1tpXSwgMCwgLV9hbmdsZVtpXSwgIWRpcmVjdGlvbik7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHgucm90YXRlKC1fYW5nbGVbaV0gLSBfc3RhcnRfYW5nbGVbaV0pO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtc3hbaV0sIC1zeVtpXSk7XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudmlzdWFscy5saW5lLmRvaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEFubnVsYXJXZWRnZVZpZXcucHJvdG90eXBlLl9oaXRfcG9pbnQgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGFuZ2xlLCBiYm94LCBjYW5kaWRhdGVzLCBkaXJlY3Rpb24sIGRpc3QsIGhpdHMsIGksIGlyMiwgaiwgaywgbGVuLCBsZW4xLCBvcjIsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgc3gsIHN4MCwgc3gxLCBzeSwgc3kwLCBzeTEsIHZ4LCB2eDAsIHZ4MSwgdnksIHZ5MCwgdnkxLCB4LCB4MCwgeDEsIHksIHkwLCB5MTtcbiAgICAgICAgcmVmID0gW2dlb21ldHJ5LnZ4LCBnZW9tZXRyeS52eV0sIHZ4ID0gcmVmWzBdLCB2eSA9IHJlZlsxXTtcbiAgICAgICAgeCA9IHRoaXMucmVuZGVyZXIueHNjYWxlLmludmVydCh2eCwgdHJ1ZSk7XG4gICAgICAgIHkgPSB0aGlzLnJlbmRlcmVyLnlzY2FsZS5pbnZlcnQodnksIHRydWUpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLm91dGVyX3JhZGl1cy51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHgwID0geCAtIHRoaXMubWF4X291dGVyX3JhZGl1cztcbiAgICAgICAgICAgIHgxID0geCArIHRoaXMubWF4X291dGVyX3JhZGl1cztcbiAgICAgICAgICAgIHkwID0geSAtIHRoaXMubWF4X291dGVyX3JhZGl1cztcbiAgICAgICAgICAgIHkxID0geSArIHRoaXMubWF4X291dGVyX3JhZGl1cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZ4MCA9IHZ4IC0gdGhpcy5tYXhfb3V0ZXJfcmFkaXVzO1xuICAgICAgICAgICAgdngxID0gdnggKyB0aGlzLm1heF9vdXRlcl9yYWRpdXM7XG4gICAgICAgICAgICByZWYxID0gdGhpcy5yZW5kZXJlci54c2NhbGUudl9pbnZlcnQoW3Z4MCwgdngxXSwgdHJ1ZSksIHgwID0gcmVmMVswXSwgeDEgPSByZWYxWzFdO1xuICAgICAgICAgICAgdnkwID0gdnkgLSB0aGlzLm1heF9vdXRlcl9yYWRpdXM7XG4gICAgICAgICAgICB2eTEgPSB2eSArIHRoaXMubWF4X291dGVyX3JhZGl1cztcbiAgICAgICAgICAgIHJlZjIgPSB0aGlzLnJlbmRlcmVyLnlzY2FsZS52X2ludmVydChbdnkwLCB2eTFdLCB0cnVlKSwgeTAgPSByZWYyWzBdLCB5MSA9IHJlZjJbMV07XG4gICAgICAgIH1cbiAgICAgICAgY2FuZGlkYXRlcyA9IFtdO1xuICAgICAgICBiYm94ID0gaGl0dGVzdC52YWxpZGF0ZV9iYm94X2Nvb3JkcyhbeDAsIHgxXSwgW3kwLCB5MV0pO1xuICAgICAgICByZWYzID0gdGhpcy5pbmRleC5pbmRpY2VzKGJib3gpO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpID0gcmVmM1tqXTtcbiAgICAgICAgICAgIG9yMiA9IE1hdGgucG93KHRoaXMuc291dGVyX3JhZGl1c1tpXSwgMik7XG4gICAgICAgICAgICBpcjIgPSBNYXRoLnBvdyh0aGlzLnNpbm5lcl9yYWRpdXNbaV0sIDIpO1xuICAgICAgICAgICAgc3gwID0gdGhpcy5yZW5kZXJlci54c2NhbGUuY29tcHV0ZSh4LCB0cnVlKTtcbiAgICAgICAgICAgIHN4MSA9IHRoaXMucmVuZGVyZXIueHNjYWxlLmNvbXB1dGUodGhpcy5feFtpXSwgdHJ1ZSk7XG4gICAgICAgICAgICBzeTAgPSB0aGlzLnJlbmRlcmVyLnlzY2FsZS5jb21wdXRlKHksIHRydWUpO1xuICAgICAgICAgICAgc3kxID0gdGhpcy5yZW5kZXJlci55c2NhbGUuY29tcHV0ZSh0aGlzLl95W2ldLCB0cnVlKTtcbiAgICAgICAgICAgIGRpc3QgPSBNYXRoLnBvdyhzeDAgLSBzeDEsIDIpICsgTWF0aC5wb3coc3kwIC0gc3kxLCAyKTtcbiAgICAgICAgICAgIGlmIChkaXN0IDw9IG9yMiAmJiBkaXN0ID49IGlyMikge1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaChbaSwgZGlzdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRpcmVjdGlvbiA9IHRoaXMubW9kZWwucHJvcGVydGllcy5kaXJlY3Rpb24udmFsdWUoKTtcbiAgICAgICAgaGl0cyA9IFtdO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4xID0gY2FuZGlkYXRlcy5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgICAgIHJlZjQgPSBjYW5kaWRhdGVzW2tdLCBpID0gcmVmNFswXSwgZGlzdCA9IHJlZjRbMV07XG4gICAgICAgICAgICBzeCA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52eF90b19zeCh2eCk7XG4gICAgICAgICAgICBzeSA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52eV90b19zeSh2eSk7XG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoc3kgLSB0aGlzLnN5W2ldLCBzeCAtIHRoaXMuc3hbaV0pO1xuICAgICAgICAgICAgaWYgKG1hdGhfMS5hbmdsZV9iZXR3ZWVuKC1hbmdsZSwgLXRoaXMuX3N0YXJ0X2FuZ2xlW2ldLCAtdGhpcy5fZW5kX2FuZ2xlW2ldLCBkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgaGl0cy5wdXNoKFtpLCBkaXN0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpdHRlc3QuY3JlYXRlXzFkX2hpdF90ZXN0X3Jlc3VsdChoaXRzKTtcbiAgICB9O1xuICAgIEFubnVsYXJXZWRnZVZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kX2Zvcl9pbmRleCA9IGZ1bmN0aW9uIChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJpY19hcmVhX2xlZ2VuZChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCk7XG4gICAgfTtcbiAgICBBbm51bGFyV2VkZ2VWaWV3LnByb3RvdHlwZS5fc2N4eSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBhLCByO1xuICAgICAgICByID0gKHRoaXMuc2lubmVyX3JhZGl1c1tpXSArIHRoaXMuc291dGVyX3JhZGl1c1tpXSkgLyAyO1xuICAgICAgICBhID0gKHRoaXMuX3N0YXJ0X2FuZ2xlW2ldICsgdGhpcy5fZW5kX2FuZ2xlW2ldKSAvIDI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB0aGlzLnN4W2ldICsgciAqIE1hdGguY29zKGEpLFxuICAgICAgICAgICAgeTogdGhpcy5zeVtpXSArIHIgKiBNYXRoLnNpbihhKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQW5udWxhcldlZGdlVmlldy5wcm90b3R5cGUuc2N4ID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjeHkoaSkueDtcbiAgICB9O1xuICAgIEFubnVsYXJXZWRnZVZpZXcucHJvdG90eXBlLnNjeSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3h5KGkpLnk7XG4gICAgfTtcbiAgICByZXR1cm4gQW5udWxhcldlZGdlVmlldztcbn0pKHh5X2dseXBoXzEuWFlHbHlwaFZpZXcpO1xuZXhwb3J0cy5Bbm51bGFyV2VkZ2UgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQW5udWxhcldlZGdlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBbm51bGFyV2VkZ2UoKSB7XG4gICAgICAgIHJldHVybiBBbm51bGFyV2VkZ2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFubnVsYXJXZWRnZS5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5Bbm51bGFyV2VkZ2VWaWV3O1xuICAgIEFubnVsYXJXZWRnZS5wcm90b3R5cGUudHlwZSA9ICdBbm51bGFyV2VkZ2UnO1xuICAgIEFubnVsYXJXZWRnZS5taXhpbnMoWydsaW5lJywgJ2ZpbGwnXSk7XG4gICAgQW5udWxhcldlZGdlLmRlZmluZSh7XG4gICAgICAgIGRpcmVjdGlvbjogW3AuRGlyZWN0aW9uLCAnYW50aWNsb2NrJ10sXG4gICAgICAgIGlubmVyX3JhZGl1czogW3AuRGlzdGFuY2VTcGVjXSxcbiAgICAgICAgb3V0ZXJfcmFkaXVzOiBbcC5EaXN0YW5jZVNwZWNdLFxuICAgICAgICBzdGFydF9hbmdsZTogW3AuQW5nbGVTcGVjXSxcbiAgICAgICAgZW5kX2FuZ2xlOiBbcC5BbmdsZVNwZWNdXG4gICAgfSk7XG4gICAgcmV0dXJuIEFubnVsYXJXZWRnZTtcbn0pKHh5X2dseXBoXzEuWFlHbHlwaCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgeHlfZ2x5cGhfMSA9IHJlcXVpcmUoXCIuL3h5X2dseXBoXCIpO1xudmFyIGhpdHRlc3QgPSByZXF1aXJlKFwiY29yZS9oaXR0ZXN0XCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5Bbm51bHVzVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBbm51bHVzVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQW5udWx1c1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiBBbm51bHVzVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQW5udWx1c1ZpZXcucHJvdG90eXBlLl9tYXBfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy5pbm5lcl9yYWRpdXMudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICB0aGlzLnNpbm5lcl9yYWRpdXMgPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXIueHNjYWxlLCB0aGlzLl94LCB0aGlzLl9pbm5lcl9yYWRpdXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaW5uZXJfcmFkaXVzID0gdGhpcy5faW5uZXJfcmFkaXVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnByb3BlcnRpZXMub3V0ZXJfcmFkaXVzLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291dGVyX3JhZGl1cyA9IHRoaXMuc2Rpc3QodGhpcy5yZW5kZXJlci54c2NhbGUsIHRoaXMuX3gsIHRoaXMuX291dGVyX3JhZGl1cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3V0ZXJfcmFkaXVzID0gdGhpcy5fb3V0ZXJfcmFkaXVzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm51bHVzVmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZykge1xuICAgICAgICB2YXIgY2xvY2t3aXNlLCBpLCBpc2llLCBqLCBrLCBsZW4sIGxlbjEsIHJlZiwgcmVzdWx0cywgc2lubmVyX3JhZGl1cywgc291dGVyX3JhZGl1cywgc3gsIHN5O1xuICAgICAgICBzeCA9IGFyZy5zeCwgc3kgPSBhcmcuc3ksIHNpbm5lcl9yYWRpdXMgPSBhcmcuc2lubmVyX3JhZGl1cywgc291dGVyX3JhZGl1cyA9IGFyZy5zb3V0ZXJfcmFkaXVzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGkgPSBpbmRpY2VzW2pdO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHN4W2ldICsgc3lbaV0gKyBzaW5uZXJfcmFkaXVzW2ldICsgc291dGVyX3JhZGl1c1tpXSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzaWUgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSA+PSAwIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpID4gMCB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzaWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmID0gW2ZhbHNlLCB0cnVlXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuMSA9IHJlZi5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb2Nrd2lzZSA9IHJlZltrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoc3hbaV0sIHN5W2ldLCBzaW5uZXJfcmFkaXVzW2ldLCAwLCBNYXRoLlBJLCBjbG9ja3dpc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhzeFtpXSwgc3lbaV0sIHNvdXRlcl9yYWRpdXNbaV0sIE1hdGguUEksIDAsICFjbG9ja3dpc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguYXJjKHN4W2ldLCBzeVtpXSwgc2lubmVyX3JhZGl1c1tpXSwgMCwgMiAqIE1hdGguUEksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBjdHguYXJjKHN4W2ldLCBzeVtpXSwgc291dGVyX3JhZGl1c1tpXSwgMiAqIE1hdGguUEksIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHN4W2ldLCBzeVtpXSwgc2lubmVyX3JhZGl1c1tpXSwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3hbaV0gKyBzb3V0ZXJfcmFkaXVzW2ldLCBzeVtpXSk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhzeFtpXSwgc3lbaV0sIHNvdXRlcl9yYWRpdXNbaV0sIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnN0cm9rZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgQW5udWx1c1ZpZXcucHJvdG90eXBlLl9oaXRfcG9pbnQgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGJib3gsIGRpc3QsIGhpdHMsIGksIGlyMiwgaiwgbGVuLCBvcjIsIHJlZiwgcmVmMSwgc3gwLCBzeDEsIHN5MCwgc3kxLCB2eCwgdnksIHgsIHgwLCB4MSwgeSwgeTAsIHkxO1xuICAgICAgICByZWYgPSBbZ2VvbWV0cnkudngsIGdlb21ldHJ5LnZ5XSwgdnggPSByZWZbMF0sIHZ5ID0gcmVmWzFdO1xuICAgICAgICB4ID0gdGhpcy5yZW5kZXJlci54c2NhbGUuaW52ZXJ0KHZ4LCB0cnVlKTtcbiAgICAgICAgeDAgPSB4IC0gdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICB4MSA9IHggKyB0aGlzLm1heF9yYWRpdXM7XG4gICAgICAgIHkgPSB0aGlzLnJlbmRlcmVyLnlzY2FsZS5pbnZlcnQodnksIHRydWUpO1xuICAgICAgICB5MCA9IHkgLSB0aGlzLm1heF9yYWRpdXM7XG4gICAgICAgIHkxID0geSArIHRoaXMubWF4X3JhZGl1cztcbiAgICAgICAgaGl0cyA9IFtdO1xuICAgICAgICBiYm94ID0gaGl0dGVzdC52YWxpZGF0ZV9iYm94X2Nvb3JkcyhbeDAsIHgxXSwgW3kwLCB5MV0pO1xuICAgICAgICByZWYxID0gdGhpcy5pbmRleC5pbmRpY2VzKGJib3gpO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpID0gcmVmMVtqXTtcbiAgICAgICAgICAgIG9yMiA9IE1hdGgucG93KHRoaXMuc291dGVyX3JhZGl1c1tpXSwgMik7XG4gICAgICAgICAgICBpcjIgPSBNYXRoLnBvdyh0aGlzLnNpbm5lcl9yYWRpdXNbaV0sIDIpO1xuICAgICAgICAgICAgc3gwID0gdGhpcy5yZW5kZXJlci54c2NhbGUuY29tcHV0ZSh4KTtcbiAgICAgICAgICAgIHN4MSA9IHRoaXMucmVuZGVyZXIueHNjYWxlLmNvbXB1dGUodGhpcy5feFtpXSk7XG4gICAgICAgICAgICBzeTAgPSB0aGlzLnJlbmRlcmVyLnlzY2FsZS5jb21wdXRlKHkpO1xuICAgICAgICAgICAgc3kxID0gdGhpcy5yZW5kZXJlci55c2NhbGUuY29tcHV0ZSh0aGlzLl95W2ldKTtcbiAgICAgICAgICAgIGRpc3QgPSBNYXRoLnBvdyhzeDAgLSBzeDEsIDIpICsgTWF0aC5wb3coc3kwIC0gc3kxLCAyKTtcbiAgICAgICAgICAgIGlmIChkaXN0IDw9IG9yMiAmJiBkaXN0ID49IGlyMikge1xuICAgICAgICAgICAgICAgIGhpdHMucHVzaChbaSwgZGlzdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaXR0ZXN0LmNyZWF0ZV8xZF9oaXRfdGVzdF9yZXN1bHQoaGl0cyk7XG4gICAgfTtcbiAgICBBbm51bHVzVmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmRfZm9yX2luZGV4ID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIHZhciBkYXRhLCBpbmRpY2VzLCByLCBzaW5uZXJfcmFkaXVzLCBzb3V0ZXJfcmFkaXVzLCBzeCwgc3k7XG4gICAgICAgIGluZGljZXMgPSBbaW5kZXhdO1xuICAgICAgICBzeCA9IHt9O1xuICAgICAgICBzeFtpbmRleF0gPSAoeDAgKyB4MSkgLyAyO1xuICAgICAgICBzeSA9IHt9O1xuICAgICAgICBzeVtpbmRleF0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgICByID0gTWF0aC5taW4oTWF0aC5hYnMoeDEgLSB4MCksIE1hdGguYWJzKHkxIC0geTApKSAqIDAuNTtcbiAgICAgICAgc2lubmVyX3JhZGl1cyA9IHt9O1xuICAgICAgICBzaW5uZXJfcmFkaXVzW2luZGV4XSA9IHIgKiAwLjQ7XG4gICAgICAgIHNvdXRlcl9yYWRpdXMgPSB7fTtcbiAgICAgICAgc291dGVyX3JhZGl1c1tpbmRleF0gPSByICogMC44O1xuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgc3g6IHN4LFxuICAgICAgICAgICAgc3k6IHN5LFxuICAgICAgICAgICAgc2lubmVyX3JhZGl1czogc2lubmVyX3JhZGl1cyxcbiAgICAgICAgICAgIHNvdXRlcl9yYWRpdXM6IHNvdXRlcl9yYWRpdXNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcihjdHgsIGluZGljZXMsIGRhdGEpO1xuICAgIH07XG4gICAgcmV0dXJuIEFubnVsdXNWaWV3O1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoVmlldyk7XG5leHBvcnRzLkFubnVsdXMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQW5udWx1cywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQW5udWx1cygpIHtcbiAgICAgICAgcmV0dXJuIEFubnVsdXMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFubnVsdXMucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuQW5udWx1c1ZpZXc7XG4gICAgQW5udWx1cy5wcm90b3R5cGUudHlwZSA9ICdBbm51bHVzJztcbiAgICBBbm51bHVzLm1peGlucyhbJ2xpbmUnLCAnZmlsbCddKTtcbiAgICBBbm51bHVzLmRlZmluZSh7XG4gICAgICAgIGlubmVyX3JhZGl1czogW3AuRGlzdGFuY2VTcGVjXSxcbiAgICAgICAgb3V0ZXJfcmFkaXVzOiBbcC5EaXN0YW5jZVNwZWNdXG4gICAgfSk7XG4gICAgcmV0dXJuIEFubnVsdXM7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHh5X2dseXBoXzEgPSByZXF1aXJlKFwiLi94eV9nbHlwaFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuQXJjVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBcmNWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBcmNWaWV3KCkge1xuICAgICAgICByZXR1cm4gQXJjVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQXJjVmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLnJhZGl1cy51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNyYWRpdXMgPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXIueHNjYWxlLCB0aGlzLl94LCB0aGlzLl9yYWRpdXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3JhZGl1cyA9IHRoaXMuX3JhZGl1cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXJjVmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZykge1xuICAgICAgICB2YXIgX2VuZF9hbmdsZSwgX3N0YXJ0X2FuZ2xlLCBkaXJlY3Rpb24sIGksIGosIGxlbiwgcmVzdWx0cywgc3JhZGl1cywgc3gsIHN5O1xuICAgICAgICBzeCA9IGFyZy5zeCwgc3kgPSBhcmcuc3ksIHNyYWRpdXMgPSBhcmcuc3JhZGl1cywgX3N0YXJ0X2FuZ2xlID0gYXJnLl9zdGFydF9hbmdsZSwgX2VuZF9hbmdsZSA9IGFyZy5fZW5kX2FuZ2xlO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gdGhpcy5tb2RlbC5wcm9wZXJ0aWVzLmRpcmVjdGlvbi52YWx1ZSgpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIGkgPSBpbmRpY2VzW2pdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihzeFtpXSArIHN5W2ldICsgc3JhZGl1c1tpXSArIF9zdGFydF9hbmdsZVtpXSArIF9lbmRfYW5nbGVbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhzeFtpXSwgc3lbaV0sIHNyYWRpdXNbaV0sIF9zdGFydF9hbmdsZVtpXSwgX2VuZF9hbmdsZVtpXSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXJjVmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmRfZm9yX2luZGV4ID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmljX2xpbmVfbGVnZW5kKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KTtcbiAgICB9O1xuICAgIHJldHVybiBBcmNWaWV3O1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoVmlldyk7XG5leHBvcnRzLkFyYyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBcmMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFyYygpIHtcbiAgICAgICAgcmV0dXJuIEFyYy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQXJjLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkFyY1ZpZXc7XG4gICAgQXJjLnByb3RvdHlwZS50eXBlID0gJ0FyYyc7XG4gICAgQXJjLm1peGlucyhbJ2xpbmUnXSk7XG4gICAgQXJjLmRlZmluZSh7XG4gICAgICAgIGRpcmVjdGlvbjogW3AuRGlyZWN0aW9uLCAnYW50aWNsb2NrJ10sXG4gICAgICAgIHJhZGl1czogW3AuRGlzdGFuY2VTcGVjXSxcbiAgICAgICAgc3RhcnRfYW5nbGU6IFtwLkFuZ2xlU3BlY10sXG4gICAgICAgIGVuZF9hbmdsZTogW3AuQW5nbGVTcGVjXVxuICAgIH0pO1xuICAgIHJldHVybiBBcmM7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX2NiYiwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHNwYXRpYWxfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvc3BhdGlhbFwiKTtcbnZhciBnbHlwaF8xID0gcmVxdWlyZShcIi4vZ2x5cGhcIik7XG5fY2JiID0gZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHZhciBhLCBiLCBiMmFjLCBib3VuZHMsIGMsIGksIGosIGpsZW4sIGssIG10LCBzcXJ0YjJhYywgdCwgdDEsIHQyLCB0dmFsdWVzLCB4LCB5O1xuICAgIHR2YWx1ZXMgPSBbXTtcbiAgICBib3VuZHMgPSBbW10sIFtdXTtcbiAgICBmb3IgKGkgPSBrID0gMDsgayA8PSAyOyBpID0gKytrKSB7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBiID0gNiAqIHgwIC0gMTIgKiB4MSArIDYgKiB4MjtcbiAgICAgICAgICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgICAgICAgICAgYyA9IDMgKiB4MSAtIDMgKiB4MDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGIgPSA2ICogeTAgLSAxMiAqIHkxICsgNiAqIHkyO1xuICAgICAgICAgICAgYSA9IC0zICogeTAgKyA5ICogeTEgLSA5ICogeTIgKyAzICogeTM7XG4gICAgICAgICAgICBjID0gMyAqIHkxIC0gMyAqIHkwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNYXRoLmFicyhhKSA8IDFlLTEyKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoYikgPCAxZS0xMikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCA9IC1jIC8gYjtcbiAgICAgICAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICAgICAgICAgIHR2YWx1ZXMucHVzaCh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGIyYWMgPSBiICogYiAtIDQgKiBjICogYTtcbiAgICAgICAgc3FydGIyYWMgPSBNYXRoLnNxcnQoYjJhYyk7XG4gICAgICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICAgICAgdHZhbHVlcy5wdXNoKHQxKTtcbiAgICAgICAgfVxuICAgICAgICB0MiA9ICgtYiAtIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICAgICAgICB0dmFsdWVzLnB1c2godDIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGogPSB0dmFsdWVzLmxlbmd0aDtcbiAgICBqbGVuID0gajtcbiAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIHQgPSB0dmFsdWVzW2pdO1xuICAgICAgICBtdCA9IDEgLSB0O1xuICAgICAgICB4ID0gKG10ICogbXQgKiBtdCAqIHgwKSArICgzICogbXQgKiBtdCAqIHQgKiB4MSkgKyAoMyAqIG10ICogdCAqIHQgKiB4MikgKyAodCAqIHQgKiB0ICogeDMpO1xuICAgICAgICBib3VuZHNbMF1bal0gPSB4O1xuICAgICAgICB5ID0gKG10ICogbXQgKiBtdCAqIHkwKSArICgzICogbXQgKiBtdCAqIHQgKiB5MSkgKyAoMyAqIG10ICogdCAqIHQgKiB5MikgKyAodCAqIHQgKiB0ICogeTMpO1xuICAgICAgICBib3VuZHNbMV1bal0gPSB5O1xuICAgIH1cbiAgICBib3VuZHNbMF1bamxlbl0gPSB4MDtcbiAgICBib3VuZHNbMV1bamxlbl0gPSB5MDtcbiAgICBib3VuZHNbMF1bamxlbiArIDFdID0geDM7XG4gICAgYm91bmRzWzFdW2psZW4gKyAxXSA9IHkzO1xuICAgIHJldHVybiBbTWF0aC5taW4uYXBwbHkobnVsbCwgYm91bmRzWzBdKSwgTWF0aC5tYXguYXBwbHkobnVsbCwgYm91bmRzWzFdKSwgTWF0aC5tYXguYXBwbHkobnVsbCwgYm91bmRzWzBdKSwgTWF0aC5taW4uYXBwbHkobnVsbCwgYm91bmRzWzFdKV07XG59O1xuZXhwb3J0cy5CZXppZXJWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEJlemllclZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEJlemllclZpZXcoKSB7XG4gICAgICAgIHJldHVybiBCZXppZXJWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCZXppZXJWaWV3LnByb3RvdHlwZS5faW5kZXhfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGksIGssIHBvaW50cywgcmVmLCByZWYxLCB4MCwgeDEsIHkwLCB5MTtcbiAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYgPSB0aGlzLl94MC5sZW5ndGg7IDAgPD0gcmVmID8gayA8IHJlZiA6IGsgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMuX3gwW2ldICsgdGhpcy5feDFbaV0gKyB0aGlzLl95MFtpXSArIHRoaXMuX3kxW2ldICsgdGhpcy5fY3gwW2ldICsgdGhpcy5fY3kwW2ldICsgdGhpcy5fY3gxW2ldICsgdGhpcy5fY3kxW2ldKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmMSA9IF9jYmIodGhpcy5feDBbaV0sIHRoaXMuX3kwW2ldLCB0aGlzLl94MVtpXSwgdGhpcy5feTFbaV0sIHRoaXMuX2N4MFtpXSwgdGhpcy5fY3kwW2ldLCB0aGlzLl9jeDFbaV0sIHRoaXMuX2N5MVtpXSksIHgwID0gcmVmMVswXSwgeTAgPSByZWYxWzFdLCB4MSA9IHJlZjFbMl0sIHkxID0gcmVmMVszXTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtaW5YOiB4MCxcbiAgICAgICAgICAgICAgICBtaW5ZOiB5MCxcbiAgICAgICAgICAgICAgICBtYXhYOiB4MSxcbiAgICAgICAgICAgICAgICBtYXhZOiB5MSxcbiAgICAgICAgICAgICAgICBpOiBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHNwYXRpYWxfMS5SQnVzaChwb2ludHMpO1xuICAgIH07XG4gICAgQmV6aWVyVmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZykge1xuICAgICAgICB2YXIgaSwgaywgbGVuLCByZXN1bHRzLCBzY3gsIHNjeDAsIHNjeDEsIHNjeTAsIHNjeTEsIHN4MCwgc3gxLCBzeTAsIHN5MTtcbiAgICAgICAgc3gwID0gYXJnLnN4MCwgc3kwID0gYXJnLnN5MCwgc3gxID0gYXJnLnN4MSwgc3kxID0gYXJnLnN5MSwgc2N4ID0gYXJnLnNjeCwgc2N4MCA9IGFyZy5zY3gwLCBzY3kwID0gYXJnLnNjeTAsIHNjeDEgPSBhcmcuc2N4MSwgc2N5MSA9IGFyZy5zY3kxO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgICAgIGkgPSBpbmRpY2VzW2tdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihzeDBbaV0gKyBzeTBbaV0gKyBzeDFbaV0gKyBzeTFbaV0gKyBzY3gwW2ldICsgc2N5MFtpXSArIHNjeDFbaV0gKyBzY3kxW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3gwW2ldLCBzeTBbaV0pO1xuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHNjeDBbaV0sIHNjeTBbaV0sIHNjeDFbaV0sIHNjeTFbaV0sIHN4MVtpXSwgc3kxW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmV6aWVyVmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmRfZm9yX2luZGV4ID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmljX2xpbmVfbGVnZW5kKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KTtcbiAgICB9O1xuICAgIHJldHVybiBCZXppZXJWaWV3O1xufSkoZ2x5cGhfMS5HbHlwaFZpZXcpO1xuZXhwb3J0cy5CZXppZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQmV6aWVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBCZXppZXIoKSB7XG4gICAgICAgIHJldHVybiBCZXppZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJlemllci5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5CZXppZXJWaWV3O1xuICAgIEJlemllci5wcm90b3R5cGUudHlwZSA9ICdCZXppZXInO1xuICAgIEJlemllci5jb29yZHMoW1sneDAnLCAneTAnXSwgWyd4MScsICd5MSddLCBbJ2N4MCcsICdjeTAnXSwgWydjeDEnLCAnY3kxJ11dKTtcbiAgICBCZXppZXIubWl4aW5zKFsnbGluZSddKTtcbiAgICByZXR1cm4gQmV6aWVyO1xufSkoZ2x5cGhfMS5HbHlwaCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgeHlfZ2x5cGhfMSA9IHJlcXVpcmUoXCIuL3h5X2dseXBoXCIpO1xudmFyIGhpdHRlc3QgPSByZXF1aXJlKFwiY29yZS9oaXR0ZXN0XCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5DaXJjbGVWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENpcmNsZVZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENpcmNsZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBDaXJjbGVWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDaXJjbGVWaWV3LnByb3RvdHlwZS5fbWFwX2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZCwgcztcbiAgICAgICAgaWYgKHRoaXMuX3JhZGl1cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLnJhZGl1cy5zcGVjLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgICAgIHJkID0gdGhpcy5tb2RlbC5wcm9wZXJ0aWVzLnJhZGl1c19kaW1lbnNpb24uc3BlYy52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zcmFkaXVzID0gdGhpcy5zZGlzdCh0aGlzLnJlbmRlcmVyW3JkICsgXCJzY2FsZVwiXSwgdGhpc1tcIl9cIiArIHJkXSwgdGhpcy5fcmFkaXVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3JhZGl1cyA9IHRoaXMuX3JhZGl1cztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhfc2l6ZSA9IDIgKiB0aGlzLm1heF9yYWRpdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcmFkaXVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgbGVuLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVmID0gdGhpcy5fc2l6ZTtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSByZWZbal07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChzIC8gMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2lyY2xlVmlldy5wcm90b3R5cGUuX21hc2tfZGF0YSA9IGZ1bmN0aW9uIChhbGxfaW5kaWNlcykge1xuICAgICAgICB2YXIgYmJveCwgaHIsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgc3gwLCBzeDEsIHN5MCwgc3kxLCB2ciwgeDAsIHgxLCB5MCwgeTE7XG4gICAgICAgIGhyID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuZnJhbWUuaF9yYW5nZTtcbiAgICAgICAgdnIgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5mcmFtZS52X3JhbmdlO1xuICAgICAgICBpZiAoKHRoaXMuX3JhZGl1cyAhPSBudWxsKSAmJiB0aGlzLm1vZGVsLnByb3BlcnRpZXMucmFkaXVzLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgc3gwID0gaHIuc3RhcnQ7XG4gICAgICAgICAgICBzeDEgPSBoci5lbmQ7XG4gICAgICAgICAgICByZWYgPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS52X2ludmVydChbc3gwLCBzeDFdLCB0cnVlKSwgeDAgPSByZWZbMF0sIHgxID0gcmVmWzFdO1xuICAgICAgICAgICAgeDAgLT0gdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgeDEgKz0gdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgc3kwID0gdnIuc3RhcnQ7XG4gICAgICAgICAgICBzeTEgPSB2ci5lbmQ7XG4gICAgICAgICAgICByZWYxID0gdGhpcy5yZW5kZXJlci55c2NhbGUudl9pbnZlcnQoW3N5MCwgc3kxXSwgdHJ1ZSksIHkwID0gcmVmMVswXSwgeTEgPSByZWYxWzFdO1xuICAgICAgICAgICAgeTAgLT0gdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgeTEgKz0gdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3gwID0gaHIuc3RhcnQgLSB0aGlzLm1heF9zaXplO1xuICAgICAgICAgICAgc3gxID0gaHIuZW5kICsgdGhpcy5tYXhfc2l6ZTtcbiAgICAgICAgICAgIHJlZjIgPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS52X2ludmVydChbc3gwLCBzeDFdLCB0cnVlKSwgeDAgPSByZWYyWzBdLCB4MSA9IHJlZjJbMV07XG4gICAgICAgICAgICBzeTAgPSB2ci5zdGFydCAtIHRoaXMubWF4X3NpemU7XG4gICAgICAgICAgICBzeTEgPSB2ci5lbmQgKyB0aGlzLm1heF9zaXplO1xuICAgICAgICAgICAgcmVmMyA9IHRoaXMucmVuZGVyZXIueXNjYWxlLnZfaW52ZXJ0KFtzeTAsIHN5MV0sIHRydWUpLCB5MCA9IHJlZjNbMF0sIHkxID0gcmVmM1sxXTtcbiAgICAgICAgfVxuICAgICAgICBiYm94ID0gaGl0dGVzdC52YWxpZGF0ZV9iYm94X2Nvb3JkcyhbeDAsIHgxXSwgW3kwLCB5MV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleC5pbmRpY2VzKGJib3gpO1xuICAgIH07XG4gICAgQ2lyY2xlVmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZykge1xuICAgICAgICB2YXIgaSwgaiwgbGVuLCByZXN1bHRzLCBzcmFkaXVzLCBzeCwgc3k7XG4gICAgICAgIHN4ID0gYXJnLnN4LCBzeSA9IGFyZy5zeSwgc3JhZGl1cyA9IGFyZy5zcmFkaXVzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGkgPSBpbmRpY2VzW2pdO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHN4W2ldICsgc3lbaV0gKyBzcmFkaXVzW2ldKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyhzeFtpXSwgc3lbaV0sIHNyYWRpdXNbaV0sIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudmlzdWFscy5saW5lLmRvaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIENpcmNsZVZpZXcucHJvdG90eXBlLl9oaXRfcG9pbnQgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGJib3gsIGNhbmRpZGF0ZXMsIGRpc3QsIGhpdHMsIGksIGosIGssIGxlbiwgbGVuMSwgcjIsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgc3gsIHN4MCwgc3gxLCBzeSwgc3kwLCBzeTEsIHZ4LCB2eDAsIHZ4MSwgdnksIHZ5MCwgdnkxLCB4LCB4MCwgeDEsIHksIHkwLCB5MTtcbiAgICAgICAgcmVmID0gW2dlb21ldHJ5LnZ4LCBnZW9tZXRyeS52eV0sIHZ4ID0gcmVmWzBdLCB2eSA9IHJlZlsxXTtcbiAgICAgICAgeCA9IHRoaXMucmVuZGVyZXIueHNjYWxlLmludmVydCh2eCwgdHJ1ZSk7XG4gICAgICAgIHkgPSB0aGlzLnJlbmRlcmVyLnlzY2FsZS5pbnZlcnQodnksIHRydWUpO1xuICAgICAgICBpZiAoKHRoaXMuX3JhZGl1cyAhPSBudWxsKSAmJiB0aGlzLm1vZGVsLnByb3BlcnRpZXMucmFkaXVzLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgeDAgPSB4IC0gdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgeDEgPSB4ICsgdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgeTAgPSB5IC0gdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgeTEgPSB5ICsgdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdngwID0gdnggLSB0aGlzLm1heF9zaXplO1xuICAgICAgICAgICAgdngxID0gdnggKyB0aGlzLm1heF9zaXplO1xuICAgICAgICAgICAgcmVmMSA9IHRoaXMucmVuZGVyZXIueHNjYWxlLnZfaW52ZXJ0KFt2eDAsIHZ4MV0sIHRydWUpLCB4MCA9IHJlZjFbMF0sIHgxID0gcmVmMVsxXTtcbiAgICAgICAgICAgIHJlZjIgPSBbTWF0aC5taW4oeDAsIHgxKSwgTWF0aC5tYXgoeDAsIHgxKV0sIHgwID0gcmVmMlswXSwgeDEgPSByZWYyWzFdO1xuICAgICAgICAgICAgdnkwID0gdnkgLSB0aGlzLm1heF9zaXplO1xuICAgICAgICAgICAgdnkxID0gdnkgKyB0aGlzLm1heF9zaXplO1xuICAgICAgICAgICAgcmVmMyA9IHRoaXMucmVuZGVyZXIueXNjYWxlLnZfaW52ZXJ0KFt2eTAsIHZ5MV0sIHRydWUpLCB5MCA9IHJlZjNbMF0sIHkxID0gcmVmM1sxXTtcbiAgICAgICAgICAgIHJlZjQgPSBbTWF0aC5taW4oeTAsIHkxKSwgTWF0aC5tYXgoeTAsIHkxKV0sIHkwID0gcmVmNFswXSwgeTEgPSByZWY0WzFdO1xuICAgICAgICB9XG4gICAgICAgIGJib3ggPSBoaXR0ZXN0LnZhbGlkYXRlX2Jib3hfY29vcmRzKFt4MCwgeDFdLCBbeTAsIHkxXSk7XG4gICAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLmluZGV4LmluZGljZXMoYmJveCk7XG4gICAgICAgIGhpdHMgPSBbXTtcbiAgICAgICAgaWYgKCh0aGlzLl9yYWRpdXMgIT0gbnVsbCkgJiYgdGhpcy5tb2RlbC5wcm9wZXJ0aWVzLnJhZGl1cy51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGNhbmRpZGF0ZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpID0gY2FuZGlkYXRlc1tqXTtcbiAgICAgICAgICAgICAgICByMiA9IE1hdGgucG93KHRoaXMuc3JhZGl1c1tpXSwgMik7XG4gICAgICAgICAgICAgICAgc3gwID0gdGhpcy5yZW5kZXJlci54c2NhbGUuY29tcHV0ZSh4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzeDEgPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS5jb21wdXRlKHRoaXMuX3hbaV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIHN5MCA9IHRoaXMucmVuZGVyZXIueXNjYWxlLmNvbXB1dGUoeSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc3kxID0gdGhpcy5yZW5kZXJlci55c2NhbGUuY29tcHV0ZSh0aGlzLl95W2ldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5wb3coc3gwIC0gc3gxLCAyKSArIE1hdGgucG93KHN5MCAtIHN5MSwgMik7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPD0gcjIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGl0cy5wdXNoKFtpLCBkaXN0XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3ggPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudnhfdG9fc3godngpO1xuICAgICAgICAgICAgc3kgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudnlfdG9fc3kodnkpO1xuICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuMSA9IGNhbmRpZGF0ZXMubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICAgICAgICAgICAgaSA9IGNhbmRpZGF0ZXNba107XG4gICAgICAgICAgICAgICAgcjIgPSBNYXRoLnBvdyh0aGlzLnNyYWRpdXNbaV0sIDIpO1xuICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnBvdyh0aGlzLnN4W2ldIC0gc3gsIDIpICsgTWF0aC5wb3codGhpcy5zeVtpXSAtIHN5LCAyKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8PSByMikge1xuICAgICAgICAgICAgICAgICAgICBoaXRzLnB1c2goW2ksIGRpc3RdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpdHRlc3QuY3JlYXRlXzFkX2hpdF90ZXN0X3Jlc3VsdChoaXRzKTtcbiAgICB9O1xuICAgIENpcmNsZVZpZXcucHJvdG90eXBlLl9oaXRfc3BhbiA9IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICB2YXIgYmJveCwgaGl0cywgbWF4WCwgbWF4WSwgbWluWCwgbWluWSwgbXMsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVmNSwgcmVzdWx0LCB2eCwgdngwLCB2eDEsIHZ5LCB2eTAsIHZ5MSwgeDAsIHgxLCB5MCwgeTE7XG4gICAgICAgIHJlZiA9IFtnZW9tZXRyeS52eCwgZ2VvbWV0cnkudnldLCB2eCA9IHJlZlswXSwgdnkgPSByZWZbMV07XG4gICAgICAgIHJlZjEgPSB0aGlzLmJvdW5kcygpLCBtaW5YID0gcmVmMS5taW5YLCBtaW5ZID0gcmVmMS5taW5ZLCBtYXhYID0gcmVmMS5tYXhYLCBtYXhZID0gcmVmMS5tYXhZO1xuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgaWYgKGdlb21ldHJ5LmRpcmVjdGlvbiA9PT0gJ2gnKSB7XG4gICAgICAgICAgICB5MCA9IG1pblk7XG4gICAgICAgICAgICB5MSA9IG1heFk7XG4gICAgICAgICAgICBpZiAoKHRoaXMuX3JhZGl1cyAhPSBudWxsKSAmJiB0aGlzLm1vZGVsLnByb3BlcnRpZXMucmFkaXVzLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgICAgIHZ4MCA9IHZ4IC0gdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgICAgIHZ4MSA9IHZ4ICsgdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgICAgIHJlZjIgPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS52X2ludmVydChbdngwLCB2eDFdKSwgeDAgPSByZWYyWzBdLCB4MSA9IHJlZjJbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtcyA9IHRoaXMubWF4X3NpemUgLyAyO1xuICAgICAgICAgICAgICAgIHZ4MCA9IHZ4IC0gbXM7XG4gICAgICAgICAgICAgICAgdngxID0gdnggKyBtcztcbiAgICAgICAgICAgICAgICByZWYzID0gdGhpcy5yZW5kZXJlci54c2NhbGUudl9pbnZlcnQoW3Z4MCwgdngxXSwgdHJ1ZSksIHgwID0gcmVmM1swXSwgeDEgPSByZWYzWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeDAgPSBtaW5YO1xuICAgICAgICAgICAgeDEgPSBtYXhYO1xuICAgICAgICAgICAgaWYgKCh0aGlzLl9yYWRpdXMgIT0gbnVsbCkgJiYgdGhpcy5tb2RlbC5wcm9wZXJ0aWVzLnJhZGl1cy51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgICAgICB2eTAgPSB2eSAtIHRoaXMubWF4X3JhZGl1cztcbiAgICAgICAgICAgICAgICB2eTEgPSB2eSArIHRoaXMubWF4X3JhZGl1cztcbiAgICAgICAgICAgICAgICByZWY0ID0gdGhpcy5yZW5kZXJlci55c2NhbGUudl9pbnZlcnQoW3Z5MCwgdnkxXSksIHkwID0gcmVmNFswXSwgeTEgPSByZWY0WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbXMgPSB0aGlzLm1heF9zaXplIC8gMjtcbiAgICAgICAgICAgICAgICB2eTAgPSB2eSAtIG1zO1xuICAgICAgICAgICAgICAgIHZ5MSA9IHZ5ICsgbXM7XG4gICAgICAgICAgICAgICAgcmVmNSA9IHRoaXMucmVuZGVyZXIueXNjYWxlLnZfaW52ZXJ0KFt2eTAsIHZ5MV0sIHRydWUpLCB5MCA9IHJlZjVbMF0sIHkxID0gcmVmNVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBiYm94ID0gaGl0dGVzdC52YWxpZGF0ZV9iYm94X2Nvb3JkcyhbeDAsIHgxXSwgW3kwLCB5MV0pO1xuICAgICAgICBoaXRzID0gdGhpcy5pbmRleC5pbmRpY2VzKGJib3gpO1xuICAgICAgICByZXN1bHRbJzFkJ10uaW5kaWNlcyA9IGhpdHM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBDaXJjbGVWaWV3LnByb3RvdHlwZS5faGl0X3JlY3QgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGJib3gsIHJlZiwgcmVmMSwgcmVzdWx0LCB4MCwgeDEsIHkwLCB5MTtcbiAgICAgICAgcmVmID0gdGhpcy5yZW5kZXJlci54c2NhbGUudl9pbnZlcnQoW2dlb21ldHJ5LnZ4MCwgZ2VvbWV0cnkudngxXSwgdHJ1ZSksIHgwID0gcmVmWzBdLCB4MSA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IHRoaXMucmVuZGVyZXIueXNjYWxlLnZfaW52ZXJ0KFtnZW9tZXRyeS52eTAsIGdlb21ldHJ5LnZ5MV0sIHRydWUpLCB5MCA9IHJlZjFbMF0sIHkxID0gcmVmMVsxXTtcbiAgICAgICAgYmJveCA9IGhpdHRlc3QudmFsaWRhdGVfYmJveF9jb29yZHMoW3gwLCB4MV0sIFt5MCwgeTFdKTtcbiAgICAgICAgcmVzdWx0ID0gaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCk7XG4gICAgICAgIHJlc3VsdFsnMWQnXS5pbmRpY2VzID0gdGhpcy5pbmRleC5pbmRpY2VzKGJib3gpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQ2lyY2xlVmlldy5wcm90b3R5cGUuX2hpdF9wb2x5ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGVzLCBoaXRzLCBpLCBpZHgsIGosIGssIHJlZiwgcmVmMSwgcmVmMiwgcmVzdWx0LCByZXN1bHRzLCBzeCwgc3ksIHZ4LCB2eTtcbiAgICAgICAgcmVmID0gW2dlb21ldHJ5LnZ4LCBnZW9tZXRyeS52eV0sIHZ4ID0gcmVmWzBdLCB2eSA9IHJlZlsxXTtcbiAgICAgICAgc3ggPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudl92eF90b19zeCh2eCk7XG4gICAgICAgIHN5ID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzLnZfdnlfdG9fc3kodnkpO1xuICAgICAgICBjYW5kaWRhdGVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCByZWYxID0gdGhpcy5zeC5sZW5ndGg7IDAgPD0gcmVmMSA/IGogPCByZWYxIDogaiA+IHJlZjE7IDAgPD0gcmVmMSA/IGorKyA6IGotLSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5hcHBseSh0aGlzKTtcbiAgICAgICAgaGl0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmMiA9IGNhbmRpZGF0ZXMubGVuZ3RoOyAwIDw9IHJlZjIgPyBrIDwgcmVmMiA6IGsgPiByZWYyOyBpID0gMCA8PSByZWYyID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBpZHggPSBjYW5kaWRhdGVzW2ldO1xuICAgICAgICAgICAgaWYgKGhpdHRlc3QucG9pbnRfaW5fcG9seSh0aGlzLnN4W2ldLCB0aGlzLnN5W2ldLCBzeCwgc3kpKSB7XG4gICAgICAgICAgICAgICAgaGl0cy5wdXNoKGlkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCk7XG4gICAgICAgIHJlc3VsdFsnMWQnXS5pbmRpY2VzID0gaGl0cztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENpcmNsZVZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kX2Zvcl9pbmRleCA9IGZ1bmN0aW9uIChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCkge1xuICAgICAgICB2YXIgZGF0YSwgaW5kaWNlcywgc3JhZGl1cywgc3gsIHN5O1xuICAgICAgICBpbmRpY2VzID0gW2luZGV4XTtcbiAgICAgICAgc3ggPSB7fTtcbiAgICAgICAgc3hbaW5kZXhdID0gKHgwICsgeDEpIC8gMjtcbiAgICAgICAgc3kgPSB7fTtcbiAgICAgICAgc3lbaW5kZXhdID0gKHkwICsgeTEpIC8gMjtcbiAgICAgICAgc3JhZGl1cyA9IHt9O1xuICAgICAgICBzcmFkaXVzW2luZGV4XSA9IE1hdGgubWluKE1hdGguYWJzKHgxIC0geDApLCBNYXRoLmFicyh5MSAtIHkwKSkgKiAwLjI7XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICBzeDogc3gsXG4gICAgICAgICAgICBzeTogc3ksXG4gICAgICAgICAgICBzcmFkaXVzOiBzcmFkaXVzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXIoY3R4LCBpbmRpY2VzLCBkYXRhKTtcbiAgICB9O1xuICAgIHJldHVybiBDaXJjbGVWaWV3O1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoVmlldyk7XG5leHBvcnRzLkNpcmNsZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDaXJjbGUsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgICAgcmV0dXJuIENpcmNsZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2lyY2xlLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkNpcmNsZVZpZXc7XG4gICAgQ2lyY2xlLnByb3RvdHlwZS50eXBlID0gJ0NpcmNsZSc7XG4gICAgQ2lyY2xlLm1peGlucyhbJ2xpbmUnLCAnZmlsbCddKTtcbiAgICBDaXJjbGUuZGVmaW5lKHtcbiAgICAgICAgYW5nbGU6IFtwLkFuZ2xlU3BlYywgMF0sXG4gICAgICAgIHNpemU6IFtcbiAgICAgICAgICAgIHAuRGlzdGFuY2VTcGVjLCB7XG4gICAgICAgICAgICAgICAgdW5pdHM6IFwic2NyZWVuXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDRcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcmFkaXVzOiBbcC5EaXN0YW5jZVNwZWMsIG51bGxdLFxuICAgICAgICByYWRpdXNfZGltZW5zaW9uOiBbcC5TdHJpbmcsICd4J11cbiAgICB9KTtcbiAgICBDaXJjbGUucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgQ2lyY2xlLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnJhZGl1cy5vcHRpb25hbCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gQ2lyY2xlO1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB4eV9nbHlwaF8xID0gcmVxdWlyZShcIi4veHlfZ2x5cGhcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkVsbGlwc2VWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEVsbGlwc2VWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBFbGxpcHNlVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEVsbGlwc2VWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFbGxpcHNlVmlldy5wcm90b3R5cGUuX3NldF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1heF93MiA9IDA7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnByb3BlcnRpZXMud2lkdGgudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICB0aGlzLm1heF93MiA9IHRoaXMubWF4X3dpZHRoIC8gMjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1heF9oMiA9IDA7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnByb3BlcnRpZXMuaGVpZ2h0LnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4X2gyID0gdGhpcy5tYXhfaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWxsaXBzZVZpZXcucHJvdG90eXBlLl9tYXBfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy53aWR0aC51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc3cgPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXIueHNjYWxlLCB0aGlzLl94LCB0aGlzLl93aWR0aCwgJ2NlbnRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdyA9IHRoaXMuX3dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnByb3BlcnRpZXMuaGVpZ2h0LnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2ggPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXIueXNjYWxlLCB0aGlzLl95LCB0aGlzLl9oZWlnaHQsICdjZW50ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNoID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbGxpcHNlVmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZykge1xuICAgICAgICB2YXIgaSwgaiwgbGVuLCByZXN1bHRzLCBzaCwgc3csIHN4LCBzeTtcbiAgICAgICAgc3ggPSBhcmcuc3gsIHN5ID0gYXJnLnN5LCBzdyA9IGFyZy5zdywgc2ggPSBhcmcuc2g7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IGluZGljZXNbal07XG4gICAgICAgICAgICBpZiAoaXNOYU4oc3hbaV0gKyBzeVtpXSArIHN3W2ldICsgc2hbaV0gKyB0aGlzLl9hbmdsZVtpXSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5lbGxpcHNlKHN4W2ldLCBzeVtpXSwgc3dbaV0gLyAyLjAsIHNoW2ldIC8gMi4wLCB0aGlzLl9hbmdsZVtpXSwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgaWYgKHRoaXMudmlzdWFscy5maWxsLmRvaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMuZmlsbC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjdHguc3Ryb2tlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBFbGxpcHNlVmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmRfZm9yX2luZGV4ID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIHZhciBkLCBkYXRhLCBpbmRpY2VzLCBzY2FsZSwgc2gsIHN3LCBzeCwgc3k7XG4gICAgICAgIGluZGljZXMgPSBbaW5kZXhdO1xuICAgICAgICBzeCA9IHt9O1xuICAgICAgICBzeFtpbmRleF0gPSAoeDAgKyB4MSkgLyAyO1xuICAgICAgICBzeSA9IHt9O1xuICAgICAgICBzeVtpbmRleF0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgICBzY2FsZSA9IHRoaXMuc3dbaW5kZXhdIC8gdGhpcy5zaFtpbmRleF07XG4gICAgICAgIGQgPSBNYXRoLm1pbihNYXRoLmFicyh4MSAtIHgwKSwgTWF0aC5hYnMoeTEgLSB5MCkpICogMC44O1xuICAgICAgICBzdyA9IHt9O1xuICAgICAgICBzaCA9IHt9O1xuICAgICAgICBpZiAoc2NhbGUgPiAxKSB7XG4gICAgICAgICAgICBzd1tpbmRleF0gPSBkO1xuICAgICAgICAgICAgc2hbaW5kZXhdID0gZCAvIHNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dbaW5kZXhdID0gZCAqIHNjYWxlO1xuICAgICAgICAgICAgc2hbaW5kZXhdID0gZDtcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgc3g6IHN4LFxuICAgICAgICAgICAgc3k6IHN5LFxuICAgICAgICAgICAgc3c6IHN3LFxuICAgICAgICAgICAgc2g6IHNoXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXIoY3R4LCBpbmRpY2VzLCBkYXRhKTtcbiAgICB9O1xuICAgIEVsbGlwc2VWaWV3LnByb3RvdHlwZS5fYm91bmRzID0gZnVuY3Rpb24gKGJkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhfd2gyX2JvdW5kcyhiZHMpO1xuICAgIH07XG4gICAgcmV0dXJuIEVsbGlwc2VWaWV3O1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoVmlldyk7XG5leHBvcnRzLkVsbGlwc2UgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRWxsaXBzZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRWxsaXBzZSgpIHtcbiAgICAgICAgcmV0dXJuIEVsbGlwc2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEVsbGlwc2UucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuRWxsaXBzZVZpZXc7XG4gICAgRWxsaXBzZS5wcm90b3R5cGUudHlwZSA9ICdFbGxpcHNlJztcbiAgICBFbGxpcHNlLm1peGlucyhbJ2xpbmUnLCAnZmlsbCddKTtcbiAgICBFbGxpcHNlLmRlZmluZSh7XG4gICAgICAgIGFuZ2xlOiBbcC5BbmdsZVNwZWMsIDAuMF0sXG4gICAgICAgIHdpZHRoOiBbcC5EaXN0YW5jZVNwZWNdLFxuICAgICAgICBoZWlnaHQ6IFtwLkRpc3RhbmNlU3BlY11cbiAgICB9KTtcbiAgICByZXR1cm4gRWxsaXBzZTtcbn0pKHh5X2dseXBoXzEuWFlHbHlwaCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQxID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGJib3ggPSByZXF1aXJlKFwiY29yZS91dGlsL2Jib3hcIik7XG52YXIgcHJvaiA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvcHJvamVjdGlvbnNcIik7XG52YXIgdmlld18xID0gcmVxdWlyZShcImNvcmUvdmlld1wiKTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xudmFyIHZpc3VhbHNfMSA9IHJlcXVpcmUoXCJjb3JlL3Zpc3VhbHNcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvb2JqZWN0XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xuZXhwb3J0cy5HbHlwaFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKEdseXBoVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gR2x5cGhWaWV3KCkge1xuICAgICAgICByZXR1cm4gR2x5cGhWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHbHlwaFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgQ2xzLCBjdHgsIGUsIGdsZ2x5cGhzO1xuICAgICAgICBHbHlwaFZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbm9oaXRfd2FybmVkID0ge307XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBvcHRpb25zLnJlbmRlcmVyO1xuICAgICAgICB0aGlzLnZpc3VhbHMgPSBuZXcgdmlzdWFsc18xLlZpc3VhbHModGhpcy5tb2RlbCk7XG4gICAgICAgIGN0eCA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgaWYgKGN0eC5nbGNhbnZhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGdsZ2x5cGhzID0gcmVxdWlyZShcIm1vZGVscy9nbHlwaHMvd2ViZ2wvaW5kZXhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gJ01PRFVMRV9OT1RfRk9VTkQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIud2FybignV2ViR0wgd2FzIHJlcXVlc3RlZCBhbmQgaXMgc3VwcG9ydGVkLCBidXQgYm9rZWgtZ2woLm1pbikuanMgaXMgbm90IGF2YWlsYWJsZSwgZmFsbGluZyBiYWNrIHRvIDJEIHJlbmRlcmluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgZ2xnbHlwaHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2xnbHlwaHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIENscyA9IGdsZ2x5cGhzW3RoaXMubW9kZWwudHlwZSArICdHTEdseXBoJ107XG4gICAgICAgICAgICAgICAgaWYgKENscyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdsZ2x5cGggPSBuZXcgQ2xzKGN0eC5nbGNhbnZhcy5nbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBHbHlwaFZpZXcucHJvdG90eXBlLnNldF92aXN1YWxzID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICB0aGlzLnZpc3VhbHMud2FybV9jYWNoZShzb3VyY2UpO1xuICAgICAgICBpZiAodGhpcy5nbGdseXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsZ2x5cGguc2V0X3Zpc3VhbHNfY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHbHlwaFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGRhdGEpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZiAodGhpcy5nbGdseXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdsZ2x5cGgucmVuZGVyKGN0eCwgaW5kaWNlcywgZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcihjdHgsIGluZGljZXMsIGRhdGEpO1xuICAgIH07XG4gICAgR2x5cGhWaWV3LnByb3RvdHlwZS5oYXNfZmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgR2x5cGhWaWV3LnByb3RvdHlwZS5ub3RpZnlfZmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLm5vdGlmeV9maW5pc2hlZCgpO1xuICAgIH07XG4gICAgR2x5cGhWaWV3LnByb3RvdHlwZS5ib3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiYm94LmVtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzKHRoaXMuaW5kZXguYmJveCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUubG9nX2JvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJiLCBqLCBrLCBsZW4sIGxlbjEsIHBvc2l0aXZlX3hfYmJzLCBwb3NpdGl2ZV95X2JicywgeCwgeTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJib3guZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICBiYiA9IGJib3guZW1wdHkoKTtcbiAgICAgICAgcG9zaXRpdmVfeF9iYnMgPSB0aGlzLmluZGV4LnNlYXJjaChiYm94LnBvc2l0aXZlX3goKSk7XG4gICAgICAgIHBvc2l0aXZlX3lfYmJzID0gdGhpcy5pbmRleC5zZWFyY2goYmJveC5wb3NpdGl2ZV95KCkpO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBwb3NpdGl2ZV94X2Jicy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgeCA9IHBvc2l0aXZlX3hfYmJzW2pdO1xuICAgICAgICAgICAgaWYgKHgubWluWCA8IGJiLm1pblgpIHtcbiAgICAgICAgICAgICAgICBiYi5taW5YID0geC5taW5YO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHgubWF4WCA+IGJiLm1heFgpIHtcbiAgICAgICAgICAgICAgICBiYi5tYXhYID0geC5tYXhYO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoayA9IDAsIGxlbjEgPSBwb3NpdGl2ZV95X2Jicy5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgICAgIHkgPSBwb3NpdGl2ZV95X2Jic1trXTtcbiAgICAgICAgICAgIGlmICh5Lm1pblkgPCBiYi5taW5ZKSB7XG4gICAgICAgICAgICAgICAgYmIubWluWSA9IHkubWluWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5Lm1heFkgPiBiYi5tYXhZKSB7XG4gICAgICAgICAgICAgICAgYmIubWF4WSA9IHkubWF4WTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzKGJiKTtcbiAgICB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUubWF4X3doMl9ib3VuZHMgPSBmdW5jdGlvbiAoYmRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW5YOiBiZHMubWluWCAtIHRoaXMubWF4X3cyLFxuICAgICAgICAgICAgbWF4WDogYmRzLm1heFggKyB0aGlzLm1heF93MixcbiAgICAgICAgICAgIG1pblk6IGJkcy5taW5ZIC0gdGhpcy5tYXhfaDIsXG4gICAgICAgICAgICBtYXhZOiBiZHMubWF4WSArIHRoaXMubWF4X2gyXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBHbHlwaFZpZXcucHJvdG90eXBlLmdldF9hbmNob3JfcG9pbnQgPSBmdW5jdGlvbiAoYW5jaG9yLCBpLCBhcmcpIHtcbiAgICAgICAgdmFyIHN4LCBzeTtcbiAgICAgICAgc3ggPSBhcmdbMF0sIHN5ID0gYXJnWzFdO1xuICAgICAgICBzd2l0Y2ggKGFuY2hvcikge1xuICAgICAgICAgICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHRoaXMuc2N4KGksIHN4LCBzeSksXG4gICAgICAgICAgICAgICAgICAgIHk6IHRoaXMuc2N5KGksIHN4LCBzeSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR2x5cGhWaWV3LnByb3RvdHlwZS5zY3ggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zeFtpXTtcbiAgICB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUuc2N5ID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3lbaV07XG4gICAgfTtcbiAgICBHbHlwaFZpZXcucHJvdG90eXBlLnNkaXN0ID0gZnVuY3Rpb24gKHNjYWxlLCBwdHMsIHNwYW5zLCBwdHNfbG9jYXRpb24sIGRpbGF0ZSkge1xuICAgICAgICB2YXIgZCwgaGFsZnNwYW4sIGksIHB0MCwgcHQxLCBzcHQwLCBzcHQxO1xuICAgICAgICBpZiAocHRzX2xvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHB0c19sb2NhdGlvbiA9IFwiZWRnZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWxhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGlsYXRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVzXzEuaXNTdHJpbmcocHRzWzBdKSkge1xuICAgICAgICAgICAgcHRzID0gc2NhbGUudl9jb21wdXRlKHB0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHB0c19sb2NhdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIGhhbGZzcGFuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBzcGFucy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBkID0gc3BhbnNbal07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChkIC8gMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHB0MCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHB0cy5sZW5ndGg7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocHRzW2ldIC0gaGFsZnNwYW5baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBwdDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBwdHMubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHB0c1tpXSArIGhhbGZzcGFuW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHQwID0gcHRzO1xuICAgICAgICAgICAgcHQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gcHQwLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChwdDBbaV0gKyBzcGFuc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICBzcHQwID0gc2NhbGUudl9jb21wdXRlKHB0MCk7XG4gICAgICAgIHNwdDEgPSBzY2FsZS52X2NvbXB1dGUocHQxKTtcbiAgICAgICAgaWYgKGRpbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHNwdDAubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKE1hdGguY2VpbChNYXRoLmFicyhzcHQxW2ldIC0gc3B0MFtpXSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHNwdDAubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKE1hdGguYWJzKHNwdDFbaV0gLSBzcHQwW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR2x5cGhWaWV3LnByb3RvdHlwZS5kcmF3X2xlZ2VuZF9mb3JfaW5kZXggPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBHbHlwaFZpZXcucHJvdG90eXBlLl9nZW5lcmljX2xpbmVfbGVnZW5kID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh4MCwgKHkwICsgeTEpIC8gMik7XG4gICAgICAgIGN0eC5saW5lVG8oeDEsICh5MCArIHkxKSAvIDIpO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGluZGV4KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUuX2dlbmVyaWNfYXJlYV9sZWdlbmQgPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGRoLCBkdywgaCwgaW5kaWNlcywgc3gwLCBzeDEsIHN5MCwgc3kxLCB3O1xuICAgICAgICBpbmRpY2VzID0gW2luZGV4XTtcbiAgICAgICAgdyA9IE1hdGguYWJzKHgxIC0geDApO1xuICAgICAgICBkdyA9IHcgKiAwLjE7XG4gICAgICAgIGggPSBNYXRoLmFicyh5MSAtIHkwKTtcbiAgICAgICAgZGggPSBoICogMC4xO1xuICAgICAgICBzeDAgPSB4MCArIGR3O1xuICAgICAgICBzeDEgPSB4MSAtIGR3O1xuICAgICAgICBzeTAgPSB5MCArIGRoO1xuICAgICAgICBzeTEgPSB5MSAtIGRoO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGluZGV4KTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChzeDAsIHN5MCwgc3gxIC0gc3gwLCBzeTEgLSBzeTApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgucmVjdChzeDAsIHN5MCwgc3gxIC0gc3gwLCBzeTEgLSBzeTApO1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUuaGl0X3Rlc3QgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGZ1bmMsIHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgZnVuYyA9IFwiX2hpdF9cIiArIGdlb21ldHJ5LnR5cGU7XG4gICAgICAgIGlmICh0aGlzW2Z1bmNdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXNbZnVuY10oZ2VvbWV0cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX25vaGl0X3dhcm5lZFtnZW9tZXRyeS50eXBlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiJ1wiICsgZ2VvbWV0cnkudHlwZSArIFwiJyBzZWxlY3Rpb24gbm90IGF2YWlsYWJsZSBmb3IgXCIgKyB0aGlzLm1vZGVsLnR5cGUpO1xuICAgICAgICAgICAgdGhpcy5fbm9oaXRfd2FybmVkW2dlb21ldHJ5LnR5cGVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgR2x5cGhWaWV3LnByb3RvdHlwZS5zZXRfZGF0YSA9IGZ1bmN0aW9uIChzb3VyY2UsIGluZGljZXMpIHtcbiAgICAgICAgdmFyIGRhdGEsIHJlZiwgcmVmMTtcbiAgICAgICAgZGF0YSA9IHRoaXMubW9kZWwubWF0ZXJpYWxpemVfZGF0YXNwZWNzKHNvdXJjZSk7XG4gICAgICAgIG9iamVjdF8xLmV4dGVuZCh0aGlzLCBkYXRhKTtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIucGxvdF92aWV3Lm1vZGVsLnVzZV9tYXApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl94ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWYgPSBwcm9qLnByb2plY3RfeHkodGhpcy5feCwgdGhpcy5feSksIHRoaXMuX3ggPSByZWZbMF0sIHRoaXMuX3kgPSByZWZbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5feHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlZjEgPSBwcm9qLnByb2plY3RfeHN5cyh0aGlzLl94cywgdGhpcy5feXMpLCB0aGlzLl94cyA9IHJlZjFbMF0sIHRoaXMuX3lzID0gcmVmMVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nbGdseXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xnbHlwaC5zZXRfZGF0YV9jaGFuZ2VkKHRoaXMuX3gubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRfZGF0YShzb3VyY2UsIGluZGljZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA9IHRoaXMuX2luZGV4X2RhdGEoKTtcbiAgICB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUuX3NldF9kYXRhID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUuX2luZGV4X2RhdGEgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgR2x5cGhWaWV3LnByb3RvdHlwZS5tYXNrX2RhdGEgPSBmdW5jdGlvbiAoaW5kaWNlcykge1xuICAgICAgICBpZiAodGhpcy5nbGdseXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hc2tfZGF0YShpbmRpY2VzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR2x5cGhWaWV3LnByb3RvdHlwZS5fbWFza19kYXRhID0gZnVuY3Rpb24gKGluZGljZXMpIHtcbiAgICAgICAgcmV0dXJuIGluZGljZXM7XG4gICAgfTtcbiAgICBHbHlwaFZpZXcucHJvdG90eXBlLl9ib3VuZHMgPSBmdW5jdGlvbiAoYm91bmRzKSB7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfTtcbiAgICBHbHlwaFZpZXcucHJvdG90eXBlLm1hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgaiwgaywgbGVuLCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHJlZjUsIHJlZjYsIHJlZjcsIHJlZjgsIHN4LCBzeG5hbWUsIHN5LCBzeW5hbWUsIHhuYW1lLCB5bmFtZTtcbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5fY29vcmRzO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHJlZjEgPSByZWZbal0sIHhuYW1lID0gcmVmMVswXSwgeW5hbWUgPSByZWYxWzFdO1xuICAgICAgICAgICAgc3huYW1lID0gXCJzXCIgKyB4bmFtZTtcbiAgICAgICAgICAgIHN5bmFtZSA9IFwic1wiICsgeW5hbWU7XG4gICAgICAgICAgICB4bmFtZSA9IFwiX1wiICsgeG5hbWU7XG4gICAgICAgICAgICB5bmFtZSA9IFwiX1wiICsgeW5hbWU7XG4gICAgICAgICAgICBpZiAodHlwZXNfMS5pc0FycmF5KChyZWYyID0gdGhpc1t4bmFtZV0pICE9IG51bGwgPyByZWYyWzBdIDogdm9pZCAwKSB8fCAoKHJlZjMgPSB0aGlzW3huYW1lXSkgIT0gbnVsbCA/IChyZWY0ID0gcmVmM1swXSkgIT0gbnVsbCA/IHJlZjQuYnVmZmVyIDogdm9pZCAwIDogdm9pZCAwKSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmVmNSA9IFtbXSwgW11dLCB0aGlzW3N4bmFtZV0gPSByZWY1WzBdLCB0aGlzW3N5bmFtZV0gPSByZWY1WzFdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWY2ID0gdGhpc1t4bmFtZV0ubGVuZ3RoOyAwIDw9IHJlZjYgPyBrIDwgcmVmNiA6IGsgPiByZWY2OyBpID0gMCA8PSByZWY2ID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjcgPSB0aGlzLm1hcF90b19zY3JlZW4odGhpc1t4bmFtZV1baV0sIHRoaXNbeW5hbWVdW2ldKSwgc3ggPSByZWY3WzBdLCBzeSA9IHJlZjdbMV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbc3huYW1lXS5wdXNoKHN4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tzeW5hbWVdLnB1c2goc3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZjggPSB0aGlzLm1hcF90b19zY3JlZW4odGhpc1t4bmFtZV0sIHRoaXNbeW5hbWVdKSwgdGhpc1tzeG5hbWVdID0gcmVmOFswXSwgdGhpc1tzeW5hbWVdID0gcmVmOFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwX2RhdGEoKTtcbiAgICB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUubWFwX3RvX3NjcmVlbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5tYXBfdG9fc2NyZWVuKHgsIHksIHRoaXMubW9kZWwueF9yYW5nZV9uYW1lLCB0aGlzLm1vZGVsLnlfcmFuZ2VfbmFtZSk7XG4gICAgfTtcbiAgICByZXR1cm4gR2x5cGhWaWV3O1xufSkodmlld18xLlZpZXcpO1xuZXhwb3J0cy5HbHlwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoR2x5cGgsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEdseXBoKCkge1xuICAgICAgICByZXR1cm4gR2x5cGguX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdseXBoLnByb3RvdHlwZS5fY29vcmRzID0gW107XG4gICAgR2x5cGguY29vcmRzID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICB2YXIgX2Nvb3JkcywgaiwgbGVuLCByZWYsIHJlc3VsdCwgeCwgeTtcbiAgICAgICAgX2Nvb3JkcyA9IHRoaXMucHJvdG90eXBlLl9jb29yZHMuY29uY2F0KGNvb3Jkcyk7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9jb29yZHMgPSBfY29vcmRzO1xuICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByZWYgPSBjb29yZHNbal0sIHggPSByZWZbMF0sIHkgPSByZWZbMV07XG4gICAgICAgICAgICByZXN1bHRbeF0gPSBbcC5OdW1iZXJTcGVjXTtcbiAgICAgICAgICAgIHJlc3VsdFt5XSA9IFtwLk51bWJlclNwZWNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmluZShyZXN1bHQpO1xuICAgIH07XG4gICAgR2x5cGguaW50ZXJuYWwoe1xuICAgICAgICB4X3JhbmdlX25hbWU6IFtwLlN0cmluZywgJ2RlZmF1bHQnXSxcbiAgICAgICAgeV9yYW5nZV9uYW1lOiBbcC5TdHJpbmcsICdkZWZhdWx0J11cbiAgICB9KTtcbiAgICByZXR1cm4gR2x5cGg7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBzcGF0aWFsXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3NwYXRpYWxcIik7XG52YXIgZ2x5cGhfMSA9IHJlcXVpcmUoXCIuL2dseXBoXCIpO1xudmFyIGNhdGVnb3JpY2FsX3NjYWxlXzEgPSByZXF1aXJlKFwiLi4vc2NhbGVzL2NhdGVnb3JpY2FsX3NjYWxlXCIpO1xudmFyIGhpdHRlc3QgPSByZXF1aXJlKFwiY29yZS9oaXR0ZXN0XCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5IQmFyVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChIQmFyVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSEJhclZpZXcoKSB7XG4gICAgICAgIHJldHVybiBIQmFyVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgSEJhclZpZXcucHJvdG90eXBlLl9tYXBfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGksIGosIHJlZiwgdmxlZnQsIHZyaWdodCwgdnk7XG4gICAgICAgIHZ5ID0gdGhpcy5yZW5kZXJlci55c2NhbGUudl9jb21wdXRlKHRoaXMuX3kpO1xuICAgICAgICB0aGlzLnN5ID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzLnZfdnlfdG9fc3kodnkpO1xuICAgICAgICB2cmlnaHQgPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS52X2NvbXB1dGUodGhpcy5fcmlnaHQpO1xuICAgICAgICB2bGVmdCA9IHRoaXMucmVuZGVyZXIueHNjYWxlLnZfY29tcHV0ZSh0aGlzLl9sZWZ0KTtcbiAgICAgICAgdGhpcy5zcmlnaHQgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudl92eF90b19zeCh2cmlnaHQpO1xuICAgICAgICB0aGlzLnNsZWZ0ID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzLnZfdnhfdG9fc3godmxlZnQpO1xuICAgICAgICB0aGlzLnN0b3AgPSBbXTtcbiAgICAgICAgdGhpcy5zYm90dG9tID0gW107XG4gICAgICAgIHRoaXMuc2ggPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXIueXNjYWxlLCB0aGlzLl95LCB0aGlzLl9oZWlnaHQsICdjZW50ZXInKTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRoaXMuc3kubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcC5wdXNoKHRoaXMuc3lbaV0gLSB0aGlzLnNoW2ldIC8gMik7XG4gICAgICAgICAgICB0aGlzLnNib3R0b20ucHVzaCh0aGlzLnN5W2ldICsgdGhpcy5zaFtpXSAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgSEJhclZpZXcucHJvdG90eXBlLl9pbmRleF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiwgaGVpZ2h0LCBpLCBqLCBsLCBsZWZ0LCBtYXBfdG9fc3ludGhldGljLCBwb2ludHMsIHIsIHJlZiwgcmlnaHQsIHQsIHk7XG4gICAgICAgIG1hcF90b19zeW50aGV0aWMgPSBmdW5jdGlvbiAoc2NhbGUsIGFycmF5KSB7XG4gICAgICAgICAgICBpZiAoc2NhbGUgaW5zdGFuY2VvZiBjYXRlZ29yaWNhbF9zY2FsZV8xLkNhdGVnb3JpY2FsU2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGUudl9jb21wdXRlKGFycmF5LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGVmdCA9IG1hcF90b19zeW50aGV0aWModGhpcy5yZW5kZXJlci54c2NhbGUsIHRoaXMuX2xlZnQpO1xuICAgICAgICByaWdodCA9IG1hcF90b19zeW50aGV0aWModGhpcy5yZW5kZXJlci54c2NhbGUsIHRoaXMuX3JpZ2h0KTtcbiAgICAgICAgeSA9IG1hcF90b19zeW50aGV0aWModGhpcy5yZW5kZXJlci55c2NhbGUsIHRoaXMuX3kpO1xuICAgICAgICBoZWlnaHQgPSBtYXBfdG9fc3ludGhldGljKHRoaXMucmVuZGVyZXIueXNjYWxlLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHkubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIGwgPSBsZWZ0W2ldO1xuICAgICAgICAgICAgciA9IHJpZ2h0W2ldO1xuICAgICAgICAgICAgdCA9IHlbaV0gKyAwLjUgKiBoZWlnaHRbaV07XG4gICAgICAgICAgICBiID0geVtpXSAtIDAuNSAqIGhlaWdodFtpXTtcbiAgICAgICAgICAgIGlmIChpc05hTihsICsgciArIHQgKyBiKSB8fCAhaXNGaW5pdGUobCArIHIgKyB0ICsgYikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtaW5YOiBsLFxuICAgICAgICAgICAgICAgIG1pblk6IGIsXG4gICAgICAgICAgICAgICAgbWF4WDogcixcbiAgICAgICAgICAgICAgICBtYXhZOiB0LFxuICAgICAgICAgICAgICAgIGk6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgc3BhdGlhbF8xLlJCdXNoKHBvaW50cyk7XG4gICAgfTtcbiAgICBIQmFyVmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZykge1xuICAgICAgICB2YXIgaSwgaiwgbGVuLCByZXN1bHRzLCBzYm90dG9tLCBzbGVmdCwgc3JpZ2h0LCBzdG9wO1xuICAgICAgICBzbGVmdCA9IGFyZy5zbGVmdCwgc3JpZ2h0ID0gYXJnLnNyaWdodCwgc3RvcCA9IGFyZy5zdG9wLCBzYm90dG9tID0gYXJnLnNib3R0b207XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IGluZGljZXNbal07XG4gICAgICAgICAgICBpZiAoaXNOYU4oc2xlZnRbaV0gKyBzdG9wW2ldICsgc3JpZ2h0W2ldICsgc2JvdHRvbVtpXSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnZpc3VhbHMuZmlsbC5kb2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXN1YWxzLmZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChzbGVmdFtpXSwgc3RvcFtpXSwgc3JpZ2h0W2ldIC0gc2xlZnRbaV0sIHNib3R0b21baV0gLSBzdG9wW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZWN0KHNsZWZ0W2ldLCBzdG9wW2ldLCBzcmlnaHRbaV0gLSBzbGVmdFtpXSwgc2JvdHRvbVtpXSAtIHN0b3BbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnN0cm9rZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgSEJhclZpZXcucHJvdG90eXBlLl9oaXRfcG9pbnQgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGhpdHMsIHJlZiwgcmVzdWx0LCB2eCwgdnksIHgsIHk7XG4gICAgICAgIHJlZiA9IFtnZW9tZXRyeS52eCwgZ2VvbWV0cnkudnldLCB2eCA9IHJlZlswXSwgdnkgPSByZWZbMV07XG4gICAgICAgIHggPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS5pbnZlcnQodngsIHRydWUpO1xuICAgICAgICB5ID0gdGhpcy5yZW5kZXJlci55c2NhbGUuaW52ZXJ0KHZ5LCB0cnVlKTtcbiAgICAgICAgaGl0cyA9IHRoaXMuaW5kZXguaW5kaWNlcyh7XG4gICAgICAgICAgICBtaW5YOiB4LFxuICAgICAgICAgICAgbWluWTogeSxcbiAgICAgICAgICAgIG1heFg6IHgsXG4gICAgICAgICAgICBtYXhZOiB5XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgcmVzdWx0WycxZCddLmluZGljZXMgPSBoaXRzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgSEJhclZpZXcucHJvdG90eXBlLnNjeCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zbGVmdFtpXSArIHRoaXMuc3JpZ2h0W2ldKSAvIDI7XG4gICAgfTtcbiAgICBIQmFyVmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmRfZm9yX2luZGV4ID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmljX2FyZWFfbGVnZW5kKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KTtcbiAgICB9O1xuICAgIHJldHVybiBIQmFyVmlldztcbn0pKGdseXBoXzEuR2x5cGhWaWV3KTtcbmV4cG9ydHMuSEJhciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChIQmFyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBIQmFyKCkge1xuICAgICAgICByZXR1cm4gSEJhci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgSEJhci5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5IQmFyVmlldztcbiAgICBIQmFyLnByb3RvdHlwZS50eXBlID0gJ0hCYXInO1xuICAgIEhCYXIubWl4aW5zKFsnbGluZScsICdmaWxsJ10pO1xuICAgIEhCYXIuZGVmaW5lKHtcbiAgICAgICAgeTogW3AuTnVtYmVyU3BlY10sXG4gICAgICAgIGhlaWdodDogW3AuRGlzdGFuY2VTcGVjXSxcbiAgICAgICAgbGVmdDogW3AuTnVtYmVyU3BlYywgMF0sXG4gICAgICAgIHJpZ2h0OiBbcC5OdW1iZXJTcGVjXVxuICAgIH0pO1xuICAgIHJldHVybiBIQmFyO1xufSkoZ2x5cGhfMS5HbHlwaCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBHcmV5czksIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB4eV9nbHlwaF8xID0gcmVxdWlyZShcIi4veHlfZ2x5cGhcIik7XG52YXIgbGluZWFyX2NvbG9yX21hcHBlcl8xID0gcmVxdWlyZShcIi4uL21hcHBlcnMvbGluZWFyX2NvbG9yX21hcHBlclwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbmV4cG9ydHMuSW1hZ2VWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEltYWdlVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSW1hZ2VWaWV3KCkge1xuICAgICAgICByZXR1cm4gSW1hZ2VWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBJbWFnZVZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBJbWFnZVZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLmNvbG9yX21hcHBlci5jaGFuZ2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVfaW1hZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbWFnZVZpZXcucHJvdG90eXBlLl91cGRhdGVfaW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlX2RhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0X2RhdGEoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbWFnZVZpZXcucHJvdG90eXBlLl9zZXRfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1ZiwgYnVmOCwgY2FudmFzLCBjbWFwLCBjdHgsIGksIGltYWdlX2RhdGEsIGltZywgaiwgcmVmLCByZXN1bHRzLCBzaGFwZTtcbiAgICAgICAgaWYgKCh0aGlzLmltYWdlX2RhdGEgPT0gbnVsbCkgfHwgdGhpcy5pbWFnZV9kYXRhLmxlbmd0aCAhPT0gdGhpcy5faW1hZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlX2RhdGEgPSBuZXcgQXJyYXkodGhpcy5faW1hZ2UubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRoaXMuX3dpZHRoID09IG51bGwpIHx8IHRoaXMuX3dpZHRoLmxlbmd0aCAhPT0gdGhpcy5faW1hZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IG5ldyBBcnJheSh0aGlzLl9pbWFnZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5faGVpZ2h0ID09IG51bGwpIHx8IHRoaXMuX2hlaWdodC5sZW5ndGggIT09IHRoaXMuX2ltYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gbmV3IEFycmF5KHRoaXMuX2ltYWdlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdGhpcy5faW1hZ2UubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIHNoYXBlID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5faW1hZ2Vfc2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNoYXBlID0gdGhpcy5faW1hZ2Vfc2hhcGVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hhcGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGltZyA9IHRoaXMuX2ltYWdlW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlaWdodFtpXSA9IHNoYXBlWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoW2ldID0gc2hhcGVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbWcgPSBhcnJheV8xLmNvbmNhdCh0aGlzLl9pbWFnZVtpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVpZ2h0W2ldID0gdGhpcy5faW1hZ2VbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoW2ldID0gdGhpcy5faW1hZ2VbaV1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLmltYWdlX2RhdGFbaV0gIT0gbnVsbCkgJiYgdGhpcy5pbWFnZV9kYXRhW2ldLndpZHRoID09PSB0aGlzLl93aWR0aFtpXSAmJiB0aGlzLmltYWdlX2RhdGFbaV0uaGVpZ2h0ID09PSB0aGlzLl9oZWlnaHRbaV0pIHtcbiAgICAgICAgICAgICAgICBjYW52YXMgPSB0aGlzLmltYWdlX2RhdGFbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLl93aWR0aFtpXTtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBpbWFnZV9kYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLl93aWR0aFtpXSwgdGhpcy5faGVpZ2h0W2ldKTtcbiAgICAgICAgICAgIGNtYXAgPSB0aGlzLm1vZGVsLmNvbG9yX21hcHBlcjtcbiAgICAgICAgICAgIGJ1ZiA9IGNtYXAudl9tYXBfc2NyZWVuKGltZywgdHJ1ZSk7XG4gICAgICAgICAgICBidWY4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICAgICAgICAgIGltYWdlX2RhdGEuZGF0YS5zZXQoYnVmOCk7XG4gICAgICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlX2RhdGEsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5pbWFnZV9kYXRhW2ldID0gY2FudmFzO1xuICAgICAgICAgICAgdGhpcy5tYXhfZHcgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2R3LnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubWF4X2R3ID0gYXJyYXlfMS5tYXgodGhpcy5fZHcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXhfZGggPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RoLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLm1heF9kaCA9IGFycmF5XzEubWF4KHRoaXMuX2RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEltYWdlVmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwucHJvcGVydGllcy5kdy51bml0cykge1xuICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnN3ID0gdGhpcy5zZGlzdCh0aGlzLnJlbmRlcmVyLnhzY2FsZSwgdGhpcy5feCwgdGhpcy5fZHcsICdlZGdlJywgdGhpcy5tb2RlbC5kaWxhdGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNjcmVlblwiOlxuICAgICAgICAgICAgICAgIHRoaXMuc3cgPSB0aGlzLl9kdztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwucHJvcGVydGllcy5kaC51bml0cykge1xuICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaCA9IHRoaXMuc2Rpc3QodGhpcy5yZW5kZXJlci55c2NhbGUsIHRoaXMuX3ksIHRoaXMuX2RoLCAnZWRnZScsIHRoaXMubW9kZWwuZGlsYXRlKTtcbiAgICAgICAgICAgIGNhc2UgXCJzY3JlZW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaCA9IHRoaXMuX2RoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbWFnZVZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGltYWdlX2RhdGEsIGosIGxlbiwgb2xkX3Ntb290aGluZywgc2gsIHN3LCBzeCwgc3ksIHlfb2Zmc2V0O1xuICAgICAgICBpbWFnZV9kYXRhID0gYXJnLmltYWdlX2RhdGEsIHN4ID0gYXJnLnN4LCBzeSA9IGFyZy5zeSwgc3cgPSBhcmcuc3csIHNoID0gYXJnLnNoO1xuICAgICAgICBvbGRfc21vb3RoaW5nID0gY3R4LmdldEltYWdlU21vb3RoaW5nRW5hYmxlZCgpO1xuICAgICAgICBjdHguc2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IGluZGljZXNbal07XG4gICAgICAgICAgICBpZiAoaW1hZ2VfZGF0YVtpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOYU4oc3hbaV0gKyBzeVtpXSArIHN3W2ldICsgc2hbaV0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5X29mZnNldCA9IHN5W2ldO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCB5X29mZnNldCk7XG4gICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCAteV9vZmZzZXQpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZV9kYXRhW2ldLCBzeFtpXSB8IDAsIHN5W2ldIHwgMCwgc3dbaV0sIHNoW2ldKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgeV9vZmZzZXQpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgLXlfb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LnNldEltYWdlU21vb3RoaW5nRW5hYmxlZChvbGRfc21vb3RoaW5nKTtcbiAgICB9O1xuICAgIEltYWdlVmlldy5wcm90b3R5cGUuYm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmJveDtcbiAgICAgICAgYmJveCA9IHRoaXMuaW5kZXguYmJveDtcbiAgICAgICAgYmJveC5tYXhYICs9IHRoaXMubWF4X2R3O1xuICAgICAgICBiYm94Lm1heFkgKz0gdGhpcy5tYXhfZGg7XG4gICAgICAgIHJldHVybiBiYm94O1xuICAgIH07XG4gICAgcmV0dXJuIEltYWdlVmlldztcbn0pKHh5X2dseXBoXzEuWFlHbHlwaFZpZXcpO1xuR3JleXM5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbMHgwMDAwMDAsIDB4MjUyNTI1LCAweDUyNTI1MiwgMHg3MzczNzMsIDB4OTY5Njk2LCAweGJkYmRiZCwgMHhkOWQ5ZDksIDB4ZjBmMGYwLCAweGZmZmZmZl07XG59O1xuZXhwb3J0cy5JbWFnZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChJbWFnZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSW1hZ2UoKSB7XG4gICAgICAgIHJldHVybiBJbWFnZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgSW1hZ2UucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuSW1hZ2VWaWV3O1xuICAgIEltYWdlLnByb3RvdHlwZS50eXBlID0gJ0ltYWdlJztcbiAgICBJbWFnZS5kZWZpbmUoe1xuICAgICAgICBpbWFnZTogW3AuTnVtYmVyU3BlY10sXG4gICAgICAgIGR3OiBbcC5EaXN0YW5jZVNwZWNdLFxuICAgICAgICBkaDogW3AuRGlzdGFuY2VTcGVjXSxcbiAgICAgICAgZGlsYXRlOiBbcC5Cb29sLCBmYWxzZV0sXG4gICAgICAgIGNvbG9yX21hcHBlcjogW1xuICAgICAgICAgICAgcC5JbnN0YW5jZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbGluZWFyX2NvbG9yX21hcHBlcl8xLkxpbmVhckNvbG9yTWFwcGVyKHtcbiAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZTogR3JleXM5KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0pO1xuICAgIHJldHVybiBJbWFnZTtcbn0pKHh5X2dseXBoXzEuWFlHbHlwaCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgeHlfZ2x5cGhfMSA9IHJlcXVpcmUoXCIuL3h5X2dseXBoXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xuZXhwb3J0cy5JbWFnZVJHQkFWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEltYWdlUkdCQVZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEltYWdlUkdCQVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBJbWFnZVJHQkFWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBJbWFnZVJHQkFWaWV3LnByb3RvdHlwZS5fc2V0X2RhdGEgPSBmdW5jdGlvbiAoc291cmNlLCBpbmRpY2VzKSB7XG4gICAgICAgIHZhciBidWYsIGJ1ZjgsIGNhbnZhcywgY29sb3IsIGN0eCwgZmxhdCwgaSwgaW1hZ2VfZGF0YSwgaiwgaywgbCwgbSwgcmVmLCByZWYxLCByZWYyLCByZXN1bHRzLCBzaGFwZTtcbiAgICAgICAgaWYgKCh0aGlzLmltYWdlX2RhdGEgPT0gbnVsbCkgfHwgdGhpcy5pbWFnZV9kYXRhLmxlbmd0aCAhPT0gdGhpcy5faW1hZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlX2RhdGEgPSBuZXcgQXJyYXkodGhpcy5faW1hZ2UubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRoaXMuX3dpZHRoID09IG51bGwpIHx8IHRoaXMuX3dpZHRoLmxlbmd0aCAhPT0gdGhpcy5faW1hZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IG5ldyBBcnJheSh0aGlzLl9pbWFnZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5faGVpZ2h0ID09IG51bGwpIHx8IHRoaXMuX2hlaWdodC5sZW5ndGggIT09IHRoaXMuX2ltYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gbmV3IEFycmF5KHRoaXMuX2ltYWdlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmID0gdGhpcy5faW1hZ2UubGVuZ3RoOyAwIDw9IHJlZiA/IGsgPCByZWYgOiBrID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIGlmICgoaW5kaWNlcyAhPSBudWxsKSAmJiBpbmRpY2VzLmluZGV4T2YoaSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaGFwZSA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ltYWdlX3NoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzaGFwZSA9IHRoaXMuX2ltYWdlX3NoYXBlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlaWdodFtpXSA9IHRoaXMuX3Jvd3NbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5fd2lkdGhbaV0gPSB0aGlzLl9jb2xzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzaGFwZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZiA9IHRoaXMuX2ltYWdlW2ldLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYXQgPSB0aGlzLl9pbWFnZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgYnVmID0gbmV3IEFycmF5QnVmZmVyKGZsYXQubGVuZ3RoICogNCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gbmV3IFVpbnQzMkFycmF5KGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGwgPSAwLCByZWYxID0gZmxhdC5sZW5ndGg7IDAgPD0gcmVmMSA/IGwgPCByZWYxIDogbCA+IHJlZjE7IGogPSAwIDw9IHJlZjEgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yW2pdID0gZmxhdFtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBidWYgPSB0aGlzLl9pbWFnZVtpXS5idWZmZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVpZ2h0W2ldID0gc2hhcGVbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5fd2lkdGhbaV0gPSBzaGFwZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZsYXQgPSBhcnJheV8xLmNvbmNhdCh0aGlzLl9pbWFnZVtpXSk7XG4gICAgICAgICAgICAgICAgYnVmID0gbmV3IEFycmF5QnVmZmVyKGZsYXQubGVuZ3RoICogNCk7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBuZXcgVWludDMyQXJyYXkoYnVmKTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBtID0gMCwgcmVmMiA9IGZsYXQubGVuZ3RoOyAwIDw9IHJlZjIgPyBtIDwgcmVmMiA6IG0gPiByZWYyOyBqID0gMCA8PSByZWYyID8gKyttIDogLS1tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yW2pdID0gZmxhdFtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5faGVpZ2h0W2ldID0gdGhpcy5faW1hZ2VbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoW2ldID0gdGhpcy5faW1hZ2VbaV1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLmltYWdlX2RhdGFbaV0gIT0gbnVsbCkgJiYgdGhpcy5pbWFnZV9kYXRhW2ldLndpZHRoID09PSB0aGlzLl93aWR0aFtpXSAmJiB0aGlzLmltYWdlX2RhdGFbaV0uaGVpZ2h0ID09PSB0aGlzLl9oZWlnaHRbaV0pIHtcbiAgICAgICAgICAgICAgICBjYW52YXMgPSB0aGlzLmltYWdlX2RhdGFbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLl93aWR0aFtpXTtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBpbWFnZV9kYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLl93aWR0aFtpXSwgdGhpcy5faGVpZ2h0W2ldKTtcbiAgICAgICAgICAgIGJ1ZjggPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgICAgICAgICAgaW1hZ2VfZGF0YS5kYXRhLnNldChidWY4KTtcbiAgICAgICAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VfZGF0YSwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmltYWdlX2RhdGFbaV0gPSBjYW52YXM7XG4gICAgICAgICAgICB0aGlzLm1heF9kdyA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHcudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhfZHcgPSBhcnJheV8xLm1heCh0aGlzLl9kdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1heF9kaCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGgudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMubWF4X2RoID0gYXJyYXlfMS5tYXgodGhpcy5fZGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgSW1hZ2VSR0JBVmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwucHJvcGVydGllcy5kdy51bml0cykge1xuICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnN3ID0gdGhpcy5zZGlzdCh0aGlzLnJlbmRlcmVyLnhzY2FsZSwgdGhpcy5feCwgdGhpcy5fZHcsICdlZGdlJywgdGhpcy5tb2RlbC5kaWxhdGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNjcmVlblwiOlxuICAgICAgICAgICAgICAgIHRoaXMuc3cgPSB0aGlzLl9kdztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwucHJvcGVydGllcy5kaC51bml0cykge1xuICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaCA9IHRoaXMuc2Rpc3QodGhpcy5yZW5kZXJlci55c2NhbGUsIHRoaXMuX3ksIHRoaXMuX2RoLCAnZWRnZScsIHRoaXMubW9kZWwuZGlsYXRlKTtcbiAgICAgICAgICAgIGNhc2UgXCJzY3JlZW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaCA9IHRoaXMuX2RoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbWFnZVJHQkFWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBpLCBpbWFnZV9kYXRhLCBrLCBsZW4sIG9sZF9zbW9vdGhpbmcsIHNoLCBzdywgc3gsIHN5LCB5X29mZnNldDtcbiAgICAgICAgaW1hZ2VfZGF0YSA9IGFyZy5pbWFnZV9kYXRhLCBzeCA9IGFyZy5zeCwgc3kgPSBhcmcuc3ksIHN3ID0gYXJnLnN3LCBzaCA9IGFyZy5zaDtcbiAgICAgICAgb2xkX3Ntb290aGluZyA9IGN0eC5nZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoKTtcbiAgICAgICAgY3R4LnNldEltYWdlU21vb3RoaW5nRW5hYmxlZChmYWxzZSk7XG4gICAgICAgIGZvciAoayA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgIGkgPSBpbmRpY2VzW2tdO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHN4W2ldICsgc3lbaV0gKyBzd1tpXSArIHNoW2ldKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeV9vZmZzZXQgPSBzeVtpXTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgeV9vZmZzZXQpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgLXlfb2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2VfZGF0YVtpXSwgc3hbaV0gfCAwLCBzeVtpXSB8IDAsIHN3W2ldLCBzaFtpXSk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIHlfb2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIC15X29mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0eC5zZXRJbWFnZVNtb290aGluZ0VuYWJsZWQob2xkX3Ntb290aGluZyk7XG4gICAgfTtcbiAgICBJbWFnZVJHQkFWaWV3LnByb3RvdHlwZS5ib3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiYm94O1xuICAgICAgICBiYm94ID0gdGhpcy5pbmRleC5iYm94O1xuICAgICAgICBiYm94Lm1heFggKz0gdGhpcy5tYXhfZHc7XG4gICAgICAgIGJib3gubWF4WSArPSB0aGlzLm1heF9kaDtcbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgfTtcbiAgICByZXR1cm4gSW1hZ2VSR0JBVmlldztcbn0pKHh5X2dseXBoXzEuWFlHbHlwaFZpZXcpO1xuZXhwb3J0cy5JbWFnZVJHQkEgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSW1hZ2VSR0JBLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBJbWFnZVJHQkEoKSB7XG4gICAgICAgIHJldHVybiBJbWFnZVJHQkEuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEltYWdlUkdCQS5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5JbWFnZVJHQkFWaWV3O1xuICAgIEltYWdlUkdCQS5wcm90b3R5cGUudHlwZSA9ICdJbWFnZVJHQkEnO1xuICAgIEltYWdlUkdCQS5kZWZpbmUoe1xuICAgICAgICBpbWFnZTogW3AuTnVtYmVyU3BlY10sXG4gICAgICAgIHJvd3M6IFtwLk51bWJlclNwZWNdLFxuICAgICAgICBjb2xzOiBbcC5OdW1iZXJTcGVjXSxcbiAgICAgICAgZHc6IFtwLkRpc3RhbmNlU3BlY10sXG4gICAgICAgIGRoOiBbcC5EaXN0YW5jZVNwZWNdLFxuICAgICAgICBkaWxhdGU6IFtwLkJvb2wsIGZhbHNlXVxuICAgIH0pO1xuICAgIEltYWdlUkdCQS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBJbWFnZVJHQkEuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMucHJvcGVydGllcy5yb3dzLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5jb2xzLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBJbWFnZVJHQkE7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGdseXBoXzEgPSByZXF1aXJlKFwiLi9nbHlwaFwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5JbWFnZVVSTFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSW1hZ2VVUkxWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBJbWFnZVVSTFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBJbWFnZVVSTFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEltYWdlVVJMVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIEltYWdlVVJMVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMubW9kZWwucHJvcGVydGllcy5nbG9iYWxfYWxwaGEuY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW5kZXJlci5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgIH07XG4gICAgSW1hZ2VVUkxWaWV3LnByb3RvdHlwZS5faW5kZXhfZGF0YSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBJbWFnZVVSTFZpZXcucHJvdG90eXBlLl9zZXRfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGksIGltZywgaiwgcmVmLCByZXN1bHRzLCByZXRyeV9hdHRlbXB0cywgcmV0cnlfdGltZW91dDtcbiAgICAgICAgaWYgKCh0aGlzLmltYWdlID09IG51bGwpIHx8IHRoaXMuaW1hZ2UubGVuZ3RoICE9PSB0aGlzLl91cmwubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgbGVuLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVmID0gdGhpcy5fdXJsO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaW1nID0gcmVmW2pdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXRyeV9hdHRlbXB0cyA9IHRoaXMubW9kZWwucmV0cnlfYXR0ZW1wdHM7XG4gICAgICAgIHJldHJ5X3RpbWVvdXQgPSB0aGlzLm1vZGVsLnJldHJ5X3RpbWVvdXQ7XG4gICAgICAgIHRoaXMucmV0cmllcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaiwgbGVuLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICByZWYgPSB0aGlzLl91cmw7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpbWcgPSByZWZbal07XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJldHJ5X2F0dGVtcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB0aGlzLl91cmwubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl91cmxbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcub25lcnJvciA9IChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGksIGltZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnJldHJpZXNbaV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci50cmFjZShcIkltYWdlVVJMIGZhaWxlZCB0byBsb2FkIFwiICsgX3RoaXMuX3VybFtpXSArIFwiIGltYWdlLCByZXRyeWluZyBpbiBcIiArIHJldHJ5X3RpbWVvdXQgKyBcIiBtc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbWcuc3JjID0gX3RoaXMuX3VybFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgcmV0cnlfdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJJbWFnZVVSTCB1bmFibGUgdG8gbG9hZCBcIiArIF90aGlzLl91cmxbaV0gKyBcIiBpbWFnZSBhZnRlciBcIiArIHJldHJ5X2F0dGVtcHRzICsgXCIgcmV0cmllc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXRyaWVzW2ldIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHRoaXMpKGksIGltZyk7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaW1nLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbWFnZVtpXSA9IGltZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW5kZXJlci5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSh0aGlzKShpbWcsIGkpO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGltZy5zcmMgPSB0aGlzLl91cmxbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgSW1hZ2VVUkxWaWV3LnByb3RvdHlwZS5oYXNfZmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBJbWFnZVVSTFZpZXcuX19zdXBlcl9fLmhhc19maW5pc2hlZC5jYWxsKHRoaXMpICYmIHRoaXMuX2ltYWdlc19yZW5kZXJlZCA9PT0gdHJ1ZTtcbiAgICB9O1xuICAgIEltYWdlVVJMVmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaHMsIHdzLCB4O1xuICAgICAgICB3cyA9ICgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGosIGxlbiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwudyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWYgPSB0aGlzLl94O1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHJlZltqXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKDAgLyAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhbGwodGhpcykpO1xuICAgICAgICBocyA9ICgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGosIGxlbiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwuaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWYgPSB0aGlzLl94O1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHJlZltqXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKDAgLyAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhbGwodGhpcykpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwucHJvcGVydGllcy53LnVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuc3cgPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXIueHNjYWxlLCB0aGlzLl94LCB3cywgJ2VkZ2UnLCB0aGlzLm1vZGVsLmRpbGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2NyZWVuXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5zdyA9IHdzO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLmgudW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2ggPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXIueXNjYWxlLCB0aGlzLl95LCBocywgJ2VkZ2UnLCB0aGlzLm1vZGVsLmRpbGF0ZSk7XG4gICAgICAgICAgICBjYXNlIFwic2NyZWVuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2ggPSBocztcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW1hZ2VVUkxWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBfYW5nbGUsIF91cmwsIGZpbmlzaGVkLCBmcmFtZSwgaSwgaW1hZ2UsIGosIGxlbiwgc2gsIHN3LCBzeCwgc3k7XG4gICAgICAgIF91cmwgPSBhcmcuX3VybCwgaW1hZ2UgPSBhcmcuaW1hZ2UsIHN4ID0gYXJnLnN4LCBzeSA9IGFyZy5zeSwgc3cgPSBhcmcuc3csIHNoID0gYXJnLnNoLCBfYW5nbGUgPSBhcmcuX2FuZ2xlO1xuICAgICAgICBmcmFtZSA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmZyYW1lO1xuICAgICAgICBjdHgucmVjdChmcmFtZS5fbGVmdC52YWx1ZSArIDEsIGZyYW1lLl9ib3R0b20udmFsdWUgKyAxLCBmcmFtZS5fd2lkdGgudmFsdWUgLSAyLCBmcmFtZS5faGVpZ2h0LnZhbHVlIC0gMik7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IGluZGljZXNbal07XG4gICAgICAgICAgICBpZiAoaXNOYU4oc3hbaV0gKyBzeVtpXSArIF9hbmdsZVtpXSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJldHJpZXNbaV0gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW1hZ2VbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJfaW1hZ2UoY3R4LCBpLCBpbWFnZVtpXSwgc3gsIHN5LCBzdywgc2gsIF9hbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmlzaGVkICYmICF0aGlzLl9pbWFnZXNfcmVuZGVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlc19yZW5kZXJlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub3RpZnlfZmluaXNoZWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW1hZ2VVUkxWaWV3LnByb3RvdHlwZS5fZmluYWxfc3hfc3kgPSBmdW5jdGlvbiAoYW5jaG9yLCBzeCwgc3ksIHN3LCBzaCkge1xuICAgICAgICBzd2l0Y2ggKGFuY2hvcikge1xuICAgICAgICAgICAgY2FzZSAndG9wX2xlZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbc3gsIHN5XTtcbiAgICAgICAgICAgIGNhc2UgJ3RvcF9jZW50ZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBbc3ggLSBzdyAvIDIsIHN5XTtcbiAgICAgICAgICAgIGNhc2UgJ3RvcF9yaWdodCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzeCAtIHN3LCBzeV07XG4gICAgICAgICAgICBjYXNlICdjZW50ZXJfcmlnaHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbc3ggLSBzdywgc3kgLSBzaCAvIDJdO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tX3JpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N4IC0gc3csIHN5IC0gc2hdO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tX2NlbnRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzeCAtIHN3IC8gMiwgc3kgLSBzaF07XG4gICAgICAgICAgICBjYXNlICdib3R0b21fbGVmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzeCwgc3kgLSBzaF07XG4gICAgICAgICAgICBjYXNlICdjZW50ZXJfbGVmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzeCwgc3kgLSBzaCAvIDJdO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N4IC0gc3cgLyAyLCBzeSAtIHNoIC8gMl07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEltYWdlVVJMVmlldy5wcm90b3R5cGUuX3JlbmRlcl9pbWFnZSA9IGZ1bmN0aW9uIChjdHgsIGksIGltYWdlLCBzeCwgc3ksIHN3LCBzaCwgYW5nbGUpIHtcbiAgICAgICAgdmFyIGFuY2hvciwgcmVmO1xuICAgICAgICBpZiAoaXNOYU4oc3dbaV0pKSB7XG4gICAgICAgICAgICBzd1tpXSA9IGltYWdlLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTihzaFtpXSkpIHtcbiAgICAgICAgICAgIHNoW2ldID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGFuY2hvciA9IHRoaXMubW9kZWwuYW5jaG9yO1xuICAgICAgICByZWYgPSB0aGlzLl9maW5hbF9zeF9zeShhbmNob3IsIHN4W2ldLCBzeVtpXSwgc3dbaV0sIHNoW2ldKSwgc3ggPSByZWZbMF0sIHN5ID0gcmVmWzFdO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLm1vZGVsLmdsb2JhbF9hbHBoYTtcbiAgICAgICAgaWYgKGFuZ2xlW2ldKSB7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHN4LCBzeSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKGFuZ2xlW2ldKTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHN3W2ldLCBzaFtpXSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKC1hbmdsZVtpXSk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1zeCwgLXN5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHN4LCBzeSwgc3dbaV0sIHNoW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBJbWFnZVVSTFZpZXc7XG59KShnbHlwaF8xLkdseXBoVmlldyk7XG5leHBvcnRzLkltYWdlVVJMID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEltYWdlVVJMLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBJbWFnZVVSTCgpIHtcbiAgICAgICAgcmV0dXJuIEltYWdlVVJMLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBJbWFnZVVSTC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5JbWFnZVVSTFZpZXc7XG4gICAgSW1hZ2VVUkwucHJvdG90eXBlLnR5cGUgPSAnSW1hZ2VVUkwnO1xuICAgIEltYWdlVVJMLmNvb3JkcyhbWyd4JywgJ3knXV0pO1xuICAgIEltYWdlVVJMLm1peGlucyhbXSk7XG4gICAgSW1hZ2VVUkwuZGVmaW5lKHtcbiAgICAgICAgdXJsOiBbcC5TdHJpbmdTcGVjXSxcbiAgICAgICAgYW5jaG9yOiBbcC5BbmNob3IsICd0b3BfbGVmdCddLFxuICAgICAgICBnbG9iYWxfYWxwaGE6IFtwLk51bWJlciwgMS4wXSxcbiAgICAgICAgYW5nbGU6IFtwLkFuZ2xlU3BlYywgMF0sXG4gICAgICAgIHc6IFtwLkRpc3RhbmNlU3BlY10sXG4gICAgICAgIGg6IFtwLkRpc3RhbmNlU3BlY10sXG4gICAgICAgIGRpbGF0ZTogW3AuQm9vbCwgZmFsc2VdLFxuICAgICAgICByZXRyeV9hdHRlbXB0czogW3AuTnVtYmVyLCAwXSxcbiAgICAgICAgcmV0cnlfdGltZW91dDogW3AuTnVtYmVyLCAwXVxuICAgIH0pO1xuICAgIHJldHVybiBJbWFnZVVSTDtcbn0pKGdseXBoXzEuR2x5cGgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYW5udWxhcl93ZWRnZV8xID0gcmVxdWlyZShcIi4vYW5udWxhcl93ZWRnZVwiKTtcbmV4cG9ydHMuQW5udWxhcldlZGdlID0gYW5udWxhcl93ZWRnZV8xLkFubnVsYXJXZWRnZTtcbnZhciBhbm51bHVzXzEgPSByZXF1aXJlKFwiLi9hbm51bHVzXCIpO1xuZXhwb3J0cy5Bbm51bHVzID0gYW5udWx1c18xLkFubnVsdXM7XG52YXIgYXJjXzEgPSByZXF1aXJlKFwiLi9hcmNcIik7XG5leHBvcnRzLkFyYyA9IGFyY18xLkFyYztcbnZhciBiZXppZXJfMSA9IHJlcXVpcmUoXCIuL2JlemllclwiKTtcbmV4cG9ydHMuQmV6aWVyID0gYmV6aWVyXzEuQmV6aWVyO1xudmFyIGNpcmNsZV8xID0gcmVxdWlyZShcIi4vY2lyY2xlXCIpO1xuZXhwb3J0cy5DaXJjbGUgPSBjaXJjbGVfMS5DaXJjbGU7XG52YXIgZWxsaXBzZV8xID0gcmVxdWlyZShcIi4vZWxsaXBzZVwiKTtcbmV4cG9ydHMuRWxsaXBzZSA9IGVsbGlwc2VfMS5FbGxpcHNlO1xudmFyIGdseXBoXzEgPSByZXF1aXJlKFwiLi9nbHlwaFwiKTtcbmV4cG9ydHMuR2x5cGggPSBnbHlwaF8xLkdseXBoO1xudmFyIGhiYXJfMSA9IHJlcXVpcmUoXCIuL2hiYXJcIik7XG5leHBvcnRzLkhCYXIgPSBoYmFyXzEuSEJhcjtcbnZhciBpbWFnZV8xID0gcmVxdWlyZShcIi4vaW1hZ2VcIik7XG5leHBvcnRzLkltYWdlID0gaW1hZ2VfMS5JbWFnZTtcbnZhciBpbWFnZV9yZ2JhXzEgPSByZXF1aXJlKFwiLi9pbWFnZV9yZ2JhXCIpO1xuZXhwb3J0cy5JbWFnZVJHQkEgPSBpbWFnZV9yZ2JhXzEuSW1hZ2VSR0JBO1xudmFyIGltYWdlX3VybF8xID0gcmVxdWlyZShcIi4vaW1hZ2VfdXJsXCIpO1xuZXhwb3J0cy5JbWFnZVVSTCA9IGltYWdlX3VybF8xLkltYWdlVVJMO1xudmFyIGxpbmVfMSA9IHJlcXVpcmUoXCIuL2xpbmVcIik7XG5leHBvcnRzLkxpbmUgPSBsaW5lXzEuTGluZTtcbnZhciBtdWx0aV9saW5lXzEgPSByZXF1aXJlKFwiLi9tdWx0aV9saW5lXCIpO1xuZXhwb3J0cy5NdWx0aUxpbmUgPSBtdWx0aV9saW5lXzEuTXVsdGlMaW5lO1xudmFyIG92YWxfMSA9IHJlcXVpcmUoXCIuL292YWxcIik7XG5leHBvcnRzLk92YWwgPSBvdmFsXzEuT3ZhbDtcbnZhciBwYXRjaF8xID0gcmVxdWlyZShcIi4vcGF0Y2hcIik7XG5leHBvcnRzLlBhdGNoID0gcGF0Y2hfMS5QYXRjaDtcbnZhciBwYXRjaGVzXzEgPSByZXF1aXJlKFwiLi9wYXRjaGVzXCIpO1xuZXhwb3J0cy5QYXRjaGVzID0gcGF0Y2hlc18xLlBhdGNoZXM7XG52YXIgcXVhZF8xID0gcmVxdWlyZShcIi4vcXVhZFwiKTtcbmV4cG9ydHMuUXVhZCA9IHF1YWRfMS5RdWFkO1xudmFyIHF1YWRyYXRpY18xID0gcmVxdWlyZShcIi4vcXVhZHJhdGljXCIpO1xuZXhwb3J0cy5RdWFkcmF0aWMgPSBxdWFkcmF0aWNfMS5RdWFkcmF0aWM7XG52YXIgcmF5XzEgPSByZXF1aXJlKFwiLi9yYXlcIik7XG5leHBvcnRzLlJheSA9IHJheV8xLlJheTtcbnZhciByZWN0XzEgPSByZXF1aXJlKFwiLi9yZWN0XCIpO1xuZXhwb3J0cy5SZWN0ID0gcmVjdF8xLlJlY3Q7XG52YXIgc2VnbWVudF8xID0gcmVxdWlyZShcIi4vc2VnbWVudFwiKTtcbmV4cG9ydHMuU2VnbWVudCA9IHNlZ21lbnRfMS5TZWdtZW50O1xudmFyIHRleHRfMSA9IHJlcXVpcmUoXCIuL3RleHRcIik7XG5leHBvcnRzLlRleHQgPSB0ZXh0XzEuVGV4dDtcbnZhciB2YmFyXzEgPSByZXF1aXJlKFwiLi92YmFyXCIpO1xuZXhwb3J0cy5WQmFyID0gdmJhcl8xLlZCYXI7XG52YXIgd2VkZ2VfMSA9IHJlcXVpcmUoXCIuL3dlZGdlXCIpO1xuZXhwb3J0cy5XZWRnZSA9IHdlZGdlXzEuV2VkZ2U7XG52YXIgeHlfZ2x5cGhfMSA9IHJlcXVpcmUoXCIuL3h5X2dseXBoXCIpO1xuZXhwb3J0cy5YWUdseXBoID0geHlfZ2x5cGhfMS5YWUdseXBoO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHh5X2dseXBoXzEgPSByZXF1aXJlKFwiLi94eV9nbHlwaFwiKTtcbnZhciBoaXR0ZXN0ID0gcmVxdWlyZShcImNvcmUvaGl0dGVzdFwiKTtcbmV4cG9ydHMuTGluZVZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTGluZVZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExpbmVWaWV3KCkge1xuICAgICAgICByZXR1cm4gTGluZVZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExpbmVWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBkcmF3aW5nLCBpLCBqLCBsZW4sIHN4LCBzeTtcbiAgICAgICAgc3ggPSBhcmcuc3gsIHN5ID0gYXJnLnN5O1xuICAgICAgICBkcmF3aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92YWx1ZShjdHgpO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpID0gaW5kaWNlc1tqXTtcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUoc3hbaV0gKyBzeVtpXSkgJiYgZHJhd2luZykge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgZHJhd2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYXdpbmcpIHtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHN4W2ldLCBzeVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhzeFtpXSwgc3lbaV0pO1xuICAgICAgICAgICAgICAgIGRyYXdpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkcmF3aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaW5lVmlldy5wcm90b3R5cGUuX2hpdF9wb2ludCA9IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICAvKiBDaGVjayBpZiB0aGUgcG9pbnQgZ2VvbWV0cnkgaGl0cyB0aGlzIGxpbmUgZ2x5cGggYW5kIHJldHVybiBhbiBvYmplY3RcbiAgICAgICAgdGhhdCBkZXNjcmliZXMgdGhlIGhpdCByZXN1bHQ6XG4gICAgICAgICAgQXJnczpcbiAgICAgICAgICAgICogZ2VvbWV0cnkgKG9iamVjdCk6IG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcga2V5c1xuICAgICAgICAgICAgICAqIHZ4IChmbG9hdCk6IHZpZXcgeCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICAgICAgICAgICAqIHZ5IChmbG9hdCk6IHZpZXcgeSBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICAgICAgICAgICAqIHR5cGUgKHN0cik6IHR5cGUgb2YgZ2VvbWV0cnkgKGluIHRoaXMgY2FzZSBpdCdzIGEgcG9pbnQpXG4gICAgICAgICAgT3V0cHV0OlxuICAgICAgICAgICAgT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgICAgICAgICAgICAqIDBkIChib29sKTogd2hldGhlciB0aGUgcG9pbnQgaGl0cyB0aGUgZ2x5cGggb3Igbm90XG4gICAgICAgICAgICAgICogMWQgKGFycmF5KGludCkpOiBhcnJheSB3aXRoIHRoZSBpbmRpY2VzIGhpdCBieSB0aGUgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBkaXN0LCBpLCBqLCBwMCwgcDEsIHBvaW50LCByZWYsIHJlZjEsIHJlc3VsdCwgc2hvcnRlc3QsIHRocmVzaG9sZDtcbiAgICAgICAgcmVzdWx0ID0gaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCk7XG4gICAgICAgIHBvaW50ID0ge1xuICAgICAgICAgICAgeDogdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzLnZ4X3RvX3N4KGdlb21ldHJ5LnZ4KSxcbiAgICAgICAgICAgIHk6IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52eV90b19zeShnZW9tZXRyeS52eSlcbiAgICAgICAgfTtcbiAgICAgICAgc2hvcnRlc3QgPSA5OTk5O1xuICAgICAgICB0aHJlc2hvbGQgPSBNYXRoLm1heCgyLCB0aGlzLnZpc3VhbHMubGluZS5saW5lX3dpZHRoLnZhbHVlKCkgLyAyKTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRoaXMuc3gubGVuZ3RoIC0gMTsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICByZWYxID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgeDogdGhpcy5zeFtpXSxcbiAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5zeVtpXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgeDogdGhpcy5zeFtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIHk6IHRoaXMuc3lbaSArIDFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSwgcDAgPSByZWYxWzBdLCBwMSA9IHJlZjFbMV07XG4gICAgICAgICAgICBkaXN0ID0gaGl0dGVzdC5kaXN0X3RvX3NlZ21lbnQocG9pbnQsIHAwLCBwMSk7XG4gICAgICAgICAgICBpZiAoZGlzdCA8IHRocmVzaG9sZCAmJiBkaXN0IDwgc2hvcnRlc3QpIHtcbiAgICAgICAgICAgICAgICBzaG9ydGVzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgcmVzdWx0WycwZCddLmdseXBoID0gdGhpcy5tb2RlbDtcbiAgICAgICAgICAgICAgICByZXN1bHRbJzBkJ10uZ2V0X3ZpZXcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9KS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFsnMGQnXS5mbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHRbJzBkJ10uaW5kaWNlcyA9IFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTGluZVZpZXcucHJvdG90eXBlLl9oaXRfc3BhbiA9IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICB2YXIgaSwgaiwgcmVmLCByZWYxLCByZXN1bHQsIHZhbCwgdmFsdWVzLCB2eCwgdnk7XG4gICAgICAgIHJlZiA9IFtnZW9tZXRyeS52eCwgZ2VvbWV0cnkudnldLCB2eCA9IHJlZlswXSwgdnkgPSByZWZbMV07XG4gICAgICAgIHJlc3VsdCA9IGhpdHRlc3QuY3JlYXRlX2hpdF90ZXN0X3Jlc3VsdCgpO1xuICAgICAgICBpZiAoZ2VvbWV0cnkuZGlyZWN0aW9uID09PSAndicpIHtcbiAgICAgICAgICAgIHZhbCA9IHRoaXMucmVuZGVyZXIueXNjYWxlLmludmVydCh2eSk7XG4gICAgICAgICAgICB2YWx1ZXMgPSB0aGlzLl95O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gdGhpcy5yZW5kZXJlci54c2NhbGUuaW52ZXJ0KHZ4KTtcbiAgICAgICAgICAgIHZhbHVlcyA9IHRoaXMuX3g7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZjEgPSB2YWx1ZXMubGVuZ3RoIC0gMTsgMCA8PSByZWYxID8gaiA8IHJlZjEgOiBqID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgaWYgKCh2YWx1ZXNbaV0gPD0gdmFsICYmIHZhbCA8PSB2YWx1ZXNbaSArIDFdKSB8fCAodmFsdWVzW2kgKyAxXSA8PSB2YWwgJiYgdmFsIDw9IHZhbHVlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbJzBkJ10uZ2x5cGggPSB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgICAgIHJlc3VsdFsnMGQnXS5nZXRfdmlldyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0pLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0WycwZCddLmZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc3VsdFsnMGQnXS5pbmRpY2VzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIExpbmVWaWV3LnByb3RvdHlwZS5nZXRfaW50ZXJwb2xhdGlvbl9oaXQgPSBmdW5jdGlvbiAoaSwgZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVmNSwgcmVmNiwgcmVmNywgcmVzLCB2eCwgdnksIHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MztcbiAgICAgICAgcmVmID0gW2dlb21ldHJ5LnZ4LCBnZW9tZXRyeS52eV0sIHZ4ID0gcmVmWzBdLCB2eSA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IFt0aGlzLl94W2ldLCB0aGlzLl95W2ldLCB0aGlzLl94W2kgKyAxXSwgdGhpcy5feVtpICsgMV1dLCB4MiA9IHJlZjFbMF0sIHkyID0gcmVmMVsxXSwgeDMgPSByZWYxWzJdLCB5MyA9IHJlZjFbM107XG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAncG9pbnQnKSB7XG4gICAgICAgICAgICByZWYyID0gdGhpcy5yZW5kZXJlci55c2NhbGUudl9pbnZlcnQoW3Z5IC0gMSwgdnkgKyAxXSksIHkwID0gcmVmMlswXSwgeTEgPSByZWYyWzFdO1xuICAgICAgICAgICAgcmVmMyA9IHRoaXMucmVuZGVyZXIueHNjYWxlLnZfaW52ZXJ0KFt2eCAtIDEsIHZ4ICsgMV0pLCB4MCA9IHJlZjNbMF0sIHgxID0gcmVmM1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChnZW9tZXRyeS5kaXJlY3Rpb24gPT09ICd2Jykge1xuICAgICAgICAgICAgICAgIHJlZjQgPSB0aGlzLnJlbmRlcmVyLnlzY2FsZS52X2ludmVydChbdnksIHZ5XSksIHkwID0gcmVmNFswXSwgeTEgPSByZWY0WzFdO1xuICAgICAgICAgICAgICAgIHJlZjUgPSBbeDIsIHgzXSwgeDAgPSByZWY1WzBdLCB4MSA9IHJlZjVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWY2ID0gdGhpcy5yZW5kZXJlci54c2NhbGUudl9pbnZlcnQoW3Z4LCB2eF0pLCB4MCA9IHJlZjZbMF0sIHgxID0gcmVmNlsxXTtcbiAgICAgICAgICAgICAgICByZWY3ID0gW3kyLCB5M10sIHkwID0gcmVmN1swXSwgeTEgPSByZWY3WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcyA9IGhpdHRlc3QuY2hlY2tfMl9zZWdtZW50c19pbnRlcnNlY3QoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgcmV0dXJuIFtyZXMueCwgcmVzLnldO1xuICAgIH07XG4gICAgTGluZVZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kX2Zvcl9pbmRleCA9IGZ1bmN0aW9uIChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJpY19saW5lX2xlZ2VuZChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGluZVZpZXc7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGhWaWV3KTtcbmV4cG9ydHMuTGluZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMaW5lLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMaW5lKCkge1xuICAgICAgICByZXR1cm4gTGluZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGluZS5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5MaW5lVmlldztcbiAgICBMaW5lLnByb3RvdHlwZS50eXBlID0gJ0xpbmUnO1xuICAgIExpbmUubWl4aW5zKFsnbGluZSddKTtcbiAgICByZXR1cm4gTGluZTtcbn0pKHh5X2dseXBoXzEuWFlHbHlwaCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgc3BhdGlhbF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9zcGF0aWFsXCIpO1xudmFyIGhpdHRlc3QgPSByZXF1aXJlKFwiY29yZS9oaXR0ZXN0XCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xudmFyIGdseXBoXzEgPSByZXF1aXJlKFwiLi9nbHlwaFwiKTtcbmV4cG9ydHMuTXVsdGlMaW5lVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChNdWx0aUxpbmVWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBNdWx0aUxpbmVWaWV3KCkge1xuICAgICAgICByZXR1cm4gTXVsdGlMaW5lVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTXVsdGlMaW5lVmlldy5wcm90b3R5cGUuX2luZGV4X2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLCBrLCBwb2ludHMsIHJlZiwgeCwgeHMsIHksIHlzO1xuICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZiA9IHRoaXMuX3hzLmxlbmd0aDsgMCA8PSByZWYgPyBrIDwgcmVmIDogayA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICB4cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwsIGxlbiwgcmVmMSwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZWYxID0gdGhpcy5feHNbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobCA9IDAsIGxlbiA9IHJlZjEubGVuZ3RoOyBsIDwgbGVuOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHJlZjFbbF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZXNfMS5pc1N0cmljdE5hTih4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHlzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbCwgbGVuLCByZWYxLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlZjEgPSB0aGlzLl95c1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGwgPCBsZW47IGwrKykge1xuICAgICAgICAgICAgICAgICAgICB5ID0gcmVmMVtsXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlc18xLmlzU3RyaWN0TmFOKHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1pblg6IGFycmF5XzEubWluKHhzKSxcbiAgICAgICAgICAgICAgICBtaW5ZOiBhcnJheV8xLm1pbih5cyksXG4gICAgICAgICAgICAgICAgbWF4WDogYXJyYXlfMS5tYXgoeHMpLFxuICAgICAgICAgICAgICAgIG1heFk6IGFycmF5XzEubWF4KHlzKSxcbiAgICAgICAgICAgICAgICBpOiBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHNwYXRpYWxfMS5SQnVzaChwb2ludHMpO1xuICAgIH07XG4gICAgTXVsdGlMaW5lVmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZykge1xuICAgICAgICB2YXIgaSwgaiwgaywgbCwgbGVuLCByZWYsIHJlZjEsIHJlc3VsdHMsIHN4LCBzeHMsIHN5LCBzeXM7XG4gICAgICAgIHN4cyA9IGFyZy5zeHMsIHN5cyA9IGFyZy5zeXM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgaSA9IGluZGljZXNba107XG4gICAgICAgICAgICByZWYgPSBbc3hzW2ldLCBzeXNbaV1dLCBzeCA9IHJlZlswXSwgc3kgPSByZWZbMV07XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICBmb3IgKGogPSBsID0gMCwgcmVmMSA9IHN4Lmxlbmd0aDsgMCA8PSByZWYxID8gbCA8IHJlZjEgOiBsID4gcmVmMTsgaiA9IDAgPD0gcmVmMSA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhzeFtqXSwgc3lbal0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOYU4oc3hbal0pIHx8IGlzTmFOKHN5W2pdKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHN4W2pdLCBzeVtqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBNdWx0aUxpbmVWaWV3LnByb3RvdHlwZS5faGl0X3BvaW50ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBkaXN0LCBoaXRzLCBpLCBqLCBrLCBsLCBwMCwgcDEsIHBvaW50LCBwb2ludHMsIHJlZiwgcmVmMSwgcmVmMiwgcmVzdWx0LCBzaG9ydGVzdCwgdGhyZXNob2xkO1xuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgcG9pbnQgPSB7XG4gICAgICAgICAgICB4OiB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudnhfdG9fc3goZ2VvbWV0cnkudngpLFxuICAgICAgICAgICAgeTogdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzLnZ5X3RvX3N5KGdlb21ldHJ5LnZ5KVxuICAgICAgICB9O1xuICAgICAgICBzaG9ydGVzdCA9IDk5OTk7XG4gICAgICAgIGhpdHMgPSB7fTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZiA9IHRoaXMuc3hzLmxlbmd0aDsgMCA8PSByZWYgPyBrIDwgcmVmIDogayA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBNYXRoLm1heCgyLCB0aGlzLnZpc3VhbHMubGluZS5jYWNoZV9zZWxlY3QoJ2xpbmVfd2lkdGgnLCBpKSAvIDIpO1xuICAgICAgICAgICAgcG9pbnRzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAoaiA9IGwgPSAwLCByZWYxID0gdGhpcy5zeHNbaV0ubGVuZ3RoIC0gMTsgMCA8PSByZWYxID8gbCA8IHJlZjEgOiBsID4gcmVmMTsgaiA9IDAgPD0gcmVmMSA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgICAgIHJlZjIgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRoaXMuc3hzW2ldW2pdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5zeXNbaV1bal1cbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogdGhpcy5zeHNbaV1baiArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5zeXNbaV1baiArIDFdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLCBwMCA9IHJlZjJbMF0sIHAxID0gcmVmMlsxXTtcbiAgICAgICAgICAgICAgICBkaXN0ID0gaGl0dGVzdC5kaXN0X3RvX3NlZ21lbnQocG9pbnQsIHAwLCBwMSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPCB0aHJlc2hvbGQgJiYgZGlzdCA8IHNob3J0ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3J0ZXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb2ludHMpIHtcbiAgICAgICAgICAgICAgICBoaXRzW2ldID0gcG9pbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFsnMWQnXS5pbmRpY2VzID0gT2JqZWN0LmtleXMoaGl0cyk7XG4gICAgICAgIHJlc3VsdFsnMmQnXS5pbmRpY2VzID0gaGl0cztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE11bHRpTGluZVZpZXcucHJvdG90eXBlLl9oaXRfc3BhbiA9IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICB2YXIgaGl0cywgaSwgaiwgaywgbCwgcG9pbnRzLCByZWYsIHJlZjEsIHJlZjIsIHJlc3VsdCwgdmFsLCB2YWx1ZXMsIHZ4LCB2eTtcbiAgICAgICAgcmVmID0gW2dlb21ldHJ5LnZ4LCBnZW9tZXRyeS52eV0sIHZ4ID0gcmVmWzBdLCB2eSA9IHJlZlsxXTtcbiAgICAgICAgcmVzdWx0ID0gaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCk7XG4gICAgICAgIGlmIChnZW9tZXRyeS5kaXJlY3Rpb24gPT09ICd2Jykge1xuICAgICAgICAgICAgdmFsID0gdGhpcy5yZW5kZXJlci55c2NhbGUuaW52ZXJ0KHZ5KTtcbiAgICAgICAgICAgIHZhbHVlcyA9IHRoaXMuX3lzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gdGhpcy5yZW5kZXJlci54c2NhbGUuaW52ZXJ0KHZ4KTtcbiAgICAgICAgICAgIHZhbHVlcyA9IHRoaXMuX3hzO1xuICAgICAgICB9XG4gICAgICAgIGhpdHMgPSB7fTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZjEgPSB2YWx1ZXMubGVuZ3RoOyAwIDw9IHJlZjEgPyBrIDwgcmVmMSA6IGsgPiByZWYxOyBpID0gMCA8PSByZWYxID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IGwgPSAwLCByZWYyID0gdmFsdWVzW2ldLmxlbmd0aCAtIDE7IDAgPD0gcmVmMiA/IGwgPCByZWYyIDogbCA+IHJlZjI7IGogPSAwIDw9IHJlZjIgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHZhbHVlc1tpXVtqXSA8PSB2YWwgJiYgdmFsIDw9IHZhbHVlc1tpXVtqICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGhpdHNbaV0gPSBwb2ludHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0WycxZCddLmluZGljZXMgPSBPYmplY3Qua2V5cyhoaXRzKTtcbiAgICAgICAgcmVzdWx0WycyZCddLmluZGljZXMgPSBoaXRzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTXVsdGlMaW5lVmlldy5wcm90b3R5cGUuZ2V0X2ludGVycG9sYXRpb25faGl0ID0gZnVuY3Rpb24gKGksIHBvaW50X2ksIGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHJlZjUsIHJlZjYsIHJlZjcsIHJlcywgdngsIHZ5LCB4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTM7XG4gICAgICAgIHJlZiA9IFtnZW9tZXRyeS52eCwgZ2VvbWV0cnkudnldLCB2eCA9IHJlZlswXSwgdnkgPSByZWZbMV07XG4gICAgICAgIHJlZjEgPSBbdGhpcy5feHNbaV1bcG9pbnRfaV0sIHRoaXMuX3lzW2ldW3BvaW50X2ldLCB0aGlzLl94c1tpXVtwb2ludF9pICsgMV0sIHRoaXMuX3lzW2ldW3BvaW50X2kgKyAxXV0sIHgyID0gcmVmMVswXSwgeTIgPSByZWYxWzFdLCB4MyA9IHJlZjFbMl0sIHkzID0gcmVmMVszXTtcbiAgICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdwb2ludCcpIHtcbiAgICAgICAgICAgIHJlZjIgPSB0aGlzLnJlbmRlcmVyLnlzY2FsZS52X2ludmVydChbdnkgLSAxLCB2eSArIDFdKSwgeTAgPSByZWYyWzBdLCB5MSA9IHJlZjJbMV07XG4gICAgICAgICAgICByZWYzID0gdGhpcy5yZW5kZXJlci54c2NhbGUudl9pbnZlcnQoW3Z4IC0gMSwgdnggKyAxXSksIHgwID0gcmVmM1swXSwgeDEgPSByZWYzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGdlb21ldHJ5LmRpcmVjdGlvbiA9PT0gJ3YnKSB7XG4gICAgICAgICAgICAgICAgcmVmNCA9IHRoaXMucmVuZGVyZXIueXNjYWxlLnZfaW52ZXJ0KFt2eSwgdnldKSwgeTAgPSByZWY0WzBdLCB5MSA9IHJlZjRbMV07XG4gICAgICAgICAgICAgICAgcmVmNSA9IFt4MiwgeDNdLCB4MCA9IHJlZjVbMF0sIHgxID0gcmVmNVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZjYgPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS52X2ludmVydChbdngsIHZ4XSksIHgwID0gcmVmNlswXSwgeDEgPSByZWY2WzFdO1xuICAgICAgICAgICAgICAgIHJlZjcgPSBbeTIsIHkzXSwgeTAgPSByZWY3WzBdLCB5MSA9IHJlZjdbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gaGl0dGVzdC5jaGVja18yX3NlZ21lbnRzX2ludGVyc2VjdCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICByZXR1cm4gW3Jlcy54LCByZXMueV07XG4gICAgfTtcbiAgICBNdWx0aUxpbmVWaWV3LnByb3RvdHlwZS5kcmF3X2xlZ2VuZF9mb3JfaW5kZXggPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyaWNfbGluZV9sZWdlbmQoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpTGluZVZpZXc7XG59KShnbHlwaF8xLkdseXBoVmlldyk7XG5leHBvcnRzLk11bHRpTGluZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChNdWx0aUxpbmUsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIE11bHRpTGluZSgpIHtcbiAgICAgICAgcmV0dXJuIE11bHRpTGluZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTXVsdGlMaW5lLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLk11bHRpTGluZVZpZXc7XG4gICAgTXVsdGlMaW5lLnByb3RvdHlwZS50eXBlID0gJ011bHRpTGluZSc7XG4gICAgTXVsdGlMaW5lLmNvb3JkcyhbWyd4cycsICd5cyddXSk7XG4gICAgTXVsdGlMaW5lLm1peGlucyhbJ2xpbmUnXSk7XG4gICAgcmV0dXJuIE11bHRpTGluZTtcbn0pKGdseXBoXzEuR2x5cGgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHh5X2dseXBoXzEgPSByZXF1aXJlKFwiLi94eV9nbHlwaFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuT3ZhbFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoT3ZhbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIE92YWxWaWV3KCkge1xuICAgICAgICByZXR1cm4gT3ZhbFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE92YWxWaWV3LnByb3RvdHlwZS5fc2V0X2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWF4X3cyID0gMDtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy53aWR0aC51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHRoaXMubWF4X3cyID0gdGhpcy5tYXhfd2lkdGggLyAyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF4X2gyID0gMDtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy5oZWlnaHQudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhfaDIgPSB0aGlzLm1heF9oZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPdmFsVmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLndpZHRoLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgdGhpcy5zdyA9IHRoaXMuc2Rpc3QodGhpcy5yZW5kZXJlci54c2NhbGUsIHRoaXMuX3gsIHRoaXMuX3dpZHRoLCAnY2VudGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN3ID0gdGhpcy5fd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy5oZWlnaHQudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaCA9IHRoaXMuc2Rpc3QodGhpcy5yZW5kZXJlci55c2NhbGUsIHRoaXMuX3ksIHRoaXMuX2hlaWdodCwgJ2NlbnRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2ggPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE92YWxWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBpLCBqLCBsZW4sIHJlc3VsdHMsIHNoLCBzdywgc3gsIHN5O1xuICAgICAgICBzeCA9IGFyZy5zeCwgc3kgPSBhcmcuc3ksIHN3ID0gYXJnLnN3LCBzaCA9IGFyZy5zaDtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpID0gaW5kaWNlc1tqXTtcbiAgICAgICAgICAgIGlmIChpc05hTihzeFtpXSArIHN5W2ldICsgc3dbaV0gKyBzaFtpXSArIHRoaXMuX2FuZ2xlW2ldKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShzeFtpXSwgc3lbaV0pO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSh0aGlzLl9hbmdsZVtpXSk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKDAsIC1zaFtpXSAvIDIpO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oc3dbaV0gLyAyLCAtc2hbaV0gLyAyLCBzd1tpXSAvIDIsIHNoW2ldIC8gMiwgMCwgc2hbaV0gLyAyKTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKC1zd1tpXSAvIDIsIHNoW2ldIC8gMiwgLXN3W2ldIC8gMiwgLXNoW2ldIC8gMiwgMCwgLXNoW2ldIC8gMik7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudmlzdWFscy5saW5lLmRvaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnJvdGF0ZSgtdGhpcy5fYW5nbGVbaV0pO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC50cmFuc2xhdGUoLXN4W2ldLCAtc3lbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIE92YWxWaWV3LnByb3RvdHlwZS5kcmF3X2xlZ2VuZF9mb3JfaW5kZXggPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGQsIGRhdGEsIGluZGljZXMsIHNjYWxlLCBzaCwgc3csIHN4LCBzeTtcbiAgICAgICAgaW5kaWNlcyA9IFtpbmRleF07XG4gICAgICAgIHN4ID0ge307XG4gICAgICAgIHN4W2luZGV4XSA9ICh4MCArIHgxKSAvIDI7XG4gICAgICAgIHN5ID0ge307XG4gICAgICAgIHN5W2luZGV4XSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICAgIHNjYWxlID0gdGhpcy5zd1tpbmRleF0gLyB0aGlzLnNoW2luZGV4XTtcbiAgICAgICAgZCA9IE1hdGgubWluKE1hdGguYWJzKHgxIC0geDApLCBNYXRoLmFicyh5MSAtIHkwKSkgKiAwLjg7XG4gICAgICAgIHN3ID0ge307XG4gICAgICAgIHNoID0ge307XG4gICAgICAgIGlmIChzY2FsZSA+IDEpIHtcbiAgICAgICAgICAgIHN3W2luZGV4XSA9IGQ7XG4gICAgICAgICAgICBzaFtpbmRleF0gPSBkIC8gc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd1tpbmRleF0gPSBkICogc2NhbGU7XG4gICAgICAgICAgICBzaFtpbmRleF0gPSBkO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICBzeDogc3gsXG4gICAgICAgICAgICBzeTogc3ksXG4gICAgICAgICAgICBzdzogc3csXG4gICAgICAgICAgICBzaDogc2hcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcihjdHgsIGluZGljZXMsIGRhdGEpO1xuICAgIH07XG4gICAgT3ZhbFZpZXcucHJvdG90eXBlLl9ib3VuZHMgPSBmdW5jdGlvbiAoYmRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heF93aDJfYm91bmRzKGJkcyk7XG4gICAgfTtcbiAgICByZXR1cm4gT3ZhbFZpZXc7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGhWaWV3KTtcbmV4cG9ydHMuT3ZhbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChPdmFsLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBPdmFsKCkge1xuICAgICAgICByZXR1cm4gT3ZhbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgT3ZhbC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5PdmFsVmlldztcbiAgICBPdmFsLnByb3RvdHlwZS50eXBlID0gJ092YWwnO1xuICAgIE92YWwubWl4aW5zKFsnbGluZScsICdmaWxsJ10pO1xuICAgIE92YWwuZGVmaW5lKHtcbiAgICAgICAgYW5nbGU6IFtwLkFuZ2xlU3BlYywgMC4wXSxcbiAgICAgICAgd2lkdGg6IFtwLkRpc3RhbmNlU3BlY10sXG4gICAgICAgIGhlaWdodDogW3AuRGlzdGFuY2VTcGVjXVxuICAgIH0pO1xuICAgIHJldHVybiBPdmFsO1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB4eV9nbHlwaF8xID0gcmVxdWlyZShcIi4veHlfZ2x5cGhcIik7XG5leHBvcnRzLlBhdGNoVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQYXRjaFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFBhdGNoVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFBhdGNoVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGF0Y2hWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBpLCBqLCBrLCBsZW4sIGxlbjEsIHN4LCBzeTtcbiAgICAgICAgc3ggPSBhcmcuc3gsIHN5ID0gYXJnLnN5O1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmZpbGwuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaSA9IGluZGljZXNbal07XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHN4W2ldLCBzeVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc05hTihzeFtpXSArIHN5W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHN4W2ldLCBzeVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICBmb3IgKGsgPSAwLCBsZW4xID0gaW5kaWNlcy5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpID0gaW5kaWNlc1trXTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3hbaV0sIHN5W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHN4W2ldICsgc3lbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhzeFtpXSwgc3lbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHJldHVybiBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhdGNoVmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmRfZm9yX2luZGV4ID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmljX2FyZWFfbGVnZW5kKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KTtcbiAgICB9O1xuICAgIHJldHVybiBQYXRjaFZpZXc7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGhWaWV3KTtcbmV4cG9ydHMuUGF0Y2ggPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUGF0Y2gsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFBhdGNoKCkge1xuICAgICAgICByZXR1cm4gUGF0Y2guX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFBhdGNoLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlBhdGNoVmlldztcbiAgICBQYXRjaC5wcm90b3R5cGUudHlwZSA9ICdQYXRjaCc7XG4gICAgUGF0Y2gubWl4aW5zKFsnbGluZScsICdmaWxsJ10pO1xuICAgIHJldHVybiBQYXRjaDtcbn0pKHh5X2dseXBoXzEuWFlHbHlwaCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgc3BhdGlhbF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9zcGF0aWFsXCIpO1xudmFyIGdseXBoXzEgPSByZXF1aXJlKFwiLi9nbHlwaFwiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90eXBlc1wiKTtcbnZhciBoaXR0ZXN0ID0gcmVxdWlyZShcImNvcmUvaGl0dGVzdFwiKTtcbmV4cG9ydHMuUGF0Y2hlc1ZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUGF0Y2hlc1ZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFBhdGNoZXNWaWV3KCkge1xuICAgICAgICByZXR1cm4gUGF0Y2hlc1ZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFBhdGNoZXNWaWV3LnByb3RvdHlwZS5fYnVpbGRfZGlzY29udGludW91c19vYmplY3QgPSBmdW5jdGlvbiAobmFubmVkX3FzKSB7XG4gICAgICAgIHZhciBkZW5hbm5lZCwgZHMsIGksIGssIG5hbl9pbmRleCwgcSwgcXMsIHFzX3BhcnQsIHJlZjtcbiAgICAgICAgZHMgPSB7fTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZiA9IG5hbm5lZF9xcy5sZW5ndGg7IDAgPD0gcmVmID8gayA8IHJlZiA6IGsgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgZHNbaV0gPSBbXTtcbiAgICAgICAgICAgIHFzID0gYXJyYXlfMS5jb3B5KG5hbm5lZF9xc1tpXSk7XG4gICAgICAgICAgICB3aGlsZSAocXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG5hbl9pbmRleCA9IGFycmF5XzEuZmluZExhc3RJbmRleChxcywgZnVuY3Rpb24gKHEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuaXNTdHJpY3ROYU4ocSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbl9pbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHFzX3BhcnQgPSBxcy5zcGxpY2UobmFuX2luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHFzX3BhcnQgPSBxcztcbiAgICAgICAgICAgICAgICAgICAgcXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVuYW5uZWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbCwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobCA9IDAsIGxlbiA9IHFzX3BhcnQubGVuZ3RoOyBsIDwgbGVuOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBxc19wYXJ0W2xdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlc18xLmlzU3RyaWN0TmFOKHEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgZHNbaV0ucHVzaChkZW5hbm5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRzO1xuICAgIH07XG4gICAgUGF0Y2hlc1ZpZXcucHJvdG90eXBlLl9pbmRleF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgaiwgaywgbCwgcG9pbnRzLCByZWYsIHJlZjEsIHhzLCB4c3MsIHlzLCB5c3M7XG4gICAgICAgIHhzcyA9IHRoaXMuX2J1aWxkX2Rpc2NvbnRpbnVvdXNfb2JqZWN0KHRoaXMuX3hzKTtcbiAgICAgICAgeXNzID0gdGhpcy5fYnVpbGRfZGlzY29udGludW91c19vYmplY3QodGhpcy5feXMpO1xuICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZiA9IHRoaXMuX3hzLmxlbmd0aDsgMCA8PSByZWYgPyBrIDwgcmVmIDogayA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBmb3IgKGogPSBsID0gMCwgcmVmMSA9IHhzc1tpXS5sZW5ndGg7IDAgPD0gcmVmMSA/IGwgPCByZWYxIDogbCA+IHJlZjE7IGogPSAwIDw9IHJlZjEgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgICAgICB4cyA9IHhzc1tpXVtqXTtcbiAgICAgICAgICAgICAgICB5cyA9IHlzc1tpXVtqXTtcbiAgICAgICAgICAgICAgICBpZiAoeHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1pblg6IGFycmF5XzEubWluKHhzKSxcbiAgICAgICAgICAgICAgICAgICAgbWluWTogYXJyYXlfMS5taW4oeXMpLFxuICAgICAgICAgICAgICAgICAgICBtYXhYOiBhcnJheV8xLm1heCh4cyksXG4gICAgICAgICAgICAgICAgICAgIG1heFk6IGFycmF5XzEubWF4KHlzKSxcbiAgICAgICAgICAgICAgICAgICAgaTogaVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgc3BhdGlhbF8xLlJCdXNoKHBvaW50cyk7XG4gICAgfTtcbiAgICBQYXRjaGVzVmlldy5wcm90b3R5cGUuX21hc2tfZGF0YSA9IGZ1bmN0aW9uIChhbGxfaW5kaWNlcykge1xuICAgICAgICB2YXIgYmJveCwgcmVmLCByZWYxLCB4MCwgeDEsIHhyLCB5MCwgeTEsIHlyO1xuICAgICAgICB4ciA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmZyYW1lLnhfcmFuZ2VzW1wiZGVmYXVsdFwiXTtcbiAgICAgICAgcmVmID0gW3hyLm1pbiwgeHIubWF4XSwgeDAgPSByZWZbMF0sIHgxID0gcmVmWzFdO1xuICAgICAgICB5ciA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmZyYW1lLnlfcmFuZ2VzW1wiZGVmYXVsdFwiXTtcbiAgICAgICAgcmVmMSA9IFt5ci5taW4sIHlyLm1heF0sIHkwID0gcmVmMVswXSwgeTEgPSByZWYxWzFdO1xuICAgICAgICBiYm94ID0gaGl0dGVzdC52YWxpZGF0ZV9iYm94X2Nvb3JkcyhbeDAsIHgxXSwgW3kwLCB5MV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleC5pbmRpY2VzKGJib3gpO1xuICAgIH07XG4gICAgUGF0Y2hlc1ZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGosIGssIGwsIGxlbiwgbSwgcmVmLCByZWYxLCByZWYyLCByZXN1bHRzLCBzeCwgc3hzLCBzeSwgc3lzO1xuICAgICAgICBzeHMgPSBhcmcuc3hzLCBzeXMgPSBhcmcuc3lzO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnN4c3MgPSB0aGlzLl9idWlsZF9kaXNjb250aW51b3VzX29iamVjdChzeHMpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnN5c3MgPSB0aGlzLl9idWlsZF9kaXNjb250aW51b3VzX29iamVjdChzeXMpO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoayA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgIGkgPSBpbmRpY2VzW2tdO1xuICAgICAgICAgICAgcmVmID0gW3N4c1tpXSwgc3lzW2ldXSwgc3ggPSByZWZbMF0sIHN5ID0gcmVmWzFdO1xuICAgICAgICAgICAgaWYgKHRoaXMudmlzdWFscy5maWxsLmRvaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMuZmlsbC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gbCA9IDAsIHJlZjEgPSBzeC5sZW5ndGg7IDAgPD0gcmVmMSA/IGwgPCByZWYxIDogbCA+IHJlZjE7IGogPSAwIDw9IHJlZjEgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3hbal0sIHN5W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHN4W2pdICsgc3lbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHN4W2pdLCBzeVtqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBtID0gMCwgcmVmMiA9IHN4Lmxlbmd0aDsgMCA8PSByZWYyID8gbSA8IHJlZjIgOiBtID4gcmVmMjsgaiA9IDAgPD0gcmVmMiA/ICsrbSA6IC0tbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhzeFtqXSwgc3lbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOYU4oc3hbal0gKyBzeVtqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhzeFtqXSwgc3lbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnN0cm9rZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgUGF0Y2hlc1ZpZXcucHJvdG90eXBlLl9oaXRfcG9pbnQgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZXMsIGhpdHMsIGksIGlkeCwgaiwgaywgbCwgcmVmLCByZWYxLCByZWYyLCByZXN1bHQsIHN4LCBzeHMsIHN5LCBzeXMsIHZ4LCB2eSwgeCwgeTtcbiAgICAgICAgcmVmID0gW2dlb21ldHJ5LnZ4LCBnZW9tZXRyeS52eV0sIHZ4ID0gcmVmWzBdLCB2eSA9IHJlZlsxXTtcbiAgICAgICAgc3ggPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudnhfdG9fc3godngpO1xuICAgICAgICBzeSA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52eV90b19zeSh2eSk7XG4gICAgICAgIHggPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS5pbnZlcnQodngsIHRydWUpO1xuICAgICAgICB5ID0gdGhpcy5yZW5kZXJlci55c2NhbGUuaW52ZXJ0KHZ5LCB0cnVlKTtcbiAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuaW5kZXguaW5kaWNlcyh7XG4gICAgICAgICAgICBtaW5YOiB4LFxuICAgICAgICAgICAgbWluWTogeSxcbiAgICAgICAgICAgIG1heFg6IHgsXG4gICAgICAgICAgICBtYXhZOiB5XG4gICAgICAgIH0pO1xuICAgICAgICBoaXRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYxID0gY2FuZGlkYXRlcy5sZW5ndGg7IDAgPD0gcmVmMSA/IGsgPCByZWYxIDogayA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIGlkeCA9IGNhbmRpZGF0ZXNbaV07XG4gICAgICAgICAgICBzeHMgPSB0aGlzLnJlbmRlcmVyLnN4c3NbaWR4XTtcbiAgICAgICAgICAgIHN5cyA9IHRoaXMucmVuZGVyZXIuc3lzc1tpZHhdO1xuICAgICAgICAgICAgZm9yIChqID0gbCA9IDAsIHJlZjIgPSBzeHMubGVuZ3RoOyAwIDw9IHJlZjIgPyBsIDwgcmVmMiA6IGwgPiByZWYyOyBqID0gMCA8PSByZWYyID8gKytsIDogLS1sKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhpdHRlc3QucG9pbnRfaW5fcG9seShzeCwgc3ksIHN4c1tqXSwgc3lzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICBoaXRzLnB1c2goaWR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCk7XG4gICAgICAgIHJlc3VsdFsnMWQnXS5pbmRpY2VzID0gaGl0cztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFBhdGNoZXNWaWV3LnByb3RvdHlwZS5fZ2V0X3NuYXBfY29vcmQgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgdmFyIGssIGxlbiwgcywgc3VtO1xuICAgICAgICBzdW0gPSAwO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgcyA9IGFycmF5W2tdO1xuICAgICAgICAgICAgc3VtICs9IHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bSAvIGFycmF5Lmxlbmd0aDtcbiAgICB9O1xuICAgIFBhdGNoZXNWaWV3LnByb3RvdHlwZS5zY3ggPSBmdW5jdGlvbiAoaSwgc3gsIHN5KSB7XG4gICAgICAgIHZhciBqLCBrLCByZWYsIHN4cywgc3lzO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5zeHNzW2ldLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9zbmFwX2Nvb3JkKHRoaXMuc3hzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN4cyA9IHRoaXMucmVuZGVyZXIuc3hzc1tpXTtcbiAgICAgICAgICAgIHN5cyA9IHRoaXMucmVuZGVyZXIuc3lzc1tpXTtcbiAgICAgICAgICAgIGZvciAoaiA9IGsgPSAwLCByZWYgPSBzeHMubGVuZ3RoOyAwIDw9IHJlZiA/IGsgPCByZWYgOiBrID4gcmVmOyBqID0gMCA8PSByZWYgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGl0dGVzdC5wb2ludF9pbl9wb2x5KHN4LCBzeSwgc3hzW2pdLCBzeXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRfc25hcF9jb29yZChzeHNbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFBhdGNoZXNWaWV3LnByb3RvdHlwZS5zY3kgPSBmdW5jdGlvbiAoaSwgc3gsIHN5KSB7XG4gICAgICAgIHZhciBqLCBrLCByZWYsIHN4cywgc3lzO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5zeXNzW2ldLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9zbmFwX2Nvb3JkKHRoaXMuc3lzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN4cyA9IHRoaXMucmVuZGVyZXIuc3hzc1tpXTtcbiAgICAgICAgICAgIHN5cyA9IHRoaXMucmVuZGVyZXIuc3lzc1tpXTtcbiAgICAgICAgICAgIGZvciAoaiA9IGsgPSAwLCByZWYgPSBzeHMubGVuZ3RoOyAwIDw9IHJlZiA/IGsgPCByZWYgOiBrID4gcmVmOyBqID0gMCA8PSByZWYgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGl0dGVzdC5wb2ludF9pbl9wb2x5KHN4LCBzeSwgc3hzW2pdLCBzeXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRfc25hcF9jb29yZChzeXNbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUGF0Y2hlc1ZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kX2Zvcl9pbmRleCA9IGZ1bmN0aW9uIChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJpY19hcmVhX2xlZ2VuZChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGF0Y2hlc1ZpZXc7XG59KShnbHlwaF8xLkdseXBoVmlldyk7XG5leHBvcnRzLlBhdGNoZXMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUGF0Y2hlcywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUGF0Y2hlcygpIHtcbiAgICAgICAgcmV0dXJuIFBhdGNoZXMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFBhdGNoZXMucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUGF0Y2hlc1ZpZXc7XG4gICAgUGF0Y2hlcy5wcm90b3R5cGUudHlwZSA9ICdQYXRjaGVzJztcbiAgICBQYXRjaGVzLmNvb3JkcyhbWyd4cycsICd5cyddXSk7XG4gICAgUGF0Y2hlcy5taXhpbnMoWydsaW5lJywgJ2ZpbGwnXSk7XG4gICAgcmV0dXJuIFBhdGNoZXM7XG59KShnbHlwaF8xLkdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBzcGF0aWFsXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3NwYXRpYWxcIik7XG52YXIgZ2x5cGhfMSA9IHJlcXVpcmUoXCIuL2dseXBoXCIpO1xudmFyIGNhdGVnb3JpY2FsX3NjYWxlXzEgPSByZXF1aXJlKFwiLi4vc2NhbGVzL2NhdGVnb3JpY2FsX3NjYWxlXCIpO1xudmFyIGhpdHRlc3QgPSByZXF1aXJlKFwiY29yZS9oaXR0ZXN0XCIpO1xuZXhwb3J0cy5RdWFkVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChRdWFkVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUXVhZFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBRdWFkVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUXVhZFZpZXcucHJvdG90eXBlLl9pbmRleF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiwgYm90dG9tLCBpLCBqLCBsLCBsZWZ0LCBtYXBfdG9fc3ludGhldGljLCBwb2ludHMsIHIsIHJlZiwgcmlnaHQsIHQsIHRvcDtcbiAgICAgICAgbWFwX3RvX3N5bnRoZXRpYyA9IGZ1bmN0aW9uIChzY2FsZSwgYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChzY2FsZSBpbnN0YW5jZW9mIGNhdGVnb3JpY2FsX3NjYWxlXzEuQ2F0ZWdvcmljYWxTY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsZS52X2NvbXB1dGUoYXJyYXksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZWZ0ID0gbWFwX3RvX3N5bnRoZXRpYyh0aGlzLnJlbmRlcmVyLnhzY2FsZSwgdGhpcy5fbGVmdCk7XG4gICAgICAgIHJpZ2h0ID0gbWFwX3RvX3N5bnRoZXRpYyh0aGlzLnJlbmRlcmVyLnhzY2FsZSwgdGhpcy5fcmlnaHQpO1xuICAgICAgICB0b3AgPSBtYXBfdG9fc3ludGhldGljKHRoaXMucmVuZGVyZXIueXNjYWxlLCB0aGlzLl90b3ApO1xuICAgICAgICBib3R0b20gPSBtYXBfdG9fc3ludGhldGljKHRoaXMucmVuZGVyZXIueXNjYWxlLCB0aGlzLl9ib3R0b20pO1xuICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGxlZnQubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIGwgPSBsZWZ0W2ldO1xuICAgICAgICAgICAgciA9IHJpZ2h0W2ldO1xuICAgICAgICAgICAgdCA9IHRvcFtpXTtcbiAgICAgICAgICAgIGIgPSBib3R0b21baV07XG4gICAgICAgICAgICBpZiAoaXNOYU4obCArIHIgKyB0ICsgYikgfHwgIWlzRmluaXRlKGwgKyByICsgdCArIGIpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWluWDogbCxcbiAgICAgICAgICAgICAgICBtaW5ZOiBiLFxuICAgICAgICAgICAgICAgIG1heFg6IHIsXG4gICAgICAgICAgICAgICAgbWF4WTogdCxcbiAgICAgICAgICAgICAgICBpOiBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHNwYXRpYWxfMS5SQnVzaChwb2ludHMpO1xuICAgIH07XG4gICAgUXVhZFZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGosIGxlbiwgcmVzdWx0cywgc2JvdHRvbSwgc2xlZnQsIHNyaWdodCwgc3RvcDtcbiAgICAgICAgc2xlZnQgPSBhcmcuc2xlZnQsIHNyaWdodCA9IGFyZy5zcmlnaHQsIHN0b3AgPSBhcmcuc3RvcCwgc2JvdHRvbSA9IGFyZy5zYm90dG9tO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGkgPSBpbmRpY2VzW2pdO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHNsZWZ0W2ldICsgc3RvcFtpXSArIHNyaWdodFtpXSArIHNib3R0b21baV0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3Qoc2xlZnRbaV0sIHN0b3BbaV0sIHNyaWdodFtpXSAtIHNsZWZ0W2ldLCBzYm90dG9tW2ldIC0gc3RvcFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVjdChzbGVmdFtpXSwgc3RvcFtpXSwgc3JpZ2h0W2ldIC0gc2xlZnRbaV0sIHNib3R0b21baV0gLSBzdG9wW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIFF1YWRWaWV3LnByb3RvdHlwZS5faGl0X3BvaW50ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBoaXRzLCByZWYsIHJlc3VsdCwgdngsIHZ5LCB4LCB5O1xuICAgICAgICByZWYgPSBbZ2VvbWV0cnkudngsIGdlb21ldHJ5LnZ5XSwgdnggPSByZWZbMF0sIHZ5ID0gcmVmWzFdO1xuICAgICAgICB4ID0gdGhpcy5yZW5kZXJlci54c2NhbGUuaW52ZXJ0KHZ4LCB0cnVlKTtcbiAgICAgICAgeSA9IHRoaXMucmVuZGVyZXIueXNjYWxlLmludmVydCh2eSwgdHJ1ZSk7XG4gICAgICAgIGhpdHMgPSB0aGlzLmluZGV4LmluZGljZXMoe1xuICAgICAgICAgICAgbWluWDogeCxcbiAgICAgICAgICAgIG1pblk6IHksXG4gICAgICAgICAgICBtYXhYOiB4LFxuICAgICAgICAgICAgbWF4WTogeVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0ID0gaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCk7XG4gICAgICAgIHJlc3VsdFsnMWQnXS5pbmRpY2VzID0gaGl0cztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFF1YWRWaWV3LnByb3RvdHlwZS5nZXRfYW5jaG9yX3BvaW50ID0gZnVuY3Rpb24gKGFuY2hvciwgaSwgc3B0KSB7XG4gICAgICAgIHZhciBib3R0b20sIGxlZnQsIHJpZ2h0LCB0b3A7XG4gICAgICAgIGxlZnQgPSBNYXRoLm1pbih0aGlzLnNsZWZ0W2ldLCB0aGlzLnNyaWdodFtpXSk7XG4gICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgodGhpcy5zcmlnaHRbaV0sIHRoaXMuc2xlZnRbaV0pO1xuICAgICAgICB0b3AgPSBNYXRoLm1pbih0aGlzLnN0b3BbaV0sIHRoaXMuc2JvdHRvbVtpXSk7XG4gICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KHRoaXMuc2JvdHRvbVtpXSwgdGhpcy5zdG9wW2ldKTtcbiAgICAgICAgc3dpdGNoIChhbmNob3IpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcF9sZWZ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAndG9wX2NlbnRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeDogKGxlZnQgKyByaWdodCkgLyAyLFxuICAgICAgICAgICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAndG9wX3JpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiByaWdodCxcbiAgICAgICAgICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcl9yaWdodCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeDogcmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHk6ICh0b3AgKyBib3R0b20pIC8gMlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdib3R0b21fcmlnaHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB5OiBib3R0b21cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tX2NlbnRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeDogKGxlZnQgKyByaWdodCkgLyAyLFxuICAgICAgICAgICAgICAgICAgICB5OiBib3R0b21cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tX2xlZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHk6IGJvdHRvbVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdjZW50ZXJfbGVmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgeTogKHRvcCArIGJvdHRvbSkgLyAyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeDogKGxlZnQgKyByaWdodCkgLyAyLFxuICAgICAgICAgICAgICAgICAgICB5OiAodG9wICsgYm90dG9tKSAvIDJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWFkVmlldy5wcm90b3R5cGUuc2N4ID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnNsZWZ0W2ldICsgdGhpcy5zcmlnaHRbaV0pIC8gMjtcbiAgICB9O1xuICAgIFF1YWRWaWV3LnByb3RvdHlwZS5zY3kgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RvcFtpXSArIHRoaXMuc2JvdHRvbVtpXSkgLyAyO1xuICAgIH07XG4gICAgUXVhZFZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kX2Zvcl9pbmRleCA9IGZ1bmN0aW9uIChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJpY19hcmVhX2xlZ2VuZChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCk7XG4gICAgfTtcbiAgICByZXR1cm4gUXVhZFZpZXc7XG59KShnbHlwaF8xLkdseXBoVmlldyk7XG5leHBvcnRzLlF1YWQgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUXVhZCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUXVhZCgpIHtcbiAgICAgICAgcmV0dXJuIFF1YWQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFF1YWQucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUXVhZFZpZXc7XG4gICAgUXVhZC5wcm90b3R5cGUudHlwZSA9ICdRdWFkJztcbiAgICBRdWFkLmNvb3JkcyhbWydyaWdodCcsICdib3R0b20nXSwgWydsZWZ0JywgJ3RvcCddXSk7XG4gICAgUXVhZC5taXhpbnMoWydsaW5lJywgJ2ZpbGwnXSk7XG4gICAgcmV0dXJuIFF1YWQ7XG59KShnbHlwaF8xLkdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9xYmIsIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBzcGF0aWFsXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3NwYXRpYWxcIik7XG52YXIgZ2x5cGhfMSA9IHJlcXVpcmUoXCIuL2dseXBoXCIpO1xuX3FiYiA9IGZ1bmN0aW9uICh1LCB2LCB3KSB7XG4gICAgdmFyIGJkLCB0O1xuICAgIGlmICh2ID09PSAodSArIHcpIC8gMikge1xuICAgICAgICByZXR1cm4gW3UsIHddO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdCA9ICh1IC0gdikgLyAodSAtIDIgKiB2ICsgdyk7XG4gICAgICAgIGJkID0gdSAqIE1hdGgucG93KDEgLSB0LCAyKSArIDIgKiB2ICogKDEgLSB0KSAqIHQgKyB3ICogTWF0aC5wb3codCwgMik7XG4gICAgICAgIHJldHVybiBbTWF0aC5taW4odSwgdywgYmQpLCBNYXRoLm1heCh1LCB3LCBiZCldO1xuICAgIH1cbn07XG5leHBvcnRzLlF1YWRyYXRpY1ZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUXVhZHJhdGljVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUXVhZHJhdGljVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFF1YWRyYXRpY1ZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFF1YWRyYXRpY1ZpZXcucHJvdG90eXBlLl9pbmRleF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgaiwgcG9pbnRzLCByZWYsIHJlZjEsIHJlZjIsIHgwLCB4MSwgeTAsIHkxO1xuICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRoaXMuX3gwLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy5feDBbaV0gKyB0aGlzLl94MVtpXSArIHRoaXMuX3kwW2ldICsgdGhpcy5feTFbaV0gKyB0aGlzLl9jeFtpXSArIHRoaXMuX2N5W2ldKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmMSA9IF9xYmIodGhpcy5feDBbaV0sIHRoaXMuX2N4W2ldLCB0aGlzLl94MVtpXSksIHgwID0gcmVmMVswXSwgeDEgPSByZWYxWzFdO1xuICAgICAgICAgICAgcmVmMiA9IF9xYmIodGhpcy5feTBbaV0sIHRoaXMuX2N5W2ldLCB0aGlzLl95MVtpXSksIHkwID0gcmVmMlswXSwgeTEgPSByZWYyWzFdO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1pblg6IHgwLFxuICAgICAgICAgICAgICAgIG1pblk6IHkwLFxuICAgICAgICAgICAgICAgIG1heFg6IHgxLFxuICAgICAgICAgICAgICAgIG1heFk6IHkxLFxuICAgICAgICAgICAgICAgIGk6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgc3BhdGlhbF8xLlJCdXNoKHBvaW50cyk7XG4gICAgfTtcbiAgICBRdWFkcmF0aWNWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBpLCBqLCBsZW4sIHJlc3VsdHMsIHNjeCwgc2N5LCBzeDAsIHN4MSwgc3kwLCBzeTE7XG4gICAgICAgIHN4MCA9IGFyZy5zeDAsIHN5MCA9IGFyZy5zeTAsIHN4MSA9IGFyZy5zeDEsIHN5MSA9IGFyZy5zeTEsIHNjeCA9IGFyZy5zY3gsIHNjeSA9IGFyZy5zY3k7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaSA9IGluZGljZXNbal07XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHN4MFtpXSArIHN5MFtpXSArIHN4MVtpXSArIHN5MVtpXSArIHNjeFtpXSArIHNjeVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHN4MFtpXSwgc3kwW2ldKTtcbiAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhzY3hbaV0sIHNjeVtpXSwgc3gxW2ldLCBzeTFbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnN0cm9rZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWFkcmF0aWNWaWV3LnByb3RvdHlwZS5kcmF3X2xlZ2VuZF9mb3JfaW5kZXggPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyaWNfbGluZV9sZWdlbmQoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIFF1YWRyYXRpY1ZpZXc7XG59KShnbHlwaF8xLkdseXBoVmlldyk7XG5leHBvcnRzLlF1YWRyYXRpYyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChRdWFkcmF0aWMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFF1YWRyYXRpYygpIHtcbiAgICAgICAgcmV0dXJuIFF1YWRyYXRpYy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUXVhZHJhdGljLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlF1YWRyYXRpY1ZpZXc7XG4gICAgUXVhZHJhdGljLnByb3RvdHlwZS50eXBlID0gJ1F1YWRyYXRpYyc7XG4gICAgUXVhZHJhdGljLmNvb3JkcyhbWyd4MCcsICd5MCddLCBbJ3gxJywgJ3kxJ10sIFsnY3gnLCAnY3knXV0pO1xuICAgIFF1YWRyYXRpYy5taXhpbnMoWydsaW5lJ10pO1xuICAgIHJldHVybiBRdWFkcmF0aWM7XG59KShnbHlwaF8xLkdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB4eV9nbHlwaF8xID0gcmVxdWlyZShcIi4veHlfZ2x5cGhcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLlJheVZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmF5Vmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUmF5VmlldygpIHtcbiAgICAgICAgcmV0dXJuIFJheVZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJheVZpZXcucHJvdG90eXBlLl9tYXBfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xlbmd0aCA9IHRoaXMuc2Rpc3QodGhpcy5yZW5kZXJlci54c2NhbGUsIHRoaXMuX3gsIHRoaXMuX2xlbmd0aCk7XG4gICAgfTtcbiAgICBSYXlWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBfYW5nbGUsIGhlaWdodCwgaSwgaW5mX2xlbiwgaiwgaywgbGVuLCByZWYsIHJlc3VsdHMsIHNsZW5ndGgsIHN4LCBzeSwgd2lkdGg7XG4gICAgICAgIHN4ID0gYXJnLnN4LCBzeSA9IGFyZy5zeSwgc2xlbmd0aCA9IGFyZy5zbGVuZ3RoLCBfYW5nbGUgPSBhcmcuX2FuZ2xlO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgd2lkdGggPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5mcmFtZS5fd2lkdGgudmFsdWU7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5mcmFtZS5faGVpZ2h0LnZhbHVlO1xuICAgICAgICAgICAgaW5mX2xlbiA9IDIgKiAod2lkdGggKyBoZWlnaHQpO1xuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHNsZW5ndGgubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICBpZiAoc2xlbmd0aFtpXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzbGVuZ3RoW2ldID0gaW5mX2xlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgaSA9IGluZGljZXNba107XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHN4W2ldICsgc3lbaV0gKyBfYW5nbGVbaV0gKyBzbGVuZ3RoW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShzeFtpXSwgc3lbaV0pO1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoX2FuZ2xlW2ldKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHNsZW5ndGhbaV0sIDApO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgtX2FuZ2xlW2ldKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnRyYW5zbGF0ZSgtc3hbaV0sIC1zeVtpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJheVZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kX2Zvcl9pbmRleCA9IGZ1bmN0aW9uIChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJpY19saW5lX2xlZ2VuZChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmF5Vmlldztcbn0pKHh5X2dseXBoXzEuWFlHbHlwaFZpZXcpO1xuZXhwb3J0cy5SYXkgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmF5LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBSYXkoKSB7XG4gICAgICAgIHJldHVybiBSYXkuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJheS5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5SYXlWaWV3O1xuICAgIFJheS5wcm90b3R5cGUudHlwZSA9ICdSYXknO1xuICAgIFJheS5taXhpbnMoWydsaW5lJ10pO1xuICAgIFJheS5kZWZpbmUoe1xuICAgICAgICBsZW5ndGg6IFtwLkRpc3RhbmNlU3BlY10sXG4gICAgICAgIGFuZ2xlOiBbcC5BbmdsZVNwZWNdXG4gICAgfSk7XG4gICAgcmV0dXJuIFJheTtcbn0pKHh5X2dseXBoXzEuWFlHbHlwaCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgeHlfZ2x5cGhfMSA9IHJlcXVpcmUoXCIuL3h5X2dseXBoXCIpO1xudmFyIGhpdHRlc3QgPSByZXF1aXJlKFwiY29yZS9oaXR0ZXN0XCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xudmFyIGNhdGVnb3JpY2FsX3NjYWxlXzEgPSByZXF1aXJlKFwiLi4vc2NhbGVzL2NhdGVnb3JpY2FsX3NjYWxlXCIpO1xuZXhwb3J0cy5SZWN0VmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChSZWN0Vmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUmVjdFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBSZWN0Vmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUmVjdFZpZXcucHJvdG90eXBlLl9zZXRfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tYXhfdzIgPSAwO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLndpZHRoLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgdGhpcy5tYXhfdzIgPSB0aGlzLm1heF93aWR0aCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXhfaDIgPSAwO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLmhlaWdodC51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heF9oMiA9IHRoaXMubWF4X2hlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY3RWaWV3LnByb3RvdHlwZS5fbWFwX2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYW52YXMsIGksIHJlZiwgcmVmMTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLndpZHRoLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgcmVmID0gdGhpcy5fbWFwX2Rpc3RfY29ybmVyX2Zvcl9kYXRhX3NpZGVfbGVuZ3RoKHRoaXMuX3gsIHRoaXMuX3dpZHRoLCB0aGlzLnJlbmRlcmVyLnhzY2FsZSwgY2FudmFzLCAwKSwgdGhpcy5zdyA9IHJlZlswXSwgdGhpcy5zeDAgPSByZWZbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN3ID0gdGhpcy5fd2lkdGg7XG4gICAgICAgICAgICB0aGlzLnN4MCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIHJlZjEsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYxID0gdGhpcy5zeC5sZW5ndGg7IDAgPD0gcmVmMSA/IGogPCByZWYxIDogaiA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuc3hbaV0gLSB0aGlzLnN3W2ldIC8gMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLmhlaWdodC51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHJlZjEgPSB0aGlzLl9tYXBfZGlzdF9jb3JuZXJfZm9yX2RhdGFfc2lkZV9sZW5ndGgodGhpcy5feSwgdGhpcy5faGVpZ2h0LCB0aGlzLnJlbmRlcmVyLnlzY2FsZSwgY2FudmFzLCAxKSwgdGhpcy5zaCA9IHJlZjFbMF0sIHRoaXMuc3kxID0gcmVmMVsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2ggPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnN5MSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIHJlZjIsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYyID0gdGhpcy5zeS5sZW5ndGg7IDAgPD0gcmVmMiA/IGogPCByZWYyIDogaiA+IHJlZjI7IGkgPSAwIDw9IHJlZjIgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuc3lbaV0gLSB0aGlzLnNoW2ldIC8gMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zc2VtaV9kaWFnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCByZWYyLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZjIgPSB0aGlzLnN3Lmxlbmd0aDsgMCA8PSByZWYyID8gaiA8IHJlZjIgOiBqID4gcmVmMjsgaSA9IDAgPD0gcmVmMiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChNYXRoLnNxcnQodGhpcy5zd1tpXSAvIDIgKiB0aGlzLnN3W2ldIC8gMiArIHRoaXMuc2hbaV0gLyAyICogdGhpcy5zaFtpXSAvIDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgUmVjdFZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIF9hbmdsZSwgaSwgaiwgaywgbGVuLCBsZW4xLCBzaCwgc3csIHN4LCBzeDAsIHN5LCBzeTE7XG4gICAgICAgIHN4ID0gYXJnLnN4LCBzeSA9IGFyZy5zeSwgc3gwID0gYXJnLnN4MCwgc3kxID0gYXJnLnN5MSwgc3cgPSBhcmcuc3csIHNoID0gYXJnLnNoLCBfYW5nbGUgPSBhcmcuX2FuZ2xlO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIGkgPSBpbmRpY2VzW2pdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihzeFtpXSArIHN5W2ldICsgc3gwW2ldICsgc3kxW2ldICsgc3dbaV0gKyBzaFtpXSArIF9hbmdsZVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoX2FuZ2xlW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoc3hbaV0sIHN5W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShfYW5nbGVbaV0pO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoLXN3W2ldIC8gMiwgLXNoW2ldIC8gMiwgc3dbaV0sIHNoW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgtX2FuZ2xlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtc3hbaV0sIC1zeVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3Qoc3gwW2ldLCBzeTFbaV0sIHN3W2ldLCBzaFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBmb3IgKGsgPSAwLCBsZW4xID0gaW5kaWNlcy5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpID0gaW5kaWNlc1trXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oc3hbaV0gKyBzeVtpXSArIHN4MFtpXSArIHN5MVtpXSArIHN3W2ldICsgc2hbaV0gKyBfYW5nbGVbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3dbaV0gPT09IDAgfHwgc2hbaV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfYW5nbGVbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShzeFtpXSwgc3lbaV0pO1xuICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKF9hbmdsZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KC1zd1tpXSAvIDIsIC1zaFtpXSAvIDIsIHN3W2ldLCBzaFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLV9hbmdsZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXN4W2ldLCAtc3lbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3Qoc3gwW2ldLCBzeTFbaV0sIHN3W2ldLCBzaFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjdFZpZXcucHJvdG90eXBlLl9oaXRfcmVjdCA9IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICB2YXIgYmJveCwgcmVmLCByZWYxLCByZXN1bHQsIHgwLCB4MSwgeTAsIHkxO1xuICAgICAgICByZWYgPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS52X2ludmVydChbZ2VvbWV0cnkudngwLCBnZW9tZXRyeS52eDFdLCB0cnVlKSwgeDAgPSByZWZbMF0sIHgxID0gcmVmWzFdO1xuICAgICAgICByZWYxID0gdGhpcy5yZW5kZXJlci55c2NhbGUudl9pbnZlcnQoW2dlb21ldHJ5LnZ5MCwgZ2VvbWV0cnkudnkxXSwgdHJ1ZSksIHkwID0gcmVmMVswXSwgeTEgPSByZWYxWzFdO1xuICAgICAgICBiYm94ID0gaGl0dGVzdC52YWxpZGF0ZV9iYm94X2Nvb3JkcyhbeDAsIHgxXSwgW3kwLCB5MV0pO1xuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgcmVzdWx0WycxZCddLmluZGljZXMgPSB0aGlzLmluZGV4LmluZGljZXMoYmJveCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBSZWN0Vmlldy5wcm90b3R5cGUuX2hpdF9wb2ludCA9IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICB2YXIgYmJveCwgYywgZCwgaGVpZ2h0X2luLCBoaXRzLCBpLCBqLCBsZW4sIG1heF94Ml9kZGlzdCwgbWF4X3kyX2RkaXN0LCBweCwgcHksIHJlZiwgcmVmMSwgcmVzdWx0LCBzLCBzY2VudGVyX3gsIHNjZW50ZXJfeSwgc3gsIHN5LCB2eCwgdnksIHdpZHRoX2luLCB4LCB4MCwgeDEsIHksIHkwLCB5MTtcbiAgICAgICAgcmVmID0gW2dlb21ldHJ5LnZ4LCBnZW9tZXRyeS52eV0sIHZ4ID0gcmVmWzBdLCB2eSA9IHJlZlsxXTtcbiAgICAgICAgeCA9IHRoaXMucmVuZGVyZXIueHNjYWxlLmludmVydCh2eCwgdHJ1ZSk7XG4gICAgICAgIHkgPSB0aGlzLnJlbmRlcmVyLnlzY2FsZS5pbnZlcnQodnksIHRydWUpO1xuICAgICAgICBzY2VudGVyX3ggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGosIHJlZjEsIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmMSA9IHRoaXMuc3gwLmxlbmd0aDsgMCA8PSByZWYxID8gaiA8IHJlZjEgOiBqID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnN4MFtpXSArIHRoaXMuc3dbaV0gLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICBzY2VudGVyX3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGosIHJlZjEsIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmMSA9IHRoaXMuc3kxLmxlbmd0aDsgMCA8PSByZWYxID8gaiA8IHJlZjEgOiBqID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnN5MVtpXSArIHRoaXMuc2hbaV0gLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICBtYXhfeDJfZGRpc3QgPSBhcnJheV8xLm1heCh0aGlzLl9kZGlzdCgwLCBzY2VudGVyX3gsIHRoaXMuc3NlbWlfZGlhZykpO1xuICAgICAgICBtYXhfeTJfZGRpc3QgPSBhcnJheV8xLm1heCh0aGlzLl9kZGlzdCgxLCBzY2VudGVyX3ksIHRoaXMuc3NlbWlfZGlhZykpO1xuICAgICAgICB4MCA9IHggLSBtYXhfeDJfZGRpc3Q7XG4gICAgICAgIHgxID0geCArIG1heF94Ml9kZGlzdDtcbiAgICAgICAgeTAgPSB5IC0gbWF4X3kyX2RkaXN0O1xuICAgICAgICB5MSA9IHkgKyBtYXhfeTJfZGRpc3Q7XG4gICAgICAgIGhpdHMgPSBbXTtcbiAgICAgICAgYmJveCA9IGhpdHRlc3QudmFsaWRhdGVfYmJveF9jb29yZHMoW3gwLCB4MV0sIFt5MCwgeTFdKTtcbiAgICAgICAgcmVmMSA9IHRoaXMuaW5kZXguaW5kaWNlcyhiYm94KTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IHJlZjFbal07XG4gICAgICAgICAgICBzeCA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52eF90b19zeCh2eCk7XG4gICAgICAgICAgICBzeSA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52eV90b19zeSh2eSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYW5nbGVbaV0pIHtcbiAgICAgICAgICAgICAgICBkID0gTWF0aC5zcXJ0KE1hdGgucG93KHN4IC0gdGhpcy5zeFtpXSwgMikgKyBNYXRoLnBvdyhzeSAtIHRoaXMuc3lbaV0sIDIpKTtcbiAgICAgICAgICAgICAgICBzID0gTWF0aC5zaW4oLXRoaXMuX2FuZ2xlW2ldKTtcbiAgICAgICAgICAgICAgICBjID0gTWF0aC5jb3MoLXRoaXMuX2FuZ2xlW2ldKTtcbiAgICAgICAgICAgICAgICBweCA9IGMgKiAoc3ggLSB0aGlzLnN4W2ldKSAtIHMgKiAoc3kgLSB0aGlzLnN5W2ldKSArIHRoaXMuc3hbaV07XG4gICAgICAgICAgICAgICAgcHkgPSBzICogKHN4IC0gdGhpcy5zeFtpXSkgKyBjICogKHN5IC0gdGhpcy5zeVtpXSkgKyB0aGlzLnN5W2ldO1xuICAgICAgICAgICAgICAgIHN4ID0gcHg7XG4gICAgICAgICAgICAgICAgc3kgPSBweTtcbiAgICAgICAgICAgICAgICB3aWR0aF9pbiA9IE1hdGguYWJzKHRoaXMuc3hbaV0gLSBzeCkgPD0gdGhpcy5zd1tpXSAvIDI7XG4gICAgICAgICAgICAgICAgaGVpZ2h0X2luID0gTWF0aC5hYnModGhpcy5zeVtpXSAtIHN5KSA8PSB0aGlzLnNoW2ldIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdpZHRoX2luID0gc3ggLSB0aGlzLnN4MFtpXSA8PSB0aGlzLnN3W2ldICYmIHN4IC0gdGhpcy5zeDBbaV0gPj0gMDtcbiAgICAgICAgICAgICAgICBoZWlnaHRfaW4gPSBzeSAtIHRoaXMuc3kxW2ldIDw9IHRoaXMuc2hbaV0gJiYgc3kgLSB0aGlzLnN5MVtpXSA+PSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodF9pbiAmJiB3aWR0aF9pbikge1xuICAgICAgICAgICAgICAgIGhpdHMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgcmVzdWx0WycxZCddLmluZGljZXMgPSBoaXRzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUmVjdFZpZXcucHJvdG90eXBlLl9tYXBfZGlzdF9jb3JuZXJfZm9yX2RhdGFfc2lkZV9sZW5ndGggPSBmdW5jdGlvbiAoY29vcmQsIHNpZGVfbGVuZ3RoLCBzY2FsZSwgY2FudmFzLCBkaW0pIHtcbiAgICAgICAgdmFyIGksIHB0MCwgcHQxLCByZXR1cm5fc3ludGhldGljLCBzc2lkZV9sZW5ndGgsIHN5bnRoZXRpY19wdCwgc3ludGhldGljX3B0X2Nvcm5lciwgdnB0MCwgdnB0MSwgdnB0X2Nvcm5lcjtcbiAgICAgICAgaWYgKHR5cGVzXzEuaXNTdHJpbmcoY29vcmRbMF0pICYmIHNjYWxlIGluc3RhbmNlb2YgY2F0ZWdvcmljYWxfc2NhbGVfMS5DYXRlZ29yaWNhbFNjYWxlKSB7XG4gICAgICAgICAgICByZXR1cm5fc3ludGhldGljID0gdHJ1ZTtcbiAgICAgICAgICAgIHN5bnRoZXRpY19wdCA9IHNjYWxlLnZfY29tcHV0ZShjb29yZCwgcmV0dXJuX3N5bnRoZXRpYyk7XG4gICAgICAgICAgICBpZiAoZGltID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ludGhldGljX3B0X2Nvcm5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvb3JkLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc3ludGhldGljX3B0W2ldIC0gc2lkZV9sZW5ndGhbaV0gLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGltID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc3ludGhldGljX3B0X2Nvcm5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvb3JkLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc3ludGhldGljX3B0W2ldICsgc2lkZV9sZW5ndGhbaV0gLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdnB0X2Nvcm5lciA9IHNjYWxlLnZfY29tcHV0ZShzeW50aGV0aWNfcHRfY29ybmVyKTtcbiAgICAgICAgICAgIHNzaWRlX2xlbmd0aCA9IHRoaXMuc2Rpc3Qoc2NhbGUsIGNvb3JkLCBzaWRlX2xlbmd0aCwgJ2NlbnRlcicsIHRoaXMubW9kZWwuZGlsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHB0MCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvb3JkLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChOdW1iZXIoY29vcmRbaV0pIC0gc2lkZV9sZW5ndGhbaV0gLyAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcHQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gY29vcmQubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKE51bWJlcihjb29yZFtpXSkgKyBzaWRlX2xlbmd0aFtpXSAvIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB2cHQwID0gc2NhbGUudl9jb21wdXRlKHB0MCk7XG4gICAgICAgICAgICB2cHQxID0gc2NhbGUudl9jb21wdXRlKHB0MSk7XG4gICAgICAgICAgICBzc2lkZV9sZW5ndGggPSB0aGlzLnNkaXN0KHNjYWxlLCBwdDAsIHNpZGVfbGVuZ3RoLCAnZWRnZScsIHRoaXMubW9kZWwuZGlsYXRlKTtcbiAgICAgICAgICAgIGlmIChkaW0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB2cHRfY29ybmVyID0gdnB0MFswXSA8IHZwdDFbMF0gPyB2cHQwIDogdnB0MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpbSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZwdF9jb3JuZXIgPSB2cHQwWzBdIDwgdnB0MVswXSA/IHZwdDEgOiB2cHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaW0gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbc3NpZGVfbGVuZ3RoLCBjYW52YXMudl92eF90b19zeCh2cHRfY29ybmVyKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGltID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NzaWRlX2xlbmd0aCwgY2FudmFzLnZfdnlfdG9fc3kodnB0X2Nvcm5lcildO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWN0Vmlldy5wcm90b3R5cGUuX2RkaXN0ID0gZnVuY3Rpb24gKGRpbSwgc3B0cywgc3BhbnMpIHtcbiAgICAgICAgdmFyIGksIHB0MCwgcHQxLCBzY2FsZSwgdnB0MCwgdnB0MSwgdnB0cztcbiAgICAgICAgaWYgKGRpbSA9PT0gMCkge1xuICAgICAgICAgICAgdnB0cyA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52X3N4X3RvX3Z4KHNwdHMpO1xuICAgICAgICAgICAgc2NhbGUgPSB0aGlzLnJlbmRlcmVyLnhzY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZwdHMgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudl92eV90b19zeShzcHRzKTtcbiAgICAgICAgICAgIHNjYWxlID0gdGhpcy5yZW5kZXJlci55c2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgdnB0MCA9IHZwdHM7XG4gICAgICAgIHZwdDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGosIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB2cHQwLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZwdDBbaV0gKyBzcGFuc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcHQwID0gc2NhbGUudl9pbnZlcnQodnB0MCk7XG4gICAgICAgIHB0MSA9IHNjYWxlLnZfaW52ZXJ0KHZwdDEpO1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gcHQwLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKE1hdGguYWJzKHB0MVtpXSAtIHB0MFtpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCk7XG4gICAgfTtcbiAgICBSZWN0Vmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmRfZm9yX2luZGV4ID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmljX2FyZWFfbGVnZW5kKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KTtcbiAgICB9O1xuICAgIFJlY3RWaWV3LnByb3RvdHlwZS5fYm91bmRzID0gZnVuY3Rpb24gKGJkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhfd2gyX2JvdW5kcyhiZHMpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY3RWaWV3O1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoVmlldyk7XG5leHBvcnRzLlJlY3QgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmVjdCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIFJlY3QuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJlY3QucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUmVjdFZpZXc7XG4gICAgUmVjdC5wcm90b3R5cGUudHlwZSA9ICdSZWN0JztcbiAgICBSZWN0Lm1peGlucyhbJ2xpbmUnLCAnZmlsbCddKTtcbiAgICBSZWN0LmRlZmluZSh7XG4gICAgICAgIGFuZ2xlOiBbcC5BbmdsZVNwZWMsIDBdLFxuICAgICAgICB3aWR0aDogW3AuRGlzdGFuY2VTcGVjXSxcbiAgICAgICAgaGVpZ2h0OiBbcC5EaXN0YW5jZVNwZWNdLFxuICAgICAgICBkaWxhdGU6IFtwLkJvb2wsIGZhbHNlXVxuICAgIH0pO1xuICAgIHJldHVybiBSZWN0O1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBoaXR0ZXN0ID0gcmVxdWlyZShcImNvcmUvaGl0dGVzdFwiKTtcbnZhciBzcGF0aWFsXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3NwYXRpYWxcIik7XG52YXIgZ2x5cGhfMSA9IHJlcXVpcmUoXCIuL2dseXBoXCIpO1xuZXhwb3J0cy5TZWdtZW50VmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTZWdtZW50Vmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gU2VnbWVudFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBTZWdtZW50Vmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2VnbWVudFZpZXcucHJvdG90eXBlLl9pbmRleF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgaiwgcG9pbnRzLCByZWY7XG4gICAgICAgIHBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdGhpcy5feDAubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIGlmICghaXNOYU4odGhpcy5feDBbaV0gKyB0aGlzLl94MVtpXSArIHRoaXMuX3kwW2ldICsgdGhpcy5feTFbaV0pKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtaW5YOiBNYXRoLm1pbih0aGlzLl94MFtpXSwgdGhpcy5feDFbaV0pLFxuICAgICAgICAgICAgICAgICAgICBtaW5ZOiBNYXRoLm1pbih0aGlzLl95MFtpXSwgdGhpcy5feTFbaV0pLFxuICAgICAgICAgICAgICAgICAgICBtYXhYOiBNYXRoLm1heCh0aGlzLl94MFtpXSwgdGhpcy5feDFbaV0pLFxuICAgICAgICAgICAgICAgICAgICBtYXhZOiBNYXRoLm1heCh0aGlzLl95MFtpXSwgdGhpcy5feTFbaV0pLFxuICAgICAgICAgICAgICAgICAgICBpOiBpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBzcGF0aWFsXzEuUkJ1c2gocG9pbnRzKTtcbiAgICB9O1xuICAgIFNlZ21lbnRWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBpLCBqLCBsZW4sIHJlc3VsdHMsIHN4MCwgc3gxLCBzeTAsIHN5MTtcbiAgICAgICAgc3gwID0gYXJnLnN4MCwgc3kwID0gYXJnLnN5MCwgc3gxID0gYXJnLnN4MSwgc3kxID0gYXJnLnN5MTtcbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpID0gaW5kaWNlc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oc3gwW2ldICsgc3kwW2ldICsgc3gxW2ldICsgc3kxW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3gwW2ldLCBzeTBbaV0pO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oc3gxW2ldLCBzeTFbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnN0cm9rZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWdtZW50Vmlldy5wcm90b3R5cGUuX2hpdF9wb2ludCA9IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlcywgZGlzdCwgaGl0cywgaSwgaiwgbGVuLCBwMCwgcDEsIHBvaW50LCByZWYsIHJlZjEsIHJlc3VsdCwgdGhyZXNob2xkLCB2eCwgdnksIHgsIHk7XG4gICAgICAgIHJlZiA9IFtnZW9tZXRyeS52eCwgZ2VvbWV0cnkudnldLCB2eCA9IHJlZlswXSwgdnkgPSByZWZbMV07XG4gICAgICAgIHggPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS5pbnZlcnQodngsIHRydWUpO1xuICAgICAgICB5ID0gdGhpcy5yZW5kZXJlci55c2NhbGUuaW52ZXJ0KHZ5LCB0cnVlKTtcbiAgICAgICAgcG9pbnQgPSB7XG4gICAgICAgICAgICB4OiB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudnhfdG9fc3godngpLFxuICAgICAgICAgICAgeTogdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzLnZ5X3RvX3N5KHZ5KVxuICAgICAgICB9O1xuICAgICAgICBoaXRzID0gW107XG4gICAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLmluZGV4LmluZGljZXMoe1xuICAgICAgICAgICAgbWluWDogeCxcbiAgICAgICAgICAgIG1pblk6IHksXG4gICAgICAgICAgICBtYXhYOiB4LFxuICAgICAgICAgICAgbWF4WTogeVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gY2FuZGlkYXRlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IGNhbmRpZGF0ZXNbal07XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBNYXRoLm1heCgyLCB0aGlzLnZpc3VhbHMubGluZS5jYWNoZV9zZWxlY3QoJ2xpbmVfd2lkdGgnLCBpKSAvIDIpO1xuICAgICAgICAgICAgcmVmMSA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHRoaXMuc3gwW2ldLFxuICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLnN5MFtpXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgeDogdGhpcy5zeDFbaV0sXG4gICAgICAgICAgICAgICAgICAgIHk6IHRoaXMuc3kxW2ldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSwgcDAgPSByZWYxWzBdLCBwMSA9IHJlZjFbMV07XG4gICAgICAgICAgICBkaXN0ID0gaGl0dGVzdC5kaXN0X3RvX3NlZ21lbnQocG9pbnQsIHAwLCBwMSk7XG4gICAgICAgICAgICBpZiAoZGlzdCA8IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIGhpdHMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgcmVzdWx0WycxZCddLmluZGljZXMgPSBoaXRzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgU2VnbWVudFZpZXcucHJvdG90eXBlLl9oaXRfc3BhbiA9IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlcywgaGl0cywgaHIsIGksIGosIGxlbiwgcmVmLCByZWYxLCByZWYyLCByZXN1bHQsIHYwLCB2MSwgdmFsLCB2ciwgdngsIHZ5O1xuICAgICAgICBociA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmZyYW1lLmhfcmFuZ2U7XG4gICAgICAgIHZyID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuZnJhbWUudl9yYW5nZTtcbiAgICAgICAgcmVmID0gW2dlb21ldHJ5LnZ4LCBnZW9tZXRyeS52eV0sIHZ4ID0gcmVmWzBdLCB2eSA9IHJlZlsxXTtcbiAgICAgICAgaWYgKGdlb21ldHJ5LmRpcmVjdGlvbiA9PT0gJ3YnKSB7XG4gICAgICAgICAgICB2YWwgPSB0aGlzLnJlbmRlcmVyLnlzY2FsZS5pbnZlcnQodnkpO1xuICAgICAgICAgICAgcmVmMSA9IFt0aGlzLl95MCwgdGhpcy5feTFdLCB2MCA9IHJlZjFbMF0sIHYxID0gcmVmMVsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IHRoaXMucmVuZGVyZXIueHNjYWxlLmludmVydCh2eCk7XG4gICAgICAgICAgICByZWYyID0gW3RoaXMuX3gwLCB0aGlzLl94MV0sIHYwID0gcmVmMlswXSwgdjEgPSByZWYyWzFdO1xuICAgICAgICB9XG4gICAgICAgIGhpdHMgPSBbXTtcbiAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuaW5kZXguaW5kaWNlcyh7XG4gICAgICAgICAgICBtaW5YOiB0aGlzLnJlbmRlcmVyLnhzY2FsZS5pbnZlcnQoaHIubWluKSxcbiAgICAgICAgICAgIG1pblk6IHRoaXMucmVuZGVyZXIueXNjYWxlLmludmVydCh2ci5taW4pLFxuICAgICAgICAgICAgbWF4WDogdGhpcy5yZW5kZXJlci54c2NhbGUuaW52ZXJ0KGhyLm1heCksXG4gICAgICAgICAgICBtYXhZOiB0aGlzLnJlbmRlcmVyLnlzY2FsZS5pbnZlcnQodnIubWF4KVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gY2FuZGlkYXRlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IGNhbmRpZGF0ZXNbal07XG4gICAgICAgICAgICBpZiAoKHYwW2ldIDw9IHZhbCAmJiB2YWwgPD0gdjFbaV0pIHx8ICh2MVtpXSA8PSB2YWwgJiYgdmFsIDw9IHYwW2ldKSkge1xuICAgICAgICAgICAgICAgIGhpdHMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgcmVzdWx0WycxZCddLmluZGljZXMgPSBoaXRzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgU2VnbWVudFZpZXcucHJvdG90eXBlLnNjeCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zeDBbaV0gKyB0aGlzLnN4MVtpXSkgLyAyO1xuICAgIH07XG4gICAgU2VnbWVudFZpZXcucHJvdG90eXBlLnNjeSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zeTBbaV0gKyB0aGlzLnN5MVtpXSkgLyAyO1xuICAgIH07XG4gICAgU2VnbWVudFZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kX2Zvcl9pbmRleCA9IGZ1bmN0aW9uIChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJpY19saW5lX2xlZ2VuZChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VnbWVudFZpZXc7XG59KShnbHlwaF8xLkdseXBoVmlldyk7XG5leHBvcnRzLlNlZ21lbnQgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU2VnbWVudCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gU2VnbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIFNlZ21lbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNlZ21lbnQucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuU2VnbWVudFZpZXc7XG4gICAgU2VnbWVudC5wcm90b3R5cGUudHlwZSA9ICdTZWdtZW50JztcbiAgICBTZWdtZW50LmNvb3JkcyhbWyd4MCcsICd5MCddLCBbJ3gxJywgJ3kxJ11dKTtcbiAgICBTZWdtZW50Lm1peGlucyhbJ2xpbmUnXSk7XG4gICAgcmV0dXJuIFNlZ21lbnQ7XG59KShnbHlwaF8xLkdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB4eV9nbHlwaF8xID0gcmVxdWlyZShcIi4veHlfZ2x5cGhcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLlRleHRWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRleHRWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUZXh0VmlldygpIHtcbiAgICAgICAgcmV0dXJuIFRleHRWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUZXh0Vmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZykge1xuICAgICAgICB2YXIgX2FuZ2xlLCBfdGV4dCwgX3hfb2Zmc2V0LCBfeV9vZmZzZXQsIGksIGosIGxlbiwgcmVzdWx0cywgc3gsIHN5O1xuICAgICAgICBzeCA9IGFyZy5zeCwgc3kgPSBhcmcuc3ksIF94X29mZnNldCA9IGFyZy5feF9vZmZzZXQsIF95X29mZnNldCA9IGFyZy5feV9vZmZzZXQsIF9hbmdsZSA9IGFyZy5fYW5nbGUsIF90ZXh0ID0gYXJnLl90ZXh0O1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGkgPSBpbmRpY2VzW2pdO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHN4W2ldICsgc3lbaV0gKyBfeF9vZmZzZXRbaV0gKyBfeV9vZmZzZXRbaV0gKyBfYW5nbGVbaV0pIHx8IChfdGV4dFtpXSA9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudmlzdWFscy50ZXh0LmRvaXQpIHtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoc3hbaV0gKyBfeF9vZmZzZXRbaV0sIHN5W2ldICsgX3lfb2Zmc2V0W2ldKTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKF9hbmdsZVtpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aXN1YWxzLnRleHQuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChfdGV4dFtpXSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5yZXN0b3JlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBUZXh0Vmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmRfZm9yX2luZGV4ID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMudGV4dF9wcm9wcy5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgY3R4LmZvbnQgPSB0aGlzLnRleHRfcHJvcHMuZm9udF92YWx1ZSgpO1xuICAgICAgICBjdHguZm9udCA9IGN0eC5mb250LnJlcGxhY2UoL1xcYltcXGRcXC5dK1tcXHddK1xcYi8sICcxMHB0Jyk7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgICBjdHguZmlsbFRleHQoXCJ0ZXh0XCIsIHgyLCAoeTEgKyB5MikgLyAyKTtcbiAgICAgICAgcmV0dXJuIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dFZpZXc7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGhWaWV3KTtcbmV4cG9ydHMuVGV4dCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUZXh0LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUZXh0KCkge1xuICAgICAgICByZXR1cm4gVGV4dC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGV4dC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5UZXh0VmlldztcbiAgICBUZXh0LnByb3RvdHlwZS50eXBlID0gJ1RleHQnO1xuICAgIFRleHQubWl4aW5zKFsndGV4dCddKTtcbiAgICBUZXh0LmRlZmluZSh7XG4gICAgICAgIHRleHQ6IFtcbiAgICAgICAgICAgIHAuU3RyaW5nU3BlYywge1xuICAgICAgICAgICAgICAgIGZpZWxkOiBcInRleHRcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBhbmdsZTogW3AuQW5nbGVTcGVjLCAwXSxcbiAgICAgICAgeF9vZmZzZXQ6IFtwLk51bWJlclNwZWMsIDBdLFxuICAgICAgICB5X29mZnNldDogW3AuTnVtYmVyU3BlYywgMF1cbiAgICB9KTtcbiAgICByZXR1cm4gVGV4dDtcbn0pKHh5X2dseXBoXzEuWFlHbHlwaCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgc3BhdGlhbF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9zcGF0aWFsXCIpO1xudmFyIGdseXBoXzEgPSByZXF1aXJlKFwiLi9nbHlwaFwiKTtcbnZhciBjYXRlZ29yaWNhbF9zY2FsZV8xID0gcmVxdWlyZShcIi4uL3NjYWxlcy9jYXRlZ29yaWNhbF9zY2FsZVwiKTtcbnZhciBoaXR0ZXN0ID0gcmVxdWlyZShcImNvcmUvaGl0dGVzdFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuVkJhclZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVkJhclZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFZCYXJWaWV3KCkge1xuICAgICAgICByZXR1cm4gVkJhclZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFZCYXJWaWV3LnByb3RvdHlwZS5fbWFwX2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLCBqLCByZWYsIHZib3R0b20sIHZ0b3A7XG4gICAgICAgIHRoaXMuc3ggPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS52X2NvbXB1dGUodGhpcy5feCk7XG4gICAgICAgIHZ0b3AgPSB0aGlzLnJlbmRlcmVyLnlzY2FsZS52X2NvbXB1dGUodGhpcy5fdG9wKTtcbiAgICAgICAgdmJvdHRvbSA9IHRoaXMucmVuZGVyZXIueXNjYWxlLnZfY29tcHV0ZSh0aGlzLl9ib3R0b20pO1xuICAgICAgICB0aGlzLnN0b3AgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudl92eV90b19zeSh2dG9wKTtcbiAgICAgICAgdGhpcy5zYm90dG9tID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzLnZfdnlfdG9fc3kodmJvdHRvbSk7XG4gICAgICAgIHRoaXMuc2xlZnQgPSBbXTtcbiAgICAgICAgdGhpcy5zcmlnaHQgPSBbXTtcbiAgICAgICAgdGhpcy5zdyA9IHRoaXMuc2Rpc3QodGhpcy5yZW5kZXJlci54c2NhbGUsIHRoaXMuX3gsIHRoaXMuX3dpZHRoLCAnY2VudGVyJyk7XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB0aGlzLnN4Lmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICB0aGlzLnNsZWZ0LnB1c2godGhpcy5zeFtpXSAtIHRoaXMuc3dbaV0gLyAyKTtcbiAgICAgICAgICAgIHRoaXMuc3JpZ2h0LnB1c2godGhpcy5zeFtpXSArIHRoaXMuc3dbaV0gLyAyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFZCYXJWaWV3LnByb3RvdHlwZS5faW5kZXhfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIsIGJvdHRvbSwgaSwgaiwgbCwgbWFwX3RvX3N5bnRoZXRpYywgcG9pbnRzLCByLCByZWYsIHQsIHRvcCwgd2lkdGgsIHg7XG4gICAgICAgIG1hcF90b19zeW50aGV0aWMgPSBmdW5jdGlvbiAoc2NhbGUsIGFycmF5KSB7XG4gICAgICAgICAgICBpZiAoc2NhbGUgaW5zdGFuY2VvZiBjYXRlZ29yaWNhbF9zY2FsZV8xLkNhdGVnb3JpY2FsU2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGUudl9jb21wdXRlKGFycmF5LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeCA9IG1hcF90b19zeW50aGV0aWModGhpcy5yZW5kZXJlci54c2NhbGUsIHRoaXMuX3gpO1xuICAgICAgICB3aWR0aCA9IG1hcF90b19zeW50aGV0aWModGhpcy5yZW5kZXJlci54c2NhbGUsIHRoaXMuX3dpZHRoKTtcbiAgICAgICAgdG9wID0gbWFwX3RvX3N5bnRoZXRpYyh0aGlzLnJlbmRlcmVyLnlzY2FsZSwgdGhpcy5fdG9wKTtcbiAgICAgICAgYm90dG9tID0gbWFwX3RvX3N5bnRoZXRpYyh0aGlzLnJlbmRlcmVyLnlzY2FsZSwgdGhpcy5fYm90dG9tKTtcbiAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB4Lmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICBsID0geFtpXSAtIHdpZHRoW2ldIC8gMjtcbiAgICAgICAgICAgIHIgPSB4W2ldICsgd2lkdGhbaV0gLyAyO1xuICAgICAgICAgICAgdCA9IHRvcFtpXTtcbiAgICAgICAgICAgIGIgPSBib3R0b21baV07XG4gICAgICAgICAgICBpZiAoaXNOYU4obCArIHIgKyB0ICsgYikgfHwgIWlzRmluaXRlKGwgKyByICsgdCArIGIpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWluWDogbCxcbiAgICAgICAgICAgICAgICBtaW5ZOiBiLFxuICAgICAgICAgICAgICAgIG1heFg6IHIsXG4gICAgICAgICAgICAgICAgbWF4WTogdCxcbiAgICAgICAgICAgICAgICBpOiBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHNwYXRpYWxfMS5SQnVzaChwb2ludHMpO1xuICAgIH07XG4gICAgVkJhclZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGosIGxlbiwgcmVzdWx0cywgc2JvdHRvbSwgc2xlZnQsIHNyaWdodCwgc3RvcDtcbiAgICAgICAgc2xlZnQgPSBhcmcuc2xlZnQsIHNyaWdodCA9IGFyZy5zcmlnaHQsIHN0b3AgPSBhcmcuc3RvcCwgc2JvdHRvbSA9IGFyZy5zYm90dG9tO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGkgPSBpbmRpY2VzW2pdO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHNsZWZ0W2ldICsgc3RvcFtpXSArIHNyaWdodFtpXSArIHNib3R0b21baV0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3Qoc2xlZnRbaV0sIHN0b3BbaV0sIHNyaWdodFtpXSAtIHNsZWZ0W2ldLCBzYm90dG9tW2ldIC0gc3RvcFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVjdChzbGVmdFtpXSwgc3RvcFtpXSwgc3JpZ2h0W2ldIC0gc2xlZnRbaV0sIHNib3R0b21baV0gLSBzdG9wW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIFZCYXJWaWV3LnByb3RvdHlwZS5faGl0X3BvaW50ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBoaXRzLCByZWYsIHJlc3VsdCwgdngsIHZ5LCB4LCB5O1xuICAgICAgICByZWYgPSBbZ2VvbWV0cnkudngsIGdlb21ldHJ5LnZ5XSwgdnggPSByZWZbMF0sIHZ5ID0gcmVmWzFdO1xuICAgICAgICB4ID0gdGhpcy5yZW5kZXJlci54c2NhbGUuaW52ZXJ0KHZ4LCB0cnVlKTtcbiAgICAgICAgeSA9IHRoaXMucmVuZGVyZXIueXNjYWxlLmludmVydCh2eSwgdHJ1ZSk7XG4gICAgICAgIGhpdHMgPSB0aGlzLmluZGV4LmluZGljZXMoe1xuICAgICAgICAgICAgbWluWDogeCxcbiAgICAgICAgICAgIG1pblk6IHksXG4gICAgICAgICAgICBtYXhYOiB4LFxuICAgICAgICAgICAgbWF4WTogeVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0ID0gaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCk7XG4gICAgICAgIHJlc3VsdFsnMWQnXS5pbmRpY2VzID0gaGl0cztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFZCYXJWaWV3LnByb3RvdHlwZS5zY3kgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RvcFtpXSArIHRoaXMuc2JvdHRvbVtpXSkgLyAyO1xuICAgIH07XG4gICAgVkJhclZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kX2Zvcl9pbmRleCA9IGZ1bmN0aW9uIChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJpY19hcmVhX2xlZ2VuZChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCk7XG4gICAgfTtcbiAgICByZXR1cm4gVkJhclZpZXc7XG59KShnbHlwaF8xLkdseXBoVmlldyk7XG5leHBvcnRzLlZCYXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVkJhciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVkJhcigpIHtcbiAgICAgICAgcmV0dXJuIFZCYXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFZCYXIucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuVkJhclZpZXc7XG4gICAgVkJhci5wcm90b3R5cGUudHlwZSA9ICdWQmFyJztcbiAgICBWQmFyLm1peGlucyhbJ2xpbmUnLCAnZmlsbCddKTtcbiAgICBWQmFyLmRlZmluZSh7XG4gICAgICAgIHg6IFtwLk51bWJlclNwZWNdLFxuICAgICAgICB3aWR0aDogW3AuRGlzdGFuY2VTcGVjXSxcbiAgICAgICAgdG9wOiBbcC5OdW1iZXJTcGVjXSxcbiAgICAgICAgYm90dG9tOiBbcC5OdW1iZXJTcGVjLCAwXVxuICAgIH0pO1xuICAgIHJldHVybiBWQmFyO1xufSkoZ2x5cGhfMS5HbHlwaCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgeHlfZ2x5cGhfMSA9IHJlcXVpcmUoXCIuL3h5X2dseXBoXCIpO1xudmFyIGhpdHRlc3QgPSByZXF1aXJlKFwiY29yZS9oaXR0ZXN0XCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIG1hdGhfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvbWF0aFwiKTtcbmV4cG9ydHMuV2VkZ2VWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFdlZGdlVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gV2VkZ2VWaWV3KCkge1xuICAgICAgICByZXR1cm4gV2VkZ2VWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBXZWRnZVZpZXcucHJvdG90eXBlLl9tYXBfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy5yYWRpdXMudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcmFkaXVzID0gdGhpcy5zZGlzdCh0aGlzLnJlbmRlcmVyLnhzY2FsZSwgdGhpcy5feCwgdGhpcy5fcmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNyYWRpdXMgPSB0aGlzLl9yYWRpdXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdlZGdlVmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZykge1xuICAgICAgICB2YXIgX2VuZF9hbmdsZSwgX3N0YXJ0X2FuZ2xlLCBkaXJlY3Rpb24sIGksIGosIGxlbiwgcmVzdWx0cywgc3JhZGl1cywgc3gsIHN5O1xuICAgICAgICBzeCA9IGFyZy5zeCwgc3kgPSBhcmcuc3ksIHNyYWRpdXMgPSBhcmcuc3JhZGl1cywgX3N0YXJ0X2FuZ2xlID0gYXJnLl9zdGFydF9hbmdsZSwgX2VuZF9hbmdsZSA9IGFyZy5fZW5kX2FuZ2xlO1xuICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLm1vZGVsLnByb3BlcnRpZXMuZGlyZWN0aW9uLnZhbHVlKCk7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IGluZGljZXNbal07XG4gICAgICAgICAgICBpZiAoaXNOYU4oc3hbaV0gKyBzeVtpXSArIHNyYWRpdXNbaV0gKyBfc3RhcnRfYW5nbGVbaV0gKyBfZW5kX2FuZ2xlW2ldKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyhzeFtpXSwgc3lbaV0sIHNyYWRpdXNbaV0sIF9zdGFydF9hbmdsZVtpXSwgX2VuZF9hbmdsZVtpXSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oc3hbaV0sIHN5W2ldKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc3VhbHMuZmlsbC5kb2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXN1YWxzLmZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnN0cm9rZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgV2VkZ2VWaWV3LnByb3RvdHlwZS5faGl0X3BvaW50ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBhbmdsZSwgYmJveCwgY2FuZGlkYXRlcywgZGlyZWN0aW9uLCBkaXN0LCBoaXRzLCBpLCBqLCBrLCBsZW4sIGxlbjEsIHIyLCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHN4LCBzeDAsIHN4MSwgc3ksIHN5MCwgc3kxLCB2eCwgdngwLCB2eDEsIHZ5LCB2eTAsIHZ5MSwgeCwgeDAsIHgxLCB5LCB5MCwgeTE7XG4gICAgICAgIHJlZiA9IFtnZW9tZXRyeS52eCwgZ2VvbWV0cnkudnldLCB2eCA9IHJlZlswXSwgdnkgPSByZWZbMV07XG4gICAgICAgIHggPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS5pbnZlcnQodngsIHRydWUpO1xuICAgICAgICB5ID0gdGhpcy5yZW5kZXJlci55c2NhbGUuaW52ZXJ0KHZ5LCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy5yYWRpdXMudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICB4MCA9IHggLSB0aGlzLm1heF9yYWRpdXM7XG4gICAgICAgICAgICB4MSA9IHggKyB0aGlzLm1heF9yYWRpdXM7XG4gICAgICAgICAgICB5MCA9IHkgLSB0aGlzLm1heF9yYWRpdXM7XG4gICAgICAgICAgICB5MSA9IHkgKyB0aGlzLm1heF9yYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2eDAgPSB2eCAtIHRoaXMubWF4X3JhZGl1cztcbiAgICAgICAgICAgIHZ4MSA9IHZ4ICsgdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgcmVmMSA9IHRoaXMucmVuZGVyZXIueHNjYWxlLnZfaW52ZXJ0KFt2eDAsIHZ4MV0sIHRydWUpLCB4MCA9IHJlZjFbMF0sIHgxID0gcmVmMVsxXTtcbiAgICAgICAgICAgIHZ5MCA9IHZ5IC0gdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgdnkxID0gdnkgKyB0aGlzLm1heF9yYWRpdXM7XG4gICAgICAgICAgICByZWYyID0gdGhpcy5yZW5kZXJlci55c2NhbGUudl9pbnZlcnQoW3Z5MCwgdnkxXSwgdHJ1ZSksIHkwID0gcmVmMlswXSwgeTEgPSByZWYyWzFdO1xuICAgICAgICB9XG4gICAgICAgIGNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgICAgYmJveCA9IGhpdHRlc3QudmFsaWRhdGVfYmJveF9jb29yZHMoW3gwLCB4MV0sIFt5MCwgeTFdKTtcbiAgICAgICAgcmVmMyA9IHRoaXMuaW5kZXguaW5kaWNlcyhiYm94KTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmMy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IHJlZjNbal07XG4gICAgICAgICAgICByMiA9IE1hdGgucG93KHRoaXMuc3JhZGl1c1tpXSwgMik7XG4gICAgICAgICAgICBzeDAgPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS5jb21wdXRlKHgsIHRydWUpO1xuICAgICAgICAgICAgc3gxID0gdGhpcy5yZW5kZXJlci54c2NhbGUuY29tcHV0ZSh0aGlzLl94W2ldLCB0cnVlKTtcbiAgICAgICAgICAgIHN5MCA9IHRoaXMucmVuZGVyZXIueXNjYWxlLmNvbXB1dGUoeSwgdHJ1ZSk7XG4gICAgICAgICAgICBzeTEgPSB0aGlzLnJlbmRlcmVyLnlzY2FsZS5jb21wdXRlKHRoaXMuX3lbaV0sIHRydWUpO1xuICAgICAgICAgICAgZGlzdCA9IE1hdGgucG93KHN4MCAtIHN4MSwgMikgKyBNYXRoLnBvdyhzeTAgLSBzeTEsIDIpO1xuICAgICAgICAgICAgaWYgKGRpc3QgPD0gcjIpIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goW2ksIGRpc3RdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLm1vZGVsLnByb3BlcnRpZXMuZGlyZWN0aW9uLnZhbHVlKCk7XG4gICAgICAgIGhpdHMgPSBbXTtcbiAgICAgICAgZm9yIChrID0gMCwgbGVuMSA9IGNhbmRpZGF0ZXMubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICAgICAgICByZWY0ID0gY2FuZGlkYXRlc1trXSwgaSA9IHJlZjRbMF0sIGRpc3QgPSByZWY0WzFdO1xuICAgICAgICAgICAgc3ggPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudnhfdG9fc3godngpO1xuICAgICAgICAgICAgc3kgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudnlfdG9fc3kodnkpO1xuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKHN5IC0gdGhpcy5zeVtpXSwgc3ggLSB0aGlzLnN4W2ldKTtcbiAgICAgICAgICAgIGlmIChtYXRoXzEuYW5nbGVfYmV0d2VlbigtYW5nbGUsIC10aGlzLl9zdGFydF9hbmdsZVtpXSwgLXRoaXMuX2VuZF9hbmdsZVtpXSwgZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIGhpdHMucHVzaChbaSwgZGlzdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaXR0ZXN0LmNyZWF0ZV8xZF9oaXRfdGVzdF9yZXN1bHQoaGl0cyk7XG4gICAgfTtcbiAgICBXZWRnZVZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kX2Zvcl9pbmRleCA9IGZ1bmN0aW9uIChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJpY19hcmVhX2xlZ2VuZChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCk7XG4gICAgfTtcbiAgICByZXR1cm4gV2VkZ2VWaWV3O1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoVmlldyk7XG5leHBvcnRzLldlZGdlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFdlZGdlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBXZWRnZSgpIHtcbiAgICAgICAgcmV0dXJuIFdlZGdlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBXZWRnZS5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5XZWRnZVZpZXc7XG4gICAgV2VkZ2UucHJvdG90eXBlLnR5cGUgPSAnV2VkZ2UnO1xuICAgIFdlZGdlLm1peGlucyhbJ2xpbmUnLCAnZmlsbCddKTtcbiAgICBXZWRnZS5kZWZpbmUoe1xuICAgICAgICBkaXJlY3Rpb246IFtwLkRpcmVjdGlvbiwgJ2FudGljbG9jayddLFxuICAgICAgICByYWRpdXM6IFtwLkRpc3RhbmNlU3BlY10sXG4gICAgICAgIHN0YXJ0X2FuZ2xlOiBbcC5BbmdsZVNwZWNdLFxuICAgICAgICBlbmRfYW5nbGU6IFtwLkFuZ2xlU3BlY11cbiAgICB9KTtcbiAgICByZXR1cm4gV2VkZ2U7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHNwYXRpYWxfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvc3BhdGlhbFwiKTtcbnZhciBnbHlwaF8xID0gcmVxdWlyZShcIi4vZ2x5cGhcIik7XG52YXIgY2F0ZWdvcmljYWxfc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi9zY2FsZXMvY2F0ZWdvcmljYWxfc2NhbGVcIik7XG5leHBvcnRzLlhZR2x5cGhWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhZR2x5cGhWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBYWUdseXBoVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFhZR2x5cGhWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBYWUdseXBoVmlldy5wcm90b3R5cGUuX2luZGV4X2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLCBqLCBwb2ludHMsIHJlZiwgeCwgeHgsIHksIHl5O1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJlci54c2NhbGUgaW5zdGFuY2VvZiBjYXRlZ29yaWNhbF9zY2FsZV8xLkNhdGVnb3JpY2FsU2NhbGUpIHtcbiAgICAgICAgICAgIHh4ID0gdGhpcy5yZW5kZXJlci54c2NhbGUudl9jb21wdXRlKHRoaXMuX3gsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeHggPSB0aGlzLl94O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLnlzY2FsZSBpbnN0YW5jZW9mIGNhdGVnb3JpY2FsX3NjYWxlXzEuQ2F0ZWdvcmljYWxTY2FsZSkge1xuICAgICAgICAgICAgeXkgPSB0aGlzLnJlbmRlcmVyLnlzY2FsZS52X2NvbXB1dGUodGhpcy5feSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5eSA9IHRoaXMuX3k7XG4gICAgICAgIH1cbiAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB4eC5sZW5ndGg7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgeCA9IHh4W2ldO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHgpIHx8ICFpc0Zpbml0ZSh4KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeSA9IHl5W2ldO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHkpIHx8ICFpc0Zpbml0ZSh5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1pblg6IHgsXG4gICAgICAgICAgICAgICAgbWluWTogeSxcbiAgICAgICAgICAgICAgICBtYXhYOiB4LFxuICAgICAgICAgICAgICAgIG1heFk6IHksXG4gICAgICAgICAgICAgICAgaTogaVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBzcGF0aWFsXzEuUkJ1c2gocG9pbnRzKTtcbiAgICB9O1xuICAgIHJldHVybiBYWUdseXBoVmlldztcbn0pKGdseXBoXzEuR2x5cGhWaWV3KTtcbmV4cG9ydHMuWFlHbHlwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYWUdseXBoLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBYWUdseXBoKCkge1xuICAgICAgICByZXR1cm4gWFlHbHlwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgWFlHbHlwaC5wcm90b3R5cGUudHlwZSA9IFwiWFlHbHlwaFwiO1xuICAgIFhZR2x5cGgucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuWFlHbHlwaFZpZXc7XG4gICAgWFlHbHlwaC5jb29yZHMoW1sneCcsICd5J11dKTtcbiAgICByZXR1cm4gWFlHbHlwaDtcbn0pKGdseXBoXzEuR2x5cGgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGd1aWRlX3JlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi4vcmVuZGVyZXJzL2d1aWRlX3JlbmRlcmVyXCIpO1xudmFyIHJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi4vcmVuZGVyZXJzL3JlbmRlcmVyXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xuZXhwb3J0cy5HcmlkVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChHcmlkVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gR3JpZFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBHcmlkVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgR3JpZFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgR3JpZFZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3hfcmFuZ2VfbmFtZSA9IHRoaXMubW9kZWwueF9yYW5nZV9uYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy5feV9yYW5nZV9uYW1lID0gdGhpcy5tb2RlbC55X3JhbmdlX25hbWU7XG4gICAgfTtcbiAgICBHcmlkVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3R4O1xuICAgICAgICBpZiAodGhpcy5tb2RlbC52aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5fZHJhd19yZWdpb25zKGN0eCk7XG4gICAgICAgIHRoaXMuX2RyYXdfbWlub3JfZ3JpZHMoY3R4KTtcbiAgICAgICAgdGhpcy5fZHJhd19ncmlkcyhjdHgpO1xuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIEdyaWRWaWV3LnByb3RvdHlwZS5jb25uZWN0X3NpZ25hbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIEdyaWRWaWV3Ll9fc3VwZXJfXy5jb25uZWN0X3NpZ25hbHMuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHcmlkVmlldy5wcm90b3R5cGUuX2RyYXdfcmVnaW9ucyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIGksIGssIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgc3gwLCBzeDEsIHN5MCwgc3kxLCB4cywgeXM7XG4gICAgICAgIGlmICghdGhpcy52aXN1YWxzLmJhbmRfZmlsbC5kb2l0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5ncmlkX2Nvb3JkcygnbWFqb3InLCBmYWxzZSksIHhzID0gcmVmWzBdLCB5cyA9IHJlZlsxXTtcbiAgICAgICAgdGhpcy52aXN1YWxzLmJhbmRfZmlsbC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZjEgPSB4cy5sZW5ndGggLSAxOyAwIDw9IHJlZjEgPyBrIDwgcmVmMSA6IGsgPiByZWYxOyBpID0gMCA8PSByZWYxID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBpZiAoaSAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZWYyID0gdGhpcy5wbG90X3ZpZXcubWFwX3RvX3NjcmVlbih4c1tpXSwgeXNbaV0sIHRoaXMuX3hfcmFuZ2VfbmFtZSwgdGhpcy5feV9yYW5nZV9uYW1lKSwgc3gwID0gcmVmMlswXSwgc3kwID0gcmVmMlsxXTtcbiAgICAgICAgICAgICAgICByZWYzID0gdGhpcy5wbG90X3ZpZXcubWFwX3RvX3NjcmVlbih4c1tpICsgMV0sIHlzW2kgKyAxXSwgdGhpcy5feF9yYW5nZV9uYW1lLCB0aGlzLl95X3JhbmdlX25hbWUpLCBzeDEgPSByZWYzWzBdLCBzeTEgPSByZWYzWzFdO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChzeDBbMF0sIHN5MFswXSwgc3gxWzFdIC0gc3gwWzBdLCBzeTFbMV0gLSBzeTBbMF0pO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRWaWV3LnByb3RvdHlwZS5fZHJhd19ncmlkcyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIHJlZiwgeHMsIHlzO1xuICAgICAgICBpZiAoIXRoaXMudmlzdWFscy5ncmlkX2xpbmUuZG9pdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwuZ3JpZF9jb29yZHMoJ21ham9yJyksIHhzID0gcmVmWzBdLCB5cyA9IHJlZlsxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyYXdfZ3JpZF9oZWxwZXIoY3R4LCB0aGlzLnZpc3VhbHMuZ3JpZF9saW5lLCB4cywgeXMpO1xuICAgIH07XG4gICAgR3JpZFZpZXcucHJvdG90eXBlLl9kcmF3X21pbm9yX2dyaWRzID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgcmVmLCB4cywgeXM7XG4gICAgICAgIGlmICghdGhpcy52aXN1YWxzLm1pbm9yX2dyaWRfbGluZS5kb2l0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5ncmlkX2Nvb3JkcygnbWlub3InKSwgeHMgPSByZWZbMF0sIHlzID0gcmVmWzFdO1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJhd19ncmlkX2hlbHBlcihjdHgsIHRoaXMudmlzdWFscy5taW5vcl9ncmlkX2xpbmUsIHhzLCB5cyk7XG4gICAgfTtcbiAgICBHcmlkVmlldy5wcm90b3R5cGUuX2RyYXdfZ3JpZF9oZWxwZXIgPSBmdW5jdGlvbiAoY3R4LCBwcm9wcywgeHMsIHlzKSB7XG4gICAgICAgIHZhciBpLCBrLCBsLCByZWYsIHJlZjEsIHJlZjIsIHN4LCBzeTtcbiAgICAgICAgcHJvcHMuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYgPSB4cy5sZW5ndGg7IDAgPD0gcmVmID8gayA8IHJlZiA6IGsgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgcmVmMSA9IHRoaXMucGxvdF92aWV3Lm1hcF90b19zY3JlZW4oeHNbaV0sIHlzW2ldLCB0aGlzLl94X3JhbmdlX25hbWUsIHRoaXMuX3lfcmFuZ2VfbmFtZSksIHN4ID0gcmVmMVswXSwgc3kgPSByZWYxWzFdO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhNYXRoLnJvdW5kKHN4WzBdKSwgTWF0aC5yb3VuZChzeVswXSkpO1xuICAgICAgICAgICAgZm9yIChpID0gbCA9IDEsIHJlZjIgPSBzeC5sZW5ndGg7IDEgPD0gcmVmMiA/IGwgPCByZWYyIDogbCA+IHJlZjI7IGkgPSAxIDw9IHJlZjIgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKE1hdGgucm91bmQoc3hbaV0pLCBNYXRoLnJvdW5kKHN5W2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBHcmlkVmlldztcbn0pKHJlbmRlcmVyXzEuUmVuZGVyZXJWaWV3KTtcbmV4cG9ydHMuR3JpZCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChHcmlkLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBHcmlkKCkge1xuICAgICAgICByZXR1cm4gR3JpZC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgR3JpZC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5HcmlkVmlldztcbiAgICBHcmlkLnByb3RvdHlwZS50eXBlID0gJ0dyaWQnO1xuICAgIEdyaWQubWl4aW5zKFsnbGluZTpncmlkXycsICdsaW5lOm1pbm9yX2dyaWRfJywgJ2ZpbGw6YmFuZF8nXSk7XG4gICAgR3JpZC5kZWZpbmUoe1xuICAgICAgICBib3VuZHM6IFtwLkFueSwgJ2F1dG8nXSxcbiAgICAgICAgZGltZW5zaW9uOiBbcC5OdW1iZXIsIDBdLFxuICAgICAgICB0aWNrZXI6IFtwLkluc3RhbmNlXSxcbiAgICAgICAgeF9yYW5nZV9uYW1lOiBbcC5TdHJpbmcsICdkZWZhdWx0J10sXG4gICAgICAgIHlfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddXG4gICAgfSk7XG4gICAgR3JpZC5vdmVycmlkZSh7XG4gICAgICAgIGxldmVsOiBcInVuZGVybGF5XCIsXG4gICAgICAgIGJhbmRfZmlsbF9jb2xvcjogbnVsbCxcbiAgICAgICAgYmFuZF9maWxsX2FscGhhOiAwLFxuICAgICAgICBncmlkX2xpbmVfY29sb3I6ICcjZTVlNWU1JyxcbiAgICAgICAgbWlub3JfZ3JpZF9saW5lX2NvbG9yOiBudWxsXG4gICAgfSk7XG4gICAgR3JpZC5wcm90b3R5cGUucmFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZnJhbWUsIGksIGosIHJhbmdlcztcbiAgICAgICAgaSA9IHRoaXMuZGltZW5zaW9uO1xuICAgICAgICBqID0gKGkgKyAxKSAlIDI7XG4gICAgICAgIGZyYW1lID0gdGhpcy5wbG90LnBsb3RfY2FudmFzLmZyYW1lO1xuICAgICAgICByYW5nZXMgPSBbZnJhbWUueF9yYW5nZXNbdGhpcy54X3JhbmdlX25hbWVdLCBmcmFtZS55X3Jhbmdlc1t0aGlzLnlfcmFuZ2VfbmFtZV1dO1xuICAgICAgICByZXR1cm4gW3Jhbmdlc1tpXSwgcmFuZ2VzW2pdXTtcbiAgICB9O1xuICAgIEdyaWQucHJvdG90eXBlLmNvbXB1dGVkX2JvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNyb3NzX3JhbmdlLCBlbmQsIHJhbmdlLCByYW5nZV9ib3VuZHMsIHJlZiwgc3RhcnQsIHVzZXJfYm91bmRzO1xuICAgICAgICByZWYgPSB0aGlzLnJhbmdlcygpLCByYW5nZSA9IHJlZlswXSwgY3Jvc3NfcmFuZ2UgPSByZWZbMV07XG4gICAgICAgIHVzZXJfYm91bmRzID0gdGhpcy5ib3VuZHM7XG4gICAgICAgIHJhbmdlX2JvdW5kcyA9IFtyYW5nZS5taW4sIHJhbmdlLm1heF07XG4gICAgICAgIGlmICh0eXBlc18xLmlzQXJyYXkodXNlcl9ib3VuZHMpKSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWluKHVzZXJfYm91bmRzWzBdLCB1c2VyX2JvdW5kc1sxXSk7XG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1heCh1c2VyX2JvdW5kc1swXSwgdXNlcl9ib3VuZHNbMV0pO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgcmFuZ2VfYm91bmRzWzBdKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSByYW5nZV9ib3VuZHNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydCA+IHJhbmdlX2JvdW5kc1sxXSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPiByYW5nZV9ib3VuZHNbMV0pIHtcbiAgICAgICAgICAgICAgICBlbmQgPSByYW5nZV9ib3VuZHNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPCByYW5nZV9ib3VuZHNbMF0pIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSByYW5nZV9ib3VuZHNbMF0sIGVuZCA9IHJhbmdlX2JvdW5kc1sxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3N0YXJ0LCBlbmRdO1xuICAgIH07XG4gICAgR3JpZC5wcm90b3R5cGUuZ3JpZF9jb29yZHMgPSBmdW5jdGlvbiAobG9jYXRpb24sIGV4Y2x1ZGVfZW5kcykge1xuICAgICAgICB2YXIgTiwgY21heCwgY21pbiwgY29vcmRzLCBjcm9zc19yYW5nZSwgZGltX2ksIGRpbV9qLCBlbmQsIGksIGlpLCBqLCBrLCBsLCBsb2MsIG1heCwgbWluLCBuLCByYW5nZSwgcmVmLCByZWYxLCByZWYyLCByZWYzLCBzdGFydCwgdGlja3MsIHRtcDtcbiAgICAgICAgaWYgKGV4Y2x1ZGVfZW5kcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBleGNsdWRlX2VuZHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGkgPSB0aGlzLmRpbWVuc2lvbjtcbiAgICAgICAgaiA9IChpICsgMSkgJSAyO1xuICAgICAgICByZWYgPSB0aGlzLnJhbmdlcygpLCByYW5nZSA9IHJlZlswXSwgY3Jvc3NfcmFuZ2UgPSByZWZbMV07XG4gICAgICAgIHJlZjEgPSB0aGlzLmNvbXB1dGVkX2JvdW5kcygpLCBzdGFydCA9IHJlZjFbMF0sIGVuZCA9IHJlZjFbMV07XG4gICAgICAgIHRtcCA9IE1hdGgubWluKHN0YXJ0LCBlbmQpO1xuICAgICAgICBlbmQgPSBNYXRoLm1heChzdGFydCwgZW5kKTtcbiAgICAgICAgc3RhcnQgPSB0bXA7XG4gICAgICAgIHRpY2tzID0gdGhpcy50aWNrZXIuZ2V0X3RpY2tzKHN0YXJ0LCBlbmQsIHJhbmdlLCBjcm9zc19yYW5nZS5taW4sIHt9KVtsb2NhdGlvbl07XG4gICAgICAgIG1pbiA9IHJhbmdlLm1pbjtcbiAgICAgICAgbWF4ID0gcmFuZ2UubWF4O1xuICAgICAgICBjbWluID0gY3Jvc3NfcmFuZ2UubWluO1xuICAgICAgICBjbWF4ID0gY3Jvc3NfcmFuZ2UubWF4O1xuICAgICAgICBjb29yZHMgPSBbW10sIFtdXTtcbiAgICAgICAgZm9yIChpaSA9IGsgPSAwLCByZWYyID0gdGlja3MubGVuZ3RoOyAwIDw9IHJlZjIgPyBrIDwgcmVmMiA6IGsgPiByZWYyOyBpaSA9IDAgPD0gcmVmMiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgaWYgKCh0aWNrc1tpaV0gPT09IG1pbiB8fCB0aWNrc1tpaV0gPT09IG1heCkgJiYgZXhjbHVkZV9lbmRzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaW1faSA9IFtdO1xuICAgICAgICAgICAgZGltX2ogPSBbXTtcbiAgICAgICAgICAgIE4gPSAyO1xuICAgICAgICAgICAgZm9yIChuID0gbCA9IDAsIHJlZjMgPSBOOyAwIDw9IHJlZjMgPyBsIDwgcmVmMyA6IGwgPiByZWYzOyBuID0gMCA8PSByZWYzID8gKytsIDogLS1sKSB7XG4gICAgICAgICAgICAgICAgbG9jID0gY21pbiArIChjbWF4IC0gY21pbikgLyAoTiAtIDEpICogbjtcbiAgICAgICAgICAgICAgICBkaW1faS5wdXNoKHRpY2tzW2lpXSk7XG4gICAgICAgICAgICAgICAgZGltX2oucHVzaChsb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29vcmRzW2ldLnB1c2goZGltX2kpO1xuICAgICAgICAgICAgY29vcmRzW2pdLnB1c2goZGltX2opO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfTtcbiAgICByZXR1cm4gR3JpZDtcbn0pKGd1aWRlX3JlbmRlcmVyXzEuR3VpZGVSZW5kZXJlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmlkXzEgPSByZXF1aXJlKFwiLi9ncmlkXCIpO1xuZXhwb3J0cy5HcmlkID0gZ3JpZF8xLkdyaWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9hbm5vdGF0aW9uc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9heGVzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NhbGxiYWNrc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jYW52YXNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vZm9ybWF0dGVyc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9nbHlwaHNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vZ3JpZHNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vbGF5b3V0c1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9tYXBwZXJzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RyYW5zZm9ybXNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vbWFya2Vyc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wbG90c1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9yYW5nZXNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcmVuZGVyZXJzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NjYWxlc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zb3VyY2VzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RpY2tlcnNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdGlsZXNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdG9vbHNcIikpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kMSA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSwgaW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSlcbiAgICAgICAgcmV0dXJuIGk7XG59IHJldHVybiAtMTsgfTtcbnZhciBzb2x2ZXJfMSA9IHJlcXVpcmUoXCJjb3JlL2xheW91dC9zb2x2ZXJcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL29iamVjdFwiKTtcbnZhciBsYXlvdXRfZG9tXzEgPSByZXF1aXJlKFwiLi9sYXlvdXRfZG9tXCIpO1xuZXhwb3J0cy5Cb3hWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShCb3hWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBCb3hWaWV3KCkge1xuICAgICAgICByZXR1cm4gQm94Vmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQm94Vmlldy5wcm90b3R5cGUuY2xhc3NOYW1lID0gXCJiay1ncmlkXCI7XG4gICAgQm94Vmlldy5wcm90b3R5cGUuY29ubmVjdF9zaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBCb3hWaWV3Ll9fc3VwZXJfXy5jb25uZWN0X3NpZ25hbHMuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnByb3BlcnRpZXMuY2hpbGRyZW4uY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZWJ1aWxkX2NoaWxkX3ZpZXdzKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgfTtcbiAgICBCb3hWaWV3LnByb3RvdHlwZS5nZXRfaGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGRfaGVpZ2h0cywgY2hpbGRyZW4sIGhlaWdodDtcbiAgICAgICAgY2hpbGRyZW4gPSB0aGlzLm1vZGVsLmdldF9sYXlvdXRhYmxlX2NoaWxkcmVuKCk7XG4gICAgICAgIGNoaWxkX2hlaWdodHMgPSBjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuX2hlaWdodC52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLl9ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBhcnJheV8xLm1heChjaGlsZF9oZWlnaHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhlaWdodCA9IGFycmF5XzEuc3VtKGNoaWxkX2hlaWdodHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfTtcbiAgICBCb3hWaWV3LnByb3RvdHlwZS5nZXRfd2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZF93aWR0aHMsIGNoaWxkcmVuLCB3aWR0aDtcbiAgICAgICAgY2hpbGRyZW4gPSB0aGlzLm1vZGVsLmdldF9sYXlvdXRhYmxlX2NoaWxkcmVuKCk7XG4gICAgICAgIGNoaWxkX3dpZHRocyA9IGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5fd2lkdGgudmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5faG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgd2lkdGggPSBhcnJheV8xLnN1bShjaGlsZF93aWR0aHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2lkdGggPSBhcnJheV8xLm1heChjaGlsZF93aWR0aHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9O1xuICAgIHJldHVybiBCb3hWaWV3O1xufSkobGF5b3V0X2RvbV8xLkxheW91dERPTVZpZXcpO1xuZXhwb3J0cy5Cb3ggPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKEJveCwgc3VwZXJDbGFzcyk7XG4gICAgQm94LnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkJveFZpZXc7XG4gICAgZnVuY3Rpb24gQm94KGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIEJveC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2NoaWxkX2VxdWFsX3NpemVfd2lkdGggPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoKTtcbiAgICAgICAgdGhpcy5fY2hpbGRfZXF1YWxfc2l6ZV9oZWlnaHQgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoKTtcbiAgICAgICAgdGhpcy5fYm94X2VxdWFsX3NpemVfdG9wID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKCk7XG4gICAgICAgIHRoaXMuX2JveF9lcXVhbF9zaXplX2JvdHRvbSA9IG5ldyBzb2x2ZXJfMS5WYXJpYWJsZSgpO1xuICAgICAgICB0aGlzLl9ib3hfZXF1YWxfc2l6ZV9sZWZ0ID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKCk7XG4gICAgICAgIHRoaXMuX2JveF9lcXVhbF9zaXplX3JpZ2h0ID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKCk7XG4gICAgICAgIHRoaXMuX2JveF9jZWxsX2FsaWduX3RvcCA9IG5ldyBzb2x2ZXJfMS5WYXJpYWJsZSgpO1xuICAgICAgICB0aGlzLl9ib3hfY2VsbF9hbGlnbl9ib3R0b20gPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoKTtcbiAgICAgICAgdGhpcy5fYm94X2NlbGxfYWxpZ25fbGVmdCA9IG5ldyBzb2x2ZXJfMS5WYXJpYWJsZSgpO1xuICAgICAgICB0aGlzLl9ib3hfY2VsbF9hbGlnbl9yaWdodCA9IG5ldyBzb2x2ZXJfMS5WYXJpYWJsZSgpO1xuICAgIH1cbiAgICBCb3guZGVmaW5lKHtcbiAgICAgICAgY2hpbGRyZW46IFtwLkFycmF5LCBbXV1cbiAgICB9KTtcbiAgICBCb3guaW50ZXJuYWwoe1xuICAgICAgICBzcGFjaW5nOiBbcC5OdW1iZXIsIDZdXG4gICAgfSk7XG4gICAgQm94LnByb3RvdHlwZS5nZXRfbGF5b3V0YWJsZV9jaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW47XG4gICAgfTtcbiAgICBCb3gucHJvdG90eXBlLmdldF9lZGl0X3ZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBlZGl0X3ZhcmlhYmxlcywgaiwgbGVuLCByZWY7XG4gICAgICAgIGVkaXRfdmFyaWFibGVzID0gQm94Ll9fc3VwZXJfXy5nZXRfZWRpdF92YXJpYWJsZXMuY2FsbCh0aGlzKTtcbiAgICAgICAgcmVmID0gdGhpcy5nZXRfbGF5b3V0YWJsZV9jaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gcmVmW2pdO1xuICAgICAgICAgICAgZWRpdF92YXJpYWJsZXMgPSBlZGl0X3ZhcmlhYmxlcy5jb25jYXQoY2hpbGQuZ2V0X2VkaXRfdmFyaWFibGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGl0X3ZhcmlhYmxlcztcbiAgICB9O1xuICAgIEJveC5wcm90b3R5cGUuZ2V0X2NvbnN0cmFpbmVkX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdF8xLmV4dGVuZCh7fSwgQm94Ll9fc3VwZXJfXy5nZXRfY29uc3RyYWluZWRfdmFyaWFibGVzLmNhbGwodGhpcyksIHtcbiAgICAgICAgICAgIGJveF9lcXVhbF9zaXplX3RvcDogdGhpcy5fYm94X2VxdWFsX3NpemVfdG9wLFxuICAgICAgICAgICAgYm94X2VxdWFsX3NpemVfYm90dG9tOiB0aGlzLl9ib3hfZXF1YWxfc2l6ZV9ib3R0b20sXG4gICAgICAgICAgICBib3hfZXF1YWxfc2l6ZV9sZWZ0OiB0aGlzLl9ib3hfZXF1YWxfc2l6ZV9sZWZ0LFxuICAgICAgICAgICAgYm94X2VxdWFsX3NpemVfcmlnaHQ6IHRoaXMuX2JveF9lcXVhbF9zaXplX3JpZ2h0LFxuICAgICAgICAgICAgYm94X2NlbGxfYWxpZ25fdG9wOiB0aGlzLl9ib3hfY2VsbF9hbGlnbl90b3AsXG4gICAgICAgICAgICBib3hfY2VsbF9hbGlnbl9ib3R0b206IHRoaXMuX2JveF9jZWxsX2FsaWduX2JvdHRvbSxcbiAgICAgICAgICAgIGJveF9jZWxsX2FsaWduX2xlZnQ6IHRoaXMuX2JveF9jZWxsX2FsaWduX2xlZnQsXG4gICAgICAgICAgICBib3hfY2VsbF9hbGlnbl9yaWdodDogdGhpcy5fYm94X2NlbGxfYWxpZ25fcmlnaHRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCb3gucHJvdG90eXBlLmdldF9jb25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBjaGlsZHJlbiwgY29uc3RyYWludHMsIGksIGosIGssIGxhc3QsIGxlbiwgbmV4dCwgcmVjdCwgcmVmLCB2YXJzO1xuICAgICAgICBjb25zdHJhaW50cyA9IFtdO1xuICAgICAgICBjaGlsZHJlbiA9IHRoaXMuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4oKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgdmFycyA9IGNoaWxkLmdldF9jb25zdHJhaW5lZF92YXJpYWJsZXMoKTtcbiAgICAgICAgICAgIHJlY3QgPSB0aGlzLl9jaGlsZF9yZWN0KHZhcnMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFycy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHJlY3QuaGVpZ2h0LCBbLTEsIHRoaXMuX2hlaWdodF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFycy53aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEocmVjdC53aWR0aCwgWy0xLCB0aGlzLl93aWR0aF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGlmICgodmFycy5ib3hfZXF1YWxfc2l6ZV9sZWZ0ICE9IG51bGwpICYmICh2YXJzLmJveF9lcXVhbF9zaXplX3JpZ2h0ICE9IG51bGwpICYmICh2YXJzLndpZHRoICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEoWy0xLCB2YXJzLmJveF9lcXVhbF9zaXplX2xlZnRdLCBbLTEsIHZhcnMuYm94X2VxdWFsX3NpemVfcmlnaHRdLCB2YXJzLndpZHRoLCB0aGlzLl9jaGlsZF9lcXVhbF9zaXplX3dpZHRoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCh2YXJzLmJveF9lcXVhbF9zaXplX3RvcCAhPSBudWxsKSAmJiAodmFycy5ib3hfZXF1YWxfc2l6ZV9ib3R0b20gIT0gbnVsbCkgJiYgKHZhcnMuaGVpZ2h0ICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEoWy0xLCB2YXJzLmJveF9lcXVhbF9zaXplX3RvcF0sIFstMSwgdmFycy5ib3hfZXF1YWxfc2l6ZV9ib3R0b21dLCB2YXJzLmhlaWdodCwgdGhpcy5fY2hpbGRfZXF1YWxfc2l6ZV9oZWlnaHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmNvbmNhdChjaGlsZC5nZXRfY29uc3RyYWludHMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdCA9IHRoaXMuX2luZm8oY2hpbGRyZW5bMF0uZ2V0X2NvbnN0cmFpbmVkX3ZhcmlhYmxlcygpKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUShsYXN0LnNwYW4uc3RhcnQsIDApKTtcbiAgICAgICAgZm9yIChpID0gayA9IDEsIHJlZiA9IGNoaWxkcmVuLmxlbmd0aDsgMSA8PSByZWYgPyBrIDwgcmVmIDogayA+IHJlZjsgaSA9IDEgPD0gcmVmID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBuZXh0ID0gdGhpcy5faW5mbyhjaGlsZHJlbltpXS5nZXRfY29uc3RyYWluZWRfdmFyaWFibGVzKCkpO1xuICAgICAgICAgICAgaWYgKGxhc3Quc3Bhbi5zaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUShsYXN0LnNwYW4uc3RhcnQsIGxhc3Quc3Bhbi5zaXplLCBbLTEsIG5leHQuc3Bhbi5zdGFydF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuV0VBS19FUShsYXN0LndoaXRlc3BhY2UuYWZ0ZXIsIG5leHQud2hpdGVzcGFjZS5iZWZvcmUsIDAgLSB0aGlzLnNwYWNpbmcpKTtcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuR0UobGFzdC53aGl0ZXNwYWNlLmFmdGVyLCBuZXh0LndoaXRlc3BhY2UuYmVmb3JlLCAwIC0gdGhpcy5zcGFjaW5nKSk7XG4gICAgICAgICAgICBsYXN0ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgaWYgKHZhcnMud2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEobGFzdC5zcGFuLnN0YXJ0LCBsYXN0LnNwYW4uc2l6ZSwgWy0xLCB0aGlzLl93aWR0aF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YXJzLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUShsYXN0LnNwYW4uc3RhcnQsIGxhc3Quc3Bhbi5zaXplLCBbLTEsIHRoaXMuX2hlaWdodF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmNvbmNhdCh0aGlzLl9hbGlnbl9vdXRlcl9lZGdlc19jb25zdHJhaW50cyh0cnVlKSwgdGhpcy5fYWxpZ25fb3V0ZXJfZWRnZXNfY29uc3RyYWludHMoZmFsc2UpLCB0aGlzLl9hbGlnbl9pbm5lcl9jZWxsX2VkZ2VzX2NvbnN0cmFpbnRzKCksIHRoaXMuX2JveF9lcXVhbF9zaXplX2JvdW5kcyh0cnVlKSwgdGhpcy5fYm94X2VxdWFsX3NpemVfYm91bmRzKGZhbHNlKSwgdGhpcy5fYm94X2NlbGxfYWxpZ25fYm91bmRzKHRydWUpLCB0aGlzLl9ib3hfY2VsbF9hbGlnbl9ib3VuZHMoZmFsc2UpLCB0aGlzLl9ib3hfd2hpdGVzcGFjZSh0cnVlKSwgdGhpcy5fYm94X3doaXRlc3BhY2UoZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgIH07XG4gICAgQm94LnByb3RvdHlwZS5fY2hpbGRfcmVjdCA9IGZ1bmN0aW9uICh2YXJzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB2YXJzLm9yaWdpbl94LFxuICAgICAgICAgICAgeTogdmFycy5vcmlnaW5feSxcbiAgICAgICAgICAgIHdpZHRoOiB2YXJzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB2YXJzLmhlaWdodFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQm94LnByb3RvdHlwZS5fc3BhbiA9IGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiByZWN0LngsXG4gICAgICAgICAgICAgICAgc2l6ZTogcmVjdC53aWR0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHJlY3QueSxcbiAgICAgICAgICAgICAgICBzaXplOiByZWN0LmhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQm94LnByb3RvdHlwZS5faW5mbyA9IGZ1bmN0aW9uICh2YXJzKSB7XG4gICAgICAgIHZhciBzcGFuLCB3aGl0ZXNwYWNlO1xuICAgICAgICBpZiAodGhpcy5faG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IHZhcnMud2hpdGVzcGFjZV9sZWZ0LFxuICAgICAgICAgICAgICAgIGFmdGVyOiB2YXJzLndoaXRlc3BhY2VfcmlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGl0ZXNwYWNlID0ge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogdmFycy53aGl0ZXNwYWNlX3RvcCxcbiAgICAgICAgICAgICAgICBhZnRlcjogdmFycy53aGl0ZXNwYWNlX2JvdHRvbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzcGFuID0gdGhpcy5fc3Bhbih0aGlzLl9jaGlsZF9yZWN0KHZhcnMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYW46IHNwYW4sXG4gICAgICAgICAgICB3aGl0ZXNwYWNlOiB3aGl0ZXNwYWNlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBCb3gucHJvdG90eXBlLl9mbGF0dGVuX2NlbGxfZWRnZV92YXJpYWJsZXMgPSBmdW5jdGlvbiAoaG9yaXpvbnRhbCkge1xuICAgICAgICB2YXIgYWRkX3BhdGgsIGFsbF92YXJzLCBhcml0eSwgY2VsbCwgY2VsbF92YXJzLCBjaGlsZCwgY2hpbGRyZW4sIGRpcmVjdGlvbiwgZmxhdHRlbmVkLCBqLCBrLCBrZXksIGtpbmQsIGxlbiwgbGVuMSwgbmFtZSwgbmV3X2tleSwgcGFyc2VkLCBwYXRoLCByZWxldmFudF9lZGdlcywgdmFyaWFibGVzO1xuICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmVsZXZhbnRfZWRnZXMgPSBCb3guX3RvcF9ib3R0b21faW5uZXJfY2VsbF9lZGdlX3ZhcmlhYmxlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlbGV2YW50X2VkZ2VzID0gQm94Ll9sZWZ0X3JpZ2h0X2lubmVyX2NlbGxfZWRnZV92YXJpYWJsZXM7XG4gICAgICAgIH1cbiAgICAgICAgYWRkX3BhdGggPSBob3Jpem9udGFsICE9PSB0aGlzLl9ob3Jpem9udGFsO1xuICAgICAgICBjaGlsZHJlbiA9IHRoaXMuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4oKTtcbiAgICAgICAgYXJpdHkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGZsYXR0ZW5lZCA9IHt9O1xuICAgICAgICBjZWxsID0gMDtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5bal07XG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCb3gpIHtcbiAgICAgICAgICAgICAgICBjZWxsX3ZhcnMgPSBjaGlsZC5fZmxhdHRlbl9jZWxsX2VkZ2VfdmFyaWFibGVzKGhvcml6b250YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbF92YXJzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbGxfdmFycyA9IGNoaWxkLmdldF9jb25zdHJhaW5lZF92YXJpYWJsZXMoKTtcbiAgICAgICAgICAgIGZvciAoayA9IDAsIGxlbjEgPSByZWxldmFudF9lZGdlcy5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gcmVsZXZhbnRfZWRnZXNba107XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gYWxsX3ZhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbF92YXJzW25hbWVdID0gW2FsbF92YXJzW25hbWVdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBjZWxsX3ZhcnMpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMgPSBjZWxsX3ZhcnNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkX3BhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0ga2V5LnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAga2luZCA9IHBhcnNlZFswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGFyc2VkWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IFwicm93XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBcImNvbFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld19rZXkgPSBraW5kICsgXCIgXCIgKyBkaXJlY3Rpb24gKyBcIi1cIiArIGFyaXR5ICsgXCItXCIgKyBjZWxsICsgXCItXCIgKyBwYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3X2tleSA9IGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld19rZXkgaW4gZmxhdHRlbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5lZFtuZXdfa2V5XSA9IGZsYXR0ZW5lZFtuZXdfa2V5XS5jb25jYXQodmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5lZFtuZXdfa2V5XSA9IHZhcmlhYmxlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsID0gY2VsbCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5lZDtcbiAgICB9O1xuICAgIEJveC5wcm90b3R5cGUuX2FsaWduX2lubmVyX2NlbGxfZWRnZXNfY29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50cywgZmxhdHRlbmVkLCBpLCBqLCBrZXksIGxhc3QsIHJlZiwgdmFyaWFibGVzO1xuICAgICAgICBjb25zdHJhaW50cyA9IFtdO1xuICAgICAgICBpZiAoKHRoaXMuZG9jdW1lbnQgIT0gbnVsbCkgJiYgaW5kZXhPZi5jYWxsKHRoaXMuZG9jdW1lbnQucm9vdHMoKSwgdGhpcykgPj0gMCkge1xuICAgICAgICAgICAgZmxhdHRlbmVkID0gdGhpcy5fZmxhdHRlbl9jZWxsX2VkZ2VfdmFyaWFibGVzKHRoaXMuX2hvcml6b250YWwpO1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gZmxhdHRlbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGVzID0gZmxhdHRlbmVkW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSB2YXJpYWJsZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGogPSAxLCByZWYgPSB2YXJpYWJsZXMubGVuZ3RoOyAxIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMSA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodmFyaWFibGVzW2ldLCBbLTEsIGxhc3RdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgIH07XG4gICAgQm94LnByb3RvdHlwZS5fZmluZF9lZGdlX2xlYXZlcyA9IGZ1bmN0aW9uIChob3Jpem9udGFsKSB7XG4gICAgICAgIHZhciBjaGlsZCwgY2hpbGRfbGVhdmVzLCBjaGlsZHJlbiwgZW5kLCBqLCBsZWF2ZXMsIGxlbiwgc3RhcnQ7XG4gICAgICAgIGNoaWxkcmVuID0gdGhpcy5nZXRfbGF5b3V0YWJsZV9jaGlsZHJlbigpO1xuICAgICAgICBsZWF2ZXMgPSBbW10sIFtdXTtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ob3Jpem9udGFsID09PSBob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBjaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBlbmQgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgaW5zdGFuY2VvZiBCb3gpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVhdmVzWzBdID0gbGVhdmVzWzBdLmNvbmNhdChzdGFydC5fZmluZF9lZGdlX2xlYXZlcyhob3Jpem9udGFsKVswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWF2ZXNbMF0ucHVzaChzdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbmQgaW5zdGFuY2VvZiBCb3gpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVhdmVzWzFdID0gbGVhdmVzWzFdLmNvbmNhdChlbmQuX2ZpbmRfZWRnZV9sZWF2ZXMoaG9yaXpvbnRhbClbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVhdmVzWzFdLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCb3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkX2xlYXZlcyA9IGNoaWxkLl9maW5kX2VkZ2VfbGVhdmVzKGhvcml6b250YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVhdmVzWzBdID0gbGVhdmVzWzBdLmNvbmNhdChjaGlsZF9sZWF2ZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVhdmVzWzFdID0gbGVhdmVzWzFdLmNvbmNhdChjaGlsZF9sZWF2ZXNbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVhdmVzWzBdLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVhdmVzWzFdLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWF2ZXM7XG4gICAgfTtcbiAgICBCb3gucHJvdG90eXBlLl9hbGlnbl9vdXRlcl9lZGdlc19jb25zdHJhaW50cyA9IGZ1bmN0aW9uIChob3Jpem9udGFsKSB7XG4gICAgICAgIHZhciBhZGRfYWxsX2VxdWFsLCBjb2xsZWN0X3ZhcnMsIGVuZF9lZGdlcywgZW5kX2xlYXZlcywgZW5kX3ZhcmlhYmxlLCByZWYsIHJlc3VsdCwgc3RhcnRfZWRnZXMsIHN0YXJ0X2xlYXZlcywgc3RhcnRfdmFyaWFibGU7XG4gICAgICAgIHJlZiA9IHRoaXMuX2ZpbmRfZWRnZV9sZWF2ZXMoaG9yaXpvbnRhbCksIHN0YXJ0X2xlYXZlcyA9IHJlZlswXSwgZW5kX2xlYXZlcyA9IHJlZlsxXTtcbiAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHN0YXJ0X3ZhcmlhYmxlID0gJ29uX2VkZ2VfYWxpZ25fbGVmdCc7XG4gICAgICAgICAgICBlbmRfdmFyaWFibGUgPSAnb25fZWRnZV9hbGlnbl9yaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydF92YXJpYWJsZSA9ICdvbl9lZGdlX2FsaWduX3RvcCc7XG4gICAgICAgICAgICBlbmRfdmFyaWFibGUgPSAnb25fZWRnZV9hbGlnbl9ib3R0b20nO1xuICAgICAgICB9XG4gICAgICAgIGNvbGxlY3RfdmFycyA9IGZ1bmN0aW9uIChsZWF2ZXMsIG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBlZGdlcywgaiwgbGVhZiwgbGVuLCB2YXJzO1xuICAgICAgICAgICAgZWRnZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGxlYXZlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIGxlYWYgPSBsZWF2ZXNbal07XG4gICAgICAgICAgICAgICAgdmFycyA9IGxlYWYuZ2V0X2NvbnN0cmFpbmVkX3ZhcmlhYmxlcygpO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIHZhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZXMucHVzaCh2YXJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgICAgIH07XG4gICAgICAgIHN0YXJ0X2VkZ2VzID0gY29sbGVjdF92YXJzKHN0YXJ0X2xlYXZlcywgc3RhcnRfdmFyaWFibGUpO1xuICAgICAgICBlbmRfZWRnZXMgPSBjb2xsZWN0X3ZhcnMoZW5kX2xlYXZlcywgZW5kX3ZhcmlhYmxlKTtcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGFkZF9hbGxfZXF1YWwgPSBmdW5jdGlvbiAoZWRnZXMpIHtcbiAgICAgICAgICAgIHZhciBlZGdlLCBmaXJzdCwgaSwgaiwgcmVmMTtcbiAgICAgICAgICAgIGlmIChlZGdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBlZGdlc1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBqID0gMSwgcmVmMSA9IGVkZ2VzLmxlbmd0aDsgMSA8PSByZWYxID8gaiA8IHJlZjEgOiBqID4gcmVmMTsgaSA9IDEgPD0gcmVmMSA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgICAgICBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNvbHZlcl8xLkVRKFstMSwgZmlyc3RdLCBlZGdlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhZGRfYWxsX2VxdWFsKHN0YXJ0X2VkZ2VzKTtcbiAgICAgICAgYWRkX2FsbF9lcXVhbChlbmRfZWRnZXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQm94LnByb3RvdHlwZS5fYm94X2luc2V0c19mcm9tX2NoaWxkX2luc2V0cyA9IGZ1bmN0aW9uIChob3Jpem9udGFsLCBjaGlsZF92YXJpYWJsZV9wcmVmaXgsIG91cl92YXJpYWJsZV9wcmVmaXgsIG1pbmltdW0pIHtcbiAgICAgICAgdmFyIGFkZF9jb25zdHJhaW50cywgZW5kX2xlYXZlcywgZW5kX3ZhcmlhYmxlLCBvdXJfZW5kLCBvdXJfc3RhcnQsIHJlZiwgcmVzdWx0LCBzdGFydF9sZWF2ZXMsIHN0YXJ0X3ZhcmlhYmxlO1xuICAgICAgICByZWYgPSB0aGlzLl9maW5kX2VkZ2VfbGVhdmVzKGhvcml6b250YWwpLCBzdGFydF9sZWF2ZXMgPSByZWZbMF0sIGVuZF9sZWF2ZXMgPSByZWZbMV07XG4gICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICBzdGFydF92YXJpYWJsZSA9IGNoaWxkX3ZhcmlhYmxlX3ByZWZpeCArIFwiX2xlZnRcIjtcbiAgICAgICAgICAgIGVuZF92YXJpYWJsZSA9IGNoaWxkX3ZhcmlhYmxlX3ByZWZpeCArIFwiX3JpZ2h0XCI7XG4gICAgICAgICAgICBvdXJfc3RhcnQgPSB0aGlzW291cl92YXJpYWJsZV9wcmVmaXggKyBcIl9sZWZ0XCJdO1xuICAgICAgICAgICAgb3VyX2VuZCA9IHRoaXNbb3VyX3ZhcmlhYmxlX3ByZWZpeCArIFwiX3JpZ2h0XCJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRfdmFyaWFibGUgPSBjaGlsZF92YXJpYWJsZV9wcmVmaXggKyBcIl90b3BcIjtcbiAgICAgICAgICAgIGVuZF92YXJpYWJsZSA9IGNoaWxkX3ZhcmlhYmxlX3ByZWZpeCArIFwiX2JvdHRvbVwiO1xuICAgICAgICAgICAgb3VyX3N0YXJ0ID0gdGhpc1tvdXJfdmFyaWFibGVfcHJlZml4ICsgXCJfdG9wXCJdO1xuICAgICAgICAgICAgb3VyX2VuZCA9IHRoaXNbb3VyX3ZhcmlhYmxlX3ByZWZpeCArIFwiX2JvdHRvbVwiXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgYWRkX2NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKG91cnMsIGxlYXZlcywgbmFtZSkge1xuICAgICAgICAgICAgdmFyIGVkZ2VzLCBqLCBsZWFmLCBsZW4sIHZhcnM7XG4gICAgICAgICAgICBlZGdlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gbGVhdmVzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGVhZiA9IGxlYXZlc1tqXTtcbiAgICAgICAgICAgICAgICB2YXJzID0gbGVhZi5nZXRfY29uc3RyYWluZWRfdmFyaWFibGVzKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gdmFycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluaW11bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc29sdmVyXzEuR0UoWy0xLCBvdXJzXSwgdmFyc1tuYW1lXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc29sdmVyXzEuRVEoWy0xLCBvdXJzXSwgdmFyc1tuYW1lXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGFkZF9jb25zdHJhaW50cyhvdXJfc3RhcnQsIHN0YXJ0X2xlYXZlcywgc3RhcnRfdmFyaWFibGUpO1xuICAgICAgICBhZGRfY29uc3RyYWludHMob3VyX2VuZCwgZW5kX2xlYXZlcywgZW5kX3ZhcmlhYmxlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEJveC5wcm90b3R5cGUuX2JveF9lcXVhbF9zaXplX2JvdW5kcyA9IGZ1bmN0aW9uIChob3Jpem9udGFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3hfaW5zZXRzX2Zyb21fY2hpbGRfaW5zZXRzKGhvcml6b250YWwsICdib3hfZXF1YWxfc2l6ZScsICdfYm94X2VxdWFsX3NpemUnLCBmYWxzZSk7XG4gICAgfTtcbiAgICBCb3gucHJvdG90eXBlLl9ib3hfY2VsbF9hbGlnbl9ib3VuZHMgPSBmdW5jdGlvbiAoaG9yaXpvbnRhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm94X2luc2V0c19mcm9tX2NoaWxkX2luc2V0cyhob3Jpem9udGFsLCAnYm94X2NlbGxfYWxpZ24nLCAnX2JveF9jZWxsX2FsaWduJywgZmFsc2UpO1xuICAgIH07XG4gICAgQm94LnByb3RvdHlwZS5fYm94X3doaXRlc3BhY2UgPSBmdW5jdGlvbiAoaG9yaXpvbnRhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm94X2luc2V0c19mcm9tX2NoaWxkX2luc2V0cyhob3Jpem9udGFsLCAnd2hpdGVzcGFjZScsICdfd2hpdGVzcGFjZScsIHRydWUpO1xuICAgIH07XG4gICAgQm94Ll9sZWZ0X3JpZ2h0X2lubmVyX2NlbGxfZWRnZV92YXJpYWJsZXMgPSBbJ2JveF9jZWxsX2FsaWduX2xlZnQnLCAnYm94X2NlbGxfYWxpZ25fcmlnaHQnXTtcbiAgICBCb3guX3RvcF9ib3R0b21faW5uZXJfY2VsbF9lZGdlX3ZhcmlhYmxlcyA9IFsnYm94X2NlbGxfYWxpZ25fdG9wJywgJ2JveF9jZWxsX2FsaWduX2JvdHRvbSddO1xuICAgIHJldHVybiBCb3g7XG59KShsYXlvdXRfZG9tXzEuTGF5b3V0RE9NKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBib3hfMSA9IHJlcXVpcmUoXCIuL2JveFwiKTtcbmV4cG9ydHMuQ29sdW1uVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDb2x1bW5WaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDb2x1bW5WaWV3KCkge1xuICAgICAgICByZXR1cm4gQ29sdW1uVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ29sdW1uVmlldy5wcm90b3R5cGUuY2xhc3NOYW1lID0gXCJiay1ncmlkLWNvbHVtblwiO1xuICAgIHJldHVybiBDb2x1bW5WaWV3O1xufSkoYm94XzEuQm94Vmlldyk7XG5leHBvcnRzLkNvbHVtbiA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDb2x1bW4sIHN1cGVyQ2xhc3MpO1xuICAgIENvbHVtbi5wcm90b3R5cGUudHlwZSA9ICdDb2x1bW4nO1xuICAgIENvbHVtbi5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5Db2x1bW5WaWV3O1xuICAgIGZ1bmN0aW9uIENvbHVtbihhdHRycywgb3B0aW9ucykge1xuICAgICAgICBDb2x1bW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9ob3Jpem9udGFsID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBDb2x1bW47XG59KShib3hfMS5Cb3gpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYm94XzEgPSByZXF1aXJlKFwiLi9ib3hcIik7XG5leHBvcnRzLkJveCA9IGJveF8xLkJveDtcbnZhciBjb2x1bW5fMSA9IHJlcXVpcmUoXCIuL2NvbHVtblwiKTtcbmV4cG9ydHMuQ29sdW1uID0gY29sdW1uXzEuQ29sdW1uO1xudmFyIGxheW91dF9kb21fMSA9IHJlcXVpcmUoXCIuL2xheW91dF9kb21cIik7XG5leHBvcnRzLkxheW91dERPTSA9IGxheW91dF9kb21fMS5MYXlvdXRET007XG52YXIgcm93XzEgPSByZXF1aXJlKFwiLi9yb3dcIik7XG5leHBvcnRzLlJvdyA9IHJvd18xLlJvdztcbnZhciBzcGFjZXJfMSA9IHJlcXVpcmUoXCIuL3NwYWNlclwiKTtcbmV4cG9ydHMuU3BhY2VyID0gc3BhY2VyXzEuU3BhY2VyO1xudmFyIHdpZGdldF9ib3hfMSA9IHJlcXVpcmUoXCIuL3dpZGdldF9ib3hcIik7XG5leHBvcnRzLldpZGdldEJveCA9IHdpZGdldF9ib3hfMS5XaWRnZXRCb3g7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQxID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxcIik7XG52YXIgZG9tXzEgPSByZXF1aXJlKFwiY29yZS9kb21cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgc29sdmVyXzEgPSByZXF1aXJlKFwiY29yZS9sYXlvdXQvc29sdmVyXCIpO1xudmFyIGJ1aWxkX3ZpZXdzXzEgPSByZXF1aXJlKFwiY29yZS9idWlsZF92aWV3c1wiKTtcbnZhciBkb21fdmlld18xID0gcmVxdWlyZShcImNvcmUvZG9tX3ZpZXdcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbmV4cG9ydHMuTGF5b3V0RE9NVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoTGF5b3V0RE9NVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGF5b3V0RE9NVmlldygpIHtcbiAgICAgICAgcmV0dXJuIExheW91dERPTVZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExheW91dERPTVZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBMYXlvdXRET01WaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLmlzX3Jvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvbHZlciA9IG5ldyBzb2x2ZXJfMS5Tb2x2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkX3ZpZXdzID0ge307XG4gICAgICAgIHRoaXMuYnVpbGRfY2hpbGRfdmlld3MoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdF9zaWduYWxzKCk7XG4gICAgfTtcbiAgICBMYXlvdXRET01WaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfLCByZWYsIHZpZXc7XG4gICAgICAgIHJlZiA9IHRoaXMuY2hpbGRfdmlld3M7XG4gICAgICAgIGZvciAoXyBpbiByZWYpIHtcbiAgICAgICAgICAgIHZpZXcgPSByZWZbX107XG4gICAgICAgICAgICB2aWV3LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRfdmlld3MgPSB7fTtcbiAgICAgICAgcmV0dXJuIExheW91dERPTVZpZXcuX19zdXBlcl9fLnJlbW92ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTGF5b3V0RE9NVmlldy5wcm90b3R5cGUuaGFzX2ZpbmlzaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgXywgY2hpbGQsIHJlZjtcbiAgICAgICAgaWYgKCFMYXlvdXRET01WaWV3Ll9fc3VwZXJfXy5oYXNfZmluaXNoZWQuY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlZiA9IHRoaXMuY2hpbGRfdmlld3M7XG4gICAgICAgIGZvciAoXyBpbiByZWYpIHtcbiAgICAgICAgICAgIGNoaWxkID0gcmVmW19dO1xuICAgICAgICAgICAgaWYgKCFjaGlsZC5oYXNfZmluaXNoZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIExheW91dERPTVZpZXcucHJvdG90eXBlLm5vdGlmeV9maW5pc2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzX3Jvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBMYXlvdXRET01WaWV3Ll9fc3VwZXJfXy5ub3RpZnlfZmluaXNoZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faWRsZV9ub3RpZmllZCAmJiB0aGlzLmhhc19maW5pc2hlZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwuZG9jdW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pZGxlX25vdGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZG9jdW1lbnQubm90aWZ5X2lkbGUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXlvdXRET01WaWV3LnByb3RvdHlwZS5fY2FsY193aWR0aF9oZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoZWlnaHQsIG1lYXN1cmluZywgcmVmLCB3aWR0aDtcbiAgICAgICAgbWVhc3VyaW5nID0gdGhpcy5lbDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIG1lYXN1cmluZyA9IG1lYXN1cmluZy5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKG1lYXN1cmluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci53YXJuKFwiZGV0YWNoZWQgZWxlbWVudFwiKTtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGhlaWdodCA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWYgPSBtZWFzdXJpbmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpZHRoID0gcmVmLndpZHRoLCBoZWlnaHQgPSByZWYuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKGhlaWdodCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbd2lkdGgsIGhlaWdodF07XG4gICAgfTtcbiAgICBMYXlvdXRET01WaWV3LnByb3RvdHlwZS5faW5pdF9zb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50LCBjb25zdHJhaW50cywgZWRpdF92YXJpYWJsZSwgZWRpdGFibGVzLCBpLCBqLCBsZW4sIGxlbjEsIHJlZiwgc3RyZW5ndGgsIHZhcmlhYmxlcztcbiAgICAgICAgdGhpcy5fcm9vdF93aWR0aCA9IG5ldyBzb2x2ZXJfMS5WYXJpYWJsZShcInJvb3Rfd2lkdGhcIik7XG4gICAgICAgIHRoaXMuX3Jvb3RfaGVpZ2h0ID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKFwicm9vdF9oZWlnaHRcIik7XG4gICAgICAgIHRoaXMuX3NvbHZlci5hZGRfZWRpdF92YXJpYWJsZSh0aGlzLl9yb290X3dpZHRoKTtcbiAgICAgICAgdGhpcy5fc29sdmVyLmFkZF9lZGl0X3ZhcmlhYmxlKHRoaXMuX3Jvb3RfaGVpZ2h0KTtcbiAgICAgICAgZWRpdGFibGVzID0gdGhpcy5tb2RlbC5nZXRfZWRpdF92YXJpYWJsZXMoKTtcbiAgICAgICAgY29uc3RyYWludHMgPSB0aGlzLm1vZGVsLmdldF9jb25zdHJhaW50cygpO1xuICAgICAgICB2YXJpYWJsZXMgPSB0aGlzLm1vZGVsLmdldF9jb25zdHJhaW5lZF92YXJpYWJsZXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZWRpdGFibGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZWYgPSBlZGl0YWJsZXNbaV0sIGVkaXRfdmFyaWFibGUgPSByZWYuZWRpdF92YXJpYWJsZSwgc3RyZW5ndGggPSByZWYuc3RyZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl9zb2x2ZXIuYWRkX2VkaXRfdmFyaWFibGUoZWRpdF92YXJpYWJsZSwgc3RyZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSBjb25zdHJhaW50cy5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQgPSBjb25zdHJhaW50c1tqXTtcbiAgICAgICAgICAgIHRoaXMuX3NvbHZlci5hZGRfY29uc3RyYWludChjb25zdHJhaW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFyaWFibGVzLndpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvbHZlci5hZGRfY29uc3RyYWludChzb2x2ZXJfMS5FUSh2YXJpYWJsZXMud2lkdGgsIHRoaXMuX3Jvb3Rfd2lkdGgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFyaWFibGVzLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9zb2x2ZXIuYWRkX2NvbnN0cmFpbnQoc29sdmVyXzEuRVEodmFyaWFibGVzLmhlaWdodCwgdGhpcy5fcm9vdF9oZWlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc29sdmVyLnVwZGF0ZV92YXJpYWJsZXMoKTtcbiAgICB9O1xuICAgIExheW91dERPTVZpZXcucHJvdG90eXBlLl9zdWdnZXN0X2RpbXMgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcmVmLCB2YXJpYWJsZXM7XG4gICAgICAgIHZhcmlhYmxlcyA9IHRoaXMubW9kZWwuZ2V0X2NvbnN0cmFpbmVkX3ZhcmlhYmxlcygpO1xuICAgICAgICBpZiAoKHZhcmlhYmxlcy53aWR0aCAhPSBudWxsKSB8fCAodmFyaWFibGVzLmhlaWdodCAhPSBudWxsKSkge1xuICAgICAgICAgICAgaWYgKHdpZHRoID09PSBudWxsIHx8IGhlaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlZiA9IHRoaXMuX2NhbGNfd2lkdGhfaGVpZ2h0KCksIHdpZHRoID0gcmVmWzBdLCBoZWlnaHQgPSByZWZbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHZhcmlhYmxlcy53aWR0aCAhPSBudWxsKSAmJiAod2lkdGggIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb2x2ZXIuc3VnZ2VzdF92YWx1ZSh0aGlzLl9yb290X3dpZHRoLCB3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHZhcmlhYmxlcy5oZWlnaHQgIT0gbnVsbCkgJiYgKGhlaWdodCAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NvbHZlci5zdWdnZXN0X3ZhbHVlKHRoaXMuX3Jvb3RfaGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvbHZlci51cGRhdGVfdmFyaWFibGVzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExheW91dERPTVZpZXcucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3aWR0aCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc19yb290KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb19sYXlvdXQoZmFsc2UsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXlvdXRET01WaWV3LnByb3RvdHlwZS5sYXlvdXQgPSBmdW5jdGlvbiAoZnVsbCkge1xuICAgICAgICBpZiAoZnVsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmdWxsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNfcm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5sYXlvdXQoZnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9fbGF5b3V0KGZ1bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXlvdXRET01WaWV3LnByb3RvdHlwZS5fZG9fbGF5b3V0ID0gZnVuY3Rpb24gKGZ1bGwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHdpZHRoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvbHZlci5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5faW5pdF9zb2x2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdWdnZXN0X2RpbXMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuX2xheW91dCgpO1xuICAgICAgICB0aGlzLl9sYXlvdXQoKTtcbiAgICAgICAgdGhpcy5fbGF5b3V0KHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub3RpZnlfZmluaXNoZWQoKTtcbiAgICB9O1xuICAgIExheW91dERPTVZpZXcucHJvdG90eXBlLl9sYXlvdXQgPSBmdW5jdGlvbiAoZmluYWwpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBjaGlsZF92aWV3LCBpLCBsZW4sIHJlZjtcbiAgICAgICAgaWYgKGZpbmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIGZpbmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5nZXRfbGF5b3V0YWJsZV9jaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gcmVmW2ldO1xuICAgICAgICAgICAgY2hpbGRfdmlldyA9IHRoaXMuY2hpbGRfdmlld3NbY2hpbGQuaWRdO1xuICAgICAgICAgICAgaWYgKGNoaWxkX3ZpZXcuX2xheW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRfdmlldy5fbGF5b3V0KGZpbmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNfZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXlvdXRET01WaWV3LnByb3RvdHlwZS5yZWJ1aWxkX2NoaWxkX3ZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNvbHZlci5jbGVhcigpO1xuICAgICAgICB0aGlzLmJ1aWxkX2NoaWxkX3ZpZXdzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dCgpO1xuICAgIH07XG4gICAgTGF5b3V0RE9NVmlldy5wcm90b3R5cGUuYnVpbGRfY2hpbGRfdmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZCwgY2hpbGRfdmlldywgY2hpbGRyZW4sIGksIGxlbiwgcmVzdWx0cztcbiAgICAgICAgY2hpbGRyZW4gPSB0aGlzLm1vZGVsLmdldF9sYXlvdXRhYmxlX2NoaWxkcmVuKCk7XG4gICAgICAgIGJ1aWxkX3ZpZXdzXzEuYnVpbGRfdmlld3ModGhpcy5jaGlsZF92aWV3cywgY2hpbGRyZW4sIHtcbiAgICAgICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgZG9tXzEuZW1wdHkodGhpcy5lbCk7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBjaGlsZF92aWV3ID0gdGhpcy5jaGlsZF92aWV3c1tjaGlsZC5pZF07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5lbC5hcHBlbmRDaGlsZChjaGlsZF92aWV3LmVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBMYXlvdXRET01WaWV3LnByb3RvdHlwZS5jb25uZWN0X3NpZ25hbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIExheW91dERPTVZpZXcuX19zdXBlcl9fLmNvbm5lY3Rfc2lnbmFscy5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pc19yb290KSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnByb3BlcnRpZXMuc2l6aW5nX21vZGUuY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5sYXlvdXQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuICAgIExheW91dERPTVZpZXcucHJvdG90eXBlLl9yZW5kZXJfY2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNscywgaSwgbGVuLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NOYW1lID0gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwuc2l6aW5nX21vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKFwiYmstbGF5b3V0LVwiICsgdGhpcy5tb2RlbC5zaXppbmdfbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwuY3NzX2NsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5jc3NfY2xhc3NlcztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNscyA9IHJlZltpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5lbC5jbGFzc0xpc3QuYWRkKGNscykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExheW91dERPTVZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhlaWdodCwgd2lkdGg7XG4gICAgICAgIHRoaXMuX3JlbmRlcl9jbGFzc2VzKCk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5zaXppbmdfbW9kZSkge1xuICAgICAgICAgICAgY2FzZSAnZml4ZWQnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLndpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLm1vZGVsLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLmdldF93aWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNldHYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5tb2RlbC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldF9oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXR2KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zb2x2ZXIuc3VnZ2VzdF92YWx1ZSh0aGlzLm1vZGVsLl93aWR0aCwgd2lkdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc29sdmVyLnN1Z2dlc3RfdmFsdWUodGhpcy5tb2RlbC5faGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc29sdmVyLnVwZGF0ZV92YXJpYWJsZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS50b3AgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICBjYXNlICdzY2FsZV93aWR0aCc6XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRfaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2x2ZXIuc3VnZ2VzdF92YWx1ZSh0aGlzLm1vZGVsLl9oZWlnaHQsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2x2ZXIudXBkYXRlX3ZhcmlhYmxlcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5sZWZ0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnRvcCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS53aWR0aCA9IHRoaXMubW9kZWwuX3dpZHRoLnZhbHVlICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLnN0eWxlLmhlaWdodCA9IHRoaXMubW9kZWwuX2hlaWdodC52YWx1ZSArIFwicHhcIjtcbiAgICAgICAgICAgIGNhc2UgJ3NjYWxlX2hlaWdodCc6XG4gICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLmdldF93aWR0aCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc29sdmVyLnN1Z2dlc3RfdmFsdWUodGhpcy5tb2RlbC5fd2lkdGgsIHdpZHRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvbHZlci51cGRhdGVfdmFyaWFibGVzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmxlZnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gdGhpcy5tb2RlbC5fd2lkdGgudmFsdWUgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5tb2RlbC5faGVpZ2h0LnZhbHVlICsgXCJweFwiO1xuICAgICAgICAgICAgY2FzZSAnc3RyZXRjaF9ib3RoJzpcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IHRoaXMubW9kZWwuX2RvbV9sZWZ0LnZhbHVlICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gdGhpcy5tb2RlbC5fZG9tX3RvcC52YWx1ZSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gdGhpcy5tb2RlbC5fd2lkdGgudmFsdWUgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5tb2RlbC5faGVpZ2h0LnZhbHVlICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXlvdXRET01WaWV3LnByb3RvdHlwZS5nZXRfaGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExheW91dERPTVZpZXcucHJvdG90eXBlLmdldF93aWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gTGF5b3V0RE9NVmlldztcbn0pKGRvbV92aWV3XzEuRE9NVmlldyk7XG5leHBvcnRzLkxheW91dERPTSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoTGF5b3V0RE9NLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMYXlvdXRET00oKSB7XG4gICAgICAgIHJldHVybiBMYXlvdXRET00uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExheW91dERPTS5wcm90b3R5cGUudHlwZSA9IFwiTGF5b3V0RE9NXCI7XG4gICAgTGF5b3V0RE9NLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIExheW91dERPTS5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJfd2lkdGggXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKFwiX2hlaWdodCBcIiArIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKFwiX2xlZnQgXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJfcmlnaHQgXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5fdG9wID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKFwiX3RvcCBcIiArIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLl9ib3R0b20gPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJfYm90dG9tIFwiICsgdGhpcy5pZCk7XG4gICAgICAgIHRoaXMuX2RvbV90b3AgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJfZG9tX3RvcCBcIiArIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLl9kb21fbGVmdCA9IG5ldyBzb2x2ZXJfMS5WYXJpYWJsZShcIl9kb21fbGVmdCBcIiArIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLl93aWR0aF9taW51c19yaWdodCA9IG5ldyBzb2x2ZXJfMS5WYXJpYWJsZShcIl93aWR0aF9taW51c19yaWdodCBcIiArIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLl9oZWlnaHRfbWludXNfYm90dG9tID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKFwiX2hlaWdodF9taW51c19ib3R0b20gXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5fd2hpdGVzcGFjZV90b3AgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoKTtcbiAgICAgICAgdGhpcy5fd2hpdGVzcGFjZV9ib3R0b20gPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoKTtcbiAgICAgICAgdGhpcy5fd2hpdGVzcGFjZV9sZWZ0ID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl93aGl0ZXNwYWNlX3JpZ2h0ID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKCk7XG4gICAgfTtcbiAgICBMYXlvdXRET00uZ2V0dGVycyh7XG4gICAgICAgIGxheW91dF9iYm94OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5fdG9wLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuX2xlZnQudmFsdWUsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuX3dpZHRoLnZhbHVlLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5faGVpZ2h0LnZhbHVlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLl9yaWdodC52YWx1ZSxcbiAgICAgICAgICAgICAgICBib3R0b206IHRoaXMuX2JvdHRvbS52YWx1ZSxcbiAgICAgICAgICAgICAgICBkb21fdG9wOiB0aGlzLl9kb21fdG9wLnZhbHVlLFxuICAgICAgICAgICAgICAgIGRvbV9sZWZ0OiB0aGlzLl9kb21fbGVmdC52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIExheW91dERPTS5wcm90b3R5cGUuZHVtcF9sYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZCwgaSwgbGVuLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMudG9TdHJpbmcoKSwgdGhpcy5sYXlvdXRfYmJveCk7XG4gICAgICAgIHJlZiA9IHRoaXMuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4oKTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gcmVmW2ldO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNoaWxkLmR1bXBfbGF5b3V0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgTGF5b3V0RE9NLnByb3RvdHlwZS5nZXRfY29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbc29sdmVyXzEuR0UodGhpcy5fZG9tX2xlZnQpLCBzb2x2ZXJfMS5HRSh0aGlzLl9kb21fdG9wKSwgc29sdmVyXzEuR0UodGhpcy5fbGVmdCksIHNvbHZlcl8xLkdFKHRoaXMuX3dpZHRoLCBbLTEsIHRoaXMuX3JpZ2h0XSksIHNvbHZlcl8xLkdFKHRoaXMuX3RvcCksIHNvbHZlcl8xLkdFKHRoaXMuX2hlaWdodCwgWy0xLCB0aGlzLl9ib3R0b21dKSwgc29sdmVyXzEuRVEodGhpcy5fd2lkdGhfbWludXNfcmlnaHQsIFstMSwgdGhpcy5fd2lkdGhdLCB0aGlzLl9yaWdodCksIHNvbHZlcl8xLkVRKHRoaXMuX2hlaWdodF9taW51c19ib3R0b20sIFstMSwgdGhpcy5faGVpZ2h0XSwgdGhpcy5fYm90dG9tKV07XG4gICAgfTtcbiAgICBMYXlvdXRET00ucHJvdG90eXBlLmdldF9sYXlvdXRhYmxlX2NoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBMYXlvdXRET00ucHJvdG90eXBlLmdldF9lZGl0X3ZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVkaXRfdmFyaWFibGVzO1xuICAgICAgICBlZGl0X3ZhcmlhYmxlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5zaXppbmdfbW9kZSA9PT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgZWRpdF92YXJpYWJsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZWRpdF92YXJpYWJsZTogdGhpcy5faGVpZ2h0LFxuICAgICAgICAgICAgICAgIHN0cmVuZ3RoOiBzb2x2ZXJfMS5TdHJlbmd0aC5zdHJvbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWRpdF92YXJpYWJsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZWRpdF92YXJpYWJsZTogdGhpcy5fd2lkdGgsXG4gICAgICAgICAgICAgICAgc3RyZW5ndGg6IHNvbHZlcl8xLlN0cmVuZ3RoLnN0cm9uZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2l6aW5nX21vZGUgPT09ICdzY2FsZV93aWR0aCcpIHtcbiAgICAgICAgICAgIGVkaXRfdmFyaWFibGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGVkaXRfdmFyaWFibGU6IHRoaXMuX2hlaWdodCxcbiAgICAgICAgICAgICAgICBzdHJlbmd0aDogc29sdmVyXzEuU3RyZW5ndGguc3Ryb25nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaXppbmdfbW9kZSA9PT0gJ3NjYWxlX2hlaWdodCcpIHtcbiAgICAgICAgICAgIGVkaXRfdmFyaWFibGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGVkaXRfdmFyaWFibGU6IHRoaXMuX3dpZHRoLFxuICAgICAgICAgICAgICAgIHN0cmVuZ3RoOiBzb2x2ZXJfMS5TdHJlbmd0aC5zdHJvbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGl0X3ZhcmlhYmxlcztcbiAgICB9O1xuICAgIExheW91dERPTS5wcm90b3R5cGUuZ2V0X2NvbnN0cmFpbmVkX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhcnM7XG4gICAgICAgIHZhcnMgPSB7XG4gICAgICAgICAgICBvcmlnaW5feDogdGhpcy5fZG9tX2xlZnQsXG4gICAgICAgICAgICBvcmlnaW5feTogdGhpcy5fZG9tX3RvcCxcbiAgICAgICAgICAgIHdoaXRlc3BhY2VfdG9wOiB0aGlzLl93aGl0ZXNwYWNlX3RvcCxcbiAgICAgICAgICAgIHdoaXRlc3BhY2VfYm90dG9tOiB0aGlzLl93aGl0ZXNwYWNlX2JvdHRvbSxcbiAgICAgICAgICAgIHdoaXRlc3BhY2VfbGVmdDogdGhpcy5fd2hpdGVzcGFjZV9sZWZ0LFxuICAgICAgICAgICAgd2hpdGVzcGFjZV9yaWdodDogdGhpcy5fd2hpdGVzcGFjZV9yaWdodFxuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2l6aW5nX21vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmV0Y2hfYm90aCc6XG4gICAgICAgICAgICAgICAgdmFycy53aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICAgICAgICAgIHZhcnMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2NhbGVfd2lkdGgnOlxuICAgICAgICAgICAgICAgIHZhcnMud2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NjYWxlX2hlaWdodCc6XG4gICAgICAgICAgICAgICAgdmFycy5oZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhcnM7XG4gICAgfTtcbiAgICBMYXlvdXRET00uZGVmaW5lKHtcbiAgICAgICAgaGVpZ2h0OiBbcC5OdW1iZXJdLFxuICAgICAgICB3aWR0aDogW3AuTnVtYmVyXSxcbiAgICAgICAgZGlzYWJsZWQ6IFtwLkJvb2wsIGZhbHNlXSxcbiAgICAgICAgc2l6aW5nX21vZGU6IFtwLlNpemluZ01vZGUsIFwiZml4ZWRcIl0sXG4gICAgICAgIGNzc19jbGFzc2VzOiBbcC5BcnJheV1cbiAgICB9KTtcbiAgICByZXR1cm4gTGF5b3V0RE9NO1xufSkobW9kZWxfMS5Nb2RlbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYm94XzEgPSByZXF1aXJlKFwiLi9ib3hcIik7XG5leHBvcnRzLlJvd1ZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUm93Vmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUm93VmlldygpIHtcbiAgICAgICAgcmV0dXJuIFJvd1ZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJvd1ZpZXcucHJvdG90eXBlLmNsYXNzTmFtZSA9IFwiYmstZ3JpZC1yb3dcIjtcbiAgICByZXR1cm4gUm93Vmlldztcbn0pKGJveF8xLkJveFZpZXcpO1xuZXhwb3J0cy5Sb3cgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUm93LCBzdXBlckNsYXNzKTtcbiAgICBSb3cucHJvdG90eXBlLnR5cGUgPSAnUm93JztcbiAgICBSb3cucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUm93VmlldztcbiAgICBmdW5jdGlvbiBSb3coYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgUm93Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faG9yaXpvbnRhbCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBSb3c7XG59KShib3hfMS5Cb3gpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kMSA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBsYXlvdXRfZG9tXzEgPSByZXF1aXJlKFwiLi9sYXlvdXRfZG9tXCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9vYmplY3RcIik7XG5leHBvcnRzLlNwYWNlclZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKFNwYWNlclZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFNwYWNlclZpZXcoKSB7XG4gICAgICAgIHJldHVybiBTcGFjZXJWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTcGFjZXJWaWV3LnByb3RvdHlwZS5jbGFzc05hbWUgPSBcImJrLXNwYWNlci1ib3hcIjtcbiAgICBTcGFjZXJWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFNwYWNlclZpZXcuX19zdXBlcl9fLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5zaXppbmdfbW9kZSA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gdGhpcy5tb2RlbC53aWR0aCArIFwicHhcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLnN0eWxlLmhlaWdodCA9IHRoaXMubW9kZWwuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTcGFjZXJWaWV3LnByb3RvdHlwZS5nZXRfaGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9O1xuICAgIHJldHVybiBTcGFjZXJWaWV3O1xufSkobGF5b3V0X2RvbV8xLkxheW91dERPTVZpZXcpO1xuZXhwb3J0cy5TcGFjZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKFNwYWNlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gU3BhY2VyKCkge1xuICAgICAgICByZXR1cm4gU3BhY2VyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTcGFjZXIucHJvdG90eXBlLnR5cGUgPSAnU3BhY2VyJztcbiAgICBTcGFjZXIucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuU3BhY2VyVmlldztcbiAgICBTcGFjZXIucHJvdG90eXBlLmdldF9jb25zdHJhaW5lZF92YXJpYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RfMS5leHRlbmQoe30sIFNwYWNlci5fX3N1cGVyX18uZ2V0X2NvbnN0cmFpbmVkX3ZhcmlhYmxlcy5jYWxsKHRoaXMpLCB7XG4gICAgICAgICAgICBvbl9lZGdlX2FsaWduX3RvcDogdGhpcy5fdG9wLFxuICAgICAgICAgICAgb25fZWRnZV9hbGlnbl9ib3R0b206IHRoaXMuX2hlaWdodF9taW51c19ib3R0b20sXG4gICAgICAgICAgICBvbl9lZGdlX2FsaWduX2xlZnQ6IHRoaXMuX2xlZnQsXG4gICAgICAgICAgICBvbl9lZGdlX2FsaWduX3JpZ2h0OiB0aGlzLl93aWR0aF9taW51c19yaWdodCxcbiAgICAgICAgICAgIGJveF9jZWxsX2FsaWduX3RvcDogdGhpcy5fdG9wLFxuICAgICAgICAgICAgYm94X2NlbGxfYWxpZ25fYm90dG9tOiB0aGlzLl9oZWlnaHRfbWludXNfYm90dG9tLFxuICAgICAgICAgICAgYm94X2NlbGxfYWxpZ25fbGVmdDogdGhpcy5fbGVmdCxcbiAgICAgICAgICAgIGJveF9jZWxsX2FsaWduX3JpZ2h0OiB0aGlzLl93aWR0aF9taW51c19yaWdodCxcbiAgICAgICAgICAgIGJveF9lcXVhbF9zaXplX3RvcDogdGhpcy5fdG9wLFxuICAgICAgICAgICAgYm94X2VxdWFsX3NpemVfYm90dG9tOiB0aGlzLl9oZWlnaHRfbWludXNfYm90dG9tLFxuICAgICAgICAgICAgYm94X2VxdWFsX3NpemVfbGVmdDogdGhpcy5fbGVmdCxcbiAgICAgICAgICAgIGJveF9lcXVhbF9zaXplX3JpZ2h0OiB0aGlzLl93aWR0aF9taW51c19yaWdodFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBTcGFjZXI7XG59KShsYXlvdXRfZG9tXzEuTGF5b3V0RE9NKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZDEgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvb2JqZWN0XCIpO1xudmFyIGxheW91dF9kb21fMSA9IHJlcXVpcmUoXCIuLi9sYXlvdXRzL2xheW91dF9kb21cIik7XG5leHBvcnRzLldpZGdldEJveFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKFdpZGdldEJveFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFdpZGdldEJveFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBXaWRnZXRCb3hWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBXaWRnZXRCb3hWaWV3LnByb3RvdHlwZS5jbGFzc05hbWUgPSBcImJrLXdpZGdldC1ib3hcIjtcbiAgICBXaWRnZXRCb3hWaWV3LnByb3RvdHlwZS5jb25uZWN0X3NpZ25hbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFdpZGdldEJveFZpZXcuX19zdXBlcl9fLmNvbm5lY3Rfc2lnbmFscy5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMubW9kZWwucHJvcGVydGllcy5jaGlsZHJlbi5jaGFuZ2UsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlYnVpbGRfY2hpbGRfdmlld3MoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuICAgIFdpZGdldEJveFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNzc193aWR0aCwgaGVpZ2h0LCB3aWR0aDtcbiAgICAgICAgdGhpcy5fcmVuZGVyX2NsYXNzZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuc2l6aW5nX21vZGUgPT09ICdmaXhlZCcgfHwgdGhpcy5tb2RlbC5zaXppbmdfbW9kZSA9PT0gJ3NjYWxlX2hlaWdodCcpIHtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5nZXRfd2lkdGgoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLl93aWR0aC52YWx1ZSAhPT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvbHZlci5zdWdnZXN0X3ZhbHVlKHRoaXMubW9kZWwuX3dpZHRoLCB3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwuc2l6aW5nX21vZGUgPT09ICdmaXhlZCcgfHwgdGhpcy5tb2RlbC5zaXppbmdfbW9kZSA9PT0gJ3NjYWxlX3dpZHRoJykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRfaGVpZ2h0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5faGVpZ2h0LnZhbHVlICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvbHZlci5zdWdnZXN0X3ZhbHVlKHRoaXMubW9kZWwuX2hlaWdodCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvbHZlci51cGRhdGVfdmFyaWFibGVzKCk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnNpemluZ19tb2RlID09PSAnc3RyZXRjaF9ib3RoJykge1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmxlZnQgPSB0aGlzLm1vZGVsLl9kb21fbGVmdC52YWx1ZSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gdGhpcy5tb2RlbC5fZG9tX3RvcC52YWx1ZSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUud2lkdGggPSB0aGlzLm1vZGVsLl93aWR0aC52YWx1ZSArIFwicHhcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLnN0eWxlLmhlaWdodCA9IHRoaXMubW9kZWwuX2hlaWdodC52YWx1ZSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLl93aWR0aC52YWx1ZSAtIDIwID4gMCkge1xuICAgICAgICAgICAgICAgIGNzc193aWR0aCA9ICh0aGlzLm1vZGVsLl93aWR0aC52YWx1ZSAtIDIwKSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNzc193aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3R5bGUud2lkdGggPSBjc3Nfd2lkdGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpZGdldEJveFZpZXcucHJvdG90eXBlLmdldF9oZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZF92aWV3LCBoZWlnaHQsIGtleSwgcmVmO1xuICAgICAgICBoZWlnaHQgPSAwO1xuICAgICAgICByZWYgPSB0aGlzLmNoaWxkX3ZpZXdzO1xuICAgICAgICBmb3IgKGtleSBpbiByZWYpIHtcbiAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwga2V5KSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNoaWxkX3ZpZXcgPSByZWZba2V5XTtcbiAgICAgICAgICAgIGhlaWdodCArPSBjaGlsZF92aWV3LmVsLnNjcm9sbEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVpZ2h0ICsgMjA7XG4gICAgfTtcbiAgICBXaWRnZXRCb3hWaWV3LnByb3RvdHlwZS5nZXRfd2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZF92aWV3LCBjaGlsZF93aWR0aCwga2V5LCByZWYsIHdpZHRoO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC53aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5lbC5zY3JvbGxXaWR0aCArIDIwO1xuICAgICAgICAgICAgcmVmID0gdGhpcy5jaGlsZF92aWV3cztcbiAgICAgICAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwga2V5KSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2hpbGRfdmlldyA9IHJlZltrZXldO1xuICAgICAgICAgICAgICAgIGNoaWxkX3dpZHRoID0gY2hpbGRfdmlldy5lbC5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRfd2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGNoaWxkX3dpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFdpZGdldEJveFZpZXc7XG59KShsYXlvdXRfZG9tXzEuTGF5b3V0RE9NVmlldyk7XG5leHBvcnRzLldpZGdldEJveCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoV2lkZ2V0Qm94LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBXaWRnZXRCb3goKSB7XG4gICAgICAgIHJldHVybiBXaWRnZXRCb3guX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFdpZGdldEJveC5wcm90b3R5cGUudHlwZSA9ICdXaWRnZXRCb3gnO1xuICAgIFdpZGdldEJveC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5XaWRnZXRCb3hWaWV3O1xuICAgIFdpZGdldEJveC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIFdpZGdldEJveC5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5zaXppbmdfbW9kZSA9PT0gJ2ZpeGVkJyAmJiB0aGlzLndpZHRoID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gMzAwO1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5pbmZvKFwiV2lkZ2V0Qm94IG1vZGUgaXMgZml4ZWQsIGJ1dCBubyB3aWR0aCBzcGVjaWZpZWQuIFVzaW5nIGRlZmF1bHQgb2YgMzAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaXppbmdfbW9kZSA9PT0gJ3NjYWxlX2hlaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJzaXppbmdfbW9kZSBgc2NhbGVfaGVpZ2h0YCBpcyBub3QgZXhwZXJpbWVudGFsIGZvciBXaWRnZXRCb3guIFBsZWFzZSByZXBvcnQgeW91ciByZXN1bHRzIHRvIHRoZSBib2tlaCBkZXYgdGVhbSBzbyB3ZSBjYW4gaW1wcm92ZS5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpZGdldEJveC5wcm90b3R5cGUuZ2V0X2VkaXRfdmFyaWFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGQsIGVkaXRfdmFyaWFibGVzLCBpLCBsZW4sIHJlZjtcbiAgICAgICAgZWRpdF92YXJpYWJsZXMgPSBXaWRnZXRCb3guX19zdXBlcl9fLmdldF9lZGl0X3ZhcmlhYmxlcy5jYWxsKHRoaXMpO1xuICAgICAgICByZWYgPSB0aGlzLmdldF9sYXlvdXRhYmxlX2NoaWxkcmVuKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSByZWZbaV07XG4gICAgICAgICAgICBlZGl0X3ZhcmlhYmxlcyA9IGVkaXRfdmFyaWFibGVzLmNvbmNhdChjaGlsZC5nZXRfZWRpdF92YXJpYWJsZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVkaXRfdmFyaWFibGVzO1xuICAgIH07XG4gICAgV2lkZ2V0Qm94LnByb3RvdHlwZS5nZXRfY29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZCwgY29uc3RyYWludHMsIGksIGxlbiwgcmVmO1xuICAgICAgICBjb25zdHJhaW50cyA9IFdpZGdldEJveC5fX3N1cGVyX18uZ2V0X2NvbnN0cmFpbnRzLmNhbGwodGhpcyk7XG4gICAgICAgIHJlZiA9IHRoaXMuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4oKTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHJlZltpXTtcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMuY29uY2F0KGNoaWxkLmdldF9jb25zdHJhaW50cygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uc3RyYWludHM7XG4gICAgfTtcbiAgICBXaWRnZXRCb3gucHJvdG90eXBlLmdldF9jb25zdHJhaW5lZF92YXJpYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YXJzO1xuICAgICAgICB2YXJzID0gb2JqZWN0XzEuZXh0ZW5kKHt9LCBXaWRnZXRCb3guX19zdXBlcl9fLmdldF9jb25zdHJhaW5lZF92YXJpYWJsZXMuY2FsbCh0aGlzKSwge1xuICAgICAgICAgICAgb25fZWRnZV9hbGlnbl90b3A6IHRoaXMuX3RvcCxcbiAgICAgICAgICAgIG9uX2VkZ2VfYWxpZ25fYm90dG9tOiB0aGlzLl9oZWlnaHRfbWludXNfYm90dG9tLFxuICAgICAgICAgICAgb25fZWRnZV9hbGlnbl9sZWZ0OiB0aGlzLl9sZWZ0LFxuICAgICAgICAgICAgb25fZWRnZV9hbGlnbl9yaWdodDogdGhpcy5fd2lkdGhfbWludXNfcmlnaHQsXG4gICAgICAgICAgICBib3hfY2VsbF9hbGlnbl90b3A6IHRoaXMuX3RvcCxcbiAgICAgICAgICAgIGJveF9jZWxsX2FsaWduX2JvdHRvbTogdGhpcy5faGVpZ2h0X21pbnVzX2JvdHRvbSxcbiAgICAgICAgICAgIGJveF9jZWxsX2FsaWduX2xlZnQ6IHRoaXMuX2xlZnQsXG4gICAgICAgICAgICBib3hfY2VsbF9hbGlnbl9yaWdodDogdGhpcy5fd2lkdGhfbWludXNfcmlnaHQsXG4gICAgICAgICAgICBib3hfZXF1YWxfc2l6ZV90b3A6IHRoaXMuX3RvcCxcbiAgICAgICAgICAgIGJveF9lcXVhbF9zaXplX2JvdHRvbTogdGhpcy5faGVpZ2h0X21pbnVzX2JvdHRvbVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuc2l6aW5nX21vZGUgIT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIHZhcnMuYm94X2VxdWFsX3NpemVfbGVmdCA9IHRoaXMuX2xlZnQ7XG4gICAgICAgICAgICB2YXJzLmJveF9lcXVhbF9zaXplX3JpZ2h0ID0gdGhpcy5fd2lkdGhfbWludXNfcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhcnM7XG4gICAgfTtcbiAgICBXaWRnZXRCb3gucHJvdG90eXBlLmdldF9sYXlvdXRhYmxlX2NoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbjtcbiAgICB9O1xuICAgIFdpZGdldEJveC5kZWZpbmUoe1xuICAgICAgICBjaGlsZHJlbjogW3AuQXJyYXksIFtdXVxuICAgIH0pO1xuICAgIHJldHVybiBXaWRnZXRCb3g7XG59KShsYXlvdXRfZG9tXzEuTGF5b3V0RE9NKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBjb2xvcl9tYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2NvbG9yX21hcHBlclwiKTtcbmV4cG9ydHMuQ2F0ZWdvcmljYWxDb2xvck1hcHBlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDYXRlZ29yaWNhbENvbG9yTWFwcGVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDYXRlZ29yaWNhbENvbG9yTWFwcGVyKCkge1xuICAgICAgICByZXR1cm4gQ2F0ZWdvcmljYWxDb2xvck1hcHBlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2F0ZWdvcmljYWxDb2xvck1hcHBlci5wcm90b3R5cGUudHlwZSA9IFwiQ2F0ZWdvcmljYWxDb2xvck1hcHBlclwiO1xuICAgIENhdGVnb3JpY2FsQ29sb3JNYXBwZXIuZGVmaW5lKHtcbiAgICAgICAgZmFjdG9yczogW3AuQXJyYXldXG4gICAgfSk7XG4gICAgQ2F0ZWdvcmljYWxDb2xvck1hcHBlci5wcm90b3R5cGUuX2dldF92YWx1ZXMgPSBmdW5jdGlvbiAoZGF0YSwgcGFsZXR0ZSkge1xuICAgICAgICB2YXIgY29sb3IsIGQsIGksIGtleSwgbGVuLCB2YWx1ZXM7XG4gICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBkID0gZGF0YVtpXTtcbiAgICAgICAgICAgIGtleSA9IHRoaXMuZmFjdG9ycy5pbmRleE9mKGQpO1xuICAgICAgICAgICAgaWYgKGtleSA8IDAgfHwga2V5ID49IHBhbGV0dGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLm5hbl9jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gcGFsZXR0ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzLnB1c2goY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0ZWdvcmljYWxDb2xvck1hcHBlcjtcbn0pKGNvbG9yX21hcHBlcl8xLkNvbG9yTWFwcGVyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciB0cmFuc2Zvcm1fMSA9IHJlcXVpcmUoXCIuLi90cmFuc2Zvcm1zL3RyYW5zZm9ybVwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90eXBlc1wiKTtcbmV4cG9ydHMuQ29sb3JNYXBwZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ29sb3JNYXBwZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENvbG9yTWFwcGVyKCkge1xuICAgICAgICByZXR1cm4gQ29sb3JNYXBwZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvbG9yTWFwcGVyLnByb3RvdHlwZS50eXBlID0gXCJDb2xvck1hcHBlclwiO1xuICAgIENvbG9yTWFwcGVyLmRlZmluZSh7XG4gICAgICAgIHBhbGV0dGU6IFtwLkFueV0sXG4gICAgICAgIG5hbl9jb2xvcjogW3AuQ29sb3IsIFwiZ3JheVwiXVxuICAgIH0pO1xuICAgIENvbG9yTWFwcGVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIENvbG9yTWFwcGVyLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9saXR0bGVfZW5kaWFuID0gdGhpcy5faXNfbGl0dGxlX2VuZGlhbigpO1xuICAgICAgICB0aGlzLl9wYWxldHRlID0gdGhpcy5fYnVpbGRfcGFsZXR0ZSh0aGlzLnBhbGV0dGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMuY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFsZXR0ZSA9IHRoaXMuX2J1aWxkX3BhbGV0dGUodGhpcy5wYWxldHRlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb2xvck1hcHBlci5wcm90b3R5cGUudl9tYXBfc2NyZWVuID0gZnVuY3Rpb24gKGRhdGEsIGltYWdlX2dseXBoKSB7XG4gICAgICAgIHZhciBidWYsIGNvbG9yLCBpLCBqLCBrLCByZWYsIHJlZjEsIHZhbHVlLCB2YWx1ZXM7XG4gICAgICAgIGlmIChpbWFnZV9nbHlwaCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbWFnZV9nbHlwaCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcyA9IHRoaXMuX2dldF92YWx1ZXMoZGF0YSwgdGhpcy5fcGFsZXR0ZSwgaW1hZ2VfZ2x5cGgpO1xuICAgICAgICBidWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YS5sZW5ndGggKiA0KTtcbiAgICAgICAgY29sb3IgPSBuZXcgVWludDMyQXJyYXkoYnVmKTtcbiAgICAgICAgaWYgKHRoaXMuX2xpdHRsZV9lbmRpYW4pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBkYXRhLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgY29sb3JbaV0gPSAoMHhmZiA8PCAyNCkgfCAoKHZhbHVlICYgMHhmZjAwMDApID4+IDE2KSB8ICh2YWx1ZSAmIDB4ZmYwMCkgfCAoKHZhbHVlICYgMHhmZikgPDwgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZjEgPSBkYXRhLmxlbmd0aDsgMCA8PSByZWYxID8gayA8IHJlZjEgOiBrID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbG9yW2ldID0gKHZhbHVlIDw8IDgpIHwgMHhmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH07XG4gICAgQ29sb3JNYXBwZXIucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENvbG9yTWFwcGVyLnByb3RvdHlwZS52X2NvbXB1dGUgPSBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgdmFyIHZhbHVlcztcbiAgICAgICAgdmFsdWVzID0gdGhpcy5fZ2V0X3ZhbHVlcyh4cywgdGhpcy5wYWxldHRlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuICAgIENvbG9yTWFwcGVyLnByb3RvdHlwZS5fZ2V0X3ZhbHVlcyA9IGZ1bmN0aW9uIChkYXRhLCBwYWxldHRlLCBpbWFnZV9nbHlwaCkge1xuICAgICAgICBpZiAoaW1hZ2VfZ2x5cGggPT0gbnVsbCkge1xuICAgICAgICAgICAgaW1hZ2VfZ2x5cGggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBDb2xvck1hcHBlci5wcm90b3R5cGUuX2lzX2xpdHRsZV9lbmRpYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidWYsIGJ1ZjMyLCBidWY4LCBsaXR0bGVfZW5kaWFuO1xuICAgICAgICBidWYgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gICAgICAgIGJ1ZjggPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgICAgICBidWYzMiA9IG5ldyBVaW50MzJBcnJheShidWYpO1xuICAgICAgICBidWYzMlsxXSA9IDB4MGEwYjBjMGQ7XG4gICAgICAgIGxpdHRsZV9lbmRpYW4gPSB0cnVlO1xuICAgICAgICBpZiAoYnVmOFs0XSA9PT0gMHgwYSAmJiBidWY4WzVdID09PSAweDBiICYmIGJ1ZjhbNl0gPT09IDB4MGMgJiYgYnVmOFs3XSA9PT0gMHgwZCkge1xuICAgICAgICAgICAgbGl0dGxlX2VuZGlhbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXR0bGVfZW5kaWFuO1xuICAgIH07XG4gICAgQ29sb3JNYXBwZXIucHJvdG90eXBlLl9idWlsZF9wYWxldHRlID0gZnVuY3Rpb24gKHBhbGV0dGUpIHtcbiAgICAgICAgdmFyIF9jb252ZXJ0LCBpLCBqLCBuZXdfcGFsZXR0ZSwgcmVmO1xuICAgICAgICBuZXdfcGFsZXR0ZSA9IG5ldyBVaW50MzJBcnJheShwYWxldHRlLmxlbmd0aCk7XG4gICAgICAgIF9jb252ZXJ0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZXNfMS5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUuc2xpY2UoMSksIDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHBhbGV0dGUubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIG5ld19wYWxldHRlW2ldID0gX2NvbnZlcnQocGFsZXR0ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld19wYWxldHRlO1xuICAgIH07XG4gICAgcmV0dXJuIENvbG9yTWFwcGVyO1xufSkodHJhbnNmb3JtXzEuVHJhbnNmb3JtKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNhdGVnb3JpY2FsX2NvbG9yX21hcHBlcl8xID0gcmVxdWlyZShcIi4vY2F0ZWdvcmljYWxfY29sb3JfbWFwcGVyXCIpO1xuZXhwb3J0cy5DYXRlZ29yaWNhbENvbG9yTWFwcGVyID0gY2F0ZWdvcmljYWxfY29sb3JfbWFwcGVyXzEuQ2F0ZWdvcmljYWxDb2xvck1hcHBlcjtcbnZhciBjb2xvcl9tYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2NvbG9yX21hcHBlclwiKTtcbmV4cG9ydHMuQ29sb3JNYXBwZXIgPSBjb2xvcl9tYXBwZXJfMS5Db2xvck1hcHBlcjtcbnZhciBsaW5lYXJfY29sb3JfbWFwcGVyXzEgPSByZXF1aXJlKFwiLi9saW5lYXJfY29sb3JfbWFwcGVyXCIpO1xuZXhwb3J0cy5MaW5lYXJDb2xvck1hcHBlciA9IGxpbmVhcl9jb2xvcl9tYXBwZXJfMS5MaW5lYXJDb2xvck1hcHBlcjtcbnZhciBsb2dfY29sb3JfbWFwcGVyXzEgPSByZXF1aXJlKFwiLi9sb2dfY29sb3JfbWFwcGVyXCIpO1xuZXhwb3J0cy5Mb2dDb2xvck1hcHBlciA9IGxvZ19jb2xvcl9tYXBwZXJfMS5Mb2dDb2xvck1hcHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBjb2xvcl8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9jb2xvclwiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbnZhciBjb2xvcl9tYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2NvbG9yX21hcHBlclwiKTtcbmV4cG9ydHMuTGluZWFyQ29sb3JNYXBwZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTGluZWFyQ29sb3JNYXBwZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExpbmVhckNvbG9yTWFwcGVyKCkge1xuICAgICAgICByZXR1cm4gTGluZWFyQ29sb3JNYXBwZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExpbmVhckNvbG9yTWFwcGVyLnByb3RvdHlwZS50eXBlID0gXCJMaW5lYXJDb2xvck1hcHBlclwiO1xuICAgIExpbmVhckNvbG9yTWFwcGVyLmRlZmluZSh7XG4gICAgICAgIGhpZ2g6IFtwLk51bWJlcl0sXG4gICAgICAgIGxvdzogW3AuTnVtYmVyXSxcbiAgICAgICAgaGlnaF9jb2xvcjogW3AuQ29sb3JdLFxuICAgICAgICBsb3dfY29sb3I6IFtwLkNvbG9yXVxuICAgIH0pO1xuICAgIExpbmVhckNvbG9yTWFwcGVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIExpbmVhckNvbG9yTWFwcGVyLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9uYW5fY29sb3IgPSB0aGlzLl9idWlsZF9wYWxldHRlKFtjb2xvcl8xLmNvbG9yMmhleCh0aGlzLm5hbl9jb2xvcildKVswXTtcbiAgICAgICAgdGhpcy5faGlnaF9jb2xvciA9IHRoaXMuaGlnaF9jb2xvciAhPSBudWxsID8gdGhpcy5fYnVpbGRfcGFsZXR0ZShbY29sb3JfMS5jb2xvcjJoZXgodGhpcy5oaWdoX2NvbG9yKV0pWzBdIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gdGhpcy5fbG93X2NvbG9yID0gdGhpcy5sb3dfY29sb3IgIT0gbnVsbCA/IHRoaXMuX2J1aWxkX3BhbGV0dGUoW2NvbG9yXzEuY29sb3IyaGV4KHRoaXMubG93X2NvbG9yKV0pWzBdIDogdm9pZCAwO1xuICAgIH07XG4gICAgTGluZWFyQ29sb3JNYXBwZXIucHJvdG90eXBlLl9nZXRfdmFsdWVzID0gZnVuY3Rpb24gKGRhdGEsIHBhbGV0dGUsIGltYWdlX2dseXBoKSB7XG4gICAgICAgIHZhciBkLCBoaWdoLCBoaWdoX2NvbG9yLCBpLCBrZXksIGxlbiwgbG93LCBsb3dfY29sb3IsIG1heF9rZXksIG5hbl9jb2xvciwgbm9ybV9mYWN0b3IsIG5vcm1lZF9kLCBub3JtZWRfaW50ZXJ2YWwsIHJlZiwgcmVmMSwgdmFsdWVzO1xuICAgICAgICBpZiAoaW1hZ2VfZ2x5cGggPT0gbnVsbCkge1xuICAgICAgICAgICAgaW1hZ2VfZ2x5cGggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsb3cgPSAocmVmID0gdGhpcy5sb3cpICE9IG51bGwgPyByZWYgOiBhcnJheV8xLm1pbihkYXRhKTtcbiAgICAgICAgaGlnaCA9IChyZWYxID0gdGhpcy5oaWdoKSAhPSBudWxsID8gcmVmMSA6IGFycmF5XzEubWF4KGRhdGEpO1xuICAgICAgICBtYXhfa2V5ID0gcGFsZXR0ZS5sZW5ndGggLSAxO1xuICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgICAgbmFuX2NvbG9yID0gaW1hZ2VfZ2x5cGggPyB0aGlzLl9uYW5fY29sb3IgOiB0aGlzLm5hbl9jb2xvcjtcbiAgICAgICAgbG93X2NvbG9yID0gaW1hZ2VfZ2x5cGggPyB0aGlzLl9sb3dfY29sb3IgOiB0aGlzLmxvd19jb2xvcjtcbiAgICAgICAgaGlnaF9jb2xvciA9IGltYWdlX2dseXBoID8gdGhpcy5faGlnaF9jb2xvciA6IHRoaXMuaGlnaF9jb2xvcjtcbiAgICAgICAgbm9ybV9mYWN0b3IgPSAxIC8gKGhpZ2ggLSBsb3cpO1xuICAgICAgICBub3JtZWRfaW50ZXJ2YWwgPSAxIC8gcGFsZXR0ZS5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGQgPSBkYXRhW2ldO1xuICAgICAgICAgICAgaWYgKGlzTmFOKGQpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gobmFuX2NvbG9yKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkID09PSBoaWdoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFsZXR0ZVttYXhfa2V5XSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3JtZWRfZCA9IChkIC0gbG93KSAqIG5vcm1fZmFjdG9yO1xuICAgICAgICAgICAga2V5ID0gTWF0aC5mbG9vcihub3JtZWRfZCAvIG5vcm1lZF9pbnRlcnZhbCk7XG4gICAgICAgICAgICBpZiAoa2V5IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvd19jb2xvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGxvd19jb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChwYWxldHRlWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPiBtYXhfa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGlnaF9jb2xvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGhpZ2hfY29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFsZXR0ZVttYXhfa2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFsZXR0ZVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgcmV0dXJuIExpbmVhckNvbG9yTWFwcGVyO1xufSkoY29sb3JfbWFwcGVyXzEuQ29sb3JNYXBwZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nMXAsIHJlZiwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGNvbG9yXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2NvbG9yXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIGNvbG9yX21hcHBlcl8xID0gcmVxdWlyZShcIi4vY29sb3JfbWFwcGVyXCIpO1xubG9nMXAgPSAocmVmID0gTWF0aC5sb2cxcCkgIT0gbnVsbCA/IHJlZiA6IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKDEgKyB4KTtcbn07XG5leHBvcnRzLkxvZ0NvbG9yTWFwcGVyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExvZ0NvbG9yTWFwcGVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMb2dDb2xvck1hcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIExvZ0NvbG9yTWFwcGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMb2dDb2xvck1hcHBlci5wcm90b3R5cGUudHlwZSA9IFwiTG9nQ29sb3JNYXBwZXJcIjtcbiAgICBMb2dDb2xvck1hcHBlci5kZWZpbmUoe1xuICAgICAgICBoaWdoOiBbcC5OdW1iZXJdLFxuICAgICAgICBsb3c6IFtwLk51bWJlcl0sXG4gICAgICAgIGhpZ2hfY29sb3I6IFtwLkNvbG9yXSxcbiAgICAgICAgbG93X2NvbG9yOiBbcC5Db2xvcl1cbiAgICB9KTtcbiAgICBMb2dDb2xvck1hcHBlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBMb2dDb2xvck1hcHBlci5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbmFuX2NvbG9yID0gdGhpcy5fYnVpbGRfcGFsZXR0ZShbY29sb3JfMS5jb2xvcjJoZXgodGhpcy5uYW5fY29sb3IpXSlbMF07XG4gICAgICAgIHRoaXMuX2hpZ2hfY29sb3IgPSB0aGlzLmhpZ2hfY29sb3IgIT0gbnVsbCA/IHRoaXMuX2J1aWxkX3BhbGV0dGUoW2NvbG9yXzEuY29sb3IyaGV4KHRoaXMuaGlnaF9jb2xvcildKVswXSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvd19jb2xvciA9IHRoaXMubG93X2NvbG9yICE9IG51bGwgPyB0aGlzLl9idWlsZF9wYWxldHRlKFtjb2xvcl8xLmNvbG9yMmhleCh0aGlzLmxvd19jb2xvcildKVswXSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIExvZ0NvbG9yTWFwcGVyLnByb3RvdHlwZS5fZ2V0X3ZhbHVlcyA9IGZ1bmN0aW9uIChkYXRhLCBwYWxldHRlLCBpbWFnZV9nbHlwaCkge1xuICAgICAgICB2YXIgZCwgaGlnaCwgaGlnaF9jb2xvciwgaSwga2V5LCBsZW4sIGxvZywgbG93LCBsb3dfY29sb3IsIG1heF9rZXksIG4sIG5hbl9jb2xvciwgcmVmMSwgcmVmMiwgc2NhbGUsIHZhbHVlcztcbiAgICAgICAgaWYgKGltYWdlX2dseXBoID09IG51bGwpIHtcbiAgICAgICAgICAgIGltYWdlX2dseXBoID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IHBhbGV0dGUubGVuZ3RoO1xuICAgICAgICBsb3cgPSAocmVmMSA9IHRoaXMubG93KSAhPSBudWxsID8gcmVmMSA6IGFycmF5XzEubWluKGRhdGEpO1xuICAgICAgICBoaWdoID0gKHJlZjIgPSB0aGlzLmhpZ2gpICE9IG51bGwgPyByZWYyIDogYXJyYXlfMS5tYXgoZGF0YSk7XG4gICAgICAgIHNjYWxlID0gbiAvIChsb2cxcChoaWdoKSAtIGxvZzFwKGxvdykpO1xuICAgICAgICBtYXhfa2V5ID0gcGFsZXR0ZS5sZW5ndGggLSAxO1xuICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgICAgbmFuX2NvbG9yID0gaW1hZ2VfZ2x5cGggPyB0aGlzLl9uYW5fY29sb3IgOiB0aGlzLm5hbl9jb2xvcjtcbiAgICAgICAgaGlnaF9jb2xvciA9IGltYWdlX2dseXBoID8gdGhpcy5faGlnaF9jb2xvciA6IHRoaXMuaGlnaF9jb2xvcjtcbiAgICAgICAgbG93X2NvbG9yID0gaW1hZ2VfZ2x5cGggPyB0aGlzLl9sb3dfY29sb3IgOiB0aGlzLmxvd19jb2xvcjtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZCA9IGRhdGFbaV07XG4gICAgICAgICAgICBpZiAoaXNOYU4oZCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChuYW5fY29sb3IpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGQgPiBoaWdoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGlnaF9jb2xvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGhpZ2hfY29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFsZXR0ZVttYXhfa2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGQgPT09IGhpZ2gpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChwYWxldHRlW21heF9rZXldKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkIDwgbG93KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG93X2NvbG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gobG93X2NvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHBhbGV0dGVbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZyA9IGxvZzFwKGQpIC0gbG9nMXAobG93KTtcbiAgICAgICAgICAgIGtleSA9IE1hdGguZmxvb3IobG9nICogc2NhbGUpO1xuICAgICAgICAgICAgaWYgKGtleSA+IG1heF9rZXkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBtYXhfa2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFsZXR0ZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgcmV0dXJuIExvZ0NvbG9yTWFwcGVyO1xufSkoY29sb3JfbWFwcGVyXzEuQ29sb3JNYXBwZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU1EzLCBfbWtfbW9kZWwsIF9vbmVfY3Jvc3MsIF9vbmVfZGlhbW9uZCwgX29uZV90cmksIF9vbmVfeCwgYXN0ZXJpc2ssIGNpcmNsZV9jcm9zcywgY2lyY2xlX3gsIGNyb3NzLCBkaWFtb25kLCBkaWFtb25kX2Nyb3NzLCBpbnZlcnRlZF90cmlhbmdsZSwgc3F1YXJlLCBzcXVhcmVfY3Jvc3MsIHNxdWFyZV94LCB0cmlhbmdsZSwgeCwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIG1hcmtlcl8xID0gcmVxdWlyZShcIi4vbWFya2VyXCIpO1xuU1EzID0gTWF0aC5zcXJ0KDMpO1xuX29uZV94ID0gZnVuY3Rpb24gKGN0eCwgcikge1xuICAgIGN0eC5tb3ZlVG8oLXIsIHIpO1xuICAgIGN0eC5saW5lVG8ociwgLXIpO1xuICAgIGN0eC5tb3ZlVG8oLXIsIC1yKTtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyhyLCByKTtcbn07XG5fb25lX2Nyb3NzID0gZnVuY3Rpb24gKGN0eCwgcikge1xuICAgIGN0eC5tb3ZlVG8oMCwgcik7XG4gICAgY3R4LmxpbmVUbygwLCAtcik7XG4gICAgY3R4Lm1vdmVUbygtciwgMCk7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8ociwgMCk7XG59O1xuX29uZV9kaWFtb25kID0gZnVuY3Rpb24gKGN0eCwgcikge1xuICAgIGN0eC5tb3ZlVG8oMCwgcik7XG4gICAgY3R4LmxpbmVUbyhyIC8gMS41LCAwKTtcbiAgICBjdHgubGluZVRvKDAsIC1yKTtcbiAgICBjdHgubGluZVRvKC1yIC8gMS41LCAwKTtcbiAgICByZXR1cm4gY3R4LmNsb3NlUGF0aCgpO1xufTtcbl9vbmVfdHJpID0gZnVuY3Rpb24gKGN0eCwgcikge1xuICAgIHZhciBhLCBoO1xuICAgIGggPSByICogU1EzO1xuICAgIGEgPSBoIC8gMztcbiAgICBjdHgubW92ZVRvKC1yLCBhKTtcbiAgICBjdHgubGluZVRvKHIsIGEpO1xuICAgIGN0eC5saW5lVG8oMCwgYSAtIGgpO1xuICAgIHJldHVybiBjdHguY2xvc2VQYXRoKCk7XG59O1xuYXN0ZXJpc2sgPSBmdW5jdGlvbiAoY3R4LCBpLCBzeCwgc3ksIHIsIGxpbmUsIGZpbGwpIHtcbiAgICB2YXIgcjI7XG4gICAgcjIgPSByICogMC42NTtcbiAgICBfb25lX2Nyb3NzKGN0eCwgcik7XG4gICAgX29uZV94KGN0eCwgcjIpO1xuICAgIGlmIChsaW5lLmRvaXQpIHtcbiAgICAgICAgbGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59O1xuY2lyY2xlX2Nyb3NzID0gZnVuY3Rpb24gKGN0eCwgaSwgc3gsIHN5LCByLCBsaW5lLCBmaWxsKSB7XG4gICAgY3R4LmFyYygwLCAwLCByLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgIGlmIChmaWxsLmRvaXQpIHtcbiAgICAgICAgZmlsbC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGlmIChsaW5lLmRvaXQpIHtcbiAgICAgICAgbGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIF9vbmVfY3Jvc3MoY3R4LCByKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbn07XG5jaXJjbGVfeCA9IGZ1bmN0aW9uIChjdHgsIGksIHN4LCBzeSwgciwgbGluZSwgZmlsbCkge1xuICAgIGN0eC5hcmMoMCwgMCwgciwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICBpZiAoZmlsbC5kb2l0KSB7XG4gICAgICAgIGZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAobGluZS5kb2l0KSB7XG4gICAgICAgIGxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBfb25lX3goY3R4LCByKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbn07XG5jcm9zcyA9IGZ1bmN0aW9uIChjdHgsIGksIHN4LCBzeSwgciwgbGluZSwgZmlsbCkge1xuICAgIF9vbmVfY3Jvc3MoY3R4LCByKTtcbiAgICBpZiAobGluZS5kb2l0KSB7XG4gICAgICAgIGxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufTtcbmRpYW1vbmQgPSBmdW5jdGlvbiAoY3R4LCBpLCBzeCwgc3ksIHIsIGxpbmUsIGZpbGwpIHtcbiAgICBfb25lX2RpYW1vbmQoY3R4LCByKTtcbiAgICBpZiAoZmlsbC5kb2l0KSB7XG4gICAgICAgIGZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAobGluZS5kb2l0KSB7XG4gICAgICAgIGxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufTtcbmRpYW1vbmRfY3Jvc3MgPSBmdW5jdGlvbiAoY3R4LCBpLCBzeCwgc3ksIHIsIGxpbmUsIGZpbGwpIHtcbiAgICBfb25lX2RpYW1vbmQoY3R4LCByKTtcbiAgICBpZiAoZmlsbC5kb2l0KSB7XG4gICAgICAgIGZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAobGluZS5kb2l0KSB7XG4gICAgICAgIGxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBfb25lX2Nyb3NzKGN0eCwgcik7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59O1xuaW52ZXJ0ZWRfdHJpYW5nbGUgPSBmdW5jdGlvbiAoY3R4LCBpLCBzeCwgc3ksIHIsIGxpbmUsIGZpbGwpIHtcbiAgICBjdHgucm90YXRlKE1hdGguUEkpO1xuICAgIF9vbmVfdHJpKGN0eCwgcik7XG4gICAgY3R4LnJvdGF0ZSgtTWF0aC5QSSk7XG4gICAgaWYgKGZpbGwuZG9pdCkge1xuICAgICAgICBmaWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKGxpbmUuZG9pdCkge1xuICAgICAgICBsaW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbn07XG5zcXVhcmUgPSBmdW5jdGlvbiAoY3R4LCBpLCBzeCwgc3ksIHIsIGxpbmUsIGZpbGwpIHtcbiAgICB2YXIgc2l6ZTtcbiAgICBzaXplID0gMiAqIHI7XG4gICAgY3R4LnJlY3QoLXIsIC1yLCBzaXplLCBzaXplKTtcbiAgICBpZiAoZmlsbC5kb2l0KSB7XG4gICAgICAgIGZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAobGluZS5kb2l0KSB7XG4gICAgICAgIGxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufTtcbnNxdWFyZV9jcm9zcyA9IGZ1bmN0aW9uIChjdHgsIGksIHN4LCBzeSwgciwgbGluZSwgZmlsbCkge1xuICAgIHZhciBzaXplO1xuICAgIHNpemUgPSAyICogcjtcbiAgICBjdHgucmVjdCgtciwgLXIsIHNpemUsIHNpemUpO1xuICAgIGlmIChmaWxsLmRvaXQpIHtcbiAgICAgICAgZmlsbC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGlmIChsaW5lLmRvaXQpIHtcbiAgICAgICAgbGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIF9vbmVfY3Jvc3MoY3R4LCByKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbn07XG5zcXVhcmVfeCA9IGZ1bmN0aW9uIChjdHgsIGksIHN4LCBzeSwgciwgbGluZSwgZmlsbCkge1xuICAgIHZhciBzaXplO1xuICAgIHNpemUgPSAyICogcjtcbiAgICBjdHgucmVjdCgtciwgLXIsIHNpemUsIHNpemUpO1xuICAgIGlmIChmaWxsLmRvaXQpIHtcbiAgICAgICAgZmlsbC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGlmIChsaW5lLmRvaXQpIHtcbiAgICAgICAgbGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIF9vbmVfeChjdHgsIHIpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufTtcbnRyaWFuZ2xlID0gZnVuY3Rpb24gKGN0eCwgaSwgc3gsIHN5LCByLCBsaW5lLCBmaWxsKSB7XG4gICAgX29uZV90cmkoY3R4LCByKTtcbiAgICBpZiAoZmlsbC5kb2l0KSB7XG4gICAgICAgIGZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAobGluZS5kb2l0KSB7XG4gICAgICAgIGxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufTtcbnggPSBmdW5jdGlvbiAoY3R4LCBpLCBzeCwgc3ksIHIsIGxpbmUsIGZpbGwpIHtcbiAgICBfb25lX3goY3R4LCByKTtcbiAgICBpZiAobGluZS5kb2l0KSB7XG4gICAgICAgIGxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufTtcbl9ta19tb2RlbCA9IGZ1bmN0aW9uICh0eXBlLCBmKSB7XG4gICAgdmFyIG1vZGVsLCB2aWV3O1xuICAgIHZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgZXh0ZW5kKHZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgICAgICBmdW5jdGlvbiB2aWV3KCkge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5wcm90b3R5cGUuX3JlbmRlcl9vbmUgPSBmO1xuICAgICAgICByZXR1cm4gdmlldztcbiAgICB9KShtYXJrZXJfMS5NYXJrZXJWaWV3KTtcbiAgICBtb2RlbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgICAgICBleHRlbmQobW9kZWwsIHN1cGVyQ2xhc3MpO1xuICAgICAgICBmdW5jdGlvbiBtb2RlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gdmlldztcbiAgICAgICAgbW9kZWwucHJvdG90eXBlLnR5cGUgPSB0eXBlO1xuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSkobWFya2VyXzEuTWFya2VyKTtcbiAgICByZXR1cm4gbW9kZWw7XG59O1xuZXhwb3J0cy5Bc3RlcmlzayA9IF9ta19tb2RlbCgnQXN0ZXJpc2snLCBhc3Rlcmlzayk7XG5leHBvcnRzLkNpcmNsZUNyb3NzID0gX21rX21vZGVsKCdDaXJjbGVDcm9zcycsIGNpcmNsZV9jcm9zcyk7XG5leHBvcnRzLkNpcmNsZVggPSBfbWtfbW9kZWwoJ0NpcmNsZVgnLCBjaXJjbGVfeCk7XG5leHBvcnRzLkNyb3NzID0gX21rX21vZGVsKCdDcm9zcycsIGNyb3NzKTtcbmV4cG9ydHMuRGlhbW9uZCA9IF9ta19tb2RlbCgnRGlhbW9uZCcsIGRpYW1vbmQpO1xuZXhwb3J0cy5EaWFtb25kQ3Jvc3MgPSBfbWtfbW9kZWwoJ0RpYW1vbmRDcm9zcycsIGRpYW1vbmRfY3Jvc3MpO1xuZXhwb3J0cy5JbnZlcnRlZFRyaWFuZ2xlID0gX21rX21vZGVsKCdJbnZlcnRlZFRyaWFuZ2xlJywgaW52ZXJ0ZWRfdHJpYW5nbGUpO1xuZXhwb3J0cy5TcXVhcmUgPSBfbWtfbW9kZWwoJ1NxdWFyZScsIHNxdWFyZSk7XG5leHBvcnRzLlNxdWFyZUNyb3NzID0gX21rX21vZGVsKCdTcXVhcmVDcm9zcycsIHNxdWFyZV9jcm9zcyk7XG5leHBvcnRzLlNxdWFyZVggPSBfbWtfbW9kZWwoJ1NxdWFyZVgnLCBzcXVhcmVfeCk7XG5leHBvcnRzLlRyaWFuZ2xlID0gX21rX21vZGVsKCdUcmlhbmdsZScsIHRyaWFuZ2xlKTtcbmV4cG9ydHMuWCA9IF9ta19tb2RlbCgnWCcsIHgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHh5X2dseXBoXzEgPSByZXF1aXJlKFwiLi4vZ2x5cGhzL3h5X2dseXBoXCIpO1xudmFyIGhpdHRlc3QgPSByZXF1aXJlKFwiY29yZS9oaXR0ZXN0XCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5NYXJrZXJWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE1hcmtlclZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIE1hcmtlclZpZXcoKSB7XG4gICAgICAgIHJldHVybiBNYXJrZXJWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNYXJrZXJWaWV3LnByb3RvdHlwZS5kcmF3X2xlZ2VuZF9mb3JfaW5kZXggPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGFuZ2xlLCBkYXRhLCBpbmRpY2VzLCBzaXplLCBzeCwgc3k7XG4gICAgICAgIGluZGljZXMgPSBbaW5kZXhdO1xuICAgICAgICBzeCA9IHt9O1xuICAgICAgICBzeFtpbmRleF0gPSAoeDAgKyB4MSkgLyAyO1xuICAgICAgICBzeSA9IHt9O1xuICAgICAgICBzeVtpbmRleF0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgICBzaXplID0ge307XG4gICAgICAgIHNpemVbaW5kZXhdID0gTWF0aC5taW4oTWF0aC5hYnMoeDEgLSB4MCksIE1hdGguYWJzKHkxIC0geTApKSAqIDAuNDtcbiAgICAgICAgYW5nbGUgPSB7fTtcbiAgICAgICAgYW5nbGVbaW5kZXhdID0gdGhpcy5fYW5nbGVbaW5kZXhdO1xuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgc3g6IHN4LFxuICAgICAgICAgICAgc3k6IHN5LFxuICAgICAgICAgICAgX3NpemU6IHNpemUsXG4gICAgICAgICAgICBfYW5nbGU6IGFuZ2xlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXIoY3R4LCBpbmRpY2VzLCBkYXRhKTtcbiAgICB9O1xuICAgIE1hcmtlclZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIF9hbmdsZSwgX3NpemUsIGksIGosIGxlbiwgciwgcmVzdWx0cywgc3gsIHN5O1xuICAgICAgICBzeCA9IGFyZy5zeCwgc3kgPSBhcmcuc3ksIF9zaXplID0gYXJnLl9zaXplLCBfYW5nbGUgPSBhcmcuX2FuZ2xlO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGkgPSBpbmRpY2VzW2pdO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHN4W2ldICsgc3lbaV0gKyBfc2l6ZVtpXSArIF9hbmdsZVtpXSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIgPSBfc2l6ZVtpXSAvIDI7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHN4W2ldLCBzeVtpXSk7XG4gICAgICAgICAgICBpZiAoX2FuZ2xlW2ldKSB7XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShfYW5nbGVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyX29uZShjdHgsIGksIHN4W2ldLCBzeVtpXSwgciwgdGhpcy52aXN1YWxzLmxpbmUsIHRoaXMudmlzdWFscy5maWxsKTtcbiAgICAgICAgICAgIGlmIChfYW5nbGVbaV0pIHtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKC1fYW5nbGVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC50cmFuc2xhdGUoLXN4W2ldLCAtc3lbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIE1hcmtlclZpZXcucHJvdG90eXBlLl9tYXNrX2RhdGEgPSBmdW5jdGlvbiAoYWxsX2luZGljZXMpIHtcbiAgICAgICAgdmFyIGJib3gsIGhyLCByZWYsIHJlZjEsIHZyLCB2eDAsIHZ4MSwgdnkwLCB2eTEsIHgwLCB4MSwgeTAsIHkxO1xuICAgICAgICBociA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmZyYW1lLmhfcmFuZ2U7XG4gICAgICAgIHZ4MCA9IGhyLnN0YXJ0IC0gdGhpcy5tYXhfc2l6ZTtcbiAgICAgICAgdngxID0gaHIuZW5kICsgdGhpcy5tYXhfc2l6ZTtcbiAgICAgICAgcmVmID0gdGhpcy5yZW5kZXJlci54c2NhbGUudl9pbnZlcnQoW3Z4MCwgdngxXSwgdHJ1ZSksIHgwID0gcmVmWzBdLCB4MSA9IHJlZlsxXTtcbiAgICAgICAgdnIgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5mcmFtZS52X3JhbmdlO1xuICAgICAgICB2eTAgPSB2ci5zdGFydCAtIHRoaXMubWF4X3NpemU7XG4gICAgICAgIHZ5MSA9IHZyLmVuZCArIHRoaXMubWF4X3NpemU7XG4gICAgICAgIHJlZjEgPSB0aGlzLnJlbmRlcmVyLnlzY2FsZS52X2ludmVydChbdnkwLCB2eTFdLCB0cnVlKSwgeTAgPSByZWYxWzBdLCB5MSA9IHJlZjFbMV07XG4gICAgICAgIGJib3ggPSBoaXR0ZXN0LnZhbGlkYXRlX2Jib3hfY29vcmRzKFt4MCwgeDFdLCBbeTAsIHkxXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4LmluZGljZXMoYmJveCk7XG4gICAgfTtcbiAgICBNYXJrZXJWaWV3LnByb3RvdHlwZS5faGl0X3BvaW50ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBiYm94LCBjYW5kaWRhdGVzLCBkaXN0LCBoaXRzLCBpLCBqLCBsZW4sIHJlZiwgcmVmMSwgcmVmMiwgczIsIHN4LCBzeSwgdngsIHZ4MCwgdngxLCB2eSwgdnkwLCB2eTEsIHgwLCB4MSwgeTAsIHkxO1xuICAgICAgICByZWYgPSBbZ2VvbWV0cnkudngsIGdlb21ldHJ5LnZ5XSwgdnggPSByZWZbMF0sIHZ5ID0gcmVmWzFdO1xuICAgICAgICBzeCA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52eF90b19zeCh2eCk7XG4gICAgICAgIHN5ID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzLnZ5X3RvX3N5KHZ5KTtcbiAgICAgICAgdngwID0gdnggLSB0aGlzLm1heF9zaXplO1xuICAgICAgICB2eDEgPSB2eCArIHRoaXMubWF4X3NpemU7XG4gICAgICAgIHJlZjEgPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS52X2ludmVydChbdngwLCB2eDFdLCB0cnVlKSwgeDAgPSByZWYxWzBdLCB4MSA9IHJlZjFbMV07XG4gICAgICAgIHZ5MCA9IHZ5IC0gdGhpcy5tYXhfc2l6ZTtcbiAgICAgICAgdnkxID0gdnkgKyB0aGlzLm1heF9zaXplO1xuICAgICAgICByZWYyID0gdGhpcy5yZW5kZXJlci55c2NhbGUudl9pbnZlcnQoW3Z5MCwgdnkxXSwgdHJ1ZSksIHkwID0gcmVmMlswXSwgeTEgPSByZWYyWzFdO1xuICAgICAgICBiYm94ID0gaGl0dGVzdC52YWxpZGF0ZV9iYm94X2Nvb3JkcyhbeDAsIHgxXSwgW3kwLCB5MV0pO1xuICAgICAgICBjYW5kaWRhdGVzID0gdGhpcy5pbmRleC5pbmRpY2VzKGJib3gpO1xuICAgICAgICBoaXRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGNhbmRpZGF0ZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGkgPSBjYW5kaWRhdGVzW2pdO1xuICAgICAgICAgICAgczIgPSB0aGlzLl9zaXplW2ldIC8gMjtcbiAgICAgICAgICAgIGRpc3QgPSBNYXRoLmFicyh0aGlzLnN4W2ldIC0gc3gpICsgTWF0aC5hYnModGhpcy5zeVtpXSAtIHN5KTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnN4W2ldIC0gc3gpIDw9IHMyICYmIE1hdGguYWJzKHRoaXMuc3lbaV0gLSBzeSkgPD0gczIpIHtcbiAgICAgICAgICAgICAgICBoaXRzLnB1c2goW2ksIGRpc3RdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGl0dGVzdC5jcmVhdGVfMWRfaGl0X3Rlc3RfcmVzdWx0KGhpdHMpO1xuICAgIH07XG4gICAgTWFya2VyVmlldy5wcm90b3R5cGUuX2hpdF9zcGFuID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBiYm94LCBoaXRzLCBtYXhYLCBtYXhZLCBtaW5YLCBtaW5ZLCBtcywgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZXN1bHQsIHZ4LCB2eDAsIHZ4MSwgdnksIHZ5MCwgdnkxLCB4MCwgeDEsIHkwLCB5MTtcbiAgICAgICAgcmVmID0gW2dlb21ldHJ5LnZ4LCBnZW9tZXRyeS52eV0sIHZ4ID0gcmVmWzBdLCB2eSA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IHRoaXMuYm91bmRzKCksIG1pblggPSByZWYxLm1pblgsIG1pblkgPSByZWYxLm1pblksIG1heFggPSByZWYxLm1heFgsIG1heFkgPSByZWYxLm1heFk7XG4gICAgICAgIHJlc3VsdCA9IGhpdHRlc3QuY3JlYXRlX2hpdF90ZXN0X3Jlc3VsdCgpO1xuICAgICAgICBpZiAoZ2VvbWV0cnkuZGlyZWN0aW9uID09PSAnaCcpIHtcbiAgICAgICAgICAgIHkwID0gbWluWTtcbiAgICAgICAgICAgIHkxID0gbWF4WTtcbiAgICAgICAgICAgIG1zID0gdGhpcy5tYXhfc2l6ZSAvIDI7XG4gICAgICAgICAgICB2eDAgPSB2eCAtIG1zO1xuICAgICAgICAgICAgdngxID0gdnggKyBtcztcbiAgICAgICAgICAgIHJlZjIgPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS52X2ludmVydChbdngwLCB2eDFdLCB0cnVlKSwgeDAgPSByZWYyWzBdLCB4MSA9IHJlZjJbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4MCA9IG1pblg7XG4gICAgICAgICAgICB4MSA9IG1heFg7XG4gICAgICAgICAgICBtcyA9IHRoaXMubWF4X3NpemUgLyAyO1xuICAgICAgICAgICAgdnkwID0gdnkgLSBtcztcbiAgICAgICAgICAgIHZ5MSA9IHZ5ICsgbXM7XG4gICAgICAgICAgICByZWYzID0gdGhpcy5yZW5kZXJlci55c2NhbGUudl9pbnZlcnQoW3Z5MCwgdnkxXSwgdHJ1ZSksIHkwID0gcmVmM1swXSwgeTEgPSByZWYzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGJib3ggPSBoaXR0ZXN0LnZhbGlkYXRlX2Jib3hfY29vcmRzKFt4MCwgeDFdLCBbeTAsIHkxXSk7XG4gICAgICAgIGhpdHMgPSB0aGlzLmluZGV4LmluZGljZXMoYmJveCk7XG4gICAgICAgIHJlc3VsdFsnMWQnXS5pbmRpY2VzID0gaGl0cztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1hcmtlclZpZXcucHJvdG90eXBlLl9oaXRfcmVjdCA9IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICB2YXIgYmJveCwgcmVmLCByZWYxLCByZXN1bHQsIHgwLCB4MSwgeTAsIHkxO1xuICAgICAgICByZWYgPSB0aGlzLnJlbmRlcmVyLnhzY2FsZS52X2ludmVydChbZ2VvbWV0cnkudngwLCBnZW9tZXRyeS52eDFdLCB0cnVlKSwgeDAgPSByZWZbMF0sIHgxID0gcmVmWzFdO1xuICAgICAgICByZWYxID0gdGhpcy5yZW5kZXJlci55c2NhbGUudl9pbnZlcnQoW2dlb21ldHJ5LnZ5MCwgZ2VvbWV0cnkudnkxXSwgdHJ1ZSksIHkwID0gcmVmMVswXSwgeTEgPSByZWYxWzFdO1xuICAgICAgICBiYm94ID0gaGl0dGVzdC52YWxpZGF0ZV9iYm94X2Nvb3JkcyhbeDAsIHgxXSwgW3kwLCB5MV0pO1xuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgcmVzdWx0WycxZCddLmluZGljZXMgPSB0aGlzLmluZGV4LmluZGljZXMoYmJveCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXJrZXJWaWV3LnByb3RvdHlwZS5faGl0X3BvbHkgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZXMsIGhpdHMsIGksIGlkeCwgaiwgaywgcmVmLCByZWYxLCByZWYyLCByZXN1bHQsIHJlc3VsdHMsIHN4LCBzeSwgdngsIHZ5O1xuICAgICAgICByZWYgPSBbZ2VvbWV0cnkudngsIGdlb21ldHJ5LnZ5XSwgdnggPSByZWZbMF0sIHZ5ID0gcmVmWzFdO1xuICAgICAgICBzeCA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52X3Z4X3RvX3N4KHZ4KTtcbiAgICAgICAgc3kgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudl92eV90b19zeSh2eSk7XG4gICAgICAgIGNhbmRpZGF0ZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIHJlZjEgPSB0aGlzLnN4Lmxlbmd0aDsgMCA8PSByZWYxID8gaiA8IHJlZjEgOiBqID4gcmVmMTsgMCA8PSByZWYxID8gaisrIDogai0tKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pLmFwcGx5KHRoaXMpO1xuICAgICAgICBoaXRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYyID0gY2FuZGlkYXRlcy5sZW5ndGg7IDAgPD0gcmVmMiA/IGsgPCByZWYyIDogayA+IHJlZjI7IGkgPSAwIDw9IHJlZjIgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIGlkeCA9IGNhbmRpZGF0ZXNbaV07XG4gICAgICAgICAgICBpZiAoaGl0dGVzdC5wb2ludF9pbl9wb2x5KHRoaXMuc3hbaV0sIHRoaXMuc3lbaV0sIHN4LCBzeSkpIHtcbiAgICAgICAgICAgICAgICBoaXRzLnB1c2goaWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgcmVzdWx0WycxZCddLmluZGljZXMgPSBoaXRzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIE1hcmtlclZpZXc7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGhWaWV3KTtcbmV4cG9ydHMuTWFya2VyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE1hcmtlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTWFya2VyKCkge1xuICAgICAgICByZXR1cm4gTWFya2VyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNYXJrZXIubWl4aW5zKFsnbGluZScsICdmaWxsJ10pO1xuICAgIE1hcmtlci5kZWZpbmUoe1xuICAgICAgICBzaXplOiBbXG4gICAgICAgICAgICBwLkRpc3RhbmNlU3BlYywge1xuICAgICAgICAgICAgICAgIHVuaXRzOiBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiA0XG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGFuZ2xlOiBbcC5BbmdsZVNwZWMsIDBdXG4gICAgfSk7XG4gICAgcmV0dXJuIE1hcmtlcjtcbn0pKHh5X2dseXBoXzEuWFlHbHlwaCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBnbWFwX3Bsb3RfY2FudmFzXzEgPSByZXF1aXJlKFwiLi9nbWFwX3Bsb3RfY2FudmFzXCIpO1xudmFyIHBsb3RfMSA9IHJlcXVpcmUoXCIuL3Bsb3RcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbFwiKTtcbmV4cG9ydHMuTWFwT3B0aW9ucyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChNYXBPcHRpb25zLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBNYXBPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gTWFwT3B0aW9ucy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWFwT3B0aW9ucy5wcm90b3R5cGUudHlwZSA9ICdNYXBPcHRpb25zJztcbiAgICBNYXBPcHRpb25zLmRlZmluZSh7XG4gICAgICAgIGxhdDogW3AuTnVtYmVyXSxcbiAgICAgICAgbG5nOiBbcC5OdW1iZXJdLFxuICAgICAgICB6b29tOiBbcC5OdW1iZXIsIDEyXVxuICAgIH0pO1xuICAgIHJldHVybiBNYXBPcHRpb25zO1xufSkobW9kZWxfMS5Nb2RlbCk7XG5leHBvcnRzLkdNYXBPcHRpb25zID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEdNYXBPcHRpb25zLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBHTWFwT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIEdNYXBPcHRpb25zLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHTWFwT3B0aW9ucy5wcm90b3R5cGUudHlwZSA9ICdHTWFwT3B0aW9ucyc7XG4gICAgR01hcE9wdGlvbnMuZGVmaW5lKHtcbiAgICAgICAgbWFwX3R5cGU6IFtwLlN0cmluZywgXCJyb2FkbWFwXCJdLFxuICAgICAgICBzY2FsZV9jb250cm9sOiBbcC5Cb29sLCBmYWxzZV0sXG4gICAgICAgIHN0eWxlczogW3AuU3RyaW5nXVxuICAgIH0pO1xuICAgIHJldHVybiBHTWFwT3B0aW9ucztcbn0pKGV4cG9ydHMuTWFwT3B0aW9ucyk7XG5leHBvcnRzLkdNYXBQbG90VmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChHTWFwUGxvdFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEdNYXBQbG90VmlldygpIHtcbiAgICAgICAgcmV0dXJuIEdNYXBQbG90Vmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIEdNYXBQbG90Vmlldztcbn0pKHBsb3RfMS5QbG90Vmlldyk7XG5leHBvcnRzLkdNYXBQbG90ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEdNYXBQbG90LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBHTWFwUGxvdCgpIHtcbiAgICAgICAgcmV0dXJuIEdNYXBQbG90Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHTWFwUGxvdC5wcm90b3R5cGUudHlwZSA9ICdHTWFwUGxvdCc7XG4gICAgR01hcFBsb3QucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuR01hcFBsb3RWaWV3O1xuICAgIEdNYXBQbG90LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgR01hcFBsb3QuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCF0aGlzLmFwaV9rZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLmVycm9yKFwiYXBpX2tleSBpcyByZXF1aXJlZC4gU2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L2dldC1hcGkta2V5IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyB0byBvYnRhaW4geW91ciBvd24uXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHTWFwUGxvdC5wcm90b3R5cGUuX2luaXRfcGxvdF9jYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgZ21hcF9wbG90X2NhbnZhc18xLkdNYXBQbG90Q2FudmFzKHtcbiAgICAgICAgICAgIHBsb3Q6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHTWFwUGxvdC5kZWZpbmUoe1xuICAgICAgICBtYXBfb3B0aW9uczogW3AuSW5zdGFuY2VdLFxuICAgICAgICBhcGlfa2V5OiBbcC5TdHJpbmddXG4gICAgfSk7XG4gICAgcmV0dXJuIEdNYXBQbG90O1xufSkocGxvdF8xLlBsb3QpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ21hcHNfcmVhZHksIGxvYWRfZ29vZ2xlX2FwaSwgYmluZCA9IGZ1bmN0aW9uIChmbiwgbWUpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LCBleHRlbmQxID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHByb2o0XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3Byb2o0XCIpO1xudmFyIHBsb3RfY2FudmFzXzEgPSByZXF1aXJlKFwiLi9wbG90X2NhbnZhc1wiKTtcbnZhciBzaWduYWxpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL3NpZ25hbGluZ1wiKTtcbmdtYXBzX3JlYWR5ID0gbmV3IHNpZ25hbGluZ18xLlNpZ25hbCh0aGlzLCBcImdtYXBzX3JlYWR5XCIpO1xubG9hZF9nb29nbGVfYXBpID0gZnVuY3Rpb24gKGFwaV9rZXkpIHtcbiAgICB2YXIgc2NyaXB0O1xuICAgIHdpbmRvdy5fYm9rZWhfZ21hcHNfY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnbWFwc19yZWFkeS5lbWl0KCk7XG4gICAgfTtcbiAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgIHNjcmlwdC5zcmMgPSBcImh0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcz9rZXk9XCIgKyBhcGlfa2V5ICsgXCImY2FsbGJhY2s9X2Jva2VoX2dtYXBzX2NhbGxiYWNrXCI7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbn07XG5leHBvcnRzLkdNYXBQbG90Q2FudmFzVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoR01hcFBsb3RDYW52YXNWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBHTWFwUGxvdENhbnZhc1ZpZXcoKSB7XG4gICAgICAgIHRoaXMuX3NldF9ib2tlaF9yYW5nZXMgPSBiaW5kKHRoaXMuX3NldF9ib2tlaF9yYW5nZXMsIHRoaXMpO1xuICAgICAgICB0aGlzLl9nZXRfcHJvamVjdGVkX2JvdW5kcyA9IGJpbmQodGhpcy5fZ2V0X3Byb2plY3RlZF9ib3VuZHMsIHRoaXMpO1xuICAgICAgICB0aGlzLl9nZXRfbGF0bG9uX2JvdW5kcyA9IGJpbmQodGhpcy5fZ2V0X2xhdGxvbl9ib3VuZHMsIHRoaXMpO1xuICAgICAgICByZXR1cm4gR01hcFBsb3RDYW52YXNWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHTWFwUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgbW8sIHJlZjtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICBHTWFwUGxvdENhbnZhc1ZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fdGlsZXNfbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuem9vbV9jb3VudCA9IDA7XG4gICAgICAgIG1vID0gdGhpcy5tb2RlbC5wbG90Lm1hcF9vcHRpb25zO1xuICAgICAgICB0aGlzLmluaXRpYWxfem9vbSA9IG1vLnpvb207XG4gICAgICAgIHRoaXMuaW5pdGlhbF9sYXQgPSBtby5sYXQ7XG4gICAgICAgIHRoaXMuaW5pdGlhbF9sbmcgPSBtby5sbmc7XG4gICAgICAgIHRoaXMuY2FudmFzX3ZpZXcubWFwX2VsLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBpZiAoKChyZWYgPSB3aW5kb3cuZ29vZ2xlKSAhPSBudWxsID8gcmVmLm1hcHMgOiB2b2lkIDApID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuX2Jva2VoX2dtYXBzX2NhbGxiYWNrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2FkX2dvb2dsZV9hcGkodGhpcy5tb2RlbC5wbG90LmFwaV9rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ21hcHNfcmVhZHkuY29ubmVjdCgoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51bnBhdXNlKCk7XG4gICAgfTtcbiAgICBHTWFwUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnVwZGF0ZV9yYW5nZSA9IGZ1bmN0aW9uIChyYW5nZV9pbmZvKSB7XG4gICAgICAgIHZhciBtbywgbmV3X21hcF96b29tLCBvbGRfbWFwX3pvb20sIHByb2pfeGVuZCwgcHJval94c3RhcnQsIHByb2pfeWVuZCwgcHJval95c3RhcnQsIHJlZiwgem9vbV9jaGFuZ2U7XG4gICAgICAgIGlmIChyYW5nZV9pbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgIG1vID0gdGhpcy5tb2RlbC5wbG90Lm1hcF9vcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5tYXAuc2V0Q2VudGVyKHtcbiAgICAgICAgICAgICAgICBsYXQ6IHRoaXMuaW5pdGlhbF9sYXQsXG4gICAgICAgICAgICAgICAgbG5nOiB0aGlzLmluaXRpYWxfbG5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubWFwLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIHpvb206IHRoaXMuaW5pdGlhbF96b29tXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEdNYXBQbG90Q2FudmFzVmlldy5fX3N1cGVyX18udXBkYXRlX3JhbmdlLmNhbGwodGhpcywgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHJhbmdlX2luZm8uc2R4ICE9IG51bGwpIHx8IChyYW5nZV9pbmZvLnNkeSAhPSBudWxsKSkge1xuICAgICAgICAgICAgdGhpcy5tYXAucGFuQnkocmFuZ2VfaW5mby5zZHgsIHJhbmdlX2luZm8uc2R5KTtcbiAgICAgICAgICAgIEdNYXBQbG90Q2FudmFzVmlldy5fX3N1cGVyX18udXBkYXRlX3JhbmdlLmNhbGwodGhpcywgcmFuZ2VfaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmFuZ2VfaW5mby5mYWN0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuem9vbV9jb3VudCAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21fY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnpvb21fY291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgR01hcFBsb3RDYW52YXNWaWV3Ll9fc3VwZXJfXy51cGRhdGVfcmFuZ2UuY2FsbCh0aGlzLCByYW5nZV9pbmZvKTtcbiAgICAgICAgICAgIGlmIChyYW5nZV9pbmZvLmZhY3RvciA8IDApIHtcbiAgICAgICAgICAgICAgICB6b29tX2NoYW5nZSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgem9vbV9jaGFuZ2UgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2xkX21hcF96b29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgbmV3X21hcF96b29tID0gb2xkX21hcF96b29tICsgem9vbV9jaGFuZ2U7XG4gICAgICAgICAgICBpZiAobmV3X21hcF96b29tID49IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5zZXRab29tKG5ld19tYXBfem9vbSk7XG4gICAgICAgICAgICAgICAgcmVmID0gdGhpcy5fZ2V0X3Byb2plY3RlZF9ib3VuZHMoKSwgcHJval94c3RhcnQgPSByZWZbMF0sIHByb2pfeGVuZCA9IHJlZlsxXSwgcHJval95c3RhcnQgPSByZWZbMl0sIHByb2pfeWVuZCA9IHJlZlszXTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2pfeGVuZCAtIHByb2pfeHN0YXJ0KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXAuc2V0Wm9vbShvbGRfbWFwX3pvb20pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXRfYm9rZWhfcmFuZ2VzKCk7XG4gICAgfTtcbiAgICBHTWFwUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl9idWlsZF9tYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXBfb3B0aW9ucywgbWFwcywgbW87XG4gICAgICAgIG1hcHMgPSB3aW5kb3cuZ29vZ2xlLm1hcHM7XG4gICAgICAgIHRoaXMubWFwX3R5cGVzID0ge1xuICAgICAgICAgICAgc2F0ZWxsaXRlOiBtYXBzLk1hcFR5cGVJZC5TQVRFTExJVEUsXG4gICAgICAgICAgICB0ZXJyYWluOiBtYXBzLk1hcFR5cGVJZC5URVJSQUlOLFxuICAgICAgICAgICAgcm9hZG1hcDogbWFwcy5NYXBUeXBlSWQuUk9BRE1BUCxcbiAgICAgICAgICAgIGh5YnJpZDogbWFwcy5NYXBUeXBlSWQuSFlCUklEXG4gICAgICAgIH07XG4gICAgICAgIG1vID0gdGhpcy5tb2RlbC5wbG90Lm1hcF9vcHRpb25zO1xuICAgICAgICBtYXBfb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNlbnRlcjogbmV3IG1hcHMuTGF0TG5nKG1vLmxhdCwgbW8ubG5nKSxcbiAgICAgICAgICAgIHpvb206IG1vLnpvb20sXG4gICAgICAgICAgICBkaXNhYmxlRGVmYXVsdFVJOiB0cnVlLFxuICAgICAgICAgICAgbWFwVHlwZUlkOiB0aGlzLm1hcF90eXBlc1ttby5tYXBfdHlwZV0sXG4gICAgICAgICAgICBzY2FsZUNvbnRyb2w6IG1vLnNjYWxlX2NvbnRyb2xcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1vLnN0eWxlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBfb3B0aW9ucy5zdHlsZXMgPSBKU09OLnBhcnNlKG1vLnN0eWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgbWFwcy5NYXAodGhpcy5jYW52YXNfdmlldy5tYXBfZWwsIG1hcF9vcHRpb25zKTtcbiAgICAgICAgbWFwcy5ldmVudC5hZGRMaXN0ZW5lcih0aGlzLm1hcCwgJ2lkbGUnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2V0X2Jva2VoX3JhbmdlcygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICBtYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRoaXMubWFwLCAnYm91bmRzX2NoYW5nZWQnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2V0X2Jva2VoX3JhbmdlcygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICBtYXBzLmV2ZW50LmFkZExpc3RlbmVyT25jZSh0aGlzLm1hcCwgJ3RpbGVzbG9hZGVkJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlbmRlcl9maW5pc2hlZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5wbG90LnByb3BlcnRpZXMubWFwX29wdGlvbnMuY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdXBkYXRlX29wdGlvbnMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMubW9kZWwucGxvdC5tYXBfb3B0aW9ucy5wcm9wZXJ0aWVzLnN0eWxlcy5jaGFuZ2UsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl91cGRhdGVfc3R5bGVzKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnBsb3QubWFwX29wdGlvbnMucHJvcGVydGllcy5sYXQuY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdXBkYXRlX2NlbnRlcignbGF0Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnBsb3QubWFwX29wdGlvbnMucHJvcGVydGllcy5sbmcuY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdXBkYXRlX2NlbnRlcignbG5nJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnBsb3QubWFwX29wdGlvbnMucHJvcGVydGllcy56b29tLmNoYW5nZSwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3VwZGF0ZV96b29tKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnBsb3QubWFwX29wdGlvbnMucHJvcGVydGllcy5tYXBfdHlwZS5jaGFuZ2UsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl91cGRhdGVfbWFwX3R5cGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnBsb3QubWFwX29wdGlvbnMucHJvcGVydGllcy5zY2FsZV9jb250cm9sLmNoYW5nZSwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3VwZGF0ZV9zY2FsZV9jb250cm9sKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgfTtcbiAgICBHTWFwUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl9yZW5kZXJfZmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RpbGVzX2xvYWRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLm5vdGlmeV9maW5pc2hlZCgpO1xuICAgIH07XG4gICAgR01hcFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5oYXNfZmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBHTWFwUGxvdENhbnZhc1ZpZXcuX19zdXBlcl9fLmhhc19maW5pc2hlZC5jYWxsKHRoaXMpICYmIHRoaXMuX3RpbGVzX2xvYWRlZCA9PT0gdHJ1ZTtcbiAgICB9O1xuICAgIEdNYXBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuX2dldF9sYXRsb25fYm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm90dG9tX2xlZnQsIGJvdW5kcywgdG9wX3JpZ2h0LCB4ZW5kLCB4c3RhcnQsIHllbmQsIHlzdGFydDtcbiAgICAgICAgYm91bmRzID0gdGhpcy5tYXAuZ2V0Qm91bmRzKCk7XG4gICAgICAgIHRvcF9yaWdodCA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKTtcbiAgICAgICAgYm90dG9tX2xlZnQgPSBib3VuZHMuZ2V0U291dGhXZXN0KCk7XG4gICAgICAgIHhzdGFydCA9IGJvdHRvbV9sZWZ0LmxuZygpO1xuICAgICAgICB4ZW5kID0gdG9wX3JpZ2h0LmxuZygpO1xuICAgICAgICB5c3RhcnQgPSBib3R0b21fbGVmdC5sYXQoKTtcbiAgICAgICAgeWVuZCA9IHRvcF9yaWdodC5sYXQoKTtcbiAgICAgICAgcmV0dXJuIFt4c3RhcnQsIHhlbmQsIHlzdGFydCwgeWVuZF07XG4gICAgfTtcbiAgICBHTWFwUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl9nZXRfcHJvamVjdGVkX2JvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb2pfeGVuZCwgcHJval94c3RhcnQsIHByb2pfeWVuZCwgcHJval95c3RhcnQsIHJlZiwgcmVmMSwgcmVmMiwgeGVuZCwgeHN0YXJ0LCB5ZW5kLCB5c3RhcnQ7XG4gICAgICAgIHJlZiA9IHRoaXMuX2dldF9sYXRsb25fYm91bmRzKCksIHhzdGFydCA9IHJlZlswXSwgeGVuZCA9IHJlZlsxXSwgeXN0YXJ0ID0gcmVmWzJdLCB5ZW5kID0gcmVmWzNdO1xuICAgICAgICByZWYxID0gcHJvajRfMS5wcm9qNChwcm9qNF8xLm1lcmNhdG9yLCBbeHN0YXJ0LCB5c3RhcnRdKSwgcHJval94c3RhcnQgPSByZWYxWzBdLCBwcm9qX3lzdGFydCA9IHJlZjFbMV07XG4gICAgICAgIHJlZjIgPSBwcm9qNF8xLnByb2o0KHByb2o0XzEubWVyY2F0b3IsIFt4ZW5kLCB5ZW5kXSksIHByb2pfeGVuZCA9IHJlZjJbMF0sIHByb2pfeWVuZCA9IHJlZjJbMV07XG4gICAgICAgIHJldHVybiBbcHJval94c3RhcnQsIHByb2pfeGVuZCwgcHJval95c3RhcnQsIHByb2pfeWVuZF07XG4gICAgfTtcbiAgICBHTWFwUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl9zZXRfYm9rZWhfcmFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJval94ZW5kLCBwcm9qX3hzdGFydCwgcHJval95ZW5kLCBwcm9qX3lzdGFydCwgcmVmO1xuICAgICAgICByZWYgPSB0aGlzLl9nZXRfcHJvamVjdGVkX2JvdW5kcygpLCBwcm9qX3hzdGFydCA9IHJlZlswXSwgcHJval94ZW5kID0gcmVmWzFdLCBwcm9qX3lzdGFydCA9IHJlZlsyXSwgcHJval95ZW5kID0gcmVmWzNdO1xuICAgICAgICB0aGlzLmZyYW1lLnhfcmFuZ2Uuc2V0dih7XG4gICAgICAgICAgICBzdGFydDogcHJval94c3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHByb2pfeGVuZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWUueV9yYW5nZS5zZXR2KHtcbiAgICAgICAgICAgIHN0YXJ0OiBwcm9qX3lzdGFydCxcbiAgICAgICAgICAgIGVuZDogcHJval95ZW5kXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR01hcFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5fdXBkYXRlX2NlbnRlciA9IGZ1bmN0aW9uIChmbGQpIHtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIGMgPSB0aGlzLm1hcC5nZXRDZW50ZXIoKS50b0pTT04oKTtcbiAgICAgICAgY1tmbGRdID0gdGhpcy5tb2RlbC5wbG90Lm1hcF9vcHRpb25zW2ZsZF07XG4gICAgICAgIHRoaXMubWFwLnNldENlbnRlcihjKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldF9ib2tlaF9yYW5nZXMoKTtcbiAgICB9O1xuICAgIEdNYXBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuX3VwZGF0ZV9tYXBfdHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hcHM7XG4gICAgICAgIG1hcHMgPSB3aW5kb3cuZ29vZ2xlLm1hcHM7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIG1hcFR5cGVJZDogdGhpcy5tYXBfdHlwZXNbdGhpcy5tb2RlbC5wbG90Lm1hcF9vcHRpb25zLm1hcF90eXBlXVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdNYXBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuX3VwZGF0ZV9zY2FsZV9jb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFwcztcbiAgICAgICAgbWFwcyA9IHdpbmRvdy5nb29nbGUubWFwcztcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgc2NhbGVDb250cm9sOiB0aGlzLm1vZGVsLnBsb3QubWFwX29wdGlvbnMuc2NhbGVfY29udHJvbFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdNYXBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuX3VwZGF0ZV9vcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVfc3R5bGVzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZV9jZW50ZXIoJ2xhdCcpO1xuICAgICAgICB0aGlzLl91cGRhdGVfY2VudGVyKCdsbmcnKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlX3pvb20oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZV9tYXBfdHlwZSgpO1xuICAgIH07XG4gICAgR01hcFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5fdXBkYXRlX3N0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgc3R5bGVzOiBKU09OLnBhcnNlKHRoaXMubW9kZWwucGxvdC5tYXBfb3B0aW9ucy5zdHlsZXMpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR01hcFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5fdXBkYXRlX3pvb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWFwLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgem9vbTogdGhpcy5tb2RlbC5wbG90Lm1hcF9vcHRpb25zLnpvb21cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXRfYm9rZWhfcmFuZ2VzKCk7XG4gICAgfTtcbiAgICBHTWFwUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl9tYXBfaG9vayA9IGZ1bmN0aW9uIChjdHgsIGZyYW1lX2JveCkge1xuICAgICAgICB2YXIgaGVpZ2h0LCBsZWZ0LCByZWYsIHRvcCwgd2lkdGg7XG4gICAgICAgIGxlZnQgPSBmcmFtZV9ib3hbMF0sIHRvcCA9IGZyYW1lX2JveFsxXSwgd2lkdGggPSBmcmFtZV9ib3hbMl0sIGhlaWdodCA9IGZyYW1lX2JveFszXTtcbiAgICAgICAgdGhpcy5jYW52YXNfdmlldy5tYXBfZWwuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICB0aGlzLmNhbnZhc192aWV3Lm1hcF9lbC5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5jYW52YXNfdmlldy5tYXBfZWwuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5jYW52YXNfdmlldy5tYXBfZWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICBpZiAoKHRoaXMubWFwID09IG51bGwpICYmICgoKHJlZiA9IHdpbmRvdy5nb29nbGUpICE9IG51bGwgPyByZWYubWFwcyA6IHZvaWQgMCkgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWlsZF9tYXAoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR01hcFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5fcGFpbnRfZW1wdHkgPSBmdW5jdGlvbiAoY3R4LCBmcmFtZV9ib3gpIHtcbiAgICAgICAgdmFyIGloLCBpdywgbGVmdCwgb2gsIG93LCB0b3A7XG4gICAgICAgIG93ID0gdGhpcy5jYW52YXMuX3dpZHRoLnZhbHVlO1xuICAgICAgICBvaCA9IHRoaXMuY2FudmFzLl9oZWlnaHQudmFsdWU7XG4gICAgICAgIGxlZnQgPSBmcmFtZV9ib3hbMF0sIHRvcCA9IGZyYW1lX2JveFsxXSwgaXcgPSBmcmFtZV9ib3hbMl0sIGloID0gZnJhbWVfYm94WzNdO1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIG93LCBvaCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCBvaCk7XG4gICAgICAgIGN0eC5saW5lVG8ob3csIG9oKTtcbiAgICAgICAgY3R4LmxpbmVUbyhvdywgMCk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgMCk7XG4gICAgICAgIGN0eC5tb3ZlVG8obGVmdCwgdG9wKTtcbiAgICAgICAgY3R4LmxpbmVUbyhsZWZ0ICsgaXcsIHRvcCk7XG4gICAgICAgIGN0eC5saW5lVG8obGVmdCArIGl3LCB0b3AgKyBpaCk7XG4gICAgICAgIGN0eC5saW5lVG8obGVmdCwgdG9wICsgaWgpO1xuICAgICAgICBjdHgubGluZVRvKGxlZnQsIHRvcCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubW9kZWwucGxvdC5ib3JkZXJfZmlsbF9jb2xvcjtcbiAgICAgICAgcmV0dXJuIGN0eC5maWxsKCk7XG4gICAgfTtcbiAgICByZXR1cm4gR01hcFBsb3RDYW52YXNWaWV3O1xufSkocGxvdF9jYW52YXNfMS5QbG90Q2FudmFzVmlldyk7XG5leHBvcnRzLkdNYXBQbG90Q2FudmFzID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShHTWFwUGxvdENhbnZhcywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gR01hcFBsb3RDYW52YXMoKSB7XG4gICAgICAgIHJldHVybiBHTWFwUGxvdENhbnZhcy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgR01hcFBsb3RDYW52YXMucHJvdG90eXBlLnR5cGUgPSAnR01hcFBsb3RDYW52YXMnO1xuICAgIEdNYXBQbG90Q2FudmFzLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkdNYXBQbG90Q2FudmFzVmlldztcbiAgICBHTWFwUGxvdENhbnZhcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnVzZV9tYXAgPSB0cnVlO1xuICAgICAgICByZXR1cm4gR01hcFBsb3RDYW52YXMuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gR01hcFBsb3RDYW52YXM7XG59KShwbG90X2NhbnZhc18xLlBsb3RDYW52YXMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ21hcF9wbG90XzEgPSByZXF1aXJlKFwiLi9nbWFwX3Bsb3RcIik7XG5leHBvcnRzLk1hcE9wdGlvbnMgPSBnbWFwX3Bsb3RfMS5NYXBPcHRpb25zO1xudmFyIGdtYXBfcGxvdF8yID0gcmVxdWlyZShcIi4vZ21hcF9wbG90XCIpO1xuZXhwb3J0cy5HTWFwT3B0aW9ucyA9IGdtYXBfcGxvdF8yLkdNYXBPcHRpb25zO1xudmFyIGdtYXBfcGxvdF8zID0gcmVxdWlyZShcIi4vZ21hcF9wbG90XCIpO1xuZXhwb3J0cy5HTWFwUGxvdCA9IGdtYXBfcGxvdF8zLkdNYXBQbG90O1xudmFyIGdtYXBfcGxvdF9jYW52YXNfMSA9IHJlcXVpcmUoXCIuL2dtYXBfcGxvdF9jYW52YXNcIik7XG5leHBvcnRzLkdNYXBQbG90Q2FudmFzID0gZ21hcF9wbG90X2NhbnZhc18xLkdNYXBQbG90Q2FudmFzO1xudmFyIHBsb3RfMSA9IHJlcXVpcmUoXCIuL3Bsb3RcIik7XG5leHBvcnRzLlBsb3QgPSBwbG90XzEuUGxvdDtcbnZhciBwbG90X2NhbnZhc18xID0gcmVxdWlyZShcIi4vcGxvdF9jYW52YXNcIik7XG5leHBvcnRzLlBsb3RDYW52YXMgPSBwbG90X2NhbnZhc18xLlBsb3RDYW52YXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQxID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBzbGljZSA9IFtdLnNsaWNlO1xudmFyIHNvbHZlcl8xID0gcmVxdWlyZShcImNvcmUvbGF5b3V0L3NvbHZlclwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9vYmplY3RcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdHlwZXNcIik7XG52YXIgbGF5b3V0X2RvbV8xID0gcmVxdWlyZShcIi4uL2xheW91dHMvbGF5b3V0X2RvbVwiKTtcbnZhciB0aXRsZV8xID0gcmVxdWlyZShcIi4uL2Fubm90YXRpb25zL3RpdGxlXCIpO1xudmFyIGxpbmVhcl9zY2FsZV8xID0gcmVxdWlyZShcIi4uL3NjYWxlcy9saW5lYXJfc2NhbGVcIik7XG52YXIgdG9vbGJhcl8xID0gcmVxdWlyZShcIi4uL3Rvb2xzL3Rvb2xiYXJcIik7XG52YXIgdG9vbF9ldmVudHNfMSA9IHJlcXVpcmUoXCIuLi90b29scy90b29sX2V2ZW50c1wiKTtcbnZhciBwbG90X2NhbnZhc18xID0gcmVxdWlyZShcIi4vcGxvdF9jYW52YXNcIik7XG52YXIgY29sdW1uX2RhdGFfc291cmNlXzEgPSByZXF1aXJlKFwiLi4vc291cmNlcy9jb2x1bW5fZGF0YV9zb3VyY2VcIik7XG52YXIgZ2x5cGhfcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuLi9yZW5kZXJlcnMvZ2x5cGhfcmVuZGVyZXJcIik7XG52YXIgYm9rZWhfZXZlbnRzXzEgPSByZXF1aXJlKFwiY29yZS9ib2tlaF9ldmVudHNcIik7XG5leHBvcnRzLlBsb3RWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShQbG90Vmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUGxvdFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBQbG90Vmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGxvdFZpZXcucHJvdG90eXBlLmNsYXNzTmFtZSA9IFwiYmstcGxvdC1sYXlvdXRcIjtcbiAgICBQbG90Vmlldy5wcm90b3R5cGUuY29ubmVjdF9zaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGl0bGVfbXNnO1xuICAgICAgICBQbG90Vmlldy5fX3N1cGVyX18uY29ubmVjdF9zaWduYWxzLmNhbGwodGhpcyk7XG4gICAgICAgIHRpdGxlX21zZyA9IFwiVGl0bGUgb2JqZWN0IGNhbm5vdCBiZSByZXBsYWNlZC4gVHJ5IGNoYW5naW5nIHByb3BlcnRpZXMgb24gdGl0bGUgdG8gdXBkYXRlIGl0IGFmdGVyIGluaXRpYWxpemF0aW9uLlwiO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMubW9kZWwucHJvcGVydGllcy50aXRsZS5jaGFuZ2UsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIud2Fybih0aXRsZV9tc2cpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgIH07XG4gICAgUGxvdFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhlaWdodCwgcmVmLCB3aWR0aDtcbiAgICAgICAgUGxvdFZpZXcuX19zdXBlcl9fLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5zaXppbmdfbW9kZSA9PT0gJ3NjYWxlX2JvdGgnKSB7XG4gICAgICAgICAgICByZWYgPSB0aGlzLmdldF93aWR0aF9oZWlnaHQoKSwgd2lkdGggPSByZWZbMF0sIGhlaWdodCA9IHJlZlsxXTtcbiAgICAgICAgICAgIHRoaXMuc29sdmVyLnN1Z2dlc3RfdmFsdWUodGhpcy5tb2RlbC5fd2lkdGgsIHdpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuc29sdmVyLnN1Z2dlc3RfdmFsdWUodGhpcy5tb2RlbC5faGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5zb2x2ZXIudXBkYXRlX3ZhcmlhYmxlcygpO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmxlZnQgPSB0aGlzLm1vZGVsLl9kb21fbGVmdC52YWx1ZSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gdGhpcy5tb2RlbC5fZG9tX3RvcC52YWx1ZSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUud2lkdGggPSB0aGlzLm1vZGVsLl93aWR0aC52YWx1ZSArIFwicHhcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLnN0eWxlLmhlaWdodCA9IHRoaXMubW9kZWwuX2hlaWdodC52YWx1ZSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxvdFZpZXcucHJvdG90eXBlLmdldF93aWR0aF9oZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhciwgaGVpZ2h0LCBuZXdfaGVpZ2h0XzEsIG5ld19oZWlnaHRfMiwgbmV3X3dpZHRoXzEsIG5ld193aWR0aF8yLCBwYXJlbnRfaGVpZ2h0LCBwYXJlbnRfd2lkdGgsIHdpZHRoO1xuICAgICAgICBwYXJlbnRfaGVpZ2h0ID0gdGhpcy5lbC5wYXJlbnROb2RlLmNsaWVudEhlaWdodDtcbiAgICAgICAgcGFyZW50X3dpZHRoID0gdGhpcy5lbC5wYXJlbnROb2RlLmNsaWVudFdpZHRoO1xuICAgICAgICBhciA9IHRoaXMubW9kZWwuZ2V0X2FzcGVjdF9yYXRpbygpO1xuICAgICAgICBuZXdfd2lkdGhfMSA9IHBhcmVudF93aWR0aDtcbiAgICAgICAgbmV3X2hlaWdodF8xID0gcGFyZW50X3dpZHRoIC8gYXI7XG4gICAgICAgIG5ld193aWR0aF8yID0gcGFyZW50X2hlaWdodCAqIGFyO1xuICAgICAgICBuZXdfaGVpZ2h0XzIgPSBwYXJlbnRfaGVpZ2h0O1xuICAgICAgICBpZiAobmV3X3dpZHRoXzEgPCBuZXdfd2lkdGhfMikge1xuICAgICAgICAgICAgd2lkdGggPSBuZXdfd2lkdGhfMTtcbiAgICAgICAgICAgIGhlaWdodCA9IG5ld19oZWlnaHRfMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpZHRoID0gbmV3X3dpZHRoXzI7XG4gICAgICAgICAgICBoZWlnaHQgPSBuZXdfaGVpZ2h0XzI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTtcbiAgICB9O1xuICAgIFBsb3RWaWV3LnByb3RvdHlwZS5nZXRfaGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5fd2lkdGgudmFsdWUgLyB0aGlzLm1vZGVsLmdldF9hc3BlY3RfcmF0aW8oKTtcbiAgICB9O1xuICAgIFBsb3RWaWV3LnByb3RvdHlwZS5nZXRfd2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLl9oZWlnaHQudmFsdWUgKiB0aGlzLm1vZGVsLmdldF9hc3BlY3RfcmF0aW8oKTtcbiAgICB9O1xuICAgIFBsb3RWaWV3LnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdF9jYW52YXNfdmlldy5zYXZlKG5hbWUpO1xuICAgIH07XG4gICAgUGxvdFZpZXcuZ2V0dGVycyh7XG4gICAgICAgIHBsb3RfY2FudmFzX3ZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2aWV3O1xuICAgICAgICAgICAgcmV0dXJuICgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpLCBsZW4sIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZWYgPSBvYmplY3RfMS52YWx1ZXModGhpcy5jaGlsZF92aWV3cyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3ID0gcmVmW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIHBsb3RfY2FudmFzXzEuUGxvdENhbnZhc1ZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcykpWzBdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFBsb3RWaWV3O1xufSkobGF5b3V0X2RvbV8xLkxheW91dERPTVZpZXcpO1xuZXhwb3J0cy5QbG90ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShQbG90LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBQbG90KCkge1xuICAgICAgICByZXR1cm4gUGxvdC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGxvdC5wcm90b3R5cGUudHlwZSA9ICdQbG90JztcbiAgICBQbG90LnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlBsb3RWaWV3O1xuICAgIFBsb3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3NldF9zaXplYWJsZSwgaSwgaiwgaywgbCwgbGF5b3V0X3JlbmRlcmVycywgbGVuLCBsZW4xLCBsZW4yLCBsZW4zLCBwbG90cywgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZW5kZXJlciwgc2lkZSwgdGl0bGUsIHhyLCB5cjtcbiAgICAgICAgUGxvdC5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICByZWYgPSBvYmplY3RfMS52YWx1ZXModGhpcy5leHRyYV94X3JhbmdlcykuY29uY2F0KHRoaXMueF9yYW5nZSk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgeHIgPSByZWZbaV07XG4gICAgICAgICAgICBwbG90cyA9IHhyLnBsb3RzO1xuICAgICAgICAgICAgaWYgKHR5cGVzXzEuaXNBcnJheShwbG90cykpIHtcbiAgICAgICAgICAgICAgICBwbG90cyA9IHBsb3RzLmNvbmNhdCh0aGlzKTtcbiAgICAgICAgICAgICAgICB4ci5zZXR2KCdwbG90cycsIHBsb3RzLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlZjEgPSBvYmplY3RfMS52YWx1ZXModGhpcy5leHRyYV95X3JhbmdlcykuY29uY2F0KHRoaXMueV9yYW5nZSk7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSByZWYxLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgICAgeXIgPSByZWYxW2pdO1xuICAgICAgICAgICAgcGxvdHMgPSB5ci5wbG90cztcbiAgICAgICAgICAgIGlmICh0eXBlc18xLmlzQXJyYXkocGxvdHMpKSB7XG4gICAgICAgICAgICAgICAgcGxvdHMgPSBwbG90cy5jb25jYXQodGhpcyk7XG4gICAgICAgICAgICAgICAgeXIuc2V0digncGxvdHMnLCBwbG90cywge1xuICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ob3Jpem9udGFsID0gKHJlZjIgPSB0aGlzLnRvb2xiYXJfbG9jYXRpb24pID09PSAnbGVmdCcgfHwgcmVmMiA9PT0gJ3JpZ2h0JztcbiAgICAgICAgaWYgKHRoaXMubWluX2JvcmRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5taW5fYm9yZGVyX3RvcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5fYm9yZGVyX3RvcCA9IHRoaXMubWluX2JvcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1pbl9ib3JkZXJfYm90dG9tID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbl9ib3JkZXJfYm90dG9tID0gdGhpcy5taW5fYm9yZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubWluX2JvcmRlcl9sZWZ0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbl9ib3JkZXJfbGVmdCA9IHRoaXMubWluX2JvcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1pbl9ib3JkZXJfcmlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWluX2JvcmRlcl9yaWdodCA9IHRoaXMubWluX2JvcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aXRsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aXRsZSA9IHR5cGVzXzEuaXNTdHJpbmcodGhpcy50aXRsZSkgPyBuZXcgdGl0bGVfMS5UaXRsZSh7XG4gICAgICAgICAgICAgICAgdGV4dDogdGhpcy50aXRsZVxuICAgICAgICAgICAgfSkgOiB0aGlzLnRpdGxlO1xuICAgICAgICAgICAgdGhpcy5hZGRfbGF5b3V0KHRpdGxlLCB0aGlzLnRpdGxlX2xvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wbG90X2NhbnZhcyA9IHRoaXMuX2luaXRfcGxvdF9jYW52YXMoKTtcbiAgICAgICAgdGhpcy50b29sYmFyLnRvb2xiYXJfbG9jYXRpb24gPSB0aGlzLnRvb2xiYXJfbG9jYXRpb247XG4gICAgICAgIHRoaXMudG9vbGJhci50b29sYmFyX3N0aWNreSA9IHRoaXMudG9vbGJhcl9zdGlja3k7XG4gICAgICAgIHRoaXMucGxvdF9jYW52YXMudG9vbGJhciA9IHRoaXMudG9vbGJhcjtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMucGxvdF93aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnBsb3RfaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJlZjMgPSBbJ2Fib3ZlJywgJ2JlbG93JywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgICAgICAgZm9yIChrID0gMCwgbGVuMiA9IHJlZjMubGVuZ3RoOyBrIDwgbGVuMjsgaysrKSB7XG4gICAgICAgICAgICBzaWRlID0gcmVmM1trXTtcbiAgICAgICAgICAgIGxheW91dF9yZW5kZXJlcnMgPSB0aGlzLmdldHYoc2lkZSk7XG4gICAgICAgICAgICBmb3IgKGwgPSAwLCBsZW4zID0gbGF5b3V0X3JlbmRlcmVycy5sZW5ndGg7IGwgPCBsZW4zOyBsKyspIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlciA9IGxheW91dF9yZW5kZXJlcnNbbF07XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuYWRkX3BhbmVsKHNpZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9zZXRfc2l6ZWFibGUgPSAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsLl9zaXplYWJsZSA9ICFfdGhpcy5faG9yaXpvbnRhbCA/IG1vZGVsLl9oZWlnaHQgOiBtb2RlbC5fd2lkdGg7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKTtcbiAgICAgICAgX3NldF9zaXplYWJsZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIF9zZXRfc2l6ZWFibGUodGhpcy5wbG90X2NhbnZhcyk7XG4gICAgfTtcbiAgICBQbG90LnByb3RvdHlwZS5faW5pdF9wbG90X2NhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwbG90X2NhbnZhc18xLlBsb3RDYW52YXMoe1xuICAgICAgICAgICAgcGxvdDogdGhpc1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBsb3QuZ2V0dGVycyh7XG4gICAgICAgIHBsb3RfY2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxvdF9jYW52YXM7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBQbG90LnByb3RvdHlwZS5fZG9jX2F0dGFjaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBsb3RfY2FudmFzLmF0dGFjaF9kb2N1bWVudCh0aGlzLmRvY3VtZW50KTtcbiAgICAgICAgcmV0dXJuIFBsb3QuX19zdXBlcl9fLl9kb2NfYXR0YWNoZWQuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFBsb3QucHJvdG90eXBlLmFkZF9yZW5kZXJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXdfcmVuZGVyZXJzLCByZW5kZXJlcnM7XG4gICAgICAgIG5ld19yZW5kZXJlcnMgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICAgICAgcmVuZGVyZXJzID0gdGhpcy5yZW5kZXJlcnM7XG4gICAgICAgIHJlbmRlcmVycyA9IHJlbmRlcmVycy5jb25jYXQobmV3X3JlbmRlcmVycyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVycyA9IHJlbmRlcmVycztcbiAgICB9O1xuICAgIFBsb3QucHJvdG90eXBlLmFkZF9sYXlvdXQgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNpZGUpIHtcbiAgICAgICAgdmFyIHNpZGVfcmVuZGVyZXJzO1xuICAgICAgICBpZiAoc2lkZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzaWRlID0gXCJjZW50ZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVuZGVyZXIucHJvcHMucGxvdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZW5kZXJlci5wbG90ID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lkZSAhPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHNpZGVfcmVuZGVyZXJzID0gdGhpcy5nZXR2KHNpZGUpO1xuICAgICAgICAgICAgc2lkZV9yZW5kZXJlcnMucHVzaChyZW5kZXJlcik7XG4gICAgICAgICAgICByZW5kZXJlci5hZGRfcGFuZWwoc2lkZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkX3JlbmRlcmVycyhyZW5kZXJlcik7XG4gICAgfTtcbiAgICBQbG90LnByb3RvdHlwZS5hZGRfZ2x5cGggPSBmdW5jdGlvbiAoZ2x5cGgsIHNvdXJjZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyO1xuICAgICAgICBpZiAoYXR0cnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0cnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IG5ldyBjb2x1bW5fZGF0YV9zb3VyY2VfMS5Db2x1bW5EYXRhU291cmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMgPSBvYmplY3RfMS5leHRlbmQoe30sIGF0dHJzLCB7XG4gICAgICAgICAgICBkYXRhX3NvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgZ2x5cGg6IGdseXBoXG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJlciA9IG5ldyBnbHlwaF9yZW5kZXJlcl8xLkdseXBoUmVuZGVyZXIoYXR0cnMpO1xuICAgICAgICB0aGlzLmFkZF9yZW5kZXJlcnMocmVuZGVyZXIpO1xuICAgICAgICByZXR1cm4gcmVuZGVyZXI7XG4gICAgfTtcbiAgICBQbG90LnByb3RvdHlwZS5hZGRfdG9vbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdHRycywgbmV3X3Rvb2xzLCB0b29sLCB0b29scztcbiAgICAgICAgdG9vbHMgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICAgICAgbmV3X3Rvb2xzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0b29scy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRvb2wgPSB0b29sc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodG9vbC5vdmVybGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRfcmVuZGVyZXJzKHRvb2wub3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b29sLnBsb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godG9vbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhdHRycyA9IG9iamVjdF8xLmNsb25lKHRvb2wuYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLnBsb3QgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IHRvb2wuY29uc3RydWN0b3IoYXR0cnMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9vbGJhci50b29scyA9IHRoaXMudG9vbGJhci50b29scy5jb25jYXQobmV3X3Rvb2xzKTtcbiAgICB9O1xuICAgIFBsb3QucHJvdG90eXBlLmdldF9hc3BlY3RfcmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQ7XG4gICAgfTtcbiAgICBQbG90LnByb3RvdHlwZS5nZXRfbGF5b3V0YWJsZV9jaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuO1xuICAgICAgICBjaGlsZHJlbiA9IFt0aGlzLnBsb3RfY2FudmFzXTtcbiAgICAgICAgaWYgKHRoaXMudG9vbGJhcl9sb2NhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IFt0aGlzLnRvb2xiYXIsIHRoaXMucGxvdF9jYW52YXNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9O1xuICAgIFBsb3QucHJvdG90eXBlLmdldF9lZGl0X3ZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBlZGl0X3ZhcmlhYmxlcywgaSwgbGVuLCByZWY7XG4gICAgICAgIGVkaXRfdmFyaWFibGVzID0gUGxvdC5fX3N1cGVyX18uZ2V0X2VkaXRfdmFyaWFibGVzLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLnNpemluZ19tb2RlID09PSAnc2NhbGVfYm90aCcpIHtcbiAgICAgICAgICAgIGVkaXRfdmFyaWFibGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGVkaXRfdmFyaWFibGU6IHRoaXMuX3dpZHRoLFxuICAgICAgICAgICAgICAgIHN0cmVuZ3RoOiBzb2x2ZXJfMS5TdHJlbmd0aC5zdHJvbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWRpdF92YXJpYWJsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZWRpdF92YXJpYWJsZTogdGhpcy5faGVpZ2h0LFxuICAgICAgICAgICAgICAgIHN0cmVuZ3RoOiBzb2x2ZXJfMS5TdHJlbmd0aC5zdHJvbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlZiA9IHRoaXMuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4oKTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHJlZltpXTtcbiAgICAgICAgICAgIGVkaXRfdmFyaWFibGVzID0gZWRpdF92YXJpYWJsZXMuY29uY2F0KGNoaWxkLmdldF9lZGl0X3ZhcmlhYmxlcygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWRpdF92YXJpYWJsZXM7XG4gICAgfTtcbiAgICBQbG90LnByb3RvdHlwZS5nZXRfY29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZCwgY29uc3RyYWludHMsIGksIGxlbiwgcmVmLCByZWYxLCByZWYyLCBzdGlja3lfZWRnZTtcbiAgICAgICAgY29uc3RyYWludHMgPSBQbG90Ll9fc3VwZXJfXy5nZXRfY29uc3RyYWludHMuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMudG9vbGJhcl9sb2NhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50b29sYmFyX3N0aWNreSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodGhpcy5fc2l6ZWFibGUsIFstMSwgdGhpcy5wbG90X2NhbnZhcy5fc2l6ZWFibGVdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHRoaXMuX3NpemVhYmxlLCBbLTEsIHRoaXMucGxvdF9jYW52YXMuX3NpemVhYmxlXSwgWy0xLCB0aGlzLnRvb2xiYXIuX3NpemVhYmxlXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLl93aWR0aCwgWy0xLCB0aGlzLnBsb3RfY2FudmFzLl93aWR0aF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodGhpcy5faGVpZ2h0LCBbLTEsIHRoaXMucGxvdF9jYW52YXMuX2hlaWdodF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRvb2xiYXJfbG9jYXRpb24gPT09ICdhYm92ZScpIHtcbiAgICAgICAgICAgICAgICBzdGlja3lfZWRnZSA9IHRoaXMudG9vbGJhcl9zdGlja3kgPT09IHRydWUgPyB0aGlzLnBsb3RfY2FudmFzLl90b3AgOiB0aGlzLnBsb3RfY2FudmFzLl9kb21fdG9wO1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEoc3RpY2t5X2VkZ2UsIFstMSwgdGhpcy50b29sYmFyLl9kb21fdG9wXSwgWy0xLCB0aGlzLnRvb2xiYXIuX2hlaWdodF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRvb2xiYXJfbG9jYXRpb24gPT09ICdiZWxvdycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b29sYmFyX3N0aWNreSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLnRvb2xiYXIuX2RvbV90b3AsIFstMSwgdGhpcy5wbG90X2NhbnZhcy5faGVpZ2h0XSwgdGhpcy50b29sYmFyLl9ib3R0b20sIFstMSwgdGhpcy50b29sYmFyLl9oZWlnaHRdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvb2xiYXJfc3RpY2t5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuR0UodGhpcy5wbG90X2NhbnZhcy5iZWxvd19wYW5lbC5faGVpZ2h0LCBbLTEsIHRoaXMudG9vbGJhci5faGVpZ2h0XSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLldFQUtfRVEodGhpcy50b29sYmFyLl9kb21fdG9wLCBbLTEsIHRoaXMucGxvdF9jYW52YXMuX2hlaWdodF0sIHRoaXMucGxvdF9jYW52YXMuYmVsb3dfcGFuZWwuX2hlaWdodCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRvb2xiYXJfbG9jYXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgIHN0aWNreV9lZGdlID0gdGhpcy50b29sYmFyX3N0aWNreSA9PT0gdHJ1ZSA/IHRoaXMucGxvdF9jYW52YXMuX2xlZnQgOiB0aGlzLnBsb3RfY2FudmFzLl9kb21fbGVmdDtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHN0aWNreV9lZGdlLCBbLTEsIHRoaXMudG9vbGJhci5fZG9tX2xlZnRdLCBbLTEsIHRoaXMudG9vbGJhci5fd2lkdGhdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50b29sYmFyX2xvY2F0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudG9vbGJhcl9zdGlja3kgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodGhpcy50b29sYmFyLl9kb21fbGVmdCwgWy0xLCB0aGlzLnBsb3RfY2FudmFzLl93aWR0aF0sIHRoaXMudG9vbGJhci5fcmlnaHQsIFstMSwgdGhpcy50b29sYmFyLl93aWR0aF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudG9vbGJhcl9zdGlja3kgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5HRSh0aGlzLnBsb3RfY2FudmFzLnJpZ2h0X3BhbmVsLl93aWR0aCwgWy0xLCB0aGlzLnRvb2xiYXIuX3dpZHRoXSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLldFQUtfRVEodGhpcy50b29sYmFyLl9kb21fbGVmdCwgWy0xLCB0aGlzLnBsb3RfY2FudmFzLl93aWR0aF0sIHRoaXMucGxvdF9jYW52YXMucmlnaHRfcGFuZWwuX3dpZHRoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChyZWYgPSB0aGlzLnRvb2xiYXJfbG9jYXRpb24pID09PSAnYWJvdmUnIHx8IHJlZiA9PT0gJ2JlbG93Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodGhpcy5fd2lkdGgsIFstMSwgdGhpcy50b29sYmFyLl93aWR0aF0sIFstMSwgdGhpcy5wbG90X2NhbnZhcy5fd2lkdGhfbWludXNfcmlnaHRdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHJlZjEgPSB0aGlzLnRvb2xiYXJfbG9jYXRpb24pID09PSAnbGVmdCcgfHwgcmVmMSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodGhpcy5faGVpZ2h0LCBbLTEsIHRoaXMudG9vbGJhci5faGVpZ2h0XSwgWy0xLCB0aGlzLnBsb3RfY2FudmFzLmFib3ZlX3BhbmVsLl9oZWlnaHRdKSk7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLnRvb2xiYXIuX2RvbV90b3AsIFstMSwgdGhpcy5wbG90X2NhbnZhcy5hYm92ZV9wYW5lbC5faGVpZ2h0XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRvb2xiYXJfbG9jYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLl93aWR0aCwgWy0xLCB0aGlzLnBsb3RfY2FudmFzLl93aWR0aF0pKTtcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodGhpcy5faGVpZ2h0LCBbLTEsIHRoaXMucGxvdF9jYW52YXMuX2hlaWdodF0pKTtcbiAgICAgICAgfVxuICAgICAgICByZWYyID0gdGhpcy5nZXRfbGF5b3V0YWJsZV9jaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHJlZjJbaV07XG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmNvbmNhdChjaGlsZC5nZXRfY29uc3RyYWludHMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgIH07XG4gICAgUGxvdC5wcm90b3R5cGUuZ2V0X2NvbnN0cmFpbmVkX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhcnM7XG4gICAgICAgIHZhcnMgPSBvYmplY3RfMS5leHRlbmQoe30sIFBsb3QuX19zdXBlcl9fLmdldF9jb25zdHJhaW5lZF92YXJpYWJsZXMuY2FsbCh0aGlzKSwge1xuICAgICAgICAgICAgb25fZWRnZV9hbGlnbl90b3A6IHRoaXMucGxvdF9jYW52YXMuX3RvcCxcbiAgICAgICAgICAgIG9uX2VkZ2VfYWxpZ25fYm90dG9tOiB0aGlzLnBsb3RfY2FudmFzLl9oZWlnaHRfbWludXNfYm90dG9tLFxuICAgICAgICAgICAgb25fZWRnZV9hbGlnbl9sZWZ0OiB0aGlzLnBsb3RfY2FudmFzLl9sZWZ0LFxuICAgICAgICAgICAgb25fZWRnZV9hbGlnbl9yaWdodDogdGhpcy5wbG90X2NhbnZhcy5fd2lkdGhfbWludXNfcmlnaHQsXG4gICAgICAgICAgICBib3hfY2VsbF9hbGlnbl90b3A6IHRoaXMucGxvdF9jYW52YXMuX3RvcCxcbiAgICAgICAgICAgIGJveF9jZWxsX2FsaWduX2JvdHRvbTogdGhpcy5wbG90X2NhbnZhcy5faGVpZ2h0X21pbnVzX2JvdHRvbSxcbiAgICAgICAgICAgIGJveF9jZWxsX2FsaWduX2xlZnQ6IHRoaXMucGxvdF9jYW52YXMuX2xlZnQsXG4gICAgICAgICAgICBib3hfY2VsbF9hbGlnbl9yaWdodDogdGhpcy5wbG90X2NhbnZhcy5fd2lkdGhfbWludXNfcmlnaHQsXG4gICAgICAgICAgICBib3hfZXF1YWxfc2l6ZV90b3A6IHRoaXMucGxvdF9jYW52YXMuX3RvcCxcbiAgICAgICAgICAgIGJveF9lcXVhbF9zaXplX2JvdHRvbTogdGhpcy5wbG90X2NhbnZhcy5faGVpZ2h0X21pbnVzX2JvdHRvbVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuc2l6aW5nX21vZGUgIT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIHZhcnMuYm94X2VxdWFsX3NpemVfbGVmdCA9IHRoaXMucGxvdF9jYW52YXMuX2xlZnQ7XG4gICAgICAgICAgICB2YXJzLmJveF9lcXVhbF9zaXplX3JpZ2h0ID0gdGhpcy5wbG90X2NhbnZhcy5fd2lkdGhfbWludXNfcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhcnM7XG4gICAgfTtcbiAgICBQbG90Lm1peGlucyhbJ2xpbmU6b3V0bGluZV8nLCAnZmlsbDpiYWNrZ3JvdW5kXycsICdmaWxsOmJvcmRlcl8nXSk7XG4gICAgUGxvdC5kZWZpbmUoe1xuICAgICAgICB0b29sYmFyOiBbXG4gICAgICAgICAgICBwLkluc3RhbmNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0b29sYmFyXzEuVG9vbGJhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICB0b29sYmFyX2xvY2F0aW9uOiBbcC5Mb2NhdGlvbiwgJ3JpZ2h0J10sXG4gICAgICAgIHRvb2xiYXJfc3RpY2t5OiBbcC5Cb29sLCB0cnVlXSxcbiAgICAgICAgcGxvdF93aWR0aDogW3AuTnVtYmVyLCA2MDBdLFxuICAgICAgICBwbG90X2hlaWdodDogW3AuTnVtYmVyLCA2MDBdLFxuICAgICAgICB0aXRsZTogW1xuICAgICAgICAgICAgcC5BbnksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRpdGxlXzEuVGl0bGUoe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHRpdGxlX2xvY2F0aW9uOiBbcC5Mb2NhdGlvbiwgJ2Fib3ZlJ10sXG4gICAgICAgIGhfc3ltbWV0cnk6IFtwLkJvb2wsIHRydWVdLFxuICAgICAgICB2X3N5bW1ldHJ5OiBbcC5Cb29sLCBmYWxzZV0sXG4gICAgICAgIGFib3ZlOiBbcC5BcnJheSwgW11dLFxuICAgICAgICBiZWxvdzogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgbGVmdDogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgcmlnaHQ6IFtwLkFycmF5LCBbXV0sXG4gICAgICAgIHJlbmRlcmVyczogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgeF9yYW5nZTogW3AuSW5zdGFuY2VdLFxuICAgICAgICBleHRyYV94X3JhbmdlczogW3AuQW55LCB7fV0sXG4gICAgICAgIHlfcmFuZ2U6IFtwLkluc3RhbmNlXSxcbiAgICAgICAgZXh0cmFfeV9yYW5nZXM6IFtwLkFueSwge31dLFxuICAgICAgICB4X3NjYWxlOiBbXG4gICAgICAgICAgICBwLkluc3RhbmNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBsaW5lYXJfc2NhbGVfMS5MaW5lYXJTY2FsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICB5X3NjYWxlOiBbXG4gICAgICAgICAgICBwLkluc3RhbmNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBsaW5lYXJfc2NhbGVfMS5MaW5lYXJTY2FsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICB0b29sX2V2ZW50czogW1xuICAgICAgICAgICAgcC5JbnN0YW5jZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdG9vbF9ldmVudHNfMS5Ub29sRXZlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGxvZF9mYWN0b3I6IFtwLk51bWJlciwgMTBdLFxuICAgICAgICBsb2RfaW50ZXJ2YWw6IFtwLk51bWJlciwgMzAwXSxcbiAgICAgICAgbG9kX3RocmVzaG9sZDogW3AuTnVtYmVyLCAyMDAwXSxcbiAgICAgICAgbG9kX3RpbWVvdXQ6IFtwLk51bWJlciwgNTAwXSxcbiAgICAgICAgaGlkcGk6IFtwLkJvb2wsIHRydWVdLFxuICAgICAgICBvdXRwdXRfYmFja2VuZDogW3AuT3V0cHV0QmFja2VuZCwgXCJjYW52YXNcIl0sXG4gICAgICAgIG1pbl9ib3JkZXI6IFtwLk51bWJlciwgNV0sXG4gICAgICAgIG1pbl9ib3JkZXJfdG9wOiBbcC5OdW1iZXIsIG51bGxdLFxuICAgICAgICBtaW5fYm9yZGVyX2xlZnQ6IFtwLk51bWJlciwgbnVsbF0sXG4gICAgICAgIG1pbl9ib3JkZXJfYm90dG9tOiBbcC5OdW1iZXIsIG51bGxdLFxuICAgICAgICBtaW5fYm9yZGVyX3JpZ2h0OiBbcC5OdW1iZXIsIG51bGxdLFxuICAgICAgICBpbm5lcl93aWR0aDogW3AuTnVtYmVyXSxcbiAgICAgICAgaW5uZXJfaGVpZ2h0OiBbcC5OdW1iZXJdLFxuICAgICAgICBsYXlvdXRfd2lkdGg6IFtwLk51bWJlcl0sXG4gICAgICAgIGxheW91dF9oZWlnaHQ6IFtwLk51bWJlcl1cbiAgICB9KTtcbiAgICBQbG90Lm92ZXJyaWRlKHtcbiAgICAgICAgb3V0bGluZV9saW5lX2NvbG9yOiAnI2U1ZTVlNScsXG4gICAgICAgIGJvcmRlcl9maWxsX2NvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgYmFja2dyb3VuZF9maWxsX2NvbG9yOiBcIiNmZmZmZmZcIlxuICAgIH0pO1xuICAgIFBsb3QuZ2V0dGVycyh7XG4gICAgICAgIGFsbF9yZW5kZXJlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpLCBsZW4sIHJlZiwgcmVuZGVyZXJzLCB0b29sO1xuICAgICAgICAgICAgcmVuZGVyZXJzID0gdGhpcy5yZW5kZXJlcnM7XG4gICAgICAgICAgICByZWYgPSB0aGlzLnRvb2xiYXIudG9vbHM7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b29sID0gcmVmW2ldO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVycyA9IHJlbmRlcmVycy5jb25jYXQodG9vbC5zeW50aGV0aWNfcmVuZGVyZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlcnM7XG4gICAgICAgIH0sXG4gICAgICAgIHhfbWFwcGVyX3R5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvZy53YXJuaW5nKFwieF9tYXBwZXJfdHlwZSBhdHRyIGlzIGRlcHJlY2F0ZWQsIHVzZSB4X3NjYWxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueF9zY2FsZTtcbiAgICAgICAgfSxcbiAgICAgICAgeV9tYXBwZXJfdHlwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbG9nLndhcm5pbmcoXCJ5X21hcHBlcl90eXBlIGF0dHIgaXMgZGVwcmVjYXRlZCwgdXNlIHlfc2NhbGVcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55X3NjYWxlO1xuICAgICAgICB9LFxuICAgICAgICB3ZWJnbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbG9nLndhcm5pbmcoXCJ3ZWJnbCBhdHRyIGlzIGRlcHJlY2F0ZWQsIHVzZSBvdXRwdXRfYmFja2VuZFwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm91dHB1dF9iYWNrZW5kID09PSBcIndlYmdsXCI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUGxvdDtcbn0pKGxheW91dF9kb21fMS5MYXlvdXRET00pO1xuYm9rZWhfZXZlbnRzXzEucmVnaXN0ZXJfd2l0aF9ldmVudChib2tlaF9ldmVudHNfMS5VSUV2ZW50LCBleHBvcnRzLlBsb3QpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2xvYmFsX2dsY2FudmFzLCBleHRlbmQxID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKVxuICAgICAgICByZXR1cm4gaTtcbn0gcmV0dXJuIC0xOyB9O1xudmFyIGNhbnZhc18xID0gcmVxdWlyZShcIi4uL2NhbnZhcy9jYW52YXNcIik7XG52YXIgY2FydGVzaWFuX2ZyYW1lXzEgPSByZXF1aXJlKFwiLi4vY2FudmFzL2NhcnRlc2lhbl9mcmFtZVwiKTtcbnZhciBkYXRhX3JhbmdlMWRfMSA9IHJlcXVpcmUoXCIuLi9yYW5nZXMvZGF0YV9yYW5nZTFkXCIpO1xudmFyIGdseXBoX3JlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi4vcmVuZGVyZXJzL2dseXBoX3JlbmRlcmVyXCIpO1xudmFyIGxheW91dF9kb21fMSA9IHJlcXVpcmUoXCIuLi9sYXlvdXRzL2xheW91dF9kb21cIik7XG52YXIgc2lnbmFsaW5nXzEgPSByZXF1aXJlKFwiY29yZS9zaWduYWxpbmdcIik7XG52YXIgYnVpbGRfdmlld3NfMSA9IHJlcXVpcmUoXCJjb3JlL2J1aWxkX3ZpZXdzXCIpO1xudmFyIHVpX2V2ZW50c18xID0gcmVxdWlyZShcImNvcmUvdWlfZXZlbnRzXCIpO1xudmFyIGJva2VoX2V2ZW50c18xID0gcmVxdWlyZShcImNvcmUvYm9rZWhfZXZlbnRzXCIpO1xudmFyIGxheW91dF9jYW52YXNfMSA9IHJlcXVpcmUoXCJjb3JlL2xheW91dC9sYXlvdXRfY2FudmFzXCIpO1xudmFyIHZpc3VhbHNfMSA9IHJlcXVpcmUoXCJjb3JlL3Zpc3VhbHNcIik7XG52YXIgZG9tX3ZpZXdfMSA9IHJlcXVpcmUoXCJjb3JlL2RvbV92aWV3XCIpO1xudmFyIHNvbHZlcl8xID0gcmVxdWlyZShcImNvcmUvbGF5b3V0L3NvbHZlclwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIGVudW1zID0gcmVxdWlyZShcImNvcmUvZW51bXNcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgdGhyb3R0bGVfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdGhyb3R0bGVcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdHlwZXNcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL29iamVjdFwiKTtcbnZhciBzaWRlX3BhbmVsXzEgPSByZXF1aXJlKFwiY29yZS9sYXlvdXQvc2lkZV9wYW5lbFwiKTtcbmdsb2JhbF9nbGNhbnZhcyA9IG51bGw7XG5leHBvcnRzLlBsb3RDYW52YXNWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShQbG90Q2FudmFzVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUGxvdENhbnZhc1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiBQbG90Q2FudmFzVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLmNsYXNzTmFtZSA9IFwiYmstcGxvdC13cmFwcGVyXCI7XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnN0YXRlID0ge1xuICAgICAgICBoaXN0b3J5OiBbXSxcbiAgICAgICAgaW5kZXg6IC0xXG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUudmlld19vcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0XzEuZXh0ZW5kKHtcbiAgICAgICAgICAgIHBsb3RfdmlldzogdGhpcyxcbiAgICAgICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMpO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faXNfcGF1c2VkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc19wYXVzZWQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzX3BhdXNlZCArPSAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUudW5wYXVzZSA9IGZ1bmN0aW9uIChub19yZW5kZXIpIHtcbiAgICAgICAgaWYgKG5vX3JlbmRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBub19yZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc19wYXVzZWQgLT0gMTtcbiAgICAgICAgaWYgKHRoaXMuX2lzX3BhdXNlZCA9PT0gMCAmJiAhbm9fcmVuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUucmVxdWVzdF9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RfcGFpbnQoKTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5yZXF1ZXN0X3BhaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNfcGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnRocm90dGxlZF9wYWludCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBidWlsZF92aWV3c18xLnJlbW92ZV92aWV3cyh0aGlzLnJlbmRlcmVyX3ZpZXdzKTtcbiAgICAgICAgYnVpbGRfdmlld3NfMS5yZW1vdmVfdmlld3ModGhpcy50b29sX3ZpZXdzKTtcbiAgICAgICAgdGhpcy5jYW52YXNfdmlldy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5jYW52YXNfdmlldyA9IG51bGw7XG4gICAgICAgIHJldHVybiBQbG90Q2FudmFzVmlldy5fX3N1cGVyX18ucmVtb3ZlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBqLCBsZW4sIGxldmVsLCByZWY7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgUGxvdENhbnZhc1ZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5mb3JjZV9wYWludCA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgXCJmb3JjZV9wYWludFwiKTtcbiAgICAgICAgdGhpcy5zdGF0ZV9jaGFuZ2VkID0gbmV3IHNpZ25hbGluZ18xLlNpZ25hbCh0aGlzLCBcInN0YXRlX2NoYW5nZWRcIik7XG4gICAgICAgIHRoaXMubG9kX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52aXN1YWxzID0gbmV3IHZpc3VhbHNfMS5WaXN1YWxzKHRoaXMubW9kZWwucGxvdCk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxfc3RhdGVfaW5mbyA9IHtcbiAgICAgICAgICAgIHJhbmdlOiBudWxsLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiB7fSxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5tb2RlbC5jYW52YXMuX3dpZHRoLnZhbHVlLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5tb2RlbC5jYW52YXMuX2hlaWdodC52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZyYW1lID0gdGhpcy5tb2RlbC5mcmFtZTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLm1vZGVsLmNhbnZhcztcbiAgICAgICAgdGhpcy5jYW52YXNfdmlldyA9IG5ldyB0aGlzLmNhbnZhcy5kZWZhdWx0X3ZpZXcoe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMuY2FudmFzLFxuICAgICAgICAgICAgcGFyZW50OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzX3ZpZXcuZWwpO1xuICAgICAgICB0aGlzLmNhbnZhc192aWV3LnJlbmRlcigpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5wbG90Lm91dHB1dF9iYWNrZW5kID09PSBcIndlYmdsXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdF93ZWJnbCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3R0bGVkX3BhaW50ID0gdGhyb3R0bGVfMS50aHJvdHRsZSgoKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZm9yY2VfcGFpbnQuZW1pdCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpLCAxNSk7XG4gICAgICAgIHRoaXMudWlfZXZlbnRfYnVzID0gbmV3IHVpX2V2ZW50c18xLlVJRXZlbnRzKHRoaXMsIHRoaXMubW9kZWwudG9vbGJhciwgdGhpcy5jYW52YXNfdmlldy5lbCwgdGhpcy5tb2RlbC5wbG90KTtcbiAgICAgICAgdGhpcy5sZXZlbHMgPSB7fTtcbiAgICAgICAgcmVmID0gZW51bXMuUmVuZGVyTGV2ZWw7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgbGV2ZWwgPSByZWZbal07XG4gICAgICAgICAgICB0aGlzLmxldmVsc1tsZXZlbF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcmVyX3ZpZXdzID0ge307XG4gICAgICAgIHRoaXMudG9vbF92aWV3cyA9IHt9O1xuICAgICAgICB0aGlzLmJ1aWxkX2xldmVscygpO1xuICAgICAgICB0aGlzLmJ1aWxkX3Rvb2xzKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdF9zaWduYWxzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlX2RhdGFyYW5nZXMoKTtcbiAgICAgICAgdGhpcy51bnBhdXNlKHRydWUpO1xuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiUGxvdFZpZXcgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnNldF9jdXJzb3IgPSBmdW5jdGlvbiAoY3Vyc29yKSB7XG4gICAgICAgIGlmIChjdXJzb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgY3Vyc29yID0gXCJkZWZhdWx0XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzX3ZpZXcuZWwuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcuZ2V0dGVycyh7XG4gICAgICAgIGNhbnZhc19vdmVybGF5czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzX3ZpZXcub3ZlcmxheXNfZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGlzX3BhdXNlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9pc19wYXVzZWQgIT0gbnVsbCkgJiYgdGhpcy5faXNfcGF1c2VkICE9PSAwO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLmluaXRfd2ViZ2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHgsIGdsY2FudmFzLCBvcHRzO1xuICAgICAgICBjdHggPSB0aGlzLmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgZ2xjYW52YXMgPSBnbG9iYWxfZ2xjYW52YXM7XG4gICAgICAgIGlmIChnbGNhbnZhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBnbG9iYWxfZ2xjYW52YXMgPSBnbGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICAncHJlbXVsdGlwbGllZEFscGhhJzogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsY2FudmFzLmdsID0gZ2xjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIG9wdHMpIHx8IGdsY2FudmFzLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsY2FudmFzLmdsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHguZ2xjYW52YXMgPSBnbGNhbnZhcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLndhcm4oJ1dlYkdMIGlzIG5vdCBzdXBwb3J0ZWQsIGZhbGxpbmcgYmFjayB0byAyRCBjYW52YXMuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5wcmVwYXJlX3dlYmdsID0gZnVuY3Rpb24gKHJhdGlvLCBmcmFtZV9ib3gpIHtcbiAgICAgICAgdmFyIGNhbnZhcywgY3R4LCBmbGlwcGVkX3RvcCwgZ2w7XG4gICAgICAgIGN0eCA9IHRoaXMuY2FudmFzX3ZpZXcuY3R4O1xuICAgICAgICBjYW52YXMgPSB0aGlzLmNhbnZhc192aWV3LmdldF9jYW52YXNfZWxlbWVudCgpO1xuICAgICAgICBpZiAoY3R4LmdsY2FudmFzKSB7XG4gICAgICAgICAgICBjdHguZ2xjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgICAgICBjdHguZ2xjYW52YXMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIGdsID0gY3R4LmdsY2FudmFzLmdsO1xuICAgICAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgY3R4LmdsY2FudmFzLndpZHRoLCBjdHguZ2xjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHx8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgICAgICAgICBmbGlwcGVkX3RvcCA9IGN0eC5nbGNhbnZhcy5oZWlnaHQgLSByYXRpbyAqIChmcmFtZV9ib3hbMV0gKyBmcmFtZV9ib3hbM10pO1xuICAgICAgICAgICAgZ2wuc2Npc3NvcihyYXRpbyAqIGZyYW1lX2JveFswXSwgZmxpcHBlZF90b3AsIHJhdGlvICogZnJhbWVfYm94WzJdLCByYXRpbyAqIGZyYW1lX2JveFszXSk7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgcmV0dXJuIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgZ2wuT05FKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLmJsaXRfd2ViZ2wgPSBmdW5jdGlvbiAocmF0aW8pIHtcbiAgICAgICAgdmFyIGN0eDtcbiAgICAgICAgY3R4ID0gdGhpcy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgIGlmIChjdHguZ2xjYW52YXMpIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoJ2RyYXdpbmcgd2l0aCBXZWJHTCcpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoY3R4LmdsY2FudmFzLCAwLCAwKTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguc2NhbGUocmF0aW8sIHJhdGlvKTtcbiAgICAgICAgICAgIHJldHVybiBjdHgudHJhbnNsYXRlKDAuNSwgMC41KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnVwZGF0ZV9kYXRhcmFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmRzLCBib3VuZHMsIGJvdW5kc190b191c2UsIGNhbGN1bGF0ZV9sb2dfYm91bmRzLCBmb2xsb3dfZW5hYmxlZCwgZnJhbWUsIGhhc19ib3VuZHMsIGosIGssIGwsIGxlbiwgbGVuMSwgbGVuMiwgbGVuMywgbGVuNCwgbG9nX2JkcywgbG9nX2JvdW5kcywgbSwgbiwgbywgciwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZWY1LCByZWY2LCByZWY3LCB2LCB4ciwgeXI7XG4gICAgICAgIGZyYW1lID0gdGhpcy5tb2RlbC5mcmFtZTtcbiAgICAgICAgYm91bmRzID0ge307XG4gICAgICAgIGxvZ19ib3VuZHMgPSB7fTtcbiAgICAgICAgY2FsY3VsYXRlX2xvZ19ib3VuZHMgPSBmYWxzZTtcbiAgICAgICAgcmVmID0gb2JqZWN0XzEudmFsdWVzKGZyYW1lLnhfcmFuZ2VzKS5jb25jYXQob2JqZWN0XzEudmFsdWVzKGZyYW1lLnlfcmFuZ2VzKSk7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgciA9IHJlZltqXTtcbiAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgZGF0YV9yYW5nZTFkXzEuRGF0YVJhbmdlMWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoci5zY2FsZV9oaW50ID09PSBcImxvZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZV9sb2dfYm91bmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVmMSA9IHRoaXMucmVuZGVyZXJfdmlld3M7XG4gICAgICAgIGZvciAoayBpbiByZWYxKSB7XG4gICAgICAgICAgICB2ID0gcmVmMVtrXTtcbiAgICAgICAgICAgIGJkcyA9IChyZWYyID0gdi5nbHlwaCkgIT0gbnVsbCA/IHR5cGVvZiByZWYyLmJvdW5kcyA9PT0gXCJmdW5jdGlvblwiID8gcmVmMi5ib3VuZHMoKSA6IHZvaWQgMCA6IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChiZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJvdW5kc1trXSA9IGJkcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxjdWxhdGVfbG9nX2JvdW5kcykge1xuICAgICAgICAgICAgICAgIGxvZ19iZHMgPSAocmVmMyA9IHYuZ2x5cGgpICE9IG51bGwgPyB0eXBlb2YgcmVmMy5sb2dfYm91bmRzID09PSBcImZ1bmN0aW9uXCIgPyByZWYzLmxvZ19ib3VuZHMoKSA6IHZvaWQgMCA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAobG9nX2JkcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ19ib3VuZHNba10gPSBsb2dfYmRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb2xsb3dfZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBoYXNfYm91bmRzID0gZmFsc2U7XG4gICAgICAgIHJlZjQgPSBvYmplY3RfMS52YWx1ZXMoZnJhbWUueF9yYW5nZXMpO1xuICAgICAgICBmb3IgKGwgPSAwLCBsZW4xID0gcmVmNC5sZW5ndGg7IGwgPCBsZW4xOyBsKyspIHtcbiAgICAgICAgICAgIHhyID0gcmVmNFtsXTtcbiAgICAgICAgICAgIGlmICh4ciBpbnN0YW5jZW9mIGRhdGFfcmFuZ2UxZF8xLkRhdGFSYW5nZTFkKSB7XG4gICAgICAgICAgICAgICAgYm91bmRzX3RvX3VzZSA9IHhyLnNjYWxlX2hpbnQgPT09IFwibG9nXCIgPyBsb2dfYm91bmRzIDogYm91bmRzO1xuICAgICAgICAgICAgICAgIHhyLnVwZGF0ZShib3VuZHNfdG9fdXNlLCAwLCB0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoeHIuZm9sbG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbGxvd19lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeHIuYm91bmRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoYXNfYm91bmRzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWY1ID0gb2JqZWN0XzEudmFsdWVzKGZyYW1lLnlfcmFuZ2VzKTtcbiAgICAgICAgZm9yIChtID0gMCwgbGVuMiA9IHJlZjUubGVuZ3RoOyBtIDwgbGVuMjsgbSsrKSB7XG4gICAgICAgICAgICB5ciA9IHJlZjVbbV07XG4gICAgICAgICAgICBpZiAoeXIgaW5zdGFuY2VvZiBkYXRhX3JhbmdlMWRfMS5EYXRhUmFuZ2UxZCkge1xuICAgICAgICAgICAgICAgIGJvdW5kc190b191c2UgPSB5ci5zY2FsZV9oaW50ID09PSBcImxvZ1wiID8gbG9nX2JvdW5kcyA6IGJvdW5kcztcbiAgICAgICAgICAgICAgICB5ci51cGRhdGUoYm91bmRzX3RvX3VzZSwgMSwgdGhpcy5tb2RlbC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHlyLmZvbGxvdykge1xuICAgICAgICAgICAgICAgICAgICBmb2xsb3dfZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlyLmJvdW5kcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaGFzX2JvdW5kcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvbGxvd19lbmFibGVkICYmIGhhc19ib3VuZHMpIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIud2FybignRm9sbG93IGVuYWJsZWQgc28gYm91bmRzIGFyZSB1bnNldC4nKTtcbiAgICAgICAgICAgIHJlZjYgPSBvYmplY3RfMS52YWx1ZXMoZnJhbWUueF9yYW5nZXMpO1xuICAgICAgICAgICAgZm9yIChuID0gMCwgbGVuMyA9IHJlZjYubGVuZ3RoOyBuIDwgbGVuMzsgbisrKSB7XG4gICAgICAgICAgICAgICAgeHIgPSByZWY2W25dO1xuICAgICAgICAgICAgICAgIHhyLmJvdW5kcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWY3ID0gb2JqZWN0XzEudmFsdWVzKGZyYW1lLnlfcmFuZ2VzKTtcbiAgICAgICAgICAgIGZvciAobyA9IDAsIGxlbjQgPSByZWY3Lmxlbmd0aDsgbyA8IGxlbjQ7IG8rKykge1xuICAgICAgICAgICAgICAgIHlyID0gcmVmN1tvXTtcbiAgICAgICAgICAgICAgICB5ci5ib3VuZHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlX3VwZGF0ZV90aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLm1hcF90b19zY3JlZW4gPSBmdW5jdGlvbiAoeCwgeSwgeF9uYW1lLCB5X25hbWUpIHtcbiAgICAgICAgaWYgKHhfbmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB4X25hbWUgPSAnZGVmYXVsdCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHlfbmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB5X25hbWUgPSAnZGVmYXVsdCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWUubWFwX3RvX3NjcmVlbih4LCB5LCB0aGlzLmNhbnZhcywgeF9uYW1lLCB5X25hbWUpO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnB1c2hfc3RhdGUgPSBmdW5jdGlvbiAodHlwZSwgaW5mbykge1xuICAgICAgICB2YXIgcHJldl9pbmZvLCByZWY7XG4gICAgICAgIHByZXZfaW5mbyA9ICgocmVmID0gdGhpcy5zdGF0ZS5oaXN0b3J5W3RoaXMuc3RhdGUuaW5kZXhdKSAhPSBudWxsID8gcmVmLmluZm8gOiB2b2lkIDApIHx8IHt9O1xuICAgICAgICBpbmZvID0gb2JqZWN0XzEuZXh0ZW5kKHt9LCB0aGlzLl9pbml0aWFsX3N0YXRlX2luZm8sIHByZXZfaW5mbywgaW5mbyk7XG4gICAgICAgIHRoaXMuc3RhdGUuaGlzdG9yeS5zbGljZSgwLCB0aGlzLnN0YXRlLmluZGV4ICsgMSk7XG4gICAgICAgIHRoaXMuc3RhdGUuaGlzdG9yeS5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBpbmZvOiBpbmZvXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXRlLmluZGV4ID0gdGhpcy5zdGF0ZS5oaXN0b3J5Lmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlX2NoYW5nZWQuZW1pdCgpO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLmNsZWFyX3N0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaGlzdG9yeTogW10sXG4gICAgICAgICAgICBpbmRleDogLTFcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVfY2hhbmdlZC5lbWl0KCk7XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuY2FuX3VuZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmluZGV4ID49IDA7XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuY2FuX3JlZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmluZGV4IDwgdGhpcy5zdGF0ZS5oaXN0b3J5Lmxlbmd0aCAtIDE7XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuX3VuZG8oKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbmRleCAtPSAxO1xuICAgICAgICAgICAgdGhpcy5fZG9fc3RhdGVfY2hhbmdlKHRoaXMuc3RhdGUuaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVfY2hhbmdlZC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5yZWRvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5fcmVkbygpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmluZGV4ICs9IDE7XG4gICAgICAgICAgICB0aGlzLl9kb19zdGF0ZV9jaGFuZ2UodGhpcy5zdGF0ZS5pbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZV9jaGFuZ2VkLmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl9kb19zdGF0ZV9jaGFuZ2UgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGluZm8sIHJlZjtcbiAgICAgICAgaW5mbyA9ICgocmVmID0gdGhpcy5zdGF0ZS5oaXN0b3J5W2luZGV4XSkgIT0gbnVsbCA/IHJlZi5pbmZvIDogdm9pZCAwKSB8fCB0aGlzLl9pbml0aWFsX3N0YXRlX2luZm87XG4gICAgICAgIGlmIChpbmZvLnJhbmdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlX3JhbmdlKGluZm8ucmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmZvLnNlbGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZV9zZWxlY3Rpb24oaW5mby5zZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmZvLmRpbWVuc2lvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzX3ZpZXcuc2V0X2RpbXMoW2luZm8uZGltZW5zaW9ucy53aWR0aCwgaW5mby5kaW1lbnNpb25zLmhlaWdodF0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUucmVzZXRfZGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlX2RpbWVuc2lvbnModGhpcy5jYW52YXMuaW5pdGlhbF93aWR0aCwgdGhpcy5jYW52YXMuaW5pdGlhbF9oZWlnaHQpO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnVwZGF0ZV9kaW1lbnNpb25zID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB0aGlzLm1vZGVsLnBsb3Qud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5tb2RlbC5wbG90LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5wYXJlbnQubGF5b3V0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnVucGF1c2UoKTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5nZXRfc2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaiwgbGVuLCByZWYsIHJlbmRlcmVyLCBzZWxlY3RlZCwgc2VsZWN0aW9uO1xuICAgICAgICBzZWxlY3Rpb24gPSBbXTtcbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5wbG90LnJlbmRlcmVycztcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByZW5kZXJlciA9IHJlZltqXTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlciBpbnN0YW5jZW9mIGdseXBoX3JlbmRlcmVyXzEuR2x5cGhSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gcmVuZGVyZXIuZGF0YV9zb3VyY2Uuc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uW3JlbmRlcmVyLmlkXSA9IHNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUudXBkYXRlX3NlbGVjdGlvbiA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGRzLCBqLCBsZW4sIHJlZiwgcmVmMSwgcmVuZGVyZXIsIHJlc3VsdHM7XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwucGxvdC5yZW5kZXJlcnM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByZW5kZXJlciA9IHJlZltqXTtcbiAgICAgICAgICAgIGlmICghKHJlbmRlcmVyIGluc3RhbmNlb2YgZ2x5cGhfcmVuZGVyZXJfMS5HbHlwaFJlbmRlcmVyKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHMgPSByZW5kZXJlci5kYXRhX3NvdXJjZTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWYxID0gcmVuZGVyZXIuaWQsIGluZGV4T2YuY2FsbChzZWxlY3Rpb24sIHJlZjEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGRzLnNlbGVjdGVkID0gc2VsZWN0aW9uW3JlbmRlcmVyLmlkXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZHMuc2VsZWN0aW9uX21hbmFnZXIuY2xlYXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUucmVzZXRfc2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVfc2VsZWN0aW9uKG51bGwpO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl91cGRhdGVfcmFuZ2VzX3RvZ2V0aGVyID0gZnVuY3Rpb24gKHJhbmdlX2luZm9faXRlcikge1xuICAgICAgICB2YXIgaiwgbCwgbGVuLCBsZW4xLCByYW5nZV9pbmZvLCByZWYsIHJlZjEsIHJlc3VsdHMsIHJuZywgd2VpZ2h0O1xuICAgICAgICB3ZWlnaHQgPSAxLjA7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJhbmdlX2luZm9faXRlci5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgcmVmID0gcmFuZ2VfaW5mb19pdGVyW2pdLCBybmcgPSByZWZbMF0sIHJhbmdlX2luZm8gPSByZWZbMV07XG4gICAgICAgICAgICB3ZWlnaHQgPSBNYXRoLm1pbih3ZWlnaHQsIHRoaXMuX2dldF93ZWlnaHRfdG9fY29uc3RyYWluX2ludGVydmFsKHJuZywgcmFuZ2VfaW5mbykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWlnaHQgPCAxKSB7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGwgPSAwLCBsZW4xID0gcmFuZ2VfaW5mb19pdGVyLmxlbmd0aDsgbCA8IGxlbjE7IGwrKykge1xuICAgICAgICAgICAgICAgIHJlZjEgPSByYW5nZV9pbmZvX2l0ZXJbbF0sIHJuZyA9IHJlZjFbMF0sIHJhbmdlX2luZm8gPSByZWYxWzFdO1xuICAgICAgICAgICAgICAgIHJhbmdlX2luZm9bJ3N0YXJ0J10gPSB3ZWlnaHQgKiByYW5nZV9pbmZvWydzdGFydCddICsgKDEgLSB3ZWlnaHQpICogcm5nLnN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyYW5nZV9pbmZvWydlbmQnXSA9IHdlaWdodCAqIHJhbmdlX2luZm9bJ2VuZCddICsgKDEgLSB3ZWlnaHQpICogcm5nLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl91cGRhdGVfcmFuZ2VzX2luZGl2aWR1YWxseSA9IGZ1bmN0aW9uIChyYW5nZV9pbmZvX2l0ZXIsIGlzX3Bhbm5pbmcsIGlzX3Njcm9sbGluZykge1xuICAgICAgICB2YXIgaGl0X2JvdW5kLCBqLCBsLCBsZW4sIGxlbjEsIG1heCwgbWluLCBuZXdfaW50ZXJ2YWwsIHJhbmdlX2luZm8sIHJlZiwgcmVmMSwgcmVzdWx0cywgcmV2ZXJzZWQsIHJuZywgd2VpZ2h0O1xuICAgICAgICBoaXRfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmFuZ2VfaW5mb19pdGVyLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByZWYgPSByYW5nZV9pbmZvX2l0ZXJbal0sIHJuZyA9IHJlZlswXSwgcmFuZ2VfaW5mbyA9IHJlZlsxXTtcbiAgICAgICAgICAgIHJldmVyc2VkID0gcm5nLnN0YXJ0ID4gcm5nLmVuZDtcbiAgICAgICAgICAgIGlmICghaXNfc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gdGhpcy5fZ2V0X3dlaWdodF90b19jb25zdHJhaW5faW50ZXJ2YWwocm5nLCByYW5nZV9pbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAod2VpZ2h0IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZV9pbmZvWydzdGFydCddID0gd2VpZ2h0ICogcmFuZ2VfaW5mb1snc3RhcnQnXSArICgxIC0gd2VpZ2h0KSAqIHJuZy5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VfaW5mb1snZW5kJ10gPSB3ZWlnaHQgKiByYW5nZV9pbmZvWydlbmQnXSArICgxIC0gd2VpZ2h0KSAqIHJuZy5lbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJuZy5ib3VuZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1pbiA9IHJuZy5ib3VuZHNbMF07XG4gICAgICAgICAgICAgICAgbWF4ID0gcm5nLmJvdW5kc1sxXTtcbiAgICAgICAgICAgICAgICBuZXdfaW50ZXJ2YWwgPSBNYXRoLmFicyhyYW5nZV9pbmZvWydlbmQnXSAtIHJhbmdlX2luZm9bJ3N0YXJ0J10pO1xuICAgICAgICAgICAgICAgIGlmIChyZXZlcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW4gPj0gcmFuZ2VfaW5mb1snZW5kJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlX2luZm9bJ2VuZCddID0gbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaXNfcGFubmluZyAhPSBudWxsKSB8fCAoaXNfc2Nyb2xsaW5nICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlX2luZm9bJ3N0YXJ0J10gPSBtaW4gKyBuZXdfaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heCA8PSByYW5nZV9pbmZvWydzdGFydCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0X2JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZV9pbmZvWydzdGFydCddID0gbWF4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaXNfcGFubmluZyAhPSBudWxsKSB8fCAoaXNfc2Nyb2xsaW5nICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlX2luZm9bJ2VuZCddID0gbWF4IC0gbmV3X2ludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluID49IHJhbmdlX2luZm9bJ3N0YXJ0J10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlX2luZm9bJ3N0YXJ0J10gPSBtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpc19wYW5uaW5nICE9IG51bGwpIHx8IChpc19zY3JvbGxpbmcgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VfaW5mb1snZW5kJ10gPSBtaW4gKyBuZXdfaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heCA8PSByYW5nZV9pbmZvWydlbmQnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VfaW5mb1snZW5kJ10gPSBtYXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpc19wYW5uaW5nICE9IG51bGwpIHx8IChpc19zY3JvbGxpbmcgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VfaW5mb1snc3RhcnQnXSA9IG1heCAtIG5ld19pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX3Njcm9sbGluZyAmJiBoaXRfYm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobCA9IDAsIGxlbjEgPSByYW5nZV9pbmZvX2l0ZXIubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICByZWYxID0gcmFuZ2VfaW5mb19pdGVyW2xdLCBybmcgPSByZWYxWzBdLCByYW5nZV9pbmZvID0gcmVmMVsxXTtcbiAgICAgICAgICAgIHJuZy5oYXZlX3VwZGF0ZWRfaW50ZXJhY3RpdmVseSA9IHRydWU7XG4gICAgICAgICAgICBpZiAocm5nLnN0YXJ0ICE9PSByYW5nZV9pbmZvWydzdGFydCddIHx8IHJuZy5lbmQgIT09IHJhbmdlX2luZm9bJ2VuZCddKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJuZy5zZXR2KHJhbmdlX2luZm8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl9nZXRfd2VpZ2h0X3RvX2NvbnN0cmFpbl9pbnRlcnZhbCA9IGZ1bmN0aW9uIChybmcsIHJhbmdlX2luZm8pIHtcbiAgICAgICAgdmFyIG1heCwgbWF4X2ludGVydmFsLCBtYXhfaW50ZXJ2YWwyLCBtaW4sIG1pbl9pbnRlcnZhbCwgbmV3X2ludGVydmFsLCBvbGRfaW50ZXJ2YWwsIHJlZiwgd2VpZ2h0O1xuICAgICAgICBtaW5faW50ZXJ2YWwgPSBybmcubWluX2ludGVydmFsO1xuICAgICAgICBtYXhfaW50ZXJ2YWwgPSBybmcubWF4X2ludGVydmFsO1xuICAgICAgICB3ZWlnaHQgPSAxLjA7XG4gICAgICAgIGlmIChybmcuYm91bmRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlZiA9IHJuZy5ib3VuZHMsIG1pbiA9IHJlZlswXSwgbWF4ID0gcmVmWzFdO1xuICAgICAgICAgICAgaWYgKChtaW4gIT0gbnVsbCkgJiYgKG1heCAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgIG1heF9pbnRlcnZhbDIgPSBNYXRoLmFicyhtYXggLSBtaW4pO1xuICAgICAgICAgICAgICAgIG1heF9pbnRlcnZhbCA9IG1heF9pbnRlcnZhbCAhPSBudWxsID8gTWF0aC5taW4obWF4X2ludGVydmFsLCBtYXhfaW50ZXJ2YWwyKSA6IG1heF9pbnRlcnZhbDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtaW5faW50ZXJ2YWwgIT0gbnVsbCkgfHwgKG1heF9pbnRlcnZhbCAhPSBudWxsKSkge1xuICAgICAgICAgICAgb2xkX2ludGVydmFsID0gTWF0aC5hYnMocm5nLmVuZCAtIHJuZy5zdGFydCk7XG4gICAgICAgICAgICBuZXdfaW50ZXJ2YWwgPSBNYXRoLmFicyhyYW5nZV9pbmZvWydlbmQnXSAtIHJhbmdlX2luZm9bJ3N0YXJ0J10pO1xuICAgICAgICAgICAgaWYgKG1pbl9pbnRlcnZhbCA+IDAgJiYgbmV3X2ludGVydmFsIDwgbWluX2ludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gKG9sZF9pbnRlcnZhbCAtIG1pbl9pbnRlcnZhbCkgLyAob2xkX2ludGVydmFsIC0gbmV3X2ludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhfaW50ZXJ2YWwgPiAwICYmIG5ld19pbnRlcnZhbCA+IG1heF9pbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IChtYXhfaW50ZXJ2YWwgLSBvbGRfaW50ZXJ2YWwpIC8gKG5ld19pbnRlcnZhbCAtIG9sZF9pbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3ZWlnaHQgPSBNYXRoLm1heCgwLjAsIE1hdGgubWluKDEuMCwgd2VpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlaWdodDtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS51cGRhdGVfcmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2VfaW5mbywgaXNfcGFubmluZywgaXNfc2Nyb2xsaW5nKSB7XG4gICAgICAgIHZhciBuYW1lLCByYW5nZV9pbmZvX2l0ZXIsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcm5nO1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIGlmIChyYW5nZV9pbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlZiA9IHRoaXMuZnJhbWUueF9yYW5nZXM7XG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgICAgICAgcm5nID0gcmVmW25hbWVdO1xuICAgICAgICAgICAgICAgIHJuZy5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmMSA9IHRoaXMuZnJhbWUueV9yYW5nZXM7XG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gcmVmMSkge1xuICAgICAgICAgICAgICAgIHJuZyA9IHJlZjFbbmFtZV07XG4gICAgICAgICAgICAgICAgcm5nLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZV9kYXRhcmFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByYW5nZV9pbmZvX2l0ZXIgPSBbXTtcbiAgICAgICAgICAgIHJlZjIgPSB0aGlzLmZyYW1lLnhfcmFuZ2VzO1xuICAgICAgICAgICAgZm9yIChuYW1lIGluIHJlZjIpIHtcbiAgICAgICAgICAgICAgICBybmcgPSByZWYyW25hbWVdO1xuICAgICAgICAgICAgICAgIHJhbmdlX2luZm9faXRlci5wdXNoKFtybmcsIHJhbmdlX2luZm8ueHJzW25hbWVdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWYzID0gdGhpcy5mcmFtZS55X3JhbmdlcztcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiByZWYzKSB7XG4gICAgICAgICAgICAgICAgcm5nID0gcmVmM1tuYW1lXTtcbiAgICAgICAgICAgICAgICByYW5nZV9pbmZvX2l0ZXIucHVzaChbcm5nLCByYW5nZV9pbmZvLnlyc1tuYW1lXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzX3Njcm9sbGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZV9yYW5nZXNfdG9nZXRoZXIocmFuZ2VfaW5mb19pdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZV9yYW5nZXNfaW5kaXZpZHVhbGx5KHJhbmdlX2luZm9faXRlciwgaXNfcGFubmluZywgaXNfc2Nyb2xsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51bnBhdXNlKCk7XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUucmVzZXRfcmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZV9yYW5nZShudWxsKTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5idWlsZF9sZXZlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZF8sIGosIGwsIGxlbiwgbGVuMSwgbW9kZWwsIG5ld19yZW5kZXJlcl92aWV3cywgb2xkX3JlbmRlcmVycywgcmVuZGVyZXJfbW9kZWxzLCByZW5kZXJlcnNfdG9fcmVtb3ZlLCB2aWV3O1xuICAgICAgICByZW5kZXJlcl9tb2RlbHMgPSB0aGlzLm1vZGVsLnBsb3QuYWxsX3JlbmRlcmVycztcbiAgICAgICAgb2xkX3JlbmRlcmVycyA9IE9iamVjdC5rZXlzKHRoaXMucmVuZGVyZXJfdmlld3MpO1xuICAgICAgICBuZXdfcmVuZGVyZXJfdmlld3MgPSBidWlsZF92aWV3c18xLmJ1aWxkX3ZpZXdzKHRoaXMucmVuZGVyZXJfdmlld3MsIHJlbmRlcmVyX21vZGVscywgdGhpcy52aWV3X29wdGlvbnMoKSk7XG4gICAgICAgIHJlbmRlcmVyc190b19yZW1vdmUgPSBhcnJheV8xLmRpZmZlcmVuY2Uob2xkX3JlbmRlcmVycywgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZW5kZXJlcl9tb2RlbHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBtb2RlbCA9IHJlbmRlcmVyX21vZGVsc1tqXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobW9kZWwuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCkpO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZW5kZXJlcnNfdG9fcmVtb3ZlLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpZF8gPSByZW5kZXJlcnNfdG9fcmVtb3ZlW2pdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubGV2ZWxzLmdseXBoW2lkX107XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsID0gMCwgbGVuMSA9IG5ld19yZW5kZXJlcl92aWV3cy5sZW5ndGg7IGwgPCBsZW4xOyBsKyspIHtcbiAgICAgICAgICAgIHZpZXcgPSBuZXdfcmVuZGVyZXJfdmlld3NbbF07XG4gICAgICAgICAgICB0aGlzLmxldmVsc1t2aWV3Lm1vZGVsLmxldmVsXVt2aWV3Lm1vZGVsLmlkXSA9IHZpZXc7XG4gICAgICAgICAgICB2aWV3LmNvbm5lY3Rfc2lnbmFscygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLmdldF9yZW5kZXJlcl92aWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGosIGxlbiwgciwgcmVmLCByZXN1bHRzO1xuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLnBsb3QucmVuZGVyZXJzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgciA9IHJlZltqXTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmxldmVsc1tyLmxldmVsXVtyLmlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuYnVpbGRfdG9vbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBqLCBsZW4sIG5ld190b29sX3ZpZXdzLCByZXN1bHRzLCB0b29sX21vZGVscywgdG9vbF92aWV3O1xuICAgICAgICB0b29sX21vZGVscyA9IHRoaXMubW9kZWwucGxvdC50b29sYmFyLnRvb2xzO1xuICAgICAgICBuZXdfdG9vbF92aWV3cyA9IGJ1aWxkX3ZpZXdzXzEuYnVpbGRfdmlld3ModGhpcy50b29sX3ZpZXdzLCB0b29sX21vZGVscywgdGhpcy52aWV3X29wdGlvbnMoKSk7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gbmV3X3Rvb2xfdmlld3MubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHRvb2xfdmlldyA9IG5ld190b29sX3ZpZXdzW2pdO1xuICAgICAgICAgICAgdG9vbF92aWV3LmNvbm5lY3Rfc2lnbmFscygpO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMudWlfZXZlbnRfYnVzLnJlZ2lzdGVyX3Rvb2wodG9vbF92aWV3KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuY29ubmVjdF9zaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmFtZSwgcmVmLCByZWYxLCBybmc7XG4gICAgICAgIFBsb3RDYW52YXNWaWV3Ll9fc3VwZXJfXy5jb25uZWN0X3NpZ25hbHMuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMuZm9yY2VfcGFpbnQsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBhaW50KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwuZnJhbWUueF9yYW5nZXM7XG4gICAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcbiAgICAgICAgICAgIHJuZyA9IHJlZltuYW1lXTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdChybmcuY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlZjEgPSB0aGlzLm1vZGVsLmZyYW1lLnlfcmFuZ2VzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmMSkge1xuICAgICAgICAgICAgcm5nID0gcmVmMVtuYW1lXTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdChybmcuY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnBsb3QucHJvcGVydGllcy5yZW5kZXJlcnMuY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5idWlsZF9sZXZlbHMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMubW9kZWwucGxvdC50b29sYmFyLnByb3BlcnRpZXMudG9vbHMuY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmJ1aWxkX2xldmVscygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5idWlsZF90b29scygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMubW9kZWwucGxvdC5jaGFuZ2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnNldF9pbml0aWFsX3JhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ29vZF92YWxzLCBuYW1lLCByZWYsIHJlZjEsIHJuZywgeHJzLCB5cnM7XG4gICAgICAgIGdvb2RfdmFscyA9IHRydWU7XG4gICAgICAgIHhycyA9IHt9O1xuICAgICAgICByZWYgPSB0aGlzLmZyYW1lLnhfcmFuZ2VzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgICBybmcgPSByZWZbbmFtZV07XG4gICAgICAgICAgICBpZiAoKHJuZy5zdGFydCA9PSBudWxsKSB8fCAocm5nLmVuZCA9PSBudWxsKSB8fCB0eXBlc18xLmlzU3RyaWN0TmFOKHJuZy5zdGFydCArIHJuZy5lbmQpKSB7XG4gICAgICAgICAgICAgICAgZ29vZF92YWxzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4cnNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHJuZy5zdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IHJuZy5lbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdvb2RfdmFscykge1xuICAgICAgICAgICAgeXJzID0ge307XG4gICAgICAgICAgICByZWYxID0gdGhpcy5mcmFtZS55X3JhbmdlcztcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiByZWYxKSB7XG4gICAgICAgICAgICAgICAgcm5nID0gcmVmMVtuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoKHJuZy5zdGFydCA9PSBudWxsKSB8fCAocm5nLmVuZCA9PSBudWxsKSB8fCB0eXBlc18xLmlzU3RyaWN0TmFOKHJuZy5zdGFydCArIHJuZy5lbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2RfdmFscyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeXJzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogcm5nLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHJuZy5lbmRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChnb29kX3ZhbHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxfc3RhdGVfaW5mby5yYW5nZSA9IHRoaXMuaW5pdGlhbF9yYW5nZV9pbmZvID0ge1xuICAgICAgICAgICAgICAgIHhyczogeHJzLFxuICAgICAgICAgICAgICAgIHlyczogeXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJpbml0aWFsIHJhbmdlcyBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci53YXJuKCdjb3VsZCBub3Qgc2V0IGluaXRpYWwgcmFuZ2VzJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS51cGRhdGVfY29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfLCByZWYsIHZpZXc7XG4gICAgICAgIHRoaXMuc29sdmVyLnN1Z2dlc3RfdmFsdWUodGhpcy5mcmFtZS5fd2lkdGgsIHRoaXMuY2FudmFzLl93aWR0aC52YWx1ZSAtIDEpO1xuICAgICAgICB0aGlzLnNvbHZlci5zdWdnZXN0X3ZhbHVlKHRoaXMuZnJhbWUuX2hlaWdodCwgdGhpcy5jYW52YXMuX2hlaWdodC52YWx1ZSAtIDEpO1xuICAgICAgICByZWYgPSB0aGlzLnJlbmRlcmVyX3ZpZXdzO1xuICAgICAgICBmb3IgKF8gaW4gcmVmKSB7XG4gICAgICAgICAgICB2aWV3ID0gcmVmW19dO1xuICAgICAgICAgICAgaWYgKHZpZXcubW9kZWwucGFuZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNpZGVfcGFuZWxfMS51cGRhdGVfcGFuZWxfY29uc3RyYWludHModmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc29sdmVyLnVwZGF0ZV92YXJpYWJsZXMoKTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5fbGF5b3V0ID0gZnVuY3Rpb24gKGZpbmFsKSB7XG4gICAgICAgIGlmIChmaW5hbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmaW5hbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wbG90LnNldHYoe1xuICAgICAgICAgICAgICAgIGlubmVyX3dpZHRoOiBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuX3dpZHRoLnZhbHVlKSxcbiAgICAgICAgICAgICAgICBpbm5lcl9oZWlnaHQ6IE1hdGgucm91bmQodGhpcy5mcmFtZS5faGVpZ2h0LnZhbHVlKSxcbiAgICAgICAgICAgICAgICBsYXlvdXRfd2lkdGg6IE1hdGgucm91bmQodGhpcy5jYW52YXMuX3dpZHRoLnZhbHVlKSxcbiAgICAgICAgICAgICAgICBsYXlvdXRfaGVpZ2h0OiBNYXRoLnJvdW5kKHRoaXMuY2FudmFzLl9oZWlnaHQudmFsdWUpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbm9fY2hhbmdlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RfcGFpbnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLmhhc19maW5pc2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF8sIHJlZiwgcmVuZGVyZXJfdmlld3MsIHZpZXc7XG4gICAgICAgIGlmICghUGxvdENhbnZhc1ZpZXcuX19zdXBlcl9fLmhhc19maW5pc2hlZC5jYWxsKHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVmID0gdGhpcy5sZXZlbHM7XG4gICAgICAgIGZvciAoXyBpbiByZWYpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyX3ZpZXdzID0gcmVmW19dO1xuICAgICAgICAgICAgZm9yIChfIGluIHJlbmRlcmVyX3ZpZXdzKSB7XG4gICAgICAgICAgICAgICAgdmlldyA9IHJlbmRlcmVyX3ZpZXdzW19dO1xuICAgICAgICAgICAgICAgIGlmICghdmlldy5oYXNfZmluaXNoZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhlaWdodCwgd2lkdGg7XG4gICAgICAgIHdpZHRoID0gdGhpcy5tb2RlbC5fd2lkdGgudmFsdWU7XG4gICAgICAgIGhlaWdodCA9IHRoaXMubW9kZWwuX2hlaWdodC52YWx1ZTtcbiAgICAgICAgdGhpcy5jYW52YXNfdmlldy5zZXRfZGltcyhbd2lkdGgsIGhlaWdodF0pO1xuICAgICAgICB0aGlzLnVwZGF0ZV9jb25zdHJhaW50cygpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5sZWZ0ID0gdGhpcy5tb2RlbC5fZG9tX2xlZnQudmFsdWUgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gdGhpcy5tb2RlbC5fZG9tX3RvcC52YWx1ZSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS53aWR0aCA9IHRoaXMubW9kZWwuX3dpZHRoLnZhbHVlICsgXCJweFwiO1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdHlsZS5oZWlnaHQgPSB0aGlzLm1vZGVsLl9oZWlnaHQudmFsdWUgKyBcInB4XCI7XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUucGFpbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHgsIGZyYW1lX2JveCwgaywgbG9kX3RpbWVvdXQsIHJhdGlvLCByZWYsIHY7XG4gICAgICAgIGlmICh0aGlzLmlzX3BhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIudHJhY2UoXCJQbG90Q2FudmFzLnJlbmRlcigpIGZvciBcIiArIHRoaXMubW9kZWwuaWQpO1xuICAgICAgICB0aGlzLmNhbnZhc192aWV3LnByZXBhcmVfY2FudmFzKCk7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5pbnRlcmFjdGl2ZV90aW1lc3RhbXAgPCB0aGlzLm1vZGVsLnBsb3QubG9kX2ludGVydmFsKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubG9kX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnBsb3QudHJpZ2dlcl9ldmVudChuZXcgYm9rZWhfZXZlbnRzXzEuTE9EU3RhcnQoe30pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZF9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgbG9kX3RpbWVvdXQgPSB0aGlzLm1vZGVsLnBsb3QubG9kX3RpbWVvdXQ7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaW50ZXJhY3RpdmUgJiYgKERhdGUubm93KCkgLSBfdGhpcy5pbnRlcmFjdGl2ZV90aW1lc3RhbXApID4gbG9kX3RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHRoaXMpLCBsb2RfdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2Rfc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucGxvdC50cmlnZ2VyX2V2ZW50KG5ldyBib2tlaF9ldmVudHNfMS5MT0RFbmQoe30pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZF9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVmID0gdGhpcy5yZW5kZXJlcl92aWV3cztcbiAgICAgICAgZm9yIChrIGluIHJlZikge1xuICAgICAgICAgICAgdiA9IHJlZltrXTtcbiAgICAgICAgICAgIGlmICgodGhpcy5yYW5nZV91cGRhdGVfdGltZXN0YW1wID09IG51bGwpIHx8IHYuc2V0X2RhdGFfdGltZXN0YW1wID4gdGhpcy5yYW5nZV91cGRhdGVfdGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVfZGF0YXJhbmdlcygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwuZnJhbWUuX3VwZGF0ZV9zY2FsZXMoKTtcbiAgICAgICAgY3R4ID0gdGhpcy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgIGN0eC5waXhlbF9yYXRpbyA9IHJhdGlvID0gdGhpcy5jYW52YXMucGl4ZWxfcmF0aW87XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICBjdHgudHJhbnNsYXRlKDAuNSwgMC41KTtcbiAgICAgICAgZnJhbWVfYm94ID0gW3RoaXMuY2FudmFzLnZ4X3RvX3N4KHRoaXMuZnJhbWUuX2xlZnQudmFsdWUpLCB0aGlzLmNhbnZhcy52eV90b19zeSh0aGlzLmZyYW1lLl90b3AudmFsdWUpLCB0aGlzLmZyYW1lLl93aWR0aC52YWx1ZSwgdGhpcy5mcmFtZS5faGVpZ2h0LnZhbHVlXTtcbiAgICAgICAgdGhpcy5fbWFwX2hvb2soY3R4LCBmcmFtZV9ib3gpO1xuICAgICAgICB0aGlzLl9wYWludF9lbXB0eShjdHgsIGZyYW1lX2JveCk7XG4gICAgICAgIHRoaXMucHJlcGFyZV93ZWJnbChyYXRpbywgZnJhbWVfYm94KTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5vdXRsaW5lX2xpbmUuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLm91dGxpbmVfbGluZS5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0LmFwcGx5KGN0eCwgZnJhbWVfYm94KTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB0aGlzLl9wYWludF9sZXZlbHMoY3R4LCBbJ2ltYWdlJywgJ3VuZGVybGF5JywgJ2dseXBoJ10sIGZyYW1lX2JveCk7XG4gICAgICAgIHRoaXMuYmxpdF93ZWJnbChyYXRpbyk7XG4gICAgICAgIHRoaXMuX3BhaW50X2xldmVscyhjdHgsIFsnYW5ub3RhdGlvbiddLCBmcmFtZV9ib3gpO1xuICAgICAgICB0aGlzLl9wYWludF9sZXZlbHMoY3R4LCBbJ292ZXJsYXknXSk7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxfcmFuZ2VfaW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldF9pbml0aWFsX3JhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNfZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc19maW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub3RpZnlfZmluaXNoZWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl9wYWludF9sZXZlbHMgPSBmdW5jdGlvbiAoY3R4LCBsZXZlbHMsIGNsaXBfcmVnaW9uKSB7XG4gICAgICAgIHZhciBpLCBpbmRpY2VzLCBqLCBsLCBsZW4sIGxlbjEsIGxlbjIsIGxldmVsLCBtLCByZWYsIHJlbmRlcmVyLCByZW5kZXJlcl92aWV3LCByZW5kZXJlcl92aWV3cywgc29ydEtleTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYgKChjbGlwX3JlZ2lvbiAhPSBudWxsKSAmJiB0aGlzLm1vZGVsLnBsb3Qub3V0cHV0X2JhY2tlbmQgPT09IFwiY2FudmFzXCIpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5yZWN0LmFwcGx5KGN0eCwgY2xpcF9yZWdpb24pO1xuICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpbmRpY2VzID0ge307XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwucGxvdC5yZW5kZXJlcnM7XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG4gICAgICAgICAgICByZW5kZXJlciA9IHJlZltpXTtcbiAgICAgICAgICAgIGluZGljZXNbcmVuZGVyZXIuaWRdID0gaTtcbiAgICAgICAgfVxuICAgICAgICBzb3J0S2V5ID0gZnVuY3Rpb24gKHJlbmRlcmVyX3ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzW3JlbmRlcmVyX3ZpZXcubW9kZWwuaWRdO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGwgPSAwLCBsZW4xID0gbGV2ZWxzLmxlbmd0aDsgbCA8IGxlbjE7IGwrKykge1xuICAgICAgICAgICAgbGV2ZWwgPSBsZXZlbHNbbF07XG4gICAgICAgICAgICByZW5kZXJlcl92aWV3cyA9IGFycmF5XzEuc29ydEJ5KG9iamVjdF8xLnZhbHVlcyh0aGlzLmxldmVsc1tsZXZlbF0pLCBzb3J0S2V5KTtcbiAgICAgICAgICAgIGZvciAobSA9IDAsIGxlbjIgPSByZW5kZXJlcl92aWV3cy5sZW5ndGg7IG0gPCBsZW4yOyBtKyspIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlcl92aWV3ID0gcmVuZGVyZXJfdmlld3NbbV07XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJfdmlldy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5fbWFwX2hvb2sgPSBmdW5jdGlvbiAoY3R4LCBmcmFtZV9ib3gpIHsgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuX3BhaW50X2VtcHR5ID0gZnVuY3Rpb24gKGN0eCwgZnJhbWVfYm94KSB7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXNfdmlldy5tb2RlbC5fd2lkdGgudmFsdWUsIHRoaXMuY2FudmFzX3ZpZXcubW9kZWwuX2hlaWdodC52YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMuYm9yZGVyX2ZpbGwuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmJvcmRlcl9maWxsLnNldF92YWx1ZShjdHgpO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuY2FudmFzX3ZpZXcubW9kZWwuX3dpZHRoLnZhbHVlLCB0aGlzLmNhbnZhc192aWV3Lm1vZGVsLl9oZWlnaHQudmFsdWUpO1xuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdC5hcHBseShjdHgsIGZyYW1lX2JveCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5iYWNrZ3JvdW5kX2ZpbGwuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmJhY2tncm91bmRfZmlsbC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgIHJldHVybiBjdHguZmlsbFJlY3QuYXBwbHkoY3R4LCBmcmFtZV9ib3gpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBibG9iLCBjYW52YXMsIGRvd25sb2FkTGluaywgbGluaywgc3ZnLCBzdmdibG9iO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5wbG90Lm91dHB1dF9iYWNrZW5kID09PSBcImNhbnZhc1wiKSB7XG4gICAgICAgICAgICBjYW52YXMgPSB0aGlzLmNhbnZhc192aWV3LmdldF9jYW52YXNfZWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKGNhbnZhcy5tc1RvQmxvYiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYmxvYiA9IGNhbnZhcy5tc1RvQmxvYigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZUJsb2IoYmxvYiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgICAgIGxpbmsuaHJlZiA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgICAgICAgICAgIGxpbmsuZG93bmxvYWQgPSBuYW1lICsgXCIucG5nXCI7XG4gICAgICAgICAgICAgICAgbGluay50YXJnZXQgPSBcIl9ibGFua1wiO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5rLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoJ2NsaWNrJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubW9kZWwucGxvdC5vdXRwdXRfYmFja2VuZCA9PT0gXCJzdmdcIikge1xuICAgICAgICAgICAgc3ZnID0gdGhpcy5jYW52YXNfdmlldy5jdHguZ2V0U2VyaWFsaXplZFN2Zyh0cnVlKTtcbiAgICAgICAgICAgIHN2Z2Jsb2IgPSBuZXcgQmxvYihbc3ZnXSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0L3BsYWluJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb3dubG9hZExpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgICAgIGRvd25sb2FkTGluay5kb3dubG9hZCA9IG5hbWUgKyBcIi5zdmdcIjtcbiAgICAgICAgICAgIGRvd25sb2FkTGluay5pbm5lckhUTUwgPSBcIkRvd25sb2FkIHN2Z1wiO1xuICAgICAgICAgICAgZG93bmxvYWRMaW5rLmhyZWYgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChzdmdibG9iKTtcbiAgICAgICAgICAgIGRvd25sb2FkTGluay5vbmNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkb3dubG9hZExpbmsuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb3dubG9hZExpbmspO1xuICAgICAgICAgICAgcmV0dXJuIGRvd25sb2FkTGluay5jbGljaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUGxvdENhbnZhc1ZpZXc7XG59KShkb21fdmlld18xLkRPTVZpZXcpO1xuZXhwb3J0cy5QbG90Q2FudmFzID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShQbG90Q2FudmFzLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBQbG90Q2FudmFzKCkge1xuICAgICAgICByZXR1cm4gUGxvdENhbnZhcy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGxvdENhbnZhcy5wcm90b3R5cGUudHlwZSA9ICdQbG90Q2FudmFzJztcbiAgICBQbG90Q2FudmFzLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlBsb3RDYW52YXNWaWV3O1xuICAgIFBsb3RDYW52YXMucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgUGxvdENhbnZhcy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBuZXcgY2FudmFzXzEuQ2FudmFzKHtcbiAgICAgICAgICAgIG1hcDogKHJlZiA9IHRoaXMudXNlX21hcCkgIT0gbnVsbCA/IHJlZiA6IGZhbHNlLFxuICAgICAgICAgICAgaW5pdGlhbF93aWR0aDogdGhpcy5wbG90LnBsb3Rfd2lkdGgsXG4gICAgICAgICAgICBpbml0aWFsX2hlaWdodDogdGhpcy5wbG90LnBsb3RfaGVpZ2h0LFxuICAgICAgICAgICAgdXNlX2hpZHBpOiB0aGlzLnBsb3QuaGlkcGksXG4gICAgICAgICAgICBvdXRwdXRfYmFja2VuZDogdGhpcy5wbG90Lm91dHB1dF9iYWNrZW5kXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZyYW1lID0gbmV3IGNhcnRlc2lhbl9mcmFtZV8xLkNhcnRlc2lhbkZyYW1lKHtcbiAgICAgICAgICAgIHhfcmFuZ2U6IHRoaXMucGxvdC54X3JhbmdlLFxuICAgICAgICAgICAgZXh0cmFfeF9yYW5nZXM6IHRoaXMucGxvdC5leHRyYV94X3JhbmdlcyxcbiAgICAgICAgICAgIHhfc2NhbGU6IHRoaXMucGxvdC54X3NjYWxlLFxuICAgICAgICAgICAgeV9yYW5nZTogdGhpcy5wbG90LnlfcmFuZ2UsXG4gICAgICAgICAgICBleHRyYV95X3JhbmdlczogdGhpcy5wbG90LmV4dHJhX3lfcmFuZ2VzLFxuICAgICAgICAgICAgeV9zY2FsZTogdGhpcy5wbG90Lnlfc2NhbGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWJvdmVfcGFuZWwgPSBuZXcgbGF5b3V0X2NhbnZhc18xLkxheW91dENhbnZhcygpO1xuICAgICAgICB0aGlzLmJlbG93X3BhbmVsID0gbmV3IGxheW91dF9jYW52YXNfMS5MYXlvdXRDYW52YXMoKTtcbiAgICAgICAgdGhpcy5sZWZ0X3BhbmVsID0gbmV3IGxheW91dF9jYW52YXNfMS5MYXlvdXRDYW52YXMoKTtcbiAgICAgICAgdGhpcy5yaWdodF9wYW5lbCA9IG5ldyBsYXlvdXRfY2FudmFzXzEuTGF5b3V0Q2FudmFzKCk7XG4gICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiUGxvdENhbnZhcyBpbml0aWFsaXplZFwiKTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXMucHJvdG90eXBlLl9kb2NfYXR0YWNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmF0dGFjaF9kb2N1bWVudCh0aGlzLmRvY3VtZW50KTtcbiAgICAgICAgdGhpcy5mcmFtZS5hdHRhY2hfZG9jdW1lbnQodGhpcy5kb2N1bWVudCk7XG4gICAgICAgIHRoaXMuYWJvdmVfcGFuZWwuYXR0YWNoX2RvY3VtZW50KHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLmJlbG93X3BhbmVsLmF0dGFjaF9kb2N1bWVudCh0aGlzLmRvY3VtZW50KTtcbiAgICAgICAgdGhpcy5sZWZ0X3BhbmVsLmF0dGFjaF9kb2N1bWVudCh0aGlzLmRvY3VtZW50KTtcbiAgICAgICAgdGhpcy5yaWdodF9wYW5lbC5hdHRhY2hfZG9jdW1lbnQodGhpcy5kb2N1bWVudCk7XG4gICAgICAgIFBsb3RDYW52YXMuX19zdXBlcl9fLl9kb2NfYXR0YWNoZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJQbG90Q2FudmFzIGF0dGFjaGVkIHRvIGRvY3VtZW50XCIpO1xuICAgIH07XG4gICAgUGxvdENhbnZhcy5vdmVycmlkZSh7XG4gICAgICAgIHNpemluZ19tb2RlOiAnc3RyZXRjaF9ib3RoJ1xuICAgIH0pO1xuICAgIFBsb3RDYW52YXMuaW50ZXJuYWwoe1xuICAgICAgICBwbG90OiBbcC5JbnN0YW5jZV0sXG4gICAgICAgIHRvb2xiYXI6IFtwLkluc3RhbmNlXSxcbiAgICAgICAgY2FudmFzOiBbcC5JbnN0YW5jZV0sXG4gICAgICAgIGZyYW1lOiBbcC5JbnN0YW5jZV1cbiAgICB9KTtcbiAgICBQbG90Q2FudmFzLnByb3RvdHlwZS5nZXRfbGF5b3V0YWJsZV9jaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuLCBjb2xsZWN0X3BhbmVscztcbiAgICAgICAgY2hpbGRyZW4gPSBbdGhpcy5hYm92ZV9wYW5lbCwgdGhpcy5iZWxvd19wYW5lbCwgdGhpcy5sZWZ0X3BhbmVsLCB0aGlzLnJpZ2h0X3BhbmVsLCB0aGlzLmNhbnZhcywgdGhpcy5mcmFtZV07XG4gICAgICAgIGNvbGxlY3RfcGFuZWxzID0gZnVuY3Rpb24gKGxheW91dF9yZW5kZXJlcnMpIHtcbiAgICAgICAgICAgIHZhciBqLCBsZW4sIHIsIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBsYXlvdXRfcmVuZGVyZXJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgciA9IGxheW91dF9yZW5kZXJlcnNbal07XG4gICAgICAgICAgICAgICAgaWYgKHIucGFuZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY2hpbGRyZW4ucHVzaChyLnBhbmVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfTtcbiAgICAgICAgY29sbGVjdF9wYW5lbHModGhpcy5wbG90LmFib3ZlKTtcbiAgICAgICAgY29sbGVjdF9wYW5lbHModGhpcy5wbG90LmJlbG93KTtcbiAgICAgICAgY29sbGVjdF9wYW5lbHModGhpcy5wbG90LmxlZnQpO1xuICAgICAgICBjb2xsZWN0X3BhbmVscyh0aGlzLnBsb3QucmlnaHQpO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfTtcbiAgICBQbG90Q2FudmFzLnByb3RvdHlwZS5nZXRfZWRpdF92YXJpYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZCwgZWRpdF92YXJpYWJsZXMsIGosIGxlbiwgcmVmO1xuICAgICAgICBlZGl0X3ZhcmlhYmxlcyA9IFtdO1xuICAgICAgICByZWYgPSB0aGlzLmdldF9sYXlvdXRhYmxlX2NoaWxkcmVuKCk7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgY2hpbGQgPSByZWZbal07XG4gICAgICAgICAgICBlZGl0X3ZhcmlhYmxlcyA9IGVkaXRfdmFyaWFibGVzLmNvbmNhdChjaGlsZC5nZXRfZWRpdF92YXJpYWJsZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVkaXRfdmFyaWFibGVzO1xuICAgIH07XG4gICAgUGxvdENhbnZhcy5wcm90b3R5cGUuZ2V0X2NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGQsIGNvbnN0cmFpbnRzLCBqLCBsZW4sIHJlZjtcbiAgICAgICAgY29uc3RyYWludHMgPSBQbG90Q2FudmFzLl9fc3VwZXJfXy5nZXRfY29uc3RyYWludHMuY2FsbCh0aGlzKTtcbiAgICAgICAgY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5jb25jYXQodGhpcy5fZ2V0X2NvbnN0YW50X2NvbnN0cmFpbnRzKCkpO1xuICAgICAgICBjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmNvbmNhdCh0aGlzLl9nZXRfc2lkZV9jb25zdHJhaW50cygpKTtcbiAgICAgICAgcmVmID0gdGhpcy5nZXRfbGF5b3V0YWJsZV9jaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gcmVmW2pdO1xuICAgICAgICAgICAgY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5jb25jYXQoY2hpbGQuZ2V0X2NvbnN0cmFpbnRzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgICB9O1xuICAgIFBsb3RDYW52YXMucHJvdG90eXBlLl9nZXRfY29uc3RhbnRfY29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbc29sdmVyXzEuR0UodGhpcy5hYm92ZV9wYW5lbC5faGVpZ2h0LCAtdGhpcy5wbG90Lm1pbl9ib3JkZXJfdG9wKSwgc29sdmVyXzEuR0UodGhpcy5iZWxvd19wYW5lbC5faGVpZ2h0LCAtdGhpcy5wbG90Lm1pbl9ib3JkZXJfYm90dG9tKSwgc29sdmVyXzEuR0UodGhpcy5sZWZ0X3BhbmVsLl93aWR0aCwgLXRoaXMucGxvdC5taW5fYm9yZGVyX2xlZnQpLCBzb2x2ZXJfMS5HRSh0aGlzLnJpZ2h0X3BhbmVsLl93aWR0aCwgLXRoaXMucGxvdC5taW5fYm9yZGVyX3JpZ2h0KSwgc29sdmVyXzEuRVEodGhpcy5hYm92ZV9wYW5lbC5fdG9wLCBbLTEsIHRoaXMuY2FudmFzLl90b3BdKSwgc29sdmVyXzEuRVEodGhpcy5hYm92ZV9wYW5lbC5fYm90dG9tLCBbLTEsIHRoaXMuZnJhbWUuX3RvcF0pLCBzb2x2ZXJfMS5FUSh0aGlzLmJlbG93X3BhbmVsLl9ib3R0b20sIFstMSwgdGhpcy5jYW52YXMuX2JvdHRvbV0pLCBzb2x2ZXJfMS5FUSh0aGlzLmJlbG93X3BhbmVsLl90b3AsIFstMSwgdGhpcy5mcmFtZS5fYm90dG9tXSksIHNvbHZlcl8xLkVRKHRoaXMubGVmdF9wYW5lbC5fbGVmdCwgWy0xLCB0aGlzLmNhbnZhcy5fbGVmdF0pLCBzb2x2ZXJfMS5FUSh0aGlzLmxlZnRfcGFuZWwuX3JpZ2h0LCBbLTEsIHRoaXMuZnJhbWUuX2xlZnRdKSwgc29sdmVyXzEuRVEodGhpcy5yaWdodF9wYW5lbC5fcmlnaHQsIFstMSwgdGhpcy5jYW52YXMuX3JpZ2h0XSksIHNvbHZlcl8xLkVRKHRoaXMucmlnaHRfcGFuZWwuX2xlZnQsIFstMSwgdGhpcy5mcmFtZS5fcmlnaHRdKSwgc29sdmVyXzEuRVEodGhpcy5hYm92ZV9wYW5lbC5faGVpZ2h0LCBbLTEsIHRoaXMuX3RvcF0pLCBzb2x2ZXJfMS5FUSh0aGlzLmFib3ZlX3BhbmVsLl9oZWlnaHQsIFstMSwgdGhpcy5jYW52YXMuX3RvcF0sIHRoaXMuZnJhbWUuX3RvcCksIHNvbHZlcl8xLkVRKHRoaXMuYmVsb3dfcGFuZWwuX2hlaWdodCwgWy0xLCB0aGlzLl9oZWlnaHRdLCB0aGlzLl9ib3R0b20pLCBzb2x2ZXJfMS5FUSh0aGlzLmJlbG93X3BhbmVsLl9oZWlnaHQsIFstMSwgdGhpcy5mcmFtZS5fYm90dG9tXSksIHNvbHZlcl8xLkVRKHRoaXMubGVmdF9wYW5lbC5fd2lkdGgsIFstMSwgdGhpcy5fbGVmdF0pLCBzb2x2ZXJfMS5FUSh0aGlzLmxlZnRfcGFuZWwuX3dpZHRoLCBbLTEsIHRoaXMuZnJhbWUuX2xlZnRdKSwgc29sdmVyXzEuRVEodGhpcy5yaWdodF9wYW5lbC5fd2lkdGgsIFstMSwgdGhpcy5fd2lkdGhdLCB0aGlzLl9yaWdodCksIHNvbHZlcl8xLkVRKHRoaXMucmlnaHRfcGFuZWwuX3dpZHRoLCBbLTEsIHRoaXMuY2FudmFzLl9yaWdodF0sIHRoaXMuZnJhbWUuX3JpZ2h0KV07XG4gICAgfTtcbiAgICBQbG90Q2FudmFzLnByb3RvdHlwZS5fZ2V0X3NpZGVfY29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50LCBjb25zdHJhaW50cywgaiwgbCwgbGFzdCwgbGF5b3V0X3JlbmRlcmVycywgbGVuLCBsZW4xLCByLCByZWYsIHNpZGUsIHNpZGVzO1xuICAgICAgICBjb25zdHJhaW50cyA9IFtdO1xuICAgICAgICBzaWRlcyA9IFtbJ2Fib3ZlJywgdGhpcy5wbG90LmFib3ZlXSwgWydiZWxvdycsIHRoaXMucGxvdC5iZWxvd10sIFsnbGVmdCcsIHRoaXMucGxvdC5sZWZ0XSwgWydyaWdodCcsIHRoaXMucGxvdC5yaWdodF1dO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBzaWRlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgcmVmID0gc2lkZXNbal0sIHNpZGUgPSByZWZbMF0sIGxheW91dF9yZW5kZXJlcnMgPSByZWZbMV07XG4gICAgICAgICAgICBsYXN0ID0gdGhpcy5mcmFtZTtcbiAgICAgICAgICAgIGZvciAobCA9IDAsIGxlbjEgPSBsYXlvdXRfcmVuZGVyZXJzLmxlbmd0aDsgbCA8IGxlbjE7IGwrKykge1xuICAgICAgICAgICAgICAgIHIgPSBsYXlvdXRfcmVuZGVyZXJzW2xdO1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhYm92ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2x2ZXJfMS5FUShsYXN0LnBhbmVsLl90b3AsIFstMSwgci5wYW5lbC5fYm90dG9tXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYmVsb3dcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29sdmVyXzEuRVEobGFzdC5wYW5lbC5fYm90dG9tLCBbLTEsIHIucGFuZWwuX3RvcF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29sdmVyXzEuRVEobGFzdC5wYW5lbC5fbGVmdCwgWy0xLCByLnBhbmVsLl9yaWdodF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvbHZlcl8xLkVRKGxhc3QucGFuZWwuX3JpZ2h0LCBbLTEsIHIucGFuZWwuX2xlZnRdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcbiAgICAgICAgICAgICAgICBsYXN0ID0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXlvdXRfcmVuZGVyZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhYm92ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2x2ZXJfMS5FUShsYXN0LnBhbmVsLl90b3AsIFstMSwgdGhpcy5hYm92ZV9wYW5lbC5fdG9wXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYmVsb3dcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29sdmVyXzEuRVEobGFzdC5wYW5lbC5fYm90dG9tLCBbLTEsIHRoaXMuYmVsb3dfcGFuZWwuX2JvdHRvbV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29sdmVyXzEuRVEobGFzdC5wYW5lbC5fbGVmdCwgWy0xLCB0aGlzLmxlZnRfcGFuZWwuX2xlZnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2x2ZXJfMS5FUShsYXN0LnBhbmVsLl9yaWdodCwgWy0xLCB0aGlzLnJpZ2h0X3BhbmVsLl9yaWdodF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgICB9O1xuICAgIHJldHVybiBQbG90Q2FudmFzO1xufSkobGF5b3V0X2RvbV8xLkxheW91dERPTSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgcmFuZ2VfMSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5EYXRhUmFuZ2UgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRGF0YVJhbmdlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBEYXRhUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBEYXRhUmFuZ2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERhdGFSYW5nZS5wcm90b3R5cGUudHlwZSA9ICdEYXRhUmFuZ2UnO1xuICAgIERhdGFSYW5nZS5kZWZpbmUoe1xuICAgICAgICBuYW1lczogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgcmVuZGVyZXJzOiBbcC5BcnJheSwgW11dXG4gICAgfSk7XG4gICAgcmV0dXJuIERhdGFSYW5nZTtcbn0pKHJhbmdlXzEuUmFuZ2UpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGRhdGFfcmFuZ2VfMSA9IHJlcXVpcmUoXCIuL2RhdGFfcmFuZ2VcIik7XG52YXIgZ2x5cGhfcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuLi9yZW5kZXJlcnMvZ2x5cGhfcmVuZGVyZXJcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBiYm94ID0gcmVxdWlyZShcImNvcmUvdXRpbC9iYm94XCIpO1xuZXhwb3J0cy5EYXRhUmFuZ2UxZCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEYXRhUmFuZ2UxZCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRGF0YVJhbmdlMWQoKSB7XG4gICAgICAgIHJldHVybiBEYXRhUmFuZ2UxZC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGF0YVJhbmdlMWQucHJvdG90eXBlLnR5cGUgPSAnRGF0YVJhbmdlMWQnO1xuICAgIERhdGFSYW5nZTFkLmRlZmluZSh7XG4gICAgICAgIHN0YXJ0OiBbcC5OdW1iZXJdLFxuICAgICAgICBlbmQ6IFtwLk51bWJlcl0sXG4gICAgICAgIHJhbmdlX3BhZGRpbmc6IFtwLk51bWJlciwgMC4xXSxcbiAgICAgICAgcmFuZ2VfcGFkZGluZ191bml0czogW3AuUGFkZGluZ1VuaXRzLCBcInBlcmNlbnRcIl0sXG4gICAgICAgIGZsaXBwZWQ6IFtwLkJvb2wsIGZhbHNlXSxcbiAgICAgICAgZm9sbG93OiBbcC5TdGFydEVuZF0sXG4gICAgICAgIGZvbGxvd19pbnRlcnZhbDogW3AuTnVtYmVyXSxcbiAgICAgICAgZGVmYXVsdF9zcGFuOiBbcC5OdW1iZXIsIDJdLFxuICAgICAgICBib3VuZHM6IFtwLkFueV0sXG4gICAgICAgIG1pbl9pbnRlcnZhbDogW3AuQW55XSxcbiAgICAgICAgbWF4X2ludGVydmFsOiBbcC5BbnldXG4gICAgfSk7XG4gICAgRGF0YVJhbmdlMWQuaW50ZXJuYWwoe1xuICAgICAgICBzY2FsZV9oaW50OiBbcC5TdHJpbmcsICdhdXRvJ11cbiAgICB9KTtcbiAgICBEYXRhUmFuZ2UxZC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBEYXRhUmFuZ2UxZC5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wbG90X2JvdW5kcyA9IHt9O1xuICAgICAgICB0aGlzLmhhdmVfdXBkYXRlZF9pbnRlcmFjdGl2ZWx5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luaXRpYWxfc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB0aGlzLl9pbml0aWFsX2VuZCA9IHRoaXMuZW5kO1xuICAgICAgICB0aGlzLl9pbml0aWFsX3JhbmdlX3BhZGRpbmcgPSB0aGlzLnJhbmdlX3BhZGRpbmc7XG4gICAgICAgIHRoaXMuX2luaXRpYWxfcmFuZ2VfcGFkZGluZ191bml0cyA9IHRoaXMucmFuZ2VfcGFkZGluZ191bml0cztcbiAgICAgICAgdGhpcy5faW5pdGlhbF9mb2xsb3cgPSB0aGlzLmZvbGxvdztcbiAgICAgICAgdGhpcy5faW5pdGlhbF9mb2xsb3dfaW50ZXJ2YWwgPSB0aGlzLmZvbGxvd19pbnRlcnZhbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRpYWxfZGVmYXVsdF9zcGFuID0gdGhpcy5kZWZhdWx0X3NwYW47XG4gICAgfTtcbiAgICBEYXRhUmFuZ2UxZC5nZXR0ZXJzKHtcbiAgICAgICAgbWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgICAgICB9LFxuICAgICAgICBtYXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBEYXRhUmFuZ2UxZC5wcm90b3R5cGUuY29tcHV0ZWRfcmVuZGVyZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWxsX3JlbmRlcmVycywgaSwgaiwgbGVuLCBsZW4xLCBuYW1lcywgcGxvdCwgciwgcmVmLCByZW5kZXJlcnMsIHJzO1xuICAgICAgICBuYW1lcyA9IHRoaXMubmFtZXM7XG4gICAgICAgIHJlbmRlcmVycyA9IHRoaXMucmVuZGVyZXJzO1xuICAgICAgICBpZiAocmVuZGVyZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVmID0gdGhpcy5wbG90cztcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHBsb3QgPSByZWZbaV07XG4gICAgICAgICAgICAgICAgYWxsX3JlbmRlcmVycyA9IHBsb3QucmVuZGVyZXJzO1xuICAgICAgICAgICAgICAgIHJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGosIGxlbjEsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuMSA9IGFsbF9yZW5kZXJlcnMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByID0gYWxsX3JlbmRlcmVyc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgZ2x5cGhfcmVuZGVyZXJfMS5HbHlwaFJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJzID0gcmVuZGVyZXJzLmNvbmNhdChycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlbmRlcmVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIGxlbjEsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSByZW5kZXJlcnMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByZW5kZXJlcnNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lcy5pbmRleE9mKHIubmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiY29tcHV0ZWQgXCIgKyByZW5kZXJlcnMubGVuZ3RoICsgXCIgcmVuZGVyZXJzIGZvciBEYXRhUmFuZ2UxZCBcIiArIHRoaXMuaWQpO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gcmVuZGVyZXJzLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgICAgciA9IHJlbmRlcmVyc1tqXTtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIudHJhY2UoXCIgLSBcIiArIHIudHlwZSArIFwiIFwiICsgci5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVycztcbiAgICB9O1xuICAgIERhdGFSYW5nZTFkLnByb3RvdHlwZS5fY29tcHV0ZV9wbG90X2JvdW5kcyA9IGZ1bmN0aW9uIChyZW5kZXJlcnMsIGJvdW5kcykge1xuICAgICAgICB2YXIgaSwgbGVuLCByLCByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IGJib3guZW1wdHkoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVuZGVyZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByID0gcmVuZGVyZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGJvdW5kc1tyLmlkXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYmJveC51bmlvbihyZXN1bHQsIGJvdW5kc1tyLmlkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIERhdGFSYW5nZTFkLnByb3RvdHlwZS5fY29tcHV0ZV9taW5fbWF4ID0gZnVuY3Rpb24gKHBsb3RfYm91bmRzLCBkaW1lbnNpb24pIHtcbiAgICAgICAgdmFyIGssIG1heCwgbWluLCBvdmVyYWxsLCByZWYsIHJlZjEsIHY7XG4gICAgICAgIG92ZXJhbGwgPSBiYm94LmVtcHR5KCk7XG4gICAgICAgIGZvciAoayBpbiBwbG90X2JvdW5kcykge1xuICAgICAgICAgICAgdiA9IHBsb3RfYm91bmRzW2tdO1xuICAgICAgICAgICAgb3ZlcmFsbCA9IGJib3gudW5pb24ob3ZlcmFsbCwgdik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpbWVuc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgcmVmID0gW292ZXJhbGwubWluWCwgb3ZlcmFsbC5tYXhYXSwgbWluID0gcmVmWzBdLCBtYXggPSByZWZbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYxID0gW292ZXJhbGwubWluWSwgb3ZlcmFsbC5tYXhZXSwgbWluID0gcmVmMVswXSwgbWF4ID0gcmVmMVsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9O1xuICAgIERhdGFSYW5nZTFkLnByb3RvdHlwZS5fY29tcHV0ZV9yYW5nZSA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgICB2YXIgY2VudGVyLCBlbmQsIGZvbGxvd19pbnRlcnZhbCwgZm9sbG93X3NpZ24sIGxvZ19tYXgsIGxvZ19taW4sIHJhbmdlX3BhZGRpbmcsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgc3Bhbiwgc3RhcnQ7XG4gICAgICAgIHJhbmdlX3BhZGRpbmcgPSB0aGlzLnJhbmdlX3BhZGRpbmc7XG4gICAgICAgIGlmICgocmFuZ2VfcGFkZGluZyAhPSBudWxsKSAmJiByYW5nZV9wYWRkaW5nID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NhbGVfaGludCA9PT0gXCJsb2dcIikge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihtaW4pIHx8ICFpc0Zpbml0ZShtaW4pIHx8IG1pbiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihtYXgpIHx8ICFpc0Zpbml0ZShtYXgpIHx8IG1heCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSAwLjE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSBtYXggLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci53YXJuKFwiY291bGQgbm90IGRldGVybWluZSBtaW5pbXVtIGRhdGEgdmFsdWUgZm9yIGxvZyBheGlzLCBEYXRhUmFuZ2UxZCB1c2luZyB2YWx1ZSBcIiArIG1pbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc05hTihtYXgpIHx8ICFpc0Zpbml0ZShtYXgpIHx8IG1heCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihtaW4pIHx8ICFpc0Zpbml0ZShtaW4pIHx8IG1pbiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IG1pbiAqIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJjb3VsZCBub3QgZGV0ZXJtaW5lIG1heGltdW0gZGF0YSB2YWx1ZSBmb3IgbG9nIGF4aXMsIERhdGFSYW5nZTFkIHVzaW5nIHZhbHVlIFwiICsgbWF4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4gPSB0aGlzLmRlZmF1bHRfc3BhbiArIDAuMDAxO1xuICAgICAgICAgICAgICAgICAgICBjZW50ZXIgPSBNYXRoLmxvZyhtaW4pIC8gTWF0aC5sb2coMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2VfcGFkZGluZ191bml0cyA9PT0gXCJwZXJjZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ19taW4gPSBNYXRoLmxvZyhtaW4pIC8gTWF0aC5sb2coMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nX21heCA9IE1hdGgubG9nKG1heCkgLyBNYXRoLmxvZygxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuID0gKGxvZ19tYXggLSBsb2dfbWluKSAqICgxICsgcmFuZ2VfcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dfbWluID0gTWF0aC5sb2cobWluIC0gcmFuZ2VfcGFkZGluZykgLyBNYXRoLmxvZygxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dfbWF4ID0gTWF0aC5sb2cobWF4ICsgcmFuZ2VfcGFkZGluZykgLyBNYXRoLmxvZygxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuID0gbG9nX21heCAtIGxvZ19taW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2VudGVyID0gKGxvZ19taW4gKyBsb2dfbWF4KSAvIDIuMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVmID0gW01hdGgucG93KDEwLCBjZW50ZXIgLSBzcGFuIC8gMi4wKSwgTWF0aC5wb3coMTAsIGNlbnRlciArIHNwYW4gLyAyLjApXSwgc3RhcnQgPSByZWZbMF0sIGVuZCA9IHJlZlsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBzcGFuID0gdGhpcy5kZWZhdWx0X3NwYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yYW5nZV9wYWRkaW5nX3VuaXRzID09PSBcInBlcmNlbnRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BhbiA9IChtYXggLSBtaW4pICogKDEgKyByYW5nZV9wYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4gPSAobWF4IC0gbWluKSArIDIgKiByYW5nZV9wYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNlbnRlciA9IChtYXggKyBtaW4pIC8gMi4wO1xuICAgICAgICAgICAgICAgIHJlZjEgPSBbY2VudGVyIC0gc3BhbiAvIDIuMCwgY2VudGVyICsgc3BhbiAvIDIuMF0sIHN0YXJ0ID0gcmVmMVswXSwgZW5kID0gcmVmMVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZjIgPSBbbWluLCBtYXhdLCBzdGFydCA9IHJlZjJbMF0sIGVuZCA9IHJlZjJbMV07XG4gICAgICAgIH1cbiAgICAgICAgZm9sbG93X3NpZ24gPSArMTtcbiAgICAgICAgaWYgKHRoaXMuZmxpcHBlZCkge1xuICAgICAgICAgICAgcmVmMyA9IFtlbmQsIHN0YXJ0XSwgc3RhcnQgPSByZWYzWzBdLCBlbmQgPSByZWYzWzFdO1xuICAgICAgICAgICAgZm9sbG93X3NpZ24gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBmb2xsb3dfaW50ZXJ2YWwgPSB0aGlzLmZvbGxvd19pbnRlcnZhbDtcbiAgICAgICAgaWYgKChmb2xsb3dfaW50ZXJ2YWwgIT0gbnVsbCkgJiYgTWF0aC5hYnMoc3RhcnQgLSBlbmQpID4gZm9sbG93X2ludGVydmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb2xsb3cgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydCArIGZvbGxvd19zaWduICogZm9sbG93X2ludGVydmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5mb2xsb3cgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQgLSBmb2xsb3dfc2lnbiAqIGZvbGxvd19pbnRlcnZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3N0YXJ0LCBlbmRdO1xuICAgIH07XG4gICAgRGF0YVJhbmdlMWQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChib3VuZHMsIGRpbWVuc2lvbiwgYm91bmRzX2lkKSB7XG4gICAgICAgIHZhciBfZW5kLCBfc3RhcnQsIGVuZCwgbWF4LCBtaW4sIG5ld19yYW5nZSwgcmVmLCByZWYxLCByZWYyLCByZW5kZXJlcnMsIHN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5oYXZlX3VwZGF0ZWRfaW50ZXJhY3RpdmVseSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVycyA9IHRoaXMuY29tcHV0ZWRfcmVuZGVyZXJzKCk7XG4gICAgICAgIHRoaXMucGxvdF9ib3VuZHNbYm91bmRzX2lkXSA9IHRoaXMuX2NvbXB1dGVfcGxvdF9ib3VuZHMocmVuZGVyZXJzLCBib3VuZHMpO1xuICAgICAgICByZWYgPSB0aGlzLl9jb21wdXRlX21pbl9tYXgodGhpcy5wbG90X2JvdW5kcywgZGltZW5zaW9uKSwgbWluID0gcmVmWzBdLCBtYXggPSByZWZbMV07XG4gICAgICAgIHJlZjEgPSB0aGlzLl9jb21wdXRlX3JhbmdlKG1pbiwgbWF4KSwgc3RhcnQgPSByZWYxWzBdLCBlbmQgPSByZWYxWzFdO1xuICAgICAgICBpZiAodGhpcy5faW5pdGlhbF9zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY2FsZV9oaW50ID09PSBcImxvZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxfc3RhcnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5faW5pdGlhbF9zdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2luaXRpYWxfc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxfZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjYWxlX2hpbnQgPT09IFwibG9nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5pdGlhbF9lbmQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuX2luaXRpYWxfZW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuX2luaXRpYWxfZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlZjIgPSBbdGhpcy5zdGFydCwgdGhpcy5lbmRdLCBfc3RhcnQgPSByZWYyWzBdLCBfZW5kID0gcmVmMlsxXTtcbiAgICAgICAgaWYgKHN0YXJ0ICE9PSBfc3RhcnQgfHwgZW5kICE9PSBfZW5kKSB7XG4gICAgICAgICAgICBuZXdfcmFuZ2UgPSB7fTtcbiAgICAgICAgICAgIGlmIChzdGFydCAhPT0gX3N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgbmV3X3JhbmdlLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kICE9PSBfZW5kKSB7XG4gICAgICAgICAgICAgICAgbmV3X3JhbmdlLmVuZCA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0dihuZXdfcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvdW5kcyA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aGlzLnNldHYoe1xuICAgICAgICAgICAgICAgIGJvdW5kczogW3N0YXJ0LCBlbmRdXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UuZW1pdCgpO1xuICAgIH07XG4gICAgRGF0YVJhbmdlMWQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhdmVfdXBkYXRlZF9pbnRlcmFjdGl2ZWx5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0dih7XG4gICAgICAgICAgICByYW5nZV9wYWRkaW5nOiB0aGlzLl9pbml0aWFsX3JhbmdlX3BhZGRpbmcsXG4gICAgICAgICAgICByYW5nZV9wYWRkaW5nX3VuaXRzOiB0aGlzLl9pbml0aWFsX3JhbmdlX3BhZGRpbmdfdW5pdHMsXG4gICAgICAgICAgICBmb2xsb3c6IHRoaXMuX2luaXRpYWxfZm9sbG93LFxuICAgICAgICAgICAgZm9sbG93X2ludGVydmFsOiB0aGlzLl9pbml0aWFsX2ZvbGxvd19pbnRlcnZhbCxcbiAgICAgICAgICAgIGRlZmF1bHRfc3BhbjogdGhpcy5faW5pdGlhbF9kZWZhdWx0X3NwYW5cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UuZW1pdCgpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGFSYW5nZTFkO1xufSkoZGF0YV9yYW5nZV8xLkRhdGFSYW5nZSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgcmFuZ2VfMSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5GYWN0b3JSYW5nZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChGYWN0b3JSYW5nZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRmFjdG9yUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBGYWN0b3JSYW5nZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRmFjdG9yUmFuZ2UucHJvdG90eXBlLnR5cGUgPSAnRmFjdG9yUmFuZ2UnO1xuICAgIEZhY3RvclJhbmdlLmRlZmluZSh7XG4gICAgICAgIG9mZnNldDogW3AuTnVtYmVyLCAwXSxcbiAgICAgICAgZmFjdG9yczogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgYm91bmRzOiBbcC5BbnldLFxuICAgICAgICBtaW5faW50ZXJ2YWw6IFtwLkFueV0sXG4gICAgICAgIG1heF9pbnRlcnZhbDogW3AuQW55XVxuICAgIH0pO1xuICAgIEZhY3RvclJhbmdlLmludGVybmFsKHtcbiAgICAgICAgX2JvdW5kc19hc19mYWN0b3JzOiBbcC5BbnldLFxuICAgICAgICBzdGFydDogW3AuTnVtYmVyXSxcbiAgICAgICAgZW5kOiBbcC5OdW1iZXJdXG4gICAgfSk7XG4gICAgRmFjdG9yUmFuZ2UucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgRmFjdG9yUmFuZ2UuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIGlmICgodGhpcy5ib3VuZHMgIT0gbnVsbCkgJiYgdGhpcy5ib3VuZHMgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgdGhpcy5zZXR2KHtcbiAgICAgICAgICAgICAgICBfYm91bmRzX2FzX2ZhY3RvcnM6IHRoaXMuYm91bmRzXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dih7XG4gICAgICAgICAgICAgICAgX2JvdW5kc19hc19mYWN0b3JzOiB0aGlzLmZhY3RvcnNcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMucHJvcGVydGllcy5mYWN0b3JzLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZV9mYWN0b3JzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMucHJvcGVydGllcy5vZmZzZXQuY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5pdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEZhY3RvclJhbmdlLmdldHRlcnMoe1xuICAgICAgICBtaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0O1xuICAgICAgICB9LFxuICAgICAgICBtYXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIEZhY3RvclJhbmdlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UuZW1pdCgpO1xuICAgIH07XG4gICAgRmFjdG9yUmFuZ2UucHJvdG90eXBlLl91cGRhdGVfZmFjdG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXR2KCdfYm91bmRzX2FzX2ZhY3RvcnMnLCB0aGlzLmZhY3RvcnMsIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXQoKTtcbiAgICB9O1xuICAgIEZhY3RvclJhbmdlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVuZCwgZmFjdG9ycywgc3RhcnQ7XG4gICAgICAgIGZhY3RvcnMgPSB0aGlzLmZhY3RvcnM7XG4gICAgICAgIGlmICgodGhpcy5ib3VuZHMgIT0gbnVsbCkgJiYgdGhpcy5ib3VuZHMgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgZmFjdG9ycyA9IHRoaXMuX2JvdW5kc19hc19mYWN0b3JzO1xuICAgICAgICAgICAgdGhpcy5zZXR2KHtcbiAgICAgICAgICAgICAgICBmYWN0b3JzOiBmYWN0b3JzXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IDAuNSArIHRoaXMub2Zmc2V0O1xuICAgICAgICBlbmQgPSBmYWN0b3JzLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICB0aGlzLnNldHYoe1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5ib3VuZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dih7XG4gICAgICAgICAgICAgICAgYm91bmRzOiBbc3RhcnQsIGVuZF1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRmFjdG9yUmFuZ2U7XG59KShyYW5nZV8xLlJhbmdlKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRhdGFfcmFuZ2VfMSA9IHJlcXVpcmUoXCIuL2RhdGFfcmFuZ2VcIik7XG5leHBvcnRzLkRhdGFSYW5nZSA9IGRhdGFfcmFuZ2VfMS5EYXRhUmFuZ2U7XG52YXIgZGF0YV9yYW5nZTFkXzEgPSByZXF1aXJlKFwiLi9kYXRhX3JhbmdlMWRcIik7XG5leHBvcnRzLkRhdGFSYW5nZTFkID0gZGF0YV9yYW5nZTFkXzEuRGF0YVJhbmdlMWQ7XG52YXIgZmFjdG9yX3JhbmdlXzEgPSByZXF1aXJlKFwiLi9mYWN0b3JfcmFuZ2VcIik7XG5leHBvcnRzLkZhY3RvclJhbmdlID0gZmFjdG9yX3JhbmdlXzEuRmFjdG9yUmFuZ2U7XG52YXIgcmFuZ2VfMSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpO1xuZXhwb3J0cy5SYW5nZSA9IHJhbmdlXzEuUmFuZ2U7XG52YXIgcmFuZ2UxZF8xID0gcmVxdWlyZShcIi4vcmFuZ2UxZFwiKTtcbmV4cG9ydHMuUmFuZ2UxZCA9IHJhbmdlMWRfMS5SYW5nZTFkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLlJhbmdlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJhbmdlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBSYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSYW5nZS5wcm90b3R5cGUudHlwZSA9ICdSYW5nZSc7XG4gICAgUmFuZ2UucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBSYW5nZS5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMuY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLmNhbGxiYWNrKSAhPSBudWxsID8gcmVmLmV4ZWN1dGUodGhpcykgOiB2b2lkIDA7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmFuZ2UuZGVmaW5lKHtcbiAgICAgICAgY2FsbGJhY2s6IFtwLkluc3RhbmNlXVxuICAgIH0pO1xuICAgIFJhbmdlLmludGVybmFsKHtcbiAgICAgICAgcGxvdHM6IFtwLkFycmF5LCBbXV1cbiAgICB9KTtcbiAgICBSYW5nZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFwiVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHJlaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcyBhbmQgZW5zdXJlIHRoYXRcXG50aGUgY2FsbGJhY2ssIGlmIGV4aXN0cywgaXMgZXhlY3V0ZWQgYXQgY29tcGxldGlvbi5cIjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlLmVtaXQoKTtcbiAgICB9O1xuICAgIHJldHVybiBSYW5nZTtcbn0pKG1vZGVsXzEuTW9kZWwpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHJhbmdlXzEgPSByZXF1aXJlKFwiLi9yYW5nZVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuUmFuZ2UxZCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChSYW5nZTFkLCBzdXBlckNsYXNzKTtcbiAgICBSYW5nZTFkLnByb3RvdHlwZS50eXBlID0gJ1JhbmdlMWQnO1xuICAgIFJhbmdlMWQuZGVmaW5lKHtcbiAgICAgICAgc3RhcnQ6IFtwLk51bWJlciwgMF0sXG4gICAgICAgIGVuZDogW3AuTnVtYmVyLCAxXSxcbiAgICAgICAgYm91bmRzOiBbcC5BbnldLFxuICAgICAgICBtaW5faW50ZXJ2YWw6IFtwLkFueV0sXG4gICAgICAgIG1heF9pbnRlcnZhbDogW3AuQW55XVxuICAgIH0pO1xuICAgIFJhbmdlMWQucHJvdG90eXBlLl9zZXRfYXV0b19ib3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXgsIG1pbjtcbiAgICAgICAgaWYgKHRoaXMuYm91bmRzID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHRoaXMuX2luaXRpYWxfc3RhcnQsIHRoaXMuX2luaXRpYWxfZW5kKTtcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KHRoaXMuX2luaXRpYWxfc3RhcnQsIHRoaXMuX2luaXRpYWxfZW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHYoe1xuICAgICAgICAgICAgICAgIGJvdW5kczogW21pbiwgbWF4XVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIFJhbmdlMWQoKSB7XG4gICAgICAgIHZhciBlbmQsIHN0YXJ0O1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFJhbmdlMWQpIHtcbiAgICAgICAgICAgIHJldHVybiBSYW5nZTFkLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBhcmd1bWVudHNbMF0sIGVuZCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UxZCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogZW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSYW5nZTFkLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIFJhbmdlMWQuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxfc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB0aGlzLl9pbml0aWFsX2VuZCA9IHRoaXMuZW5kO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0X2F1dG9fYm91bmRzKCk7XG4gICAgfTtcbiAgICBSYW5nZTFkLmdldHRlcnMoe1xuICAgICAgICBtaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1heDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFJhbmdlMWQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zZXRfYXV0b19ib3VuZHMoKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnQgIT09IHRoaXMuX2luaXRpYWxfc3RhcnQgfHwgdGhpcy5lbmQgIT09IHRoaXMuX2luaXRpYWxfZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR2KHtcbiAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5faW5pdGlhbF9zdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuX2luaXRpYWxfZW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZS5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSYW5nZTFkO1xufSkocmFuZ2VfMS5SYW5nZSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQxID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKVxuICAgICAgICByZXR1cm4gaTtcbn0gcmV0dXJuIC0xOyB9O1xudmFyIHJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9yZW5kZXJlclwiKTtcbnZhciByZW1vdGVfZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuLi9zb3VyY2VzL3JlbW90ZV9kYXRhX3NvdXJjZVwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9vYmplY3RcIik7XG5leHBvcnRzLkdseXBoUmVuZGVyZXJWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShHbHlwaFJlbmRlcmVyVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gR2x5cGhSZW5kZXJlclZpZXcoKSB7XG4gICAgICAgIHJldHVybiBHbHlwaFJlbmRlcmVyVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgR2x5cGhSZW5kZXJlclZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgYmFzZV9nbHlwaCwgZGVjaW1hdGVkX2dseXBoLCBnbHlwaF9hdHRycywgaGFzX2ZpbGwsIGhhc19saW5lLCBob3Zlcl9nbHlwaCwgbWtfZ2x5cGgsIG11dGVkX2dseXBoLCBub25zZWxlY3Rpb25fZ2x5cGgsIHNlbGVjdGlvbl9nbHlwaDtcbiAgICAgICAgR2x5cGhSZW5kZXJlclZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgYmFzZV9nbHlwaCA9IHRoaXMubW9kZWwuZ2x5cGg7XG4gICAgICAgIGhhc19maWxsID0gaW5kZXhPZi5jYWxsKGJhc2VfZ2x5cGgubWl4aW5zLCBcImZpbGxcIikgPj0gMDtcbiAgICAgICAgaGFzX2xpbmUgPSBpbmRleE9mLmNhbGwoYmFzZV9nbHlwaC5taXhpbnMsIFwibGluZVwiKSA+PSAwO1xuICAgICAgICBnbHlwaF9hdHRycyA9IG9iamVjdF8xLmNsb25lKGJhc2VfZ2x5cGguYXR0cmlidXRlcyk7XG4gICAgICAgIGRlbGV0ZSBnbHlwaF9hdHRycy5pZDtcbiAgICAgICAgbWtfZ2x5cGggPSBmdW5jdGlvbiAoZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIHZhciBhdHRycztcbiAgICAgICAgICAgIGF0dHJzID0gb2JqZWN0XzEuY2xvbmUoZ2x5cGhfYXR0cnMpO1xuICAgICAgICAgICAgaWYgKGhhc19maWxsKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0XzEuZXh0ZW5kKGF0dHJzLCBkZWZhdWx0cy5maWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNfbGluZSkge1xuICAgICAgICAgICAgICAgIG9iamVjdF8xLmV4dGVuZChhdHRycywgZGVmYXVsdHMubGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGJhc2VfZ2x5cGguY29uc3RydWN0b3IoYXR0cnMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdseXBoID0gdGhpcy5idWlsZF9nbHlwaF92aWV3KGJhc2VfZ2x5cGgpO1xuICAgICAgICBzZWxlY3Rpb25fZ2x5cGggPSB0aGlzLm1vZGVsLnNlbGVjdGlvbl9nbHlwaDtcbiAgICAgICAgaWYgKHNlbGVjdGlvbl9nbHlwaCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25fZ2x5cGggPSBta19nbHlwaCh7XG4gICAgICAgICAgICAgICAgZmlsbDoge30sXG4gICAgICAgICAgICAgICAgbGluZToge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdGlvbl9nbHlwaCA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbl9nbHlwaCA9IG1rX2dseXBoKHRoaXMubW9kZWwuc2VsZWN0aW9uX2RlZmF1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbl9nbHlwaCA9IHRoaXMuYnVpbGRfZ2x5cGhfdmlldyhzZWxlY3Rpb25fZ2x5cGgpO1xuICAgICAgICBub25zZWxlY3Rpb25fZ2x5cGggPSB0aGlzLm1vZGVsLm5vbnNlbGVjdGlvbl9nbHlwaDtcbiAgICAgICAgaWYgKG5vbnNlbGVjdGlvbl9nbHlwaCA9PSBudWxsKSB7XG4gICAgICAgICAgICBub25zZWxlY3Rpb25fZ2x5cGggPSBta19nbHlwaCh7XG4gICAgICAgICAgICAgICAgZmlsbDoge30sXG4gICAgICAgICAgICAgICAgbGluZToge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vbnNlbGVjdGlvbl9nbHlwaCA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICAgIG5vbnNlbGVjdGlvbl9nbHlwaCA9IG1rX2dseXBoKHRoaXMubW9kZWwubm9uc2VsZWN0aW9uX2RlZmF1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vbnNlbGVjdGlvbl9nbHlwaCA9IHRoaXMuYnVpbGRfZ2x5cGhfdmlldyhub25zZWxlY3Rpb25fZ2x5cGgpO1xuICAgICAgICBob3Zlcl9nbHlwaCA9IHRoaXMubW9kZWwuaG92ZXJfZ2x5cGg7XG4gICAgICAgIGlmIChob3Zlcl9nbHlwaCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmhvdmVyX2dseXBoID0gdGhpcy5idWlsZF9nbHlwaF92aWV3KGhvdmVyX2dseXBoKTtcbiAgICAgICAgfVxuICAgICAgICBtdXRlZF9nbHlwaCA9IHRoaXMubW9kZWwubXV0ZWRfZ2x5cGg7XG4gICAgICAgIGlmIChtdXRlZF9nbHlwaCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm11dGVkX2dseXBoID0gdGhpcy5idWlsZF9nbHlwaF92aWV3KG11dGVkX2dseXBoKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNpbWF0ZWRfZ2x5cGggPSBta19nbHlwaCh0aGlzLm1vZGVsLmRlY2ltYXRlZF9kZWZhdWx0cyk7XG4gICAgICAgIHRoaXMuZGVjaW1hdGVkX2dseXBoID0gdGhpcy5idWlsZF9nbHlwaF92aWV3KGRlY2ltYXRlZF9nbHlwaCk7XG4gICAgICAgIHRoaXMueHNjYWxlID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueHNjYWxlc1t0aGlzLm1vZGVsLnhfcmFuZ2VfbmFtZV07XG4gICAgICAgIHRoaXMueXNjYWxlID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueXNjYWxlc1t0aGlzLm1vZGVsLnlfcmFuZ2VfbmFtZV07XG4gICAgICAgIHRoaXMuc2V0X2RhdGEoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5kYXRhX3NvdXJjZSBpbnN0YW5jZW9mIHJlbW90ZV9kYXRhX3NvdXJjZV8xLlJlbW90ZURhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmRhdGFfc291cmNlLnNldHVwKHRoaXMucGxvdF92aWV3LCB0aGlzLmdseXBoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR2x5cGhSZW5kZXJlclZpZXcuZ2V0dGVycyh7XG4gICAgICAgIHhtYXBwZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvZy53YXJuaW5nKFwieG1hcHBlciBhdHRyIGlzIGRlcHJlY2F0ZWQsIHVzZSB4c2NhbGVcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54c2NhbGU7XG4gICAgICAgIH0sXG4gICAgICAgIHltYXBwZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvZy53YXJuaW5nKFwieW1hcHBlciBhdHRyIGlzIGRlcHJlY2F0ZWQsIHVzZSB5c2NhbGVcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55c2NhbGU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBHbHlwaFJlbmRlcmVyVmlldy5wcm90b3R5cGUuYnVpbGRfZ2x5cGhfdmlldyA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICByZXR1cm4gbmV3IG1vZGVsLmRlZmF1bHRfdmlldyh7XG4gICAgICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgICAgICAgIHBsb3RfdmlldzogdGhpcy5wbG90X3ZpZXcsXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHbHlwaFJlbmRlcmVyVmlldy5wcm90b3R5cGUuY29ubmVjdF9zaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBHbHlwaFJlbmRlcmVyVmlldy5fX3N1cGVyX18uY29ubmVjdF9zaWduYWxzLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLmRhdGFfc291cmNlLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0X2RhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLmRhdGFfc291cmNlLnN0cmVhbWluZywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0X2RhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLmRhdGFfc291cmNlLnBhdGNoaW5nLCBmdW5jdGlvbiAoaW5kaWNlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0X2RhdGEodHJ1ZSwgaW5kaWNlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5kYXRhX3NvdXJjZS5zZWxlY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5ob3Zlcl9nbHlwaCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5kYXRhX3NvdXJjZS5pbnNwZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLmdseXBoLnRyYW5zZm9ybWNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0X2RhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5nbHlwaC5wcm9wY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmdseXBoLnNldF92aXN1YWxzKHRoaXMubW9kZWwuZGF0YV9zb3VyY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHbHlwaFJlbmRlcmVyVmlldy5wcm90b3R5cGUuaGF2ZV9zZWxlY3Rpb25fZ2x5cGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc2VsZWN0aW9uX2dseXBoICE9IG51bGwpICYmICh0aGlzLm5vbnNlbGVjdGlvbl9nbHlwaCAhPSBudWxsKTtcbiAgICB9O1xuICAgIEdseXBoUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5zZXRfZGF0YSA9IGZ1bmN0aW9uIChyZXF1ZXN0X3JlbmRlciwgaW5kaWNlcykge1xuICAgICAgICB2YXIgZHQsIGksIGosIGssIGxlbmd0aCwgbG9kX2ZhY3RvciwgcmVmLCByZXN1bHRzLCBzb3VyY2UsIHQwO1xuICAgICAgICBpZiAocmVxdWVzdF9yZW5kZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVxdWVzdF9yZW5kZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHQwID0gRGF0ZS5ub3coKTtcbiAgICAgICAgc291cmNlID0gdGhpcy5tb2RlbC5kYXRhX3NvdXJjZTtcbiAgICAgICAgdGhpcy5nbHlwaC5tb2RlbC5zZXR2KHtcbiAgICAgICAgICAgIHhfcmFuZ2VfbmFtZTogdGhpcy5tb2RlbC54X3JhbmdlX25hbWUsXG4gICAgICAgICAgICB5X3JhbmdlX25hbWU6IHRoaXMubW9kZWwueV9yYW5nZV9uYW1lXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nbHlwaC5zZXRfZGF0YShzb3VyY2UsIGluZGljZXMpO1xuICAgICAgICB0aGlzLmdseXBoLnNldF92aXN1YWxzKHNvdXJjZSk7XG4gICAgICAgIHRoaXMuZGVjaW1hdGVkX2dseXBoLnNldF92aXN1YWxzKHNvdXJjZSk7XG4gICAgICAgIGlmICh0aGlzLmhhdmVfc2VsZWN0aW9uX2dseXBocygpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbl9nbHlwaC5zZXRfdmlzdWFscyhzb3VyY2UpO1xuICAgICAgICAgICAgdGhpcy5ub25zZWxlY3Rpb25fZ2x5cGguc2V0X3Zpc3VhbHMoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ob3Zlcl9nbHlwaCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmhvdmVyX2dseXBoLnNldF92aXN1YWxzKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubXV0ZWRfZ2x5cGggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tdXRlZF9nbHlwaC5zZXRfdmlzdWFscyhzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZS5nZXRfbGVuZ3RoKCk7XG4gICAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbF9pbmRpY2VzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyAwIDw9IGxlbmd0aCA/IGogPCBsZW5ndGggOiBqID4gbGVuZ3RoOyAwIDw9IGxlbmd0aCA/IGorKyA6IGotLSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5hcHBseSh0aGlzKTtcbiAgICAgICAgbG9kX2ZhY3RvciA9IHRoaXMucGxvdF9tb2RlbC5wbG90LmxvZF9mYWN0b3I7XG4gICAgICAgIHRoaXMuZGVjaW1hdGVkID0gW107XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYgPSBNYXRoLmZsb29yKHRoaXMuYWxsX2luZGljZXMubGVuZ3RoIC8gbG9kX2ZhY3Rvcik7IDAgPD0gcmVmID8gayA8IHJlZiA6IGsgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgdGhpcy5kZWNpbWF0ZWQucHVzaCh0aGlzLmFsbF9pbmRpY2VzW2kgKiBsb2RfZmFjdG9yXSk7XG4gICAgICAgIH1cbiAgICAgICAgZHQgPSBEYXRlLm5vdygpIC0gdDA7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcodGhpcy5nbHlwaC5tb2RlbC50eXBlICsgXCIgR2x5cGhSZW5kZXJlciAoXCIgKyB0aGlzLm1vZGVsLmlkICsgXCIpOiBzZXRfZGF0YSBmaW5pc2hlZCBpbiBcIiArIGR0ICsgXCJtc1wiKTtcbiAgICAgICAgdGhpcy5zZXRfZGF0YV90aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAocmVxdWVzdF9yZW5kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdseXBoUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHgsIGR0bWFwLCBkdG1hc2ssIGR0cmVuZGVyLCBkdHNlbGVjdCwgZHR0b3QsIGdsc3VwcG9ydCwgZ2x5cGgsIGksIGluZGljZXMsIGluc3BlY3RlZCwgaiwgaywgbGVuLCBsZW4xLCBsb2RfdGhyZXNob2xkLCBub25zZWxlY3RlZCwgbm9uc2VsZWN0aW9uX2dseXBoLCBzZWxlY3RlZCwgc2VsZWN0ZWRfbWFzaywgc2VsZWN0aW9uX2dseXBoLCB0MCwgdG1hcCwgdG1hc2ssIHRyZW5kZXIsIHRzZWxlY3Q7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdDAgPSBEYXRlLm5vdygpO1xuICAgICAgICBnbHN1cHBvcnQgPSB0aGlzLmdseXBoLmdsZ2x5cGg7XG4gICAgICAgIHRtYXAgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLmdseXBoLm1hcF9kYXRhKCk7XG4gICAgICAgIGR0bWFwID0gRGF0ZS5ub3coKSAtIHQwO1xuICAgICAgICB0bWFzayA9IERhdGUubm93KCk7XG4gICAgICAgIGluZGljZXMgPSB0aGlzLmdseXBoLm1hc2tfZGF0YSh0aGlzLmFsbF9pbmRpY2VzKTtcbiAgICAgICAgZHRtYXNrID0gRGF0ZS5ub3coKSAtIHRtYXNrO1xuICAgICAgICBjdHggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHNlbGVjdGVkID0gdGhpcy5tb2RlbC5kYXRhX3NvdXJjZS5zZWxlY3RlZDtcbiAgICAgICAgaWYgKCFzZWxlY3RlZCB8fCBzZWxlY3RlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRbJzBkJ10uZ2x5cGgpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGluZGljZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3RlZFsnMWQnXS5pbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHNlbGVjdGVkWycxZCddLmluZGljZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluc3BlY3RlZCA9IHRoaXMubW9kZWwuZGF0YV9zb3VyY2UuaW5zcGVjdGVkO1xuICAgICAgICBpZiAoIWluc3BlY3RlZCB8fCBpbnNwZWN0ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpbnNwZWN0ZWQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbnNwZWN0ZWRbJzBkJ10uZ2x5cGgpIHtcbiAgICAgICAgICAgICAgICBpbnNwZWN0ZWQgPSBpbmRpY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5zcGVjdGVkWycxZCddLmluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGluc3BlY3RlZCA9IGluc3BlY3RlZFsnMWQnXS5pbmRpY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zcGVjdGVkID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9kX3RocmVzaG9sZCA9IHRoaXMucGxvdF9tb2RlbC5wbG90LmxvZF90aHJlc2hvbGQ7XG4gICAgICAgIGlmICh0aGlzLnBsb3Rfdmlldy5pbnRlcmFjdGl2ZSAmJiAhZ2xzdXBwb3J0ICYmIChsb2RfdGhyZXNob2xkICE9IG51bGwpICYmIHRoaXMuYWxsX2luZGljZXMubGVuZ3RoID4gbG9kX3RocmVzaG9sZCkge1xuICAgICAgICAgICAgaW5kaWNlcyA9IHRoaXMuZGVjaW1hdGVkO1xuICAgICAgICAgICAgZ2x5cGggPSB0aGlzLmRlY2ltYXRlZF9nbHlwaDtcbiAgICAgICAgICAgIG5vbnNlbGVjdGlvbl9nbHlwaCA9IHRoaXMuZGVjaW1hdGVkX2dseXBoO1xuICAgICAgICAgICAgc2VsZWN0aW9uX2dseXBoID0gdGhpcy5zZWxlY3Rpb25fZ2x5cGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbHlwaCA9IHRoaXMubW9kZWwubXV0ZWQgJiYgKHRoaXMubXV0ZWRfZ2x5cGggIT0gbnVsbCkgPyB0aGlzLm11dGVkX2dseXBoIDogdGhpcy5nbHlwaDtcbiAgICAgICAgICAgIG5vbnNlbGVjdGlvbl9nbHlwaCA9IHRoaXMubm9uc2VsZWN0aW9uX2dseXBoO1xuICAgICAgICAgICAgc2VsZWN0aW9uX2dseXBoID0gdGhpcy5zZWxlY3Rpb25fZ2x5cGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0aGlzLmhvdmVyX2dseXBoICE9IG51bGwpICYmIGluc3BlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGluZGljZXMgPSBhcnJheV8xLmRpZmZlcmVuY2UoaW5kaWNlcywgaW5zcGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzZWxlY3RlZC5sZW5ndGggJiYgdGhpcy5oYXZlX3NlbGVjdGlvbl9nbHlwaHMoKSkpIHtcbiAgICAgICAgICAgIHRyZW5kZXIgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgZ2x5cGgucmVuZGVyKGN0eCwgaW5kaWNlcywgdGhpcy5nbHlwaCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ob3Zlcl9nbHlwaCAmJiBpbnNwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3Zlcl9nbHlwaC5yZW5kZXIoY3R4LCBpbnNwZWN0ZWQsIHRoaXMuZ2x5cGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHRyZW5kZXIgPSBEYXRlLm5vdygpIC0gdHJlbmRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRzZWxlY3QgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgc2VsZWN0ZWRfbWFzayA9IHt9O1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gc2VsZWN0ZWQubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpID0gc2VsZWN0ZWRbal07XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbWFza1tpXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3RlZCA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgbm9uc2VsZWN0ZWQgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgIGZvciAoayA9IDAsIGxlbjEgPSBpbmRpY2VzLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICAgICAgICAgIGkgPSBpbmRpY2VzW2tdO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZF9tYXNrW2ldICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vbnNlbGVjdGVkLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHRzZWxlY3QgPSBEYXRlLm5vdygpIC0gdHNlbGVjdDtcbiAgICAgICAgICAgIHRyZW5kZXIgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgbm9uc2VsZWN0aW9uX2dseXBoLnJlbmRlcihjdHgsIG5vbnNlbGVjdGVkLCB0aGlzLmdseXBoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbl9nbHlwaC5yZW5kZXIoY3R4LCBzZWxlY3RlZCwgdGhpcy5nbHlwaCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ob3Zlcl9nbHlwaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3Zlcl9nbHlwaC5yZW5kZXIoY3R4LCBpbnNwZWN0ZWQsIHRoaXMuZ2x5cGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHRyZW5kZXIgPSBEYXRlLm5vdygpIC0gdHJlbmRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RfZHRyZW5kZXIgPSBkdHJlbmRlcjtcbiAgICAgICAgZHR0b3QgPSBEYXRlLm5vdygpIC0gdDA7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcodGhpcy5nbHlwaC5tb2RlbC50eXBlICsgXCIgR2x5cGhSZW5kZXJlciAoXCIgKyB0aGlzLm1vZGVsLmlkICsgXCIpOiByZW5kZXIgZmluaXNoZWQgaW4gXCIgKyBkdHRvdCArIFwibXNcIik7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIudHJhY2UoXCIgLSBtYXBfZGF0YSBmaW5pc2hlZCBpbiAgICAgICA6IFwiICsgZHRtYXAgKyBcIm1zXCIpO1xuICAgICAgICBpZiAoZHRtYXNrICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIudHJhY2UoXCIgLSBtYXNrX2RhdGEgZmluaXNoZWQgaW4gICAgICA6IFwiICsgZHRtYXNrICsgXCJtc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHRzZWxlY3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci50cmFjZShcIiAtIHNlbGVjdGlvbiBtYXNrIGZpbmlzaGVkIGluIDogXCIgKyBkdHNlbGVjdCArIFwibXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci50cmFjZShcIiAtIGdseXBoIHJlbmRlcnMgZmluaXNoZWQgaW4gIDogXCIgKyBkdHJlbmRlciArIFwibXNcIik7XG4gICAgICAgIHJldHVybiBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgR2x5cGhSZW5kZXJlclZpZXcucHJvdG90eXBlLm1hcF90b19zY3JlZW4gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wbG90X3ZpZXcubWFwX3RvX3NjcmVlbih4LCB5LCB0aGlzLm1vZGVsLnhfcmFuZ2VfbmFtZSwgdGhpcy5tb2RlbC55X3JhbmdlX25hbWUpO1xuICAgIH07XG4gICAgR2x5cGhSZW5kZXJlclZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGZpZWxkLCBsYWJlbCkge1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIGluZGV4ID0gdGhpcy5tb2RlbC5nZXRfcmVmZXJlbmNlX3BvaW50KGZpZWxkLCBsYWJlbCk7XG4gICAgICAgIHJldHVybiB0aGlzLmdseXBoLmRyYXdfbGVnZW5kX2Zvcl9pbmRleChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCk7XG4gICAgfTtcbiAgICBHbHlwaFJlbmRlcmVyVmlldy5wcm90b3R5cGUuaGl0X3Rlc3QgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuaGl0X3Rlc3RfaGVscGVyKGdlb21ldHJ5LCB0aGlzLmdseXBoKTtcbiAgICB9O1xuICAgIHJldHVybiBHbHlwaFJlbmRlcmVyVmlldztcbn0pKHJlbmRlcmVyXzEuUmVuZGVyZXJWaWV3KTtcbmV4cG9ydHMuR2x5cGhSZW5kZXJlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoR2x5cGhSZW5kZXJlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gR2x5cGhSZW5kZXJlcigpIHtcbiAgICAgICAgcmV0dXJuIEdseXBoUmVuZGVyZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdseXBoUmVuZGVyZXIucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuR2x5cGhSZW5kZXJlclZpZXc7XG4gICAgR2x5cGhSZW5kZXJlci5wcm90b3R5cGUudHlwZSA9ICdHbHlwaFJlbmRlcmVyJztcbiAgICBHbHlwaFJlbmRlcmVyLnByb3RvdHlwZS5nZXRfcmVmZXJlbmNlX3BvaW50ID0gZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF0YSwgaSwgaW5kZXg7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgaWYgKChmaWVsZCAhPSBudWxsKSAmJiAodGhpcy5kYXRhX3NvdXJjZS5nZXRfY29sdW1uICE9IG51bGwpKSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhX3NvdXJjZS5nZXRfY29sdW1uKGZpZWxkKTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaSA9IGRhdGEuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgR2x5cGhSZW5kZXJlci5wcm90b3R5cGUuaGl0X3Rlc3RfaGVscGVyID0gZnVuY3Rpb24gKGdlb21ldHJ5LCBnbHlwaCkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2x5cGguaGl0X3Rlc3QoZ2VvbWV0cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdseXBoUmVuZGVyZXIuZGVmaW5lKHtcbiAgICAgICAgeF9yYW5nZV9uYW1lOiBbcC5TdHJpbmcsICdkZWZhdWx0J10sXG4gICAgICAgIHlfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddLFxuICAgICAgICBkYXRhX3NvdXJjZTogW3AuSW5zdGFuY2VdLFxuICAgICAgICBnbHlwaDogW3AuSW5zdGFuY2VdLFxuICAgICAgICBob3Zlcl9nbHlwaDogW3AuSW5zdGFuY2VdLFxuICAgICAgICBub25zZWxlY3Rpb25fZ2x5cGg6IFtwLkFueSwgJ2F1dG8nXSxcbiAgICAgICAgc2VsZWN0aW9uX2dseXBoOiBbcC5BbnksICdhdXRvJ10sXG4gICAgICAgIG11dGVkX2dseXBoOiBbcC5JbnN0YW5jZV0sXG4gICAgICAgIG11dGVkOiBbcC5Cb29sLCBmYWxzZV1cbiAgICB9KTtcbiAgICBHbHlwaFJlbmRlcmVyLm92ZXJyaWRlKHtcbiAgICAgICAgbGV2ZWw6ICdnbHlwaCdcbiAgICB9KTtcbiAgICBHbHlwaFJlbmRlcmVyLnByb3RvdHlwZS5zZWxlY3Rpb25fZGVmYXVsdHMgPSB7XG4gICAgICAgIGZpbGw6IHt9LFxuICAgICAgICBsaW5lOiB7fVxuICAgIH07XG4gICAgR2x5cGhSZW5kZXJlci5wcm90b3R5cGUuZGVjaW1hdGVkX2RlZmF1bHRzID0ge1xuICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICBmaWxsX2FscGhhOiAwLjMsXG4gICAgICAgICAgICBmaWxsX2NvbG9yOiBcImdyZXlcIlxuICAgICAgICB9LFxuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICBsaW5lX2FscGhhOiAwLjMsXG4gICAgICAgICAgICBsaW5lX2NvbG9yOiBcImdyZXlcIlxuICAgICAgICB9XG4gICAgfTtcbiAgICBHbHlwaFJlbmRlcmVyLnByb3RvdHlwZS5ub25zZWxlY3Rpb25fZGVmYXVsdHMgPSB7XG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIGZpbGxfYWxwaGE6IDAuMixcbiAgICAgICAgICAgIGxpbmVfYWxwaGE6IDAuMlxuICAgICAgICB9LFxuICAgICAgICBsaW5lOiB7fVxuICAgIH07XG4gICAgcmV0dXJuIEdseXBoUmVuZGVyZXI7XG59KShyZW5kZXJlcl8xLlJlbmRlcmVyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciByZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vcmVuZGVyZXJcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkd1aWRlUmVuZGVyZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoR3VpZGVSZW5kZXJlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gR3VpZGVSZW5kZXJlcigpIHtcbiAgICAgICAgcmV0dXJuIEd1aWRlUmVuZGVyZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEd1aWRlUmVuZGVyZXIucHJvdG90eXBlLnR5cGUgPSAnR3VpZGVSZW5kZXJlcic7XG4gICAgR3VpZGVSZW5kZXJlci5kZWZpbmUoe1xuICAgICAgICBwbG90OiBbcC5JbnN0YW5jZV1cbiAgICB9KTtcbiAgICBHdWlkZVJlbmRlcmVyLm92ZXJyaWRlKHtcbiAgICAgICAgbGV2ZWw6ICdvdmVybGF5J1xuICAgIH0pO1xuICAgIHJldHVybiBHdWlkZVJlbmRlcmVyO1xufSkocmVuZGVyZXJfMS5SZW5kZXJlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBnbHlwaF9yZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vZ2x5cGhfcmVuZGVyZXJcIik7XG5leHBvcnRzLkdseXBoUmVuZGVyZXIgPSBnbHlwaF9yZW5kZXJlcl8xLkdseXBoUmVuZGVyZXI7XG52YXIgZ3VpZGVfcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL2d1aWRlX3JlbmRlcmVyXCIpO1xuZXhwb3J0cy5HdWlkZVJlbmRlcmVyID0gZ3VpZGVfcmVuZGVyZXJfMS5HdWlkZVJlbmRlcmVyO1xudmFyIHJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9yZW5kZXJlclwiKTtcbmV4cG9ydHMuUmVuZGVyZXIgPSByZW5kZXJlcl8xLlJlbmRlcmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kMSA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBkb21fdmlld18xID0gcmVxdWlyZShcImNvcmUvZG9tX3ZpZXdcIik7XG52YXIgdmlzdWFsc18xID0gcmVxdWlyZShcImNvcmUvdmlzdWFsc1wiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBwcm9qID0gcmVxdWlyZShcImNvcmUvdXRpbC9wcm9qZWN0aW9uc1wiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvb2JqZWN0XCIpO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxcIik7XG5leHBvcnRzLlJlbmRlcmVyVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoUmVuZGVyZXJWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBSZW5kZXJlclZpZXcoKSB7XG4gICAgICAgIHJldHVybiBSZW5kZXJlclZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJlbmRlcmVyVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIFJlbmRlcmVyVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnBsb3RfdmlldyA9IG9wdGlvbnMucGxvdF92aWV3O1xuICAgICAgICB0aGlzLnZpc3VhbHMgPSBuZXcgdmlzdWFsc18xLlZpc3VhbHModGhpcy5tb2RlbCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNfZmluaXNoZWQgPSB0cnVlO1xuICAgIH07XG4gICAgUmVuZGVyZXJWaWV3LmdldHRlcnMoe1xuICAgICAgICBwbG90X21vZGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wbG90X3ZpZXcubW9kZWw7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBSZW5kZXJlclZpZXcucHJvdG90eXBlLnJlcXVlc3RfcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wbG90X3ZpZXcucmVxdWVzdF9yZW5kZXIoKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyVmlldy5wcm90b3R5cGUuc2V0X2RhdGEgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBkYXRhLCByZWYsIHJlZjE7XG4gICAgICAgIGRhdGEgPSB0aGlzLm1vZGVsLm1hdGVyaWFsaXplX2RhdGFzcGVjcyhzb3VyY2UpO1xuICAgICAgICBvYmplY3RfMS5leHRlbmQodGhpcywgZGF0YSk7XG4gICAgICAgIGlmICh0aGlzLnBsb3RfbW9kZWwudXNlX21hcCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlZiA9IHByb2oucHJvamVjdF94eSh0aGlzLl94LCB0aGlzLl95KSwgdGhpcy5feCA9IHJlZlswXSwgdGhpcy5feSA9IHJlZlsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl94cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZjEgPSBwcm9qLnByb2plY3RfeHN5cyh0aGlzLl94cywgdGhpcy5feXMpLCB0aGlzLl94cyA9IHJlZjFbMF0sIHRoaXMuX3lzID0gcmVmMVsxXSwgcmVmMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5tYXBfdG9fc2NyZWVuID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3Lm1hcF90b19zY3JlZW4oeCwgeSwgdGhpcy5tb2RlbC54X3JhbmdlX25hbWUsIHRoaXMubW9kZWwueV9yYW5nZV9uYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBSZW5kZXJlclZpZXc7XG59KShkb21fdmlld18xLkRPTVZpZXcpO1xuZXhwb3J0cy5SZW5kZXJlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoUmVuZGVyZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuICAgICAgICByZXR1cm4gUmVuZGVyZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJlbmRlcmVyLnByb3RvdHlwZS50eXBlID0gXCJSZW5kZXJlclwiO1xuICAgIFJlbmRlcmVyLmRlZmluZSh7XG4gICAgICAgIGxldmVsOiBbcC5SZW5kZXJMZXZlbCwgbnVsbF0sXG4gICAgICAgIHZpc2libGU6IFtwLkJvb2wsIHRydWVdXG4gICAgfSk7XG4gICAgcmV0dXJuIFJlbmRlcmVyO1xufSkobW9kZWxfMS5Nb2RlbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgbGluZWFyX3NjYWxlXzEgPSByZXF1aXJlKFwiLi9saW5lYXJfc2NhbGVcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdHlwZXNcIik7XG5leHBvcnRzLkNhdGVnb3JpY2FsU2NhbGUgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ2F0ZWdvcmljYWxTY2FsZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcmljYWxTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIENhdGVnb3JpY2FsU2NhbGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhdGVnb3JpY2FsU2NhbGUucHJvdG90eXBlLnR5cGUgPSBcIkNhdGVnb3JpY2FsU2NhbGVcIjtcbiAgICBDYXRlZ29yaWNhbFNjYWxlLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24gKHgsIHJldHVybl9zeW50aGV0aWMpIHtcbiAgICAgICAgdmFyIGZhY3RvciwgZmFjdG9ycywgcGVyY2VudCwgcmFuZ2UsIHJlZiwgcmVzdWx0O1xuICAgICAgICBpZiAocmV0dXJuX3N5bnRoZXRpYyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5fc3ludGhldGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVzXzEuaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5fc3ludGhldGljKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2F0ZWdvcmljYWxTY2FsZS5fX3N1cGVyX18uY29tcHV0ZS5jYWxsKHRoaXMsIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJhbmdlID0gdGhpcy5zb3VyY2VfcmFuZ2U7XG4gICAgICAgIGZhY3RvcnMgPSByYW5nZS5mYWN0b3JzO1xuICAgICAgICBpZiAoeC5pbmRleE9mKCc6JykgPj0gMCkge1xuICAgICAgICAgICAgcmVmID0geC5zcGxpdCgnOicpLCBmYWN0b3IgPSByZWZbMF0sIHBlcmNlbnQgPSByZWZbMV07XG4gICAgICAgICAgICBwZXJjZW50ID0gcGFyc2VGbG9hdChwZXJjZW50KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhY3RvcnMuaW5kZXhPZihmYWN0b3IpICsgMC41ICsgcmFuZ2Uub2Zmc2V0ICsgcGVyY2VudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhY3RvcnMuaW5kZXhPZih4KSArIDEgKyByYW5nZS5vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldHVybl9zeW50aGV0aWMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQ2F0ZWdvcmljYWxTY2FsZS5fX3N1cGVyX18uY29tcHV0ZS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhdGVnb3JpY2FsU2NhbGUucHJvdG90eXBlLnZfY29tcHV0ZSA9IGZ1bmN0aW9uICh4cywgcmV0dXJuX3N5bnRoZXRpYykge1xuICAgICAgICB2YXIgZmFjdG9yLCBmYWN0b3JzLCBpLCBqLCBwZXJjZW50LCByYW5nZSwgcmVmLCByZWYxLCByZXN1bHRzLCB4O1xuICAgICAgICBpZiAocmV0dXJuX3N5bnRoZXRpYyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5fc3ludGhldGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVzXzEuaXNOdW1iZXIoeHNbMF0pKSB7XG4gICAgICAgICAgICBpZiAocmV0dXJuX3N5bnRoZXRpYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB4cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBDYXRlZ29yaWNhbFNjYWxlLl9fc3VwZXJfXy52X2NvbXB1dGUuY2FsbCh0aGlzLCB4cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2UgPSB0aGlzLnNvdXJjZV9yYW5nZTtcbiAgICAgICAgZmFjdG9ycyA9IHJhbmdlLmZhY3RvcnM7XG4gICAgICAgIHJlc3VsdHMgPSBBcnJheSh4cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0geHMubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIHggPSB4c1tpXTtcbiAgICAgICAgICAgIGlmICh4LmluZGV4T2YoJzonKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVmMSA9IHguc3BsaXQoJzonKSwgZmFjdG9yID0gcmVmMVswXSwgcGVyY2VudCA9IHJlZjFbMV07XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9IHBhcnNlRmxvYXQocGVyY2VudCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IGZhY3RvcnMuaW5kZXhPZihmYWN0b3IpICsgMC41ICsgcmFuZ2Uub2Zmc2V0ICsgcGVyY2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBmYWN0b3JzLmluZGV4T2YoeCkgKyAxICsgcmFuZ2Uub2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXR1cm5fc3ludGhldGljKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBDYXRlZ29yaWNhbFNjYWxlLl9fc3VwZXJfXy52X2NvbXB1dGUuY2FsbCh0aGlzLCByZXN1bHRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2F0ZWdvcmljYWxTY2FsZS5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKHhwcmltZSwgc2tpcF9jYXQpIHtcbiAgICAgICAgdmFyIGZhY3RvcnMsIHJhbmdlO1xuICAgICAgICBpZiAoc2tpcF9jYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2tpcF9jYXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB4cHJpbWUgPSBDYXRlZ29yaWNhbFNjYWxlLl9fc3VwZXJfXy5pbnZlcnQuY2FsbCh0aGlzLCB4cHJpbWUpO1xuICAgICAgICBpZiAoc2tpcF9jYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB4cHJpbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2UgPSB0aGlzLnNvdXJjZV9yYW5nZTtcbiAgICAgICAgZmFjdG9ycyA9IHJhbmdlLmZhY3RvcnM7XG4gICAgICAgIHJldHVybiBmYWN0b3JzW01hdGguZmxvb3IoeHByaW1lIC0gMC41IC0gcmFuZ2Uub2Zmc2V0KV07XG4gICAgfTtcbiAgICBDYXRlZ29yaWNhbFNjYWxlLnByb3RvdHlwZS52X2ludmVydCA9IGZ1bmN0aW9uICh4cHJpbWVzLCBza2lwX2NhdCkge1xuICAgICAgICB2YXIgZmFjdG9ycywgaSwgaiwgaywgcmFuZ2UsIHJlZiwgcmVmMSwgcmVzdWx0LCB4O1xuICAgICAgICBpZiAoc2tpcF9jYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2tpcF9jYXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB4ID0gQ2F0ZWdvcmljYWxTY2FsZS5fX3N1cGVyX18udl9pbnZlcnQuY2FsbCh0aGlzLCB4cHJpbWVzKTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHgubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIHhbaV0gPSB4W2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwX2NhdCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoeCk7XG4gICAgICAgIHJhbmdlID0gdGhpcy5zb3VyY2VfcmFuZ2U7XG4gICAgICAgIGZhY3RvcnMgPSByYW5nZS5mYWN0b3JzO1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmMSA9IHhwcmltZXMubGVuZ3RoOyAwIDw9IHJlZjEgPyBrIDwgcmVmMSA6IGsgPiByZWYxOyBpID0gMCA8PSByZWYxID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBmYWN0b3JzW01hdGguZmxvb3IoeFtpXSAtIDAuNSAtIHJhbmdlLm9mZnNldCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0ZWdvcmljYWxTY2FsZTtcbn0pKGxpbmVhcl9zY2FsZV8xLkxpbmVhclNjYWxlKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNhdGVnb3JpY2FsX3NjYWxlXzEgPSByZXF1aXJlKFwiLi9jYXRlZ29yaWNhbF9zY2FsZVwiKTtcbmV4cG9ydHMuQ2F0ZWdvcmljYWxTY2FsZSA9IGNhdGVnb3JpY2FsX3NjYWxlXzEuQ2F0ZWdvcmljYWxTY2FsZTtcbnZhciBsaW5lYXJfc2NhbGVfMSA9IHJlcXVpcmUoXCIuL2xpbmVhcl9zY2FsZVwiKTtcbmV4cG9ydHMuTGluZWFyU2NhbGUgPSBsaW5lYXJfc2NhbGVfMS5MaW5lYXJTY2FsZTtcbnZhciBsb2dfc2NhbGVfMSA9IHJlcXVpcmUoXCIuL2xvZ19zY2FsZVwiKTtcbmV4cG9ydHMuTG9nU2NhbGUgPSBsb2dfc2NhbGVfMS5Mb2dTY2FsZTtcbnZhciBzY2FsZV8xID0gcmVxdWlyZShcIi4vc2NhbGVcIik7XG5leHBvcnRzLlNjYWxlID0gc2NhbGVfMS5TY2FsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBzY2FsZV8xID0gcmVxdWlyZShcIi4vc2NhbGVcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkxpbmVhclNjYWxlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExpbmVhclNjYWxlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMaW5lYXJTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIExpbmVhclNjYWxlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMaW5lYXJTY2FsZS5wcm90b3R5cGUudHlwZSA9IFwiTGluZWFyU2NhbGVcIjtcbiAgICBMaW5lYXJTY2FsZS5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBmYWN0b3IsIG9mZnNldCwgcmVmO1xuICAgICAgICByZWYgPSB0aGlzLl9jb21wdXRlX3N0YXRlKCksIGZhY3RvciA9IHJlZlswXSwgb2Zmc2V0ID0gcmVmWzFdO1xuICAgICAgICByZXR1cm4gZmFjdG9yICogeCArIG9mZnNldDtcbiAgICB9O1xuICAgIExpbmVhclNjYWxlLnByb3RvdHlwZS52X2NvbXB1dGUgPSBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgdmFyIGZhY3RvciwgaSwgaWR4LCBsZW4sIG9mZnNldCwgcmVmLCByZXN1bHQsIHg7XG4gICAgICAgIHJlZiA9IHRoaXMuX2NvbXB1dGVfc3RhdGUoKSwgZmFjdG9yID0gcmVmWzBdLCBvZmZzZXQgPSByZWZbMV07XG4gICAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDY0QXJyYXkoeHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpZHggPSBpID0gMCwgbGVuID0geHMubGVuZ3RoOyBpIDwgbGVuOyBpZHggPSArK2kpIHtcbiAgICAgICAgICAgIHggPSB4c1tpZHhdO1xuICAgICAgICAgICAgcmVzdWx0W2lkeF0gPSBmYWN0b3IgKiB4ICsgb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBMaW5lYXJTY2FsZS5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKHhwcmltZSkge1xuICAgICAgICB2YXIgZmFjdG9yLCBvZmZzZXQsIHJlZjtcbiAgICAgICAgcmVmID0gdGhpcy5fY29tcHV0ZV9zdGF0ZSgpLCBmYWN0b3IgPSByZWZbMF0sIG9mZnNldCA9IHJlZlsxXTtcbiAgICAgICAgcmV0dXJuICh4cHJpbWUgLSBvZmZzZXQpIC8gZmFjdG9yO1xuICAgIH07XG4gICAgTGluZWFyU2NhbGUucHJvdG90eXBlLnZfaW52ZXJ0ID0gZnVuY3Rpb24gKHhwcmltZXMpIHtcbiAgICAgICAgdmFyIGZhY3RvciwgaSwgaWR4LCBsZW4sIG9mZnNldCwgcmVmLCByZXN1bHQsIHhwcmltZTtcbiAgICAgICAgcmVmID0gdGhpcy5fY29tcHV0ZV9zdGF0ZSgpLCBmYWN0b3IgPSByZWZbMF0sIG9mZnNldCA9IHJlZlsxXTtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEZsb2F0NjRBcnJheSh4cHJpbWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaWR4ID0gaSA9IDAsIGxlbiA9IHhwcmltZXMubGVuZ3RoOyBpIDwgbGVuOyBpZHggPSArK2kpIHtcbiAgICAgICAgICAgIHhwcmltZSA9IHhwcmltZXNbaWR4XTtcbiAgICAgICAgICAgIHJlc3VsdFtpZHhdID0gKHhwcmltZSAtIG9mZnNldCkgLyBmYWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIExpbmVhclNjYWxlLnByb3RvdHlwZS5fY29tcHV0ZV9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZhY3Rvciwgb2Zmc2V0LCBzb3VyY2VfZW5kLCBzb3VyY2Vfc3RhcnQsIHRhcmdldF9lbmQsIHRhcmdldF9zdGFydDtcbiAgICAgICAgc291cmNlX3N0YXJ0ID0gdGhpcy5zb3VyY2VfcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIHNvdXJjZV9lbmQgPSB0aGlzLnNvdXJjZV9yYW5nZS5lbmQ7XG4gICAgICAgIHRhcmdldF9zdGFydCA9IHRoaXMudGFyZ2V0X3JhbmdlLnN0YXJ0O1xuICAgICAgICB0YXJnZXRfZW5kID0gdGhpcy50YXJnZXRfcmFuZ2UuZW5kO1xuICAgICAgICBmYWN0b3IgPSAodGFyZ2V0X2VuZCAtIHRhcmdldF9zdGFydCkgLyAoc291cmNlX2VuZCAtIHNvdXJjZV9zdGFydCk7XG4gICAgICAgIG9mZnNldCA9IC0oZmFjdG9yICogc291cmNlX3N0YXJ0KSArIHRhcmdldF9zdGFydDtcbiAgICAgICAgcmV0dXJuIFtmYWN0b3IsIG9mZnNldF07XG4gICAgfTtcbiAgICBMaW5lYXJTY2FsZS5pbnRlcm5hbCh7XG4gICAgICAgIHNvdXJjZV9yYW5nZTogW3AuQW55XSxcbiAgICAgICAgdGFyZ2V0X3JhbmdlOiBbcC5BbnldXG4gICAgfSk7XG4gICAgcmV0dXJuIExpbmVhclNjYWxlO1xufSkoc2NhbGVfMS5TY2FsZSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuL3NjYWxlXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5Mb2dTY2FsZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMb2dTY2FsZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTG9nU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiBMb2dTY2FsZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTG9nU2NhbGUucHJvdG90eXBlLnR5cGUgPSBcIkxvZ1NjYWxlXCI7XG4gICAgTG9nU2NhbGUucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgX3gsIGZhY3RvciwgaW50ZXJfZmFjdG9yLCBpbnRlcl9vZmZzZXQsIG9mZnNldCwgcmVmLCB2YWx1ZTtcbiAgICAgICAgcmVmID0gdGhpcy5fY29tcHV0ZV9zdGF0ZSgpLCBmYWN0b3IgPSByZWZbMF0sIG9mZnNldCA9IHJlZlsxXSwgaW50ZXJfZmFjdG9yID0gcmVmWzJdLCBpbnRlcl9vZmZzZXQgPSByZWZbM107XG4gICAgICAgIGlmIChpbnRlcl9mYWN0b3IgPT09IDApIHtcbiAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF94ID0gKE1hdGgubG9nKHgpIC0gaW50ZXJfb2Zmc2V0KSAvIGludGVyX2ZhY3RvcjtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShfeCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF94ICogZmFjdG9yICsgb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAwIC8gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBMb2dTY2FsZS5wcm90b3R5cGUudl9jb21wdXRlID0gZnVuY3Rpb24gKHhzKSB7XG4gICAgICAgIHZhciBfeCwgZmFjdG9yLCBpLCBpbnRlcl9mYWN0b3IsIGludGVyX29mZnNldCwgaiwgaywgb2Zmc2V0LCByZWYsIHJlZjEsIHJlZjIsIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgIHJlZiA9IHRoaXMuX2NvbXB1dGVfc3RhdGUoKSwgZmFjdG9yID0gcmVmWzBdLCBvZmZzZXQgPSByZWZbMV0sIGludGVyX2ZhY3RvciA9IHJlZlsyXSwgaW50ZXJfb2Zmc2V0ID0gcmVmWzNdO1xuICAgICAgICByZXN1bHQgPSBuZXcgRmxvYXQ2NEFycmF5KHhzLmxlbmd0aCk7XG4gICAgICAgIGlmIChpbnRlcl9mYWN0b3IgPT09IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYxID0geHMubGVuZ3RoOyAwIDw9IHJlZjEgPyBqIDwgcmVmMSA6IGogPiByZWYxOyBpID0gMCA8PSByZWYxID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYyID0geHMubGVuZ3RoOyAwIDw9IHJlZjIgPyBrIDwgcmVmMiA6IGsgPiByZWYyOyBpID0gMCA8PSByZWYyID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICAgICAgX3ggPSAoTWF0aC5sb2coeHNbaV0pIC0gaW50ZXJfb2Zmc2V0KSAvIGludGVyX2ZhY3RvcjtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoX3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3ggKiBmYWN0b3IgKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDAgLyAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTG9nU2NhbGUucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uICh4cHJpbWUpIHtcbiAgICAgICAgdmFyIGZhY3RvciwgaW50ZXJfZmFjdG9yLCBpbnRlcl9vZmZzZXQsIG9mZnNldCwgcmVmLCB2YWx1ZTtcbiAgICAgICAgcmVmID0gdGhpcy5fY29tcHV0ZV9zdGF0ZSgpLCBmYWN0b3IgPSByZWZbMF0sIG9mZnNldCA9IHJlZlsxXSwgaW50ZXJfZmFjdG9yID0gcmVmWzJdLCBpbnRlcl9vZmZzZXQgPSByZWZbM107XG4gICAgICAgIHZhbHVlID0gKHhwcmltZSAtIG9mZnNldCkgLyBmYWN0b3I7XG4gICAgICAgIHJldHVybiBNYXRoLmV4cChpbnRlcl9mYWN0b3IgKiB2YWx1ZSArIGludGVyX29mZnNldCk7XG4gICAgfTtcbiAgICBMb2dTY2FsZS5wcm90b3R5cGUudl9pbnZlcnQgPSBmdW5jdGlvbiAoeHByaW1lcykge1xuICAgICAgICB2YXIgZmFjdG9yLCBpLCBpbnRlcl9mYWN0b3IsIGludGVyX29mZnNldCwgaiwgb2Zmc2V0LCByZWYsIHJlZjEsIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgIHJlZiA9IHRoaXMuX2NvbXB1dGVfc3RhdGUoKSwgZmFjdG9yID0gcmVmWzBdLCBvZmZzZXQgPSByZWZbMV0sIGludGVyX2ZhY3RvciA9IHJlZlsyXSwgaW50ZXJfb2Zmc2V0ID0gcmVmWzNdO1xuICAgICAgICByZXN1bHQgPSBuZXcgRmxvYXQ2NEFycmF5KHhwcmltZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZjEgPSB4cHJpbWVzLmxlbmd0aDsgMCA8PSByZWYxID8gaiA8IHJlZjEgOiBqID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgdmFsdWUgPSAoeHByaW1lc1tpXSAtIG9mZnNldCkgLyBmYWN0b3I7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBNYXRoLmV4cChpbnRlcl9mYWN0b3IgKiB2YWx1ZSArIGludGVyX29mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIExvZ1NjYWxlLnByb3RvdHlwZS5fZ2V0X3NhZmVfZmFjdG9yID0gZnVuY3Rpb24gKG9yaWdfc3RhcnQsIG9yaWdfZW5kKSB7XG4gICAgICAgIHZhciBlbmQsIGxvZ192YWwsIHJlZiwgc3RhcnQ7XG4gICAgICAgIGlmIChvcmlnX3N0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBvcmlnX3N0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmlnX2VuZCA8IDApIHtcbiAgICAgICAgICAgIGVuZCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSBvcmlnX2VuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVmID0gWzEsIDEwXSwgc3RhcnQgPSByZWZbMF0sIGVuZCA9IHJlZlsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ192YWwgPSBNYXRoLmxvZyhzdGFydCkgLyBNYXRoLmxvZygxMCk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2dfdmFsKSk7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguY2VpbChsb2dfdmFsKSAhPT0gTWF0aC5mbG9vcihsb2dfdmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBNYXRoLnBvdygxMCwgTWF0aC5jZWlsKGxvZ192YWwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IE1hdGgucG93KDEwLCBNYXRoLmNlaWwobG9nX3ZhbCkgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzdGFydCwgZW5kXTtcbiAgICB9O1xuICAgIExvZ1NjYWxlLnByb3RvdHlwZS5fY29tcHV0ZV9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVuZCwgZmFjdG9yLCBpbnRlcl9mYWN0b3IsIGludGVyX29mZnNldCwgb2Zmc2V0LCByZWYsIHNjcmVlbl9yYW5nZSwgc291cmNlX2VuZCwgc291cmNlX3N0YXJ0LCBzdGFydCwgdGFyZ2V0X2VuZCwgdGFyZ2V0X3N0YXJ0O1xuICAgICAgICBzb3VyY2Vfc3RhcnQgPSB0aGlzLnNvdXJjZV9yYW5nZS5zdGFydDtcbiAgICAgICAgc291cmNlX2VuZCA9IHRoaXMuc291cmNlX3JhbmdlLmVuZDtcbiAgICAgICAgdGFyZ2V0X3N0YXJ0ID0gdGhpcy50YXJnZXRfcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIHRhcmdldF9lbmQgPSB0aGlzLnRhcmdldF9yYW5nZS5lbmQ7XG4gICAgICAgIHNjcmVlbl9yYW5nZSA9IHRhcmdldF9lbmQgLSB0YXJnZXRfc3RhcnQ7XG4gICAgICAgIHJlZiA9IHRoaXMuX2dldF9zYWZlX2ZhY3Rvcihzb3VyY2Vfc3RhcnQsIHNvdXJjZV9lbmQpLCBzdGFydCA9IHJlZlswXSwgZW5kID0gcmVmWzFdO1xuICAgICAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgICAgICAgIGludGVyX2ZhY3RvciA9IE1hdGgubG9nKGVuZCk7XG4gICAgICAgICAgICBpbnRlcl9vZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW50ZXJfZmFjdG9yID0gTWF0aC5sb2coZW5kKSAtIE1hdGgubG9nKHN0YXJ0KTtcbiAgICAgICAgICAgIGludGVyX29mZnNldCA9IE1hdGgubG9nKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBmYWN0b3IgPSBzY3JlZW5fcmFuZ2U7XG4gICAgICAgIG9mZnNldCA9IHRhcmdldF9zdGFydDtcbiAgICAgICAgcmV0dXJuIFtmYWN0b3IsIG9mZnNldCwgaW50ZXJfZmFjdG9yLCBpbnRlcl9vZmZzZXRdO1xuICAgIH07XG4gICAgTG9nU2NhbGUuaW50ZXJuYWwoe1xuICAgICAgICBzb3VyY2VfcmFuZ2U6IFtwLkFueV0sXG4gICAgICAgIHRhcmdldF9yYW5nZTogW3AuQW55XVxuICAgIH0pO1xuICAgIHJldHVybiBMb2dTY2FsZTtcbn0pKHNjYWxlXzEuU2NhbGUpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBzbGljZSA9IFtdLnNsaWNlO1xudmFyIHRyYW5zZm9ybXNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2Zvcm1zXCIpO1xuZXhwb3J0cy5TY2FsZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTY2FsZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiBTY2FsZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2NhbGUucHJvdG90eXBlLm1hcF90b190YXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN0LCB4O1xuICAgICAgICB4ID0gYXJndW1lbnRzWzBdLCByZXN0ID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogW107XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGUuYXBwbHkodGhpcywgW3hdLmNvbmNhdChzbGljZS5jYWxsKHJlc3QpKSk7XG4gICAgfTtcbiAgICBTY2FsZS5wcm90b3R5cGUudl9tYXBfdG9fdGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdCwgeHM7XG4gICAgICAgIHhzID0gYXJndW1lbnRzWzBdLCByZXN0ID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogW107XG4gICAgICAgIHJldHVybiB0aGlzLnZfY29tcHV0ZS5hcHBseSh0aGlzLCBbeHNdLmNvbmNhdChzbGljZS5jYWxsKHJlc3QpKSk7XG4gICAgfTtcbiAgICBTY2FsZS5wcm90b3R5cGUubWFwX2Zyb21fdGFyZ2V0ID0gZnVuY3Rpb24gKHhwcmltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnZlcnQoeHByaW1lKTtcbiAgICB9O1xuICAgIFNjYWxlLnByb3RvdHlwZS52X21hcF9mcm9tX3RhcmdldCA9IGZ1bmN0aW9uICh4cHJpbWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZfaW52ZXJ0KHhwcmltZXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFNjYWxlO1xufSkodHJhbnNmb3Jtc18xLlRyYW5zZm9ybSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBiaW5kID0gZnVuY3Rpb24gKGZuLCBtZSkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciByZW1vdGVfZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuL3JlbW90ZV9kYXRhX3NvdXJjZVwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5BamF4RGF0YVNvdXJjZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBamF4RGF0YVNvdXJjZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQWpheERhdGFTb3VyY2UoKSB7XG4gICAgICAgIHRoaXMuZ2V0X2RhdGEgPSBiaW5kKHRoaXMuZ2V0X2RhdGEsIHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwID0gYmluZCh0aGlzLnNldHVwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gYmluZCh0aGlzLmRlc3Ryb3ksIHRoaXMpO1xuICAgICAgICByZXR1cm4gQWpheERhdGFTb3VyY2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFqYXhEYXRhU291cmNlLnByb3RvdHlwZS50eXBlID0gJ0FqYXhEYXRhU291cmNlJztcbiAgICBBamF4RGF0YVNvdXJjZS5kZWZpbmUoe1xuICAgICAgICBtb2RlOiBbcC5TdHJpbmcsICdyZXBsYWNlJ10sXG4gICAgICAgIGNvbnRlbnRfdHlwZTogW3AuU3RyaW5nLCAnYXBwbGljYXRpb24vanNvbiddLFxuICAgICAgICBodHRwX2hlYWRlcnM6IFtwLkFueSwge31dLFxuICAgICAgICBtYXhfc2l6ZTogW3AuTnVtYmVyXSxcbiAgICAgICAgbWV0aG9kOiBbcC5TdHJpbmcsICdQT1NUJ10sXG4gICAgICAgIGlmX21vZGlmaWVkOiBbcC5Cb29sLCBmYWxzZV1cbiAgICB9KTtcbiAgICBBamF4RGF0YVNvdXJjZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFqYXhEYXRhU291cmNlLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uIChwbG90X3ZpZXcsIGdseXBoKSB7XG4gICAgICAgIHRoaXMucHYgPSBwbG90X3ZpZXc7XG4gICAgICAgIHRoaXMuZ2V0X2RhdGEodGhpcy5tb2RlKTtcbiAgICAgICAgaWYgKHRoaXMucG9sbGluZ19pbnRlcnZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLmdldF9kYXRhLCB0aGlzLnBvbGxpbmdfaW50ZXJ2YWwsIHRoaXMubW9kZSwgdGhpcy5tYXhfc2l6ZSwgdGhpcy5pZl9tb2RpZmllZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFqYXhEYXRhU291cmNlLnByb3RvdHlwZS5nZXRfZGF0YSA9IGZ1bmN0aW9uIChtb2RlLCBtYXhfc2l6ZSwgaWZfbW9kaWZpZWQpIHtcbiAgICAgICAgdmFyIG5hbWUsIHJlZiwgdmFsdWUsIHhocjtcbiAgICAgICAgaWYgKG1heF9zaXplID09IG51bGwpIHtcbiAgICAgICAgICAgIG1heF9zaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWZfbW9kaWZpZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWZfbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMuZGF0YV91cmwsIHRydWUpO1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIHRoaXMuY29udGVudF90eXBlKTtcbiAgICAgICAgcmVmID0gdGhpcy5odHRwX2hlYWRlcnM7XG4gICAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVmW25hbWVdO1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW4sIGRhdGEsIGksIGxlbiwgb3JpZ2luYWxfZGF0YSwgcmVmMTtcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FwcGVuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxfZGF0YSA9IF90aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmMSA9IF90aGlzLmNvbHVtbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IHJlZjFbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbY29sdW1uXSA9IG9yaWdpbmFsX2RhdGFbY29sdW1uXS5jb25jYXQoZGF0YVtjb2x1bW5dKS5zbGljZSgtbWF4X3NpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBKU09OIGZyb20gXCIgKyBfdGhpcy5kYXRhX3VybCArIFwiIHdpdGggY29kZSBcIiArIHhoci5zdGF0dXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBBamF4RGF0YVNvdXJjZTtcbn0pKHJlbW90ZV9kYXRhX3NvdXJjZV8xLlJlbW90ZURhdGFTb3VyY2UpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGNvbHVtbmFyX2RhdGFfc291cmNlXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5hcl9kYXRhX3NvdXJjZVwiKTtcbnZhciBoYXNfcHJvcHNfMSA9IHJlcXVpcmUoXCJjb3JlL2hhc19wcm9wc1wiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBkYXRhX3N0cnVjdHVyZXNfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvZGF0YV9zdHJ1Y3R1cmVzXCIpO1xudmFyIHNlcmlhbGl6YXRpb24gPSByZXF1aXJlKFwiY29yZS91dGlsL3NlcmlhbGl6YXRpb25cIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdHlwZXNcIik7XG5leHBvcnRzLmNvbmNhdF90eXBlZF9hcnJheXMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBjO1xuICAgIGMgPSBuZXcgYS5jb25zdHJ1Y3RvcihhLmxlbmd0aCArIGIubGVuZ3RoKTtcbiAgICBjLnNldChhLCAwKTtcbiAgICBjLnNldChiLCBhLmxlbmd0aCk7XG4gICAgcmV0dXJuIGM7XG59O1xuZXhwb3J0cy5zdHJlYW1fdG9fY29sdW1uID0gZnVuY3Rpb24gKGNvbCwgbmV3X2NvbCwgcm9sbG92ZXIpIHtcbiAgICB2YXIgZW5kLCBpLCBsLCBtLCByZWYsIHJlZjEsIHJlZjIsIHN0YXJ0LCB0bXAsIHRvdGFsX2xlbjtcbiAgICBpZiAoY29sLmNvbmNhdCAhPSBudWxsKSB7XG4gICAgICAgIGNvbCA9IGNvbC5jb25jYXQobmV3X2NvbCk7XG4gICAgICAgIGlmIChjb2wubGVuZ3RoID4gcm9sbG92ZXIpIHtcbiAgICAgICAgICAgIGNvbCA9IGNvbC5zbGljZSgtcm9sbG92ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2w7XG4gICAgfVxuICAgIHRvdGFsX2xlbiA9IGNvbC5sZW5ndGggKyBuZXdfY29sLmxlbmd0aDtcbiAgICBpZiAoKHJvbGxvdmVyICE9IG51bGwpICYmIHRvdGFsX2xlbiA+IHJvbGxvdmVyKSB7XG4gICAgICAgIHN0YXJ0ID0gdG90YWxfbGVuIC0gcm9sbG92ZXI7XG4gICAgICAgIGVuZCA9IGNvbC5sZW5ndGg7XG4gICAgICAgIGlmIChjb2wubGVuZ3RoIDwgcm9sbG92ZXIpIHtcbiAgICAgICAgICAgIHRtcCA9IG5ldyBjb2wuY29uc3RydWN0b3Iocm9sbG92ZXIpO1xuICAgICAgICAgICAgdG1wLnNldChjb2wsIDApO1xuICAgICAgICAgICAgY29sID0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGwgPSByZWYgPSBzdGFydCwgcmVmMSA9IGVuZDsgcmVmIDw9IHJlZjEgPyBsIDwgcmVmMSA6IGwgPiByZWYxOyBpID0gcmVmIDw9IHJlZjEgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgIGNvbFtpIC0gc3RhcnRdID0gY29sW2ldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IG0gPSAwLCByZWYyID0gbmV3X2NvbC5sZW5ndGg7IDAgPD0gcmVmMiA/IG0gPCByZWYyIDogbSA+IHJlZjI7IGkgPSAwIDw9IHJlZjIgPyArK20gOiAtLW0pIHtcbiAgICAgICAgICAgIGNvbFtpICsgKGVuZCAtIHN0YXJ0KV0gPSBuZXdfY29sW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2w7XG4gICAgfVxuICAgIHRtcCA9IG5ldyBjb2wuY29uc3RydWN0b3IobmV3X2NvbCk7XG4gICAgcmV0dXJuIGV4cG9ydHMuY29uY2F0X3R5cGVkX2FycmF5cyhjb2wsIHRtcCk7XG59O1xuZXhwb3J0cy5zbGljZSA9IGZ1bmN0aW9uIChpbmQsIGxlbmd0aCkge1xuICAgIHZhciByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHN0YXJ0LCBzdGVwLCBzdG9wO1xuICAgIGlmICh0eXBlc18xLmlzT2JqZWN0KGluZCkpIHtcbiAgICAgICAgcmV0dXJuIFsocmVmID0gaW5kLnN0YXJ0KSAhPSBudWxsID8gcmVmIDogMCwgKHJlZjEgPSBpbmQuc3RvcCkgIT0gbnVsbCA/IHJlZjEgOiBsZW5ndGgsIChyZWYyID0gaW5kLnN0ZXApICE9IG51bGwgPyByZWYyIDogMV07XG4gICAgfVxuICAgIHJldHVybiByZWYzID0gW2luZCwgaW5kICsgMSwgMV0sIHN0YXJ0ID0gcmVmM1swXSwgc3RvcCA9IHJlZjNbMV0sIHN0ZXAgPSByZWYzWzJdLCByZWYzO1xufTtcbmV4cG9ydHMucGF0Y2hfdG9fY29sdW1uID0gZnVuY3Rpb24gKGNvbCwgcGF0Y2gsIHNoYXBlcykge1xuICAgIHZhciBmbGF0X2luZGV4LCBpLCBpbmQsIGlzdGFydCwgaXN0ZXAsIGlzdG9wLCBpdGVtLCBqLCBqc3RhcnQsIGpzdGVwLCBqc3RvcCwgbCwgbGVuLCBtLCBuLCBwYXRjaGVkLCBwYXRjaGVkX3JhbmdlLCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHJlZjUsIHJlZjYsIHJlZjcsIHJlZjgsIHNoYXBlLCB2YWx1ZTtcbiAgICBwYXRjaGVkID0gbmV3IGRhdGFfc3RydWN0dXJlc18xLlNldCgpO1xuICAgIHBhdGNoZWRfcmFuZ2UgPSBmYWxzZTtcbiAgICBmb3IgKGwgPSAwLCBsZW4gPSBwYXRjaC5sZW5ndGg7IGwgPCBsZW47IGwrKykge1xuICAgICAgICByZWYgPSBwYXRjaFtsXSwgaW5kID0gcmVmWzBdLCB2YWx1ZSA9IHJlZlsxXTtcbiAgICAgICAgaWYgKCF0eXBlc18xLmlzQXJyYXkoaW5kKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVzXzEuaXNOdW1iZXIoaW5kKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICBwYXRjaGVkLnB1c2goaW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGNoZWRfcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kID0gWzAsIDAsIGluZF07XG4gICAgICAgICAgICBzaGFwZSA9IFsxLCBjb2wubGVuZ3RoXTtcbiAgICAgICAgICAgIGl0ZW0gPSBjb2w7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRjaGVkLnB1c2goaW5kWzBdKTtcbiAgICAgICAgICAgIHNoYXBlID0gc2hhcGVzW2luZFswXV07XG4gICAgICAgICAgICBpdGVtID0gY29sW2luZFswXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHNoYXBlID0gWzEsIHNoYXBlWzBdXTtcbiAgICAgICAgICAgIGluZCA9IFtpbmRbMF0sIDAsIGluZFsxXV07XG4gICAgICAgIH1cbiAgICAgICAgZmxhdF9pbmRleCA9IDA7XG4gICAgICAgIHJlZjEgPSBleHBvcnRzLnNsaWNlKGluZFsxXSwgc2hhcGVbMF0pLCBpc3RhcnQgPSByZWYxWzBdLCBpc3RvcCA9IHJlZjFbMV0sIGlzdGVwID0gcmVmMVsyXTtcbiAgICAgICAgcmVmMiA9IGV4cG9ydHMuc2xpY2UoaW5kWzJdLCBzaGFwZVsxXSksIGpzdGFydCA9IHJlZjJbMF0sIGpzdG9wID0gcmVmMlsxXSwganN0ZXAgPSByZWYyWzJdO1xuICAgICAgICBmb3IgKGkgPSBtID0gcmVmMyA9IGlzdGFydCwgcmVmNCA9IGlzdG9wLCByZWY1ID0gaXN0ZXA7IHJlZjUgPiAwID8gbSA8IHJlZjQgOiBtID4gcmVmNDsgaSA9IG0gKz0gcmVmNSkge1xuICAgICAgICAgICAgZm9yIChqID0gbiA9IHJlZjYgPSBqc3RhcnQsIHJlZjcgPSBqc3RvcCwgcmVmOCA9IGpzdGVwOyByZWY4ID4gMCA/IG4gPCByZWY3IDogbiA+IHJlZjc7IGogPSBuICs9IHJlZjgpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hlZF9yYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaGVkLnB1c2goaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW1baSAqIHNoYXBlWzFdICsgal0gPSB2YWx1ZVtmbGF0X2luZGV4XTtcbiAgICAgICAgICAgICAgICBmbGF0X2luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGNoZWQ7XG59O1xuZXhwb3J0cy5Db2x1bW5EYXRhU291cmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENvbHVtbkRhdGFTb3VyY2UsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENvbHVtbkRhdGFTb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiBDb2x1bW5EYXRhU291cmNlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDb2x1bW5EYXRhU291cmNlLnByb3RvdHlwZS50eXBlID0gJ0NvbHVtbkRhdGFTb3VyY2UnO1xuICAgIENvbHVtbkRhdGFTb3VyY2UucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICBDb2x1bW5EYXRhU291cmNlLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByZWYgPSBzZXJpYWxpemF0aW9uLmRlY29kZV9jb2x1bW5fZGF0YSh0aGlzLmRhdGEpLCB0aGlzLmRhdGEgPSByZWZbMF0sIHRoaXMuX3NoYXBlcyA9IHJlZlsxXSwgcmVmO1xuICAgIH07XG4gICAgQ29sdW1uRGF0YVNvdXJjZS5kZWZpbmUoe1xuICAgICAgICBkYXRhOiBbcC5BbnksIHt9XVxuICAgIH0pO1xuICAgIENvbHVtbkRhdGFTb3VyY2UucHJvdG90eXBlLmF0dHJpYnV0ZXNfYXNfanNvbiA9IGZ1bmN0aW9uIChpbmNsdWRlX2RlZmF1bHRzLCB2YWx1ZV90b19qc29uKSB7XG4gICAgICAgIHZhciBhdHRycywga2V5LCByZWYsIHZhbHVlO1xuICAgICAgICBpZiAoaW5jbHVkZV9kZWZhdWx0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmNsdWRlX2RlZmF1bHRzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVfdG9fanNvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZV90b19qc29uID0gQ29sdW1uRGF0YVNvdXJjZS5fdmFsdWVfdG9fanNvbjtcbiAgICAgICAgfVxuICAgICAgICBhdHRycyA9IHt9O1xuICAgICAgICByZWYgPSB0aGlzLnNlcmlhbGl6YWJsZV9hdHRyaWJ1dGVzKCk7XG4gICAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBrZXkpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFsdWUgPSByZWZba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gc2VyaWFsaXphdGlvbi5lbmNvZGVfY29sdW1uX2RhdGEodmFsdWUsIHRoaXMuX3NoYXBlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5jbHVkZV9kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSBpbiB0aGlzLl9zZXRfYWZ0ZXJfZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlX3RvX2pzb24oXCJhdHRyaWJ1dGVzXCIsIGF0dHJzLCB0aGlzKTtcbiAgICB9O1xuICAgIENvbHVtbkRhdGFTb3VyY2UuX3ZhbHVlX3RvX2pzb24gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3B0aW9uYWxfcGFyZW50X29iamVjdCkge1xuICAgICAgICBpZiAodHlwZXNfMS5pc09iamVjdCh2YWx1ZSkgJiYga2V5ID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uLmVuY29kZV9jb2x1bW5fZGF0YSh2YWx1ZSwgb3B0aW9uYWxfcGFyZW50X29iamVjdC5fc2hhcGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNfcHJvcHNfMS5IYXNQcm9wcy5fdmFsdWVfdG9fanNvbihrZXksIHZhbHVlLCBvcHRpb25hbF9wYXJlbnRfb2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sdW1uRGF0YVNvdXJjZS5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24gKG5ld19kYXRhLCByb2xsb3Zlcikge1xuICAgICAgICB2YXIgZGF0YSwgaywgdjtcbiAgICAgICAgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgZm9yIChrIGluIG5ld19kYXRhKSB7XG4gICAgICAgICAgICB2ID0gbmV3X2RhdGFba107XG4gICAgICAgICAgICBkYXRhW2tdID0gZXhwb3J0cy5zdHJlYW1fdG9fY29sdW1uKGRhdGFba10sIG5ld19kYXRhW2tdLCByb2xsb3Zlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXR2KCdkYXRhJywgZGF0YSwge1xuICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1pbmcuZW1pdCgpO1xuICAgIH07XG4gICAgQ29sdW1uRGF0YVNvdXJjZS5wcm90b3R5cGUucGF0Y2ggPSBmdW5jdGlvbiAocGF0Y2hlcykge1xuICAgICAgICB2YXIgZGF0YSwgaywgcGF0Y2gsIHBhdGNoZWQ7XG4gICAgICAgIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIHBhdGNoZWQgPSBuZXcgZGF0YV9zdHJ1Y3R1cmVzXzEuU2V0KCk7XG4gICAgICAgIGZvciAoayBpbiBwYXRjaGVzKSB7XG4gICAgICAgICAgICBwYXRjaCA9IHBhdGNoZXNba107XG4gICAgICAgICAgICBwYXRjaGVkID0gcGF0Y2hlZC51bmlvbihleHBvcnRzLnBhdGNoX3RvX2NvbHVtbihkYXRhW2tdLCBwYXRjaCwgdGhpcy5fc2hhcGVzW2tdKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXR2KCdkYXRhJywgZGF0YSwge1xuICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRjaGluZy5lbWl0KHBhdGNoZWQudmFsdWVzKTtcbiAgICB9O1xuICAgIHJldHVybiBDb2x1bW5EYXRhU291cmNlO1xufSkoY29sdW1uYXJfZGF0YV9zb3VyY2VfMS5Db2x1bW5hckRhdGFTb3VyY2UpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGRhdGFfc291cmNlXzEgPSByZXF1aXJlKFwiLi9kYXRhX3NvdXJjZVwiKTtcbnZhciBzaWduYWxpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL3NpZ25hbGluZ1wiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIHNlbGVjdGlvbl9tYW5hZ2VyXzEgPSByZXF1aXJlKFwiY29yZS9zZWxlY3Rpb25fbWFuYWdlclwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbmV4cG9ydHMuQ29sdW1uYXJEYXRhU291cmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENvbHVtbmFyRGF0YVNvdXJjZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ29sdW1uYXJEYXRhU291cmNlKCkge1xuICAgICAgICByZXR1cm4gQ29sdW1uYXJEYXRhU291cmNlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDb2x1bW5hckRhdGFTb3VyY2UucHJvdG90eXBlLnR5cGUgPSAnQ29sdW1uYXJEYXRhU291cmNlJztcbiAgICBDb2x1bW5hckRhdGFTb3VyY2UuZGVmaW5lKHtcbiAgICAgICAgY29sdW1uX25hbWVzOiBbcC5BcnJheSwgW11dXG4gICAgfSk7XG4gICAgQ29sdW1uYXJEYXRhU291cmNlLmludGVybmFsKHtcbiAgICAgICAgc2VsZWN0aW9uX21hbmFnZXI6IFtcbiAgICAgICAgICAgIHAuSW5zdGFuY2UsIGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzZWxlY3Rpb25fbWFuYWdlcl8xLlNlbGVjdGlvbk1hbmFnZXIoe1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNlbGZcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgaW5zcGVjdGVkOiBbcC5BbnldLFxuICAgICAgICBfc2hhcGVzOiBbcC5BbnksIHt9XVxuICAgIH0pO1xuICAgIENvbHVtbmFyRGF0YVNvdXJjZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIENvbHVtbmFyRGF0YVNvdXJjZS5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgXCJzZWxlY3RcIik7XG4gICAgICAgIHRoaXMuaW5zcGVjdCA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgXCJpbnNwZWN0XCIpO1xuICAgICAgICB0aGlzLnN0cmVhbWluZyA9IG5ldyBzaWduYWxpbmdfMS5TaWduYWwodGhpcywgXCJzdHJlYW1pbmdcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGNoaW5nID0gbmV3IHNpZ25hbGluZ18xLlNpZ25hbCh0aGlzLCBcInBhdGNoaW5nXCIpO1xuICAgIH07XG4gICAgQ29sdW1uYXJEYXRhU291cmNlLnByb3RvdHlwZS5nZXRfY29sdW1uID0gZnVuY3Rpb24gKGNvbG5hbWUpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLmRhdGFbY29sbmFtZV0pICE9IG51bGwgPyByZWYgOiBudWxsO1xuICAgIH07XG4gICAgQ29sdW1uYXJEYXRhU291cmNlLnByb3RvdHlwZS5jb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kYXRhKTtcbiAgICB9O1xuICAgIENvbHVtbmFyRGF0YVNvdXJjZS5wcm90b3R5cGUuZ2V0X2xlbmd0aCA9IGZ1bmN0aW9uIChzb2Z0KSB7XG4gICAgICAgIHZhciBfa2V5LCBsZW5ndGhzLCBtc2csIHZhbDtcbiAgICAgICAgaWYgKHNvZnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc29mdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RocyA9IGFycmF5XzEudW5pcSgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlZiA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoX2tleSBpbiByZWYpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSByZWZbX2tleV07XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZhbC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pLmNhbGwodGhpcykpO1xuICAgICAgICBzd2l0Y2ggKGxlbmd0aHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aHNbMF07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG1zZyA9IFwiZGF0YSBzb3VyY2UgaGFzIGNvbHVtbnMgb2YgaW5jb25zaXN0ZW50IGxlbmd0aHNcIjtcbiAgICAgICAgICAgICAgICBpZiAoc29mdCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4obXNnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aHMuc29ydCgpWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29sdW1uYXJEYXRhU291cmNlO1xufSkoZGF0YV9zb3VyY2VfMS5EYXRhU291cmNlKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xudmFyIGhpdHRlc3QgPSByZXF1aXJlKFwiY29yZS9oaXR0ZXN0XCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xuZXhwb3J0cy5EYXRhU291cmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERhdGFTb3VyY2UsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERhdGFTb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiBEYXRhU291cmNlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEYXRhU291cmNlLnByb3RvdHlwZS50eXBlID0gJ0RhdGFTb3VyY2UnO1xuICAgIERhdGFTb3VyY2UuZGVmaW5lKHtcbiAgICAgICAgc2VsZWN0ZWQ6IFtwLkFueSwgaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCldLFxuICAgICAgICBjYWxsYmFjazogW3AuQW55XVxuICAgIH0pO1xuICAgIERhdGFTb3VyY2UucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBEYXRhU291cmNlLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5wcm9wZXJ0aWVzLnNlbGVjdGVkLmNoYW5nZSwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBfdGhpcy5jYWxsYmFjaztcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZXNfMS5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5leGVjdXRlKF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRhU291cmNlO1xufSkobW9kZWxfMS5Nb2RlbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgY29sdW1uYXJfZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuL2NvbHVtbmFyX2RhdGFfc291cmNlXCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL2xvZ2dpbmdcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkdlb0pTT05EYXRhU291cmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEdlb0pTT05EYXRhU291cmNlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBHZW9KU09ORGF0YVNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIEdlb0pTT05EYXRhU291cmNlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHZW9KU09ORGF0YVNvdXJjZS5wcm90b3R5cGUudHlwZSA9ICdHZW9KU09ORGF0YVNvdXJjZSc7XG4gICAgR2VvSlNPTkRhdGFTb3VyY2UuZGVmaW5lKHtcbiAgICAgICAgZ2VvanNvbjogW3AuQW55XVxuICAgIH0pO1xuICAgIEdlb0pTT05EYXRhU291cmNlLmludGVybmFsKHtcbiAgICAgICAgZGF0YTogW3AuQW55LCB7fV1cbiAgICB9KTtcbiAgICBHZW9KU09ORGF0YVNvdXJjZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIEdlb0pTT05EYXRhU291cmNlLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZV9kYXRhKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5wcm9wZXJ0aWVzLmdlb2pzb24uY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdXBkYXRlX2RhdGEoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuICAgIEdlb0pTT05EYXRhU291cmNlLnByb3RvdHlwZS5fdXBkYXRlX2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEgPSB0aGlzLmdlb2pzb25fdG9fY29sdW1uX2RhdGEoKTtcbiAgICB9O1xuICAgIEdlb0pTT05EYXRhU291cmNlLnByb3RvdHlwZS5fZ2V0X25ld19saXN0X2FycmF5ID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICB2YXIgaSwgaywgcmVmLCByZXN1bHRzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYgPSBsZW5ndGg7IDAgPD0gcmVmID8gayA8IHJlZiA6IGsgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKFtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEdlb0pTT05EYXRhU291cmNlLnByb3RvdHlwZS5fZ2V0X25ld19uYW5fYXJyYXkgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpLCBrLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZiA9IGxlbmd0aDsgMCA8PSByZWYgPyBrIDwgcmVmIDogayA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goMCAvIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgR2VvSlNPTkRhdGFTb3VyY2UucHJvdG90eXBlLl9mbGF0dGVuX2Z1bmN0aW9uID0gZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBjdXJyZW50SXRlbSkge1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3IuY29uY2F0KFtbMCAvIDAsIDAgLyAwLCAwIC8gMF1dKS5jb25jYXQoY3VycmVudEl0ZW0pO1xuICAgIH07XG4gICAgR2VvSlNPTkRhdGFTb3VyY2UucHJvdG90eXBlLl9hZGRfcHJvcGVydGllcyA9IGZ1bmN0aW9uIChpdGVtLCBkYXRhLCBpLCBpdGVtX2NvdW50KSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSwgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIGl0ZW0ucHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGRhdGFbcHJvcGVydHldID0gdGhpcy5fZ2V0X25ld19uYW5fYXJyYXkoaXRlbV9jb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goZGF0YVtwcm9wZXJ0eV1baV0gPSBpdGVtLnByb3BlcnRpZXNbcHJvcGVydHldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEdlb0pTT05EYXRhU291cmNlLnByb3RvdHlwZS5fYWRkX2dlb21ldHJ5ID0gZnVuY3Rpb24gKGdlb21ldHJ5LCBkYXRhLCBpKSB7XG4gICAgICAgIHZhciBjb29yZF9saXN0LCBjb29yZHMsIGV4dGVyaW9yX3JpbmcsIGV4dGVyaW9yX3JpbmdzLCBmbGF0dGVuZWRfY29vcmRfbGlzdCwgaiwgaywgbCwgbGVuLCBsZW4xLCBsZW4yLCBsZW4zLCBsZW40LCBtLCBuLCBvLCBwb2x5Z29uLCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHJlZjUsIHJlc3VsdHMsIHJlc3VsdHMxLCByZXN1bHRzMiwgcmVzdWx0czM7XG4gICAgICAgIHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICAgICAgICAgICAgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICAgICAgZGF0YS54W2ldID0gY29vcmRzWzBdO1xuICAgICAgICAgICAgICAgIGRhdGEueVtpXSA9IGNvb3Jkc1sxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS56W2ldID0gKHJlZiA9IGNvb3Jkc1syXSkgIT0gbnVsbCA/IHJlZiA6IDAgLyAwO1xuICAgICAgICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBjb29yZF9saXN0ID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IGsgPSAwLCBsZW4gPSBjb29yZF9saXN0Lmxlbmd0aDsgayA8IGxlbjsgaiA9ICsraykge1xuICAgICAgICAgICAgICAgICAgICBjb29yZHMgPSBjb29yZF9saXN0W2pdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnhzW2ldW2pdID0gY29vcmRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnlzW2ldW2pdID0gY29vcmRzWzFdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZGF0YS56c1tpXVtqXSA9IChyZWYxID0gY29vcmRzWzJdKSAhPSBudWxsID8gcmVmMSA6IDAgLyAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgICAgICAgICAgIGlmIChnZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIud2FybignQm9rZWggZG9lcyBub3Qgc3VwcG9ydCBQb2x5Z29ucyB3aXRoIGhvbGVzIGluLCBvbmx5IGV4dGVyaW9yIHJpbmcgdXNlZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXh0ZXJpb3JfcmluZyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMxID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gbCA9IDAsIGxlbjEgPSBleHRlcmlvcl9yaW5nLmxlbmd0aDsgbCA8IGxlbjE7IGogPSArK2wpIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzID0gZXh0ZXJpb3JfcmluZ1tqXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS54c1tpXVtqXSA9IGNvb3Jkc1swXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS55c1tpXVtqXSA9IGNvb3Jkc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0czEucHVzaChkYXRhLnpzW2ldW2pdID0gKHJlZjIgPSBjb29yZHNbMl0pICE9IG51bGwgPyByZWYyIDogMCAvIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0czE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLndhcm4oJ011bHRpUG9pbnQgbm90IHN1cHBvcnRlZCBpbiBCb2tlaCcpO1xuICAgICAgICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGZsYXR0ZW5lZF9jb29yZF9saXN0ID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXMucmVkdWNlKHRoaXMuX2ZsYXR0ZW5fZnVuY3Rpb24pO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMyID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gbSA9IDAsIGxlbjIgPSBmbGF0dGVuZWRfY29vcmRfbGlzdC5sZW5ndGg7IG0gPCBsZW4yOyBqID0gKyttKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkcyA9IGZsYXR0ZW5lZF9jb29yZF9saXN0W2pdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnhzW2ldW2pdID0gY29vcmRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnlzW2ldW2pdID0gY29vcmRzWzFdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzMi5wdXNoKGRhdGEuenNbaV1bal0gPSAocmVmMyA9IGNvb3Jkc1syXSkgIT0gbnVsbCA/IHJlZjMgOiAwIC8gMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgICAgICAgICAgICBleHRlcmlvcl9yaW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgIHJlZjQgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgICAgICAgICBmb3IgKG4gPSAwLCBsZW4zID0gcmVmNC5sZW5ndGg7IG4gPCBsZW4zOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbiA9IHJlZjRbbl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIud2FybignQm9rZWggZG9lcyBub3Qgc3VwcG9ydCBQb2x5Z29ucyB3aXRoIGhvbGVzIGluLCBvbmx5IGV4dGVyaW9yIHJpbmcgdXNlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHRlcmlvcl9yaW5ncy5wdXNoKHBvbHlnb25bMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbGF0dGVuZWRfY29vcmRfbGlzdCA9IGV4dGVyaW9yX3JpbmdzLnJlZHVjZSh0aGlzLl9mbGF0dGVuX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzMyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IG8gPSAwLCBsZW40ID0gZmxhdHRlbmVkX2Nvb3JkX2xpc3QubGVuZ3RoOyBvIDwgbGVuNDsgaiA9ICsrbykge1xuICAgICAgICAgICAgICAgICAgICBjb29yZHMgPSBmbGF0dGVuZWRfY29vcmRfbGlzdFtqXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS54c1tpXVtqXSA9IGNvb3Jkc1swXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS55c1tpXVtqXSA9IGNvb3Jkc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0czMucHVzaChkYXRhLnpzW2ldW2pdID0gKHJlZjUgPSBjb29yZHNbMl0pICE9IG51bGwgPyByZWY1IDogMCAvIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0czM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlICcgKyBnZW9tZXRyeS50eXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR2VvSlNPTkRhdGFTb3VyY2UucHJvdG90eXBlLl9nZXRfaXRlbXNfbGVuZ3RoID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgIHZhciBjb3VudCwgZywgZ2VvbWV0cnksIGksIGl0ZW0sIGosIGssIGwsIGxlbiwgbGVuMSwgcmVmO1xuICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGsgPCBsZW47IGkgPSArK2spIHtcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gaXRlbS50eXBlID09PSAnRmVhdHVyZScgPyBpdGVtLmdlb21ldHJ5IDogaXRlbTtcbiAgICAgICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlZiA9IGdlb21ldHJ5Lmdlb21ldHJpZXM7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gbCA9IDAsIGxlbjEgPSByZWYubGVuZ3RoOyBsIDwgbGVuMTsgaiA9ICsrbCkge1xuICAgICAgICAgICAgICAgICAgICBnID0gcmVmW2pdO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH07XG4gICAgR2VvSlNPTkRhdGFTb3VyY2UucHJvdG90eXBlLmdlb2pzb25fdG9fY29sdW1uX2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnJfaW5kZXgsIGRhdGEsIGcsIGdlb2pzb24sIGdlb21ldHJ5LCBpLCBpdGVtLCBpdGVtX2NvdW50LCBpdGVtcywgaiwgaywgbCwgbGVuLCBsZW4xLCByZWYsIHJlZjE7XG4gICAgICAgIGdlb2pzb24gPSBKU09OLnBhcnNlKHRoaXMuZ2VvanNvbik7XG4gICAgICAgIGlmICgocmVmID0gZ2VvanNvbi50eXBlKSAhPT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicgJiYgcmVmICE9PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jva2VoIG9ubHkgc3VwcG9ydHMgdHlwZSBHZW9tZXRyeUNvbGxlY3Rpb24gYW5kIEZlYXR1cmVDb2xsZWN0aW9uIGF0IHRvcCBsZXZlbCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW9qc29uLnR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoZ2VvanNvbi5nZW9tZXRyaWVzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGdlb21ldHJpZXMgZm91bmQgaW4gR2VvbWV0cnlDb2xsZWN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2VvanNvbi5nZW9tZXRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2VvanNvbi5nZW9tZXRyaWVzIG11c3QgaGF2ZSBvbmUgb3IgbW9yZSBpdGVtcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbXMgPSBnZW9qc29uLmdlb21ldHJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGdlb2pzb24uZmVhdHVyZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZmVhdHVyZXMgZm91bmQgaW4gRmVhdHVyZXNDb2xsZWN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlb2pzb24uZmVhdHVyZXMgbXVzdCBoYXZlIG9uZSBvciBtb3JlIGl0ZW1zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtcyA9IGdlb2pzb24uZmVhdHVyZXM7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbV9jb3VudCA9IHRoaXMuX2dldF9pdGVtc19sZW5ndGgoaXRlbXMpO1xuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgJ3gnOiB0aGlzLl9nZXRfbmV3X25hbl9hcnJheShpdGVtX2NvdW50KSxcbiAgICAgICAgICAgICd5JzogdGhpcy5fZ2V0X25ld19uYW5fYXJyYXkoaXRlbV9jb3VudCksXG4gICAgICAgICAgICAneic6IHRoaXMuX2dldF9uZXdfbmFuX2FycmF5KGl0ZW1fY291bnQpLFxuICAgICAgICAgICAgJ3hzJzogdGhpcy5fZ2V0X25ld19saXN0X2FycmF5KGl0ZW1fY291bnQpLFxuICAgICAgICAgICAgJ3lzJzogdGhpcy5fZ2V0X25ld19saXN0X2FycmF5KGl0ZW1fY291bnQpLFxuICAgICAgICAgICAgJ3pzJzogdGhpcy5fZ2V0X25ld19saXN0X2FycmF5KGl0ZW1fY291bnQpXG4gICAgICAgIH07XG4gICAgICAgIGFycl9pbmRleCA9IDA7XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGsgPCBsZW47IGkgPSArK2spIHtcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gaXRlbS50eXBlID09PSAnRmVhdHVyZScgPyBpdGVtLmdlb21ldHJ5IDogaXRlbTtcbiAgICAgICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlZjEgPSBnZW9tZXRyeS5nZW9tZXRyaWVzO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IGwgPSAwLCBsZW4xID0gcmVmMS5sZW5ndGg7IGwgPCBsZW4xOyBqID0gKytsKSB7XG4gICAgICAgICAgICAgICAgICAgIGcgPSByZWYxW2pdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRfZ2VvbWV0cnkoZywgZGF0YSwgYXJyX2luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRfcHJvcGVydGllcyhpdGVtLCBkYXRhLCBhcnJfaW5kZXgsIGl0ZW1fY291bnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFycl9pbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZF9nZW9tZXRyeShnZW9tZXRyeSwgZGF0YSwgYXJyX2luZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnRmVhdHVyZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkX3Byb3BlcnRpZXMoaXRlbSwgZGF0YSwgYXJyX2luZGV4LCBpdGVtX2NvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJyX2luZGV4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICByZXR1cm4gR2VvSlNPTkRhdGFTb3VyY2U7XG59KShjb2x1bW5hcl9kYXRhX3NvdXJjZV8xLkNvbHVtbmFyRGF0YVNvdXJjZSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhamF4X2RhdGFfc291cmNlXzEgPSByZXF1aXJlKFwiLi9hamF4X2RhdGFfc291cmNlXCIpO1xuZXhwb3J0cy5BamF4RGF0YVNvdXJjZSA9IGFqYXhfZGF0YV9zb3VyY2VfMS5BamF4RGF0YVNvdXJjZTtcbnZhciBjb2x1bW5fZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuL2NvbHVtbl9kYXRhX3NvdXJjZVwiKTtcbmV4cG9ydHMuQ29sdW1uRGF0YVNvdXJjZSA9IGNvbHVtbl9kYXRhX3NvdXJjZV8xLkNvbHVtbkRhdGFTb3VyY2U7XG52YXIgY29sdW1uYXJfZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuL2NvbHVtbmFyX2RhdGFfc291cmNlXCIpO1xuZXhwb3J0cy5Db2x1bW5hckRhdGFTb3VyY2UgPSBjb2x1bW5hcl9kYXRhX3NvdXJjZV8xLkNvbHVtbmFyRGF0YVNvdXJjZTtcbnZhciBkYXRhX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vZGF0YV9zb3VyY2VcIik7XG5leHBvcnRzLkRhdGFTb3VyY2UgPSBkYXRhX3NvdXJjZV8xLkRhdGFTb3VyY2U7XG52YXIgZ2VvanNvbl9kYXRhX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vZ2VvanNvbl9kYXRhX3NvdXJjZVwiKTtcbmV4cG9ydHMuR2VvSlNPTkRhdGFTb3VyY2UgPSBnZW9qc29uX2RhdGFfc291cmNlXzEuR2VvSlNPTkRhdGFTb3VyY2U7XG52YXIgcmVtb3RlX2RhdGFfc291cmNlXzEgPSByZXF1aXJlKFwiLi9yZW1vdGVfZGF0YV9zb3VyY2VcIik7XG5leHBvcnRzLlJlbW90ZURhdGFTb3VyY2UgPSByZW1vdGVfZGF0YV9zb3VyY2VfMS5SZW1vdGVEYXRhU291cmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGNvbHVtbl9kYXRhX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vY29sdW1uX2RhdGFfc291cmNlXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5SZW1vdGVEYXRhU291cmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJlbW90ZURhdGFTb3VyY2UsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFJlbW90ZURhdGFTb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiBSZW1vdGVEYXRhU291cmNlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZW1vdGVEYXRhU291cmNlLnByb3RvdHlwZS50eXBlID0gJ1JlbW90ZURhdGFTb3VyY2UnO1xuICAgIFJlbW90ZURhdGFTb3VyY2UuZGVmaW5lKHtcbiAgICAgICAgZGF0YV91cmw6IFtwLlN0cmluZ10sXG4gICAgICAgIHBvbGxpbmdfaW50ZXJ2YWw6IFtwLk51bWJlcl1cbiAgICB9KTtcbiAgICByZXR1cm4gUmVtb3RlRGF0YVNvdXJjZTtcbn0pKGNvbHVtbl9kYXRhX3NvdXJjZV8xLkNvbHVtbkRhdGFTb3VyY2UpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY2xhbXAsIGxvZywgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBzbGljZSA9IFtdLnNsaWNlO1xudmFyIGNvbnRpbnVvdXNfdGlja2VyXzEgPSByZXF1aXJlKFwiLi9jb250aW51b3VzX3RpY2tlclwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbmNsYW1wID0gZnVuY3Rpb24gKHgsIG1pbl92YWwsIG1heF92YWwpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluX3ZhbCwgTWF0aC5taW4obWF4X3ZhbCwgeCkpO1xufTtcbmxvZyA9IGZ1bmN0aW9uICh4LCBiYXNlKSB7XG4gICAgaWYgKGJhc2UgPT0gbnVsbCkge1xuICAgICAgICBiYXNlID0gTWF0aC5FO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLmxvZyhiYXNlKTtcbn07XG5leHBvcnRzLkFkYXB0aXZlVGlja2VyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFkYXB0aXZlVGlja2VyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBZGFwdGl2ZVRpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIEFkYXB0aXZlVGlja2VyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBZGFwdGl2ZVRpY2tlci5wcm90b3R5cGUudHlwZSA9ICdBZGFwdGl2ZVRpY2tlcic7XG4gICAgQWRhcHRpdmVUaWNrZXIuZGVmaW5lKHtcbiAgICAgICAgYmFzZTogW3AuTnVtYmVyLCAxMC4wXSxcbiAgICAgICAgbWFudGlzc2FzOiBbcC5BcnJheSwgWzEsIDIsIDVdXSxcbiAgICAgICAgbWluX2ludGVydmFsOiBbcC5OdW1iZXIsIDAuMF0sXG4gICAgICAgIG1heF9pbnRlcnZhbDogW3AuTnVtYmVyXVxuICAgIH0pO1xuICAgIEFkYXB0aXZlVGlja2VyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBwcmVmaXhfbWFudGlzc2EsIHN1ZmZpeF9tYW50aXNzYTtcbiAgICAgICAgQWRhcHRpdmVUaWNrZXIuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHByZWZpeF9tYW50aXNzYSA9IGFycmF5XzEubnRoKHRoaXMubWFudGlzc2FzLCAtMSkgLyB0aGlzLmJhc2U7XG4gICAgICAgIHN1ZmZpeF9tYW50aXNzYSA9IGFycmF5XzEubnRoKHRoaXMubWFudGlzc2FzLCAwKSAqIHRoaXMuYmFzZTtcbiAgICAgICAgdGhpcy5leHRlbmRlZF9tYW50aXNzYXMgPSBbcHJlZml4X21hbnRpc3NhXS5jb25jYXQoc2xpY2UuY2FsbCh0aGlzLm1hbnRpc3NhcyksIFtzdWZmaXhfbWFudGlzc2FdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZV9mYWN0b3IgPSB0aGlzLmdldF9taW5faW50ZXJ2YWwoKSA9PT0gMC4wID8gMS4wIDogdGhpcy5nZXRfbWluX2ludGVydmFsKCk7XG4gICAgfTtcbiAgICBBZGFwdGl2ZVRpY2tlci5wcm90b3R5cGUuZ2V0X2ludGVydmFsID0gZnVuY3Rpb24gKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGRlc2lyZWRfbl90aWNrcykge1xuICAgICAgICB2YXIgYmVzdF9tYW50aXNzYSwgY2FuZGlkYXRlX21hbnRpc3NhcywgZGF0YV9yYW5nZSwgZXJyb3JzLCBpZGVhbF9pbnRlcnZhbCwgaWRlYWxfbWFnbml0dWRlLCBpZGVhbF9tYW50aXNzYSwgaW50ZXJ2YWwsIGludGVydmFsX2V4cG9uZW50O1xuICAgICAgICBkYXRhX3JhbmdlID0gZGF0YV9oaWdoIC0gZGF0YV9sb3c7XG4gICAgICAgIGlkZWFsX2ludGVydmFsID0gdGhpcy5nZXRfaWRlYWxfaW50ZXJ2YWwoZGF0YV9sb3csIGRhdGFfaGlnaCwgZGVzaXJlZF9uX3RpY2tzKTtcbiAgICAgICAgaW50ZXJ2YWxfZXhwb25lbnQgPSBNYXRoLmZsb29yKGxvZyhpZGVhbF9pbnRlcnZhbCAvIHRoaXMuYmFzZV9mYWN0b3IsIHRoaXMuYmFzZSkpO1xuICAgICAgICBpZGVhbF9tYWduaXR1ZGUgPSBNYXRoLnBvdyh0aGlzLmJhc2UsIGludGVydmFsX2V4cG9uZW50KSAqIHRoaXMuYmFzZV9mYWN0b3I7XG4gICAgICAgIGlkZWFsX21hbnRpc3NhID0gaWRlYWxfaW50ZXJ2YWwgLyBpZGVhbF9tYWduaXR1ZGU7XG4gICAgICAgIGNhbmRpZGF0ZV9tYW50aXNzYXMgPSB0aGlzLmV4dGVuZGVkX21hbnRpc3NhcztcbiAgICAgICAgZXJyb3JzID0gY2FuZGlkYXRlX21hbnRpc3Nhcy5tYXAoZnVuY3Rpb24gKG1hbnRpc3NhKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoZGVzaXJlZF9uX3RpY2tzIC0gKGRhdGFfcmFuZ2UgLyAobWFudGlzc2EgKiBpZGVhbF9tYWduaXR1ZGUpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBiZXN0X21hbnRpc3NhID0gY2FuZGlkYXRlX21hbnRpc3Nhc1thcnJheV8xLmFyZ21pbihlcnJvcnMpXTtcbiAgICAgICAgaW50ZXJ2YWwgPSBiZXN0X21hbnRpc3NhICogaWRlYWxfbWFnbml0dWRlO1xuICAgICAgICByZXR1cm4gY2xhbXAoaW50ZXJ2YWwsIHRoaXMuZ2V0X21pbl9pbnRlcnZhbCgpLCB0aGlzLmdldF9tYXhfaW50ZXJ2YWwoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQWRhcHRpdmVUaWNrZXI7XG59KShjb250aW51b3VzX3RpY2tlcl8xLkNvbnRpbnVvdXNUaWNrZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFkYXB0aXZlX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vYWRhcHRpdmVfdGlja2VyXCIpO1xuZXhwb3J0cy5CYXNpY1RpY2tlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChCYXNpY1RpY2tlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQmFzaWNUaWNrZXIoKSB7XG4gICAgICAgIHJldHVybiBCYXNpY1RpY2tlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQmFzaWNUaWNrZXIucHJvdG90eXBlLnR5cGUgPSAnQmFzaWNUaWNrZXInO1xuICAgIHJldHVybiBCYXNpY1RpY2tlcjtcbn0pKGFkYXB0aXZlX3RpY2tlcl8xLkFkYXB0aXZlVGlja2VyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0aWNrZXJfMSA9IHJlcXVpcmUoXCIuL3RpY2tlclwiKTtcbmV4cG9ydHMuQ2F0ZWdvcmljYWxUaWNrZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ2F0ZWdvcmljYWxUaWNrZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENhdGVnb3JpY2FsVGlja2VyKCkge1xuICAgICAgICByZXR1cm4gQ2F0ZWdvcmljYWxUaWNrZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhdGVnb3JpY2FsVGlja2VyLnByb3RvdHlwZS50eXBlID0gJ0NhdGVnb3JpY2FsVGlja2VyJztcbiAgICBDYXRlZ29yaWNhbFRpY2tlci5wcm90b3R5cGUuZ2V0X3RpY2tzID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHJhbmdlLCBjcm9zc19sb2MsIGFyZykge1xuICAgICAgICB2YXIgZGVzaXJlZF9uX3RpY2tzLCBmYWN0b3JzLCBpLCBpaSwgaiwgbWFqb3JzLCByZWY7XG4gICAgICAgIGRlc2lyZWRfbl90aWNrcyA9IGFyZy5kZXNpcmVkX25fdGlja3M7XG4gICAgICAgIG1ham9ycyA9IFtdO1xuICAgICAgICBmYWN0b3JzID0gcmFuZ2UuZmFjdG9ycztcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGZhY3RvcnMubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIGlpID0gaSArIHJhbmdlLm9mZnNldDtcbiAgICAgICAgICAgIGlmICgoaWkgKyAxKSA+IHN0YXJ0ICYmIChpaSArIDEpIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgbWFqb3JzLnB1c2goZmFjdG9yc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwibWFqb3JcIjogbWFqb3JzLFxuICAgICAgICAgICAgXCJtaW5vclwiOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENhdGVnb3JpY2FsVGlja2VyO1xufSkodGlja2VyXzEuVGlja2VyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBjb250aW51b3VzX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vY29udGludW91c190aWNrZXJcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL29iamVjdFwiKTtcbmV4cG9ydHMuQ29tcG9zaXRlVGlja2VyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENvbXBvc2l0ZVRpY2tlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ29tcG9zaXRlVGlja2VyKCkge1xuICAgICAgICByZXR1cm4gQ29tcG9zaXRlVGlja2VyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDb21wb3NpdGVUaWNrZXIucHJvdG90eXBlLnR5cGUgPSAnQ29tcG9zaXRlVGlja2VyJztcbiAgICBDb21wb3NpdGVUaWNrZXIuZGVmaW5lKHtcbiAgICAgICAgdGlja2VyczogW3AuQXJyYXksIFtdXVxuICAgIH0pO1xuICAgIENvbXBvc2l0ZVRpY2tlci5nZXR0ZXJzKHtcbiAgICAgICAgbWluX2ludGVydmFsczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVmLCByZXN1bHRzLCB0aWNrZXI7XG4gICAgICAgICAgICByZWYgPSB0aGlzLnRpY2tlcnM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aWNrZXIgPSByZWZbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRpY2tlci5nZXRfbWluX2ludGVydmFsKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0sXG4gICAgICAgIG1heF9pbnRlcnZhbHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpLCBsZW4sIHJlZiwgcmVzdWx0cywgdGlja2VyO1xuICAgICAgICAgICAgcmVmID0gdGhpcy50aWNrZXJzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGlja2VyID0gcmVmW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aWNrZXIuZ2V0X21heF9pbnRlcnZhbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9LFxuICAgICAgICBtaW5faW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbl9pbnRlcnZhbHNbMF07XG4gICAgICAgIH0sXG4gICAgICAgIG1heF9pbnRlcnZhbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4X2ludGVydmFsc1swXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIENvbXBvc2l0ZVRpY2tlci5wcm90b3R5cGUuZ2V0X2Jlc3RfdGlja2VyID0gZnVuY3Rpb24gKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGRlc2lyZWRfbl90aWNrcykge1xuICAgICAgICB2YXIgYmVzdF9pbmRleCwgYmVzdF90aWNrZXIsIGJlc3RfdGlja2VyX25keCwgZGF0YV9yYW5nZSwgZXJyb3JzLCBpZGVhbF9pbnRlcnZhbCwgaW50ZXJ2YWxzLCB0aWNrZXJfbmR4cztcbiAgICAgICAgZGF0YV9yYW5nZSA9IGRhdGFfaGlnaCAtIGRhdGFfbG93O1xuICAgICAgICBpZGVhbF9pbnRlcnZhbCA9IHRoaXMuZ2V0X2lkZWFsX2ludGVydmFsKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGRlc2lyZWRfbl90aWNrcyk7XG4gICAgICAgIHRpY2tlcl9uZHhzID0gW2FycmF5XzEuc29ydGVkSW5kZXgodGhpcy5taW5faW50ZXJ2YWxzLCBpZGVhbF9pbnRlcnZhbCkgLSAxLCBhcnJheV8xLnNvcnRlZEluZGV4KHRoaXMubWF4X2ludGVydmFscywgaWRlYWxfaW50ZXJ2YWwpXTtcbiAgICAgICAgaW50ZXJ2YWxzID0gW3RoaXMubWluX2ludGVydmFsc1t0aWNrZXJfbmR4c1swXV0sIHRoaXMubWF4X2ludGVydmFsc1t0aWNrZXJfbmR4c1sxXV1dO1xuICAgICAgICBlcnJvcnMgPSBpbnRlcnZhbHMubWFwKGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGRlc2lyZWRfbl90aWNrcyAtIChkYXRhX3JhbmdlIC8gaW50ZXJ2YWwpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvYmplY3RfMS5pc0VtcHR5KGVycm9ycy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAhaXNOYU4oZSk7XG4gICAgICAgIH0pKSkge1xuICAgICAgICAgICAgYmVzdF90aWNrZXIgPSB0aGlzLnRpY2tlcnNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiZXN0X2luZGV4ID0gYXJyYXlfMS5hcmdtaW4oZXJyb3JzKTtcbiAgICAgICAgICAgIGJlc3RfdGlja2VyX25keCA9IHRpY2tlcl9uZHhzW2Jlc3RfaW5kZXhdO1xuICAgICAgICAgICAgYmVzdF90aWNrZXIgPSB0aGlzLnRpY2tlcnNbYmVzdF90aWNrZXJfbmR4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdF90aWNrZXI7XG4gICAgfTtcbiAgICBDb21wb3NpdGVUaWNrZXIucHJvdG90eXBlLmdldF9pbnRlcnZhbCA9IGZ1bmN0aW9uIChkYXRhX2xvdywgZGF0YV9oaWdoLCBkZXNpcmVkX25fdGlja3MpIHtcbiAgICAgICAgdmFyIGJlc3RfdGlja2VyO1xuICAgICAgICBiZXN0X3RpY2tlciA9IHRoaXMuZ2V0X2Jlc3RfdGlja2VyKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGRlc2lyZWRfbl90aWNrcyk7XG4gICAgICAgIHJldHVybiBiZXN0X3RpY2tlci5nZXRfaW50ZXJ2YWwoZGF0YV9sb3csIGRhdGFfaGlnaCwgZGVzaXJlZF9uX3RpY2tzKTtcbiAgICB9O1xuICAgIENvbXBvc2l0ZVRpY2tlci5wcm90b3R5cGUuZ2V0X3RpY2tzX25vX2RlZmF1bHRzID0gZnVuY3Rpb24gKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGNyb3NzX2xvYywgZGVzaXJlZF9uX3RpY2tzKSB7XG4gICAgICAgIHZhciBiZXN0X3RpY2tlciwgdGlja3M7XG4gICAgICAgIGJlc3RfdGlja2VyID0gdGhpcy5nZXRfYmVzdF90aWNrZXIoZGF0YV9sb3csIGRhdGFfaGlnaCwgZGVzaXJlZF9uX3RpY2tzKTtcbiAgICAgICAgdGlja3MgPSBiZXN0X3RpY2tlci5nZXRfdGlja3Nfbm9fZGVmYXVsdHMoZGF0YV9sb3csIGRhdGFfaGlnaCwgY3Jvc3NfbG9jLCBkZXNpcmVkX25fdGlja3MpO1xuICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcG9zaXRlVGlja2VyO1xufSkoY29udGludW91c190aWNrZXJfMS5Db250aW51b3VzVGlja2VyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0aWNrZXJfMSA9IHJlcXVpcmUoXCIuL3RpY2tlclwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuQ29udGludW91c1RpY2tlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDb250aW51b3VzVGlja2VyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDb250aW51b3VzVGlja2VyKCkge1xuICAgICAgICByZXR1cm4gQ29udGludW91c1RpY2tlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ29udGludW91c1RpY2tlci5wcm90b3R5cGUudHlwZSA9ICdDb250aW51b3VzVGlja2VyJztcbiAgICBDb250aW51b3VzVGlja2VyLmRlZmluZSh7XG4gICAgICAgIG51bV9taW5vcl90aWNrczogW3AuTnVtYmVyLCA1XSxcbiAgICAgICAgZGVzaXJlZF9udW1fdGlja3M6IFtwLk51bWJlciwgNl1cbiAgICB9KTtcbiAgICBDb250aW51b3VzVGlja2VyLnByb3RvdHlwZS5nZXRfaW50ZXJ2YWwgPSB2b2lkIDA7XG4gICAgQ29udGludW91c1RpY2tlci5wcm90b3R5cGUuZ2V0X21pbl9pbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluX2ludGVydmFsO1xuICAgIH07XG4gICAgQ29udGludW91c1RpY2tlci5wcm90b3R5cGUuZ2V0X21heF9pbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLm1heF9pbnRlcnZhbCkgIT0gbnVsbCA/IHJlZiA6IDJlMzA4O1xuICAgIH07XG4gICAgQ29udGludW91c1RpY2tlci5wcm90b3R5cGUuZ2V0X2lkZWFsX2ludGVydmFsID0gZnVuY3Rpb24gKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGRlc2lyZWRfbl90aWNrcykge1xuICAgICAgICB2YXIgZGF0YV9yYW5nZTtcbiAgICAgICAgZGF0YV9yYW5nZSA9IGRhdGFfaGlnaCAtIGRhdGFfbG93O1xuICAgICAgICByZXR1cm4gZGF0YV9yYW5nZSAvIGRlc2lyZWRfbl90aWNrcztcbiAgICB9O1xuICAgIHJldHVybiBDb250aW51b3VzVGlja2VyO1xufSkodGlja2VyXzEuVGlja2VyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE9ORV9IT1VSLCBPTkVfTUlMTEksIE9ORV9NSU5VVEUsIE9ORV9NT05USCwgT05FX1NFQ09ORCwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIGFkYXB0aXZlX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vYWRhcHRpdmVfdGlja2VyXCIpO1xudmFyIGNvbXBvc2l0ZV90aWNrZXJfMSA9IHJlcXVpcmUoXCIuL2NvbXBvc2l0ZV90aWNrZXJcIik7XG52YXIgZGF5c190aWNrZXJfMSA9IHJlcXVpcmUoXCIuL2RheXNfdGlja2VyXCIpO1xudmFyIG1vbnRoc190aWNrZXJfMSA9IHJlcXVpcmUoXCIuL21vbnRoc190aWNrZXJcIik7XG52YXIgeWVhcnNfdGlja2VyXzEgPSByZXF1aXJlKFwiLi95ZWFyc190aWNrZXJcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5PTkVfTUlMTEkgPSB1dGlsLk9ORV9NSUxMSTtcbk9ORV9TRUNPTkQgPSB1dGlsLk9ORV9TRUNPTkQ7XG5PTkVfTUlOVVRFID0gdXRpbC5PTkVfTUlOVVRFO1xuT05FX0hPVVIgPSB1dGlsLk9ORV9IT1VSO1xuT05FX01PTlRIID0gdXRpbC5PTkVfTU9OVEg7XG5leHBvcnRzLkRhdGV0aW1lVGlja2VyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERhdGV0aW1lVGlja2VyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBEYXRldGltZVRpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIERhdGV0aW1lVGlja2VyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEYXRldGltZVRpY2tlci5wcm90b3R5cGUudHlwZSA9ICdEYXRldGltZVRpY2tlcic7XG4gICAgRGF0ZXRpbWVUaWNrZXIub3ZlcnJpZGUoe1xuICAgICAgICBudW1fbWlub3JfdGlja3M6IDAsXG4gICAgICAgIHRpY2tlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbmV3IGFkYXB0aXZlX3RpY2tlcl8xLkFkYXB0aXZlVGlja2VyKHtcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2FzOiBbMSwgMiwgNV0sXG4gICAgICAgICAgICAgICAgICAgIGJhc2U6IDEwLFxuICAgICAgICAgICAgICAgICAgICBtaW5faW50ZXJ2YWw6IDAsXG4gICAgICAgICAgICAgICAgICAgIG1heF9pbnRlcnZhbDogNTAwICogT05FX01JTExJLFxuICAgICAgICAgICAgICAgICAgICBudW1fbWlub3JfdGlja3M6IDBcbiAgICAgICAgICAgICAgICB9KSwgbmV3IGFkYXB0aXZlX3RpY2tlcl8xLkFkYXB0aXZlVGlja2VyKHtcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2FzOiBbMSwgMiwgNSwgMTAsIDE1LCAyMCwgMzBdLFxuICAgICAgICAgICAgICAgICAgICBiYXNlOiA2MCxcbiAgICAgICAgICAgICAgICAgICAgbWluX2ludGVydmFsOiBPTkVfU0VDT05ELFxuICAgICAgICAgICAgICAgICAgICBtYXhfaW50ZXJ2YWw6IDMwICogT05FX01JTlVURSxcbiAgICAgICAgICAgICAgICAgICAgbnVtX21pbm9yX3RpY2tzOiAwXG4gICAgICAgICAgICAgICAgfSksIG5ldyBhZGFwdGl2ZV90aWNrZXJfMS5BZGFwdGl2ZVRpY2tlcih7XG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhczogWzEsIDIsIDQsIDYsIDgsIDEyXSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogMjQuMCxcbiAgICAgICAgICAgICAgICAgICAgbWluX2ludGVydmFsOiBPTkVfSE9VUixcbiAgICAgICAgICAgICAgICAgICAgbWF4X2ludGVydmFsOiAxMiAqIE9ORV9IT1VSLFxuICAgICAgICAgICAgICAgICAgICBudW1fbWlub3JfdGlja3M6IDBcbiAgICAgICAgICAgICAgICB9KSwgbmV3IGRheXNfdGlja2VyXzEuRGF5c1RpY2tlcih7XG4gICAgICAgICAgICAgICAgICAgIGRheXM6IGFycmF5XzEucmFuZ2UoMSwgMzIpXG4gICAgICAgICAgICAgICAgfSksIG5ldyBkYXlzX3RpY2tlcl8xLkRheXNUaWNrZXIoe1xuICAgICAgICAgICAgICAgICAgICBkYXlzOiBhcnJheV8xLnJhbmdlKDEsIDMxLCAzKVxuICAgICAgICAgICAgICAgIH0pLCBuZXcgZGF5c190aWNrZXJfMS5EYXlzVGlja2VyKHtcbiAgICAgICAgICAgICAgICAgICAgZGF5czogWzEsIDgsIDE1LCAyMl1cbiAgICAgICAgICAgICAgICB9KSwgbmV3IGRheXNfdGlja2VyXzEuRGF5c1RpY2tlcih7XG4gICAgICAgICAgICAgICAgICAgIGRheXM6IFsxLCAxNV1cbiAgICAgICAgICAgICAgICB9KSwgbmV3IG1vbnRoc190aWNrZXJfMS5Nb250aHNUaWNrZXIoe1xuICAgICAgICAgICAgICAgICAgICBtb250aHM6IGFycmF5XzEucmFuZ2UoMCwgMTIsIDEpXG4gICAgICAgICAgICAgICAgfSksIG5ldyBtb250aHNfdGlja2VyXzEuTW9udGhzVGlja2VyKHtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhzOiBhcnJheV8xLnJhbmdlKDAsIDEyLCAyKVxuICAgICAgICAgICAgICAgIH0pLCBuZXcgbW9udGhzX3RpY2tlcl8xLk1vbnRoc1RpY2tlcih7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoczogYXJyYXlfMS5yYW5nZSgwLCAxMiwgNClcbiAgICAgICAgICAgICAgICB9KSwgbmV3IG1vbnRoc190aWNrZXJfMS5Nb250aHNUaWNrZXIoe1xuICAgICAgICAgICAgICAgICAgICBtb250aHM6IGFycmF5XzEucmFuZ2UoMCwgMTIsIDYpXG4gICAgICAgICAgICAgICAgfSksIG5ldyB5ZWFyc190aWNrZXJfMS5ZZWFyc1RpY2tlcih7fSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gRGF0ZXRpbWVUaWNrZXI7XG59KShjb21wb3NpdGVfdGlja2VyXzEuQ29tcG9zaXRlVGlja2VyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE9ORV9EQVksIGNvcHlfZGF0ZSwgZGF0ZV9yYW5nZV9ieV9tb250aCwgbGFzdF9tb250aF9ub19sYXRlcl90aGFuLCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgc2luZ2xlX2ludGVydmFsX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vc2luZ2xlX2ludGVydmFsX3RpY2tlclwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbmNvcHlfZGF0ZSA9IHV0aWwuY29weV9kYXRlO1xubGFzdF9tb250aF9ub19sYXRlcl90aGFuID0gdXRpbC5sYXN0X21vbnRoX25vX2xhdGVyX3RoYW47XG5PTkVfREFZID0gdXRpbC5PTkVfREFZO1xuZGF0ZV9yYW5nZV9ieV9tb250aCA9IGZ1bmN0aW9uIChzdGFydF90aW1lLCBlbmRfdGltZSkge1xuICAgIHZhciBkYXRlLCBkYXRlcywgZW5kX2RhdGUsIHByZXZfZW5kX2RhdGUsIHN0YXJ0X2RhdGU7XG4gICAgc3RhcnRfZGF0ZSA9IGxhc3RfbW9udGhfbm9fbGF0ZXJfdGhhbihuZXcgRGF0ZShzdGFydF90aW1lKSk7XG4gICAgZW5kX2RhdGUgPSBsYXN0X21vbnRoX25vX2xhdGVyX3RoYW4obmV3IERhdGUoZW5kX3RpbWUpKTtcbiAgICBwcmV2X2VuZF9kYXRlID0gY29weV9kYXRlKGVuZF9kYXRlKTtcbiAgICBlbmRfZGF0ZS5zZXRVVENNb250aChlbmRfZGF0ZS5nZXRVVENNb250aCgpICsgMSk7XG4gICAgZGF0ZXMgPSBbXTtcbiAgICBkYXRlID0gc3RhcnRfZGF0ZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBkYXRlcy5wdXNoKGNvcHlfZGF0ZShkYXRlKSk7XG4gICAgICAgIGRhdGUuc2V0VVRDTW9udGgoZGF0ZS5nZXRVVENNb250aCgpICsgMSk7XG4gICAgICAgIGlmIChkYXRlID4gZW5kX2RhdGUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRlcztcbn07XG5leHBvcnRzLkRheXNUaWNrZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRGF5c1RpY2tlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRGF5c1RpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIERheXNUaWNrZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERheXNUaWNrZXIucHJvdG90eXBlLnR5cGUgPSAnRGF5c1RpY2tlcic7XG4gICAgRGF5c1RpY2tlci5kZWZpbmUoe1xuICAgICAgICBkYXlzOiBbcC5BcnJheSwgW11dXG4gICAgfSk7XG4gICAgRGF5c1RpY2tlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICB2YXIgZGF5cywgaW50ZXJ2YWw7XG4gICAgICAgIGF0dHJzLm51bV9taW5vcl90aWNrcyA9IDA7XG4gICAgICAgIERheXNUaWNrZXIuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIGRheXMgPSB0aGlzLmRheXM7XG4gICAgICAgIGludGVydmFsID0gZGF5cy5sZW5ndGggPiAxID8gKGRheXNbMV0gLSBkYXlzWzBdKSAqIE9ORV9EQVkgOiAzMSAqIE9ORV9EQVk7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgfTtcbiAgICBEYXlzVGlja2VyLnByb3RvdHlwZS5nZXRfdGlja3Nfbm9fZGVmYXVsdHMgPSBmdW5jdGlvbiAoZGF0YV9sb3csIGRhdGFfaGlnaCwgY3Jvc3NfbG9jLCBkZXNpcmVkX25fdGlja3MpIHtcbiAgICAgICAgdmFyIGFsbF90aWNrcywgZGF0ZSwgZGF5X2RhdGUsIGRheV9kYXRlcywgZGF5cywgZGF5c19vZl9tb250aCwgaW50ZXJ2YWwsIG1vbnRoX2RhdGVzLCB0aWNrc19pbl9yYW5nZTtcbiAgICAgICAgbW9udGhfZGF0ZXMgPSBkYXRlX3JhbmdlX2J5X21vbnRoKGRhdGFfbG93LCBkYXRhX2hpZ2gpO1xuICAgICAgICBkYXlzID0gdGhpcy5kYXlzO1xuICAgICAgICBkYXlzX29mX21vbnRoID0gKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb250aF9kYXRlLCBpbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlcywgZGF5LCBkYXlfZGF0ZSwgZnV0dXJlX2RhdGUsIGksIGxlbjtcbiAgICAgICAgICAgICAgICBkYXRlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRheXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5ID0gZGF5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZGF5X2RhdGUgPSBjb3B5X2RhdGUobW9udGhfZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGRheV9kYXRlLnNldFVUQ0RhdGUoZGF5KTtcbiAgICAgICAgICAgICAgICAgICAgZnV0dXJlX2RhdGUgPSBuZXcgRGF0ZShkYXlfZGF0ZS5nZXRUaW1lKCkgKyAoaW50ZXJ2YWwgLyAyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdXR1cmVfZGF0ZS5nZXRVVENNb250aCgpID09PSBtb250aF9kYXRlLmdldFVUQ01vbnRoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVzLnB1c2goZGF5X2RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpO1xuICAgICAgICBpbnRlcnZhbCA9IHRoaXMuaW50ZXJ2YWw7XG4gICAgICAgIGRheV9kYXRlcyA9IGFycmF5XzEuY29uY2F0KChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaSwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbW9udGhfZGF0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbW9udGhfZGF0ZXNbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGRheXNfb2ZfbW9udGgoZGF0ZSwgaW50ZXJ2YWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpKTtcbiAgICAgICAgYWxsX3RpY2tzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkYXlfZGF0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkYXlfZGF0ZSA9IGRheV9kYXRlc1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZGF5X2RhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpO1xuICAgICAgICB0aWNrc19pbl9yYW5nZSA9IGFsbF90aWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRpY2spIHtcbiAgICAgICAgICAgIHJldHVybiAoZGF0YV9sb3cgPD0gdGljayAmJiB0aWNrIDw9IGRhdGFfaGlnaCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJtYWpvclwiOiB0aWNrc19pbl9yYW5nZSxcbiAgICAgICAgICAgIFwibWlub3JcIjogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlzVGlja2VyO1xufSkoc2luZ2xlX2ludGVydmFsX3RpY2tlcl8xLlNpbmdsZUludGVydmFsVGlja2VyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBjb250aW51b3VzX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vY29udGludW91c190aWNrZXJcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkZpeGVkVGlja2VyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEZpeGVkVGlja2VyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBGaXhlZFRpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIEZpeGVkVGlja2VyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBGaXhlZFRpY2tlci5wcm90b3R5cGUudHlwZSA9ICdGaXhlZFRpY2tlcic7XG4gICAgRml4ZWRUaWNrZXIuZGVmaW5lKHtcbiAgICAgICAgdGlja3M6IFtwLkFycmF5LCBbXV1cbiAgICB9KTtcbiAgICBGaXhlZFRpY2tlci5wcm90b3R5cGUuZ2V0X3RpY2tzX25vX2RlZmF1bHRzID0gZnVuY3Rpb24gKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGNyb3NzX2xvYywgZGVzaXJlZF9uX3RpY2tzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYWpvcjogdGhpcy50aWNrcyxcbiAgICAgICAgICAgIG1pbm9yOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEZpeGVkVGlja2VyO1xufSkoY29udGludW91c190aWNrZXJfMS5Db250aW51b3VzVGlja2VyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFkYXB0aXZlX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vYWRhcHRpdmVfdGlja2VyXCIpO1xuZXhwb3J0cy5BZGFwdGl2ZVRpY2tlciA9IGFkYXB0aXZlX3RpY2tlcl8xLkFkYXB0aXZlVGlja2VyO1xudmFyIGJhc2ljX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vYmFzaWNfdGlja2VyXCIpO1xuZXhwb3J0cy5CYXNpY1RpY2tlciA9IGJhc2ljX3RpY2tlcl8xLkJhc2ljVGlja2VyO1xudmFyIGNhdGVnb3JpY2FsX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vY2F0ZWdvcmljYWxfdGlja2VyXCIpO1xuZXhwb3J0cy5DYXRlZ29yaWNhbFRpY2tlciA9IGNhdGVnb3JpY2FsX3RpY2tlcl8xLkNhdGVnb3JpY2FsVGlja2VyO1xudmFyIGNvbXBvc2l0ZV90aWNrZXJfMSA9IHJlcXVpcmUoXCIuL2NvbXBvc2l0ZV90aWNrZXJcIik7XG5leHBvcnRzLkNvbXBvc2l0ZVRpY2tlciA9IGNvbXBvc2l0ZV90aWNrZXJfMS5Db21wb3NpdGVUaWNrZXI7XG52YXIgY29udGludW91c190aWNrZXJfMSA9IHJlcXVpcmUoXCIuL2NvbnRpbnVvdXNfdGlja2VyXCIpO1xuZXhwb3J0cy5Db250aW51b3VzVGlja2VyID0gY29udGludW91c190aWNrZXJfMS5Db250aW51b3VzVGlja2VyO1xudmFyIGRhdGV0aW1lX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vZGF0ZXRpbWVfdGlja2VyXCIpO1xuZXhwb3J0cy5EYXRldGltZVRpY2tlciA9IGRhdGV0aW1lX3RpY2tlcl8xLkRhdGV0aW1lVGlja2VyO1xudmFyIGRheXNfdGlja2VyXzEgPSByZXF1aXJlKFwiLi9kYXlzX3RpY2tlclwiKTtcbmV4cG9ydHMuRGF5c1RpY2tlciA9IGRheXNfdGlja2VyXzEuRGF5c1RpY2tlcjtcbnZhciBmaXhlZF90aWNrZXJfMSA9IHJlcXVpcmUoXCIuL2ZpeGVkX3RpY2tlclwiKTtcbmV4cG9ydHMuRml4ZWRUaWNrZXIgPSBmaXhlZF90aWNrZXJfMS5GaXhlZFRpY2tlcjtcbnZhciBsb2dfdGlja2VyXzEgPSByZXF1aXJlKFwiLi9sb2dfdGlja2VyXCIpO1xuZXhwb3J0cy5Mb2dUaWNrZXIgPSBsb2dfdGlja2VyXzEuTG9nVGlja2VyO1xudmFyIG1lcmNhdG9yX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vbWVyY2F0b3JfdGlja2VyXCIpO1xuZXhwb3J0cy5NZXJjYXRvclRpY2tlciA9IG1lcmNhdG9yX3RpY2tlcl8xLk1lcmNhdG9yVGlja2VyO1xudmFyIG1vbnRoc190aWNrZXJfMSA9IHJlcXVpcmUoXCIuL21vbnRoc190aWNrZXJcIik7XG5leHBvcnRzLk1vbnRoc1RpY2tlciA9IG1vbnRoc190aWNrZXJfMS5Nb250aHNUaWNrZXI7XG52YXIgc2luZ2xlX2ludGVydmFsX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vc2luZ2xlX2ludGVydmFsX3RpY2tlclwiKTtcbmV4cG9ydHMuU2luZ2xlSW50ZXJ2YWxUaWNrZXIgPSBzaW5nbGVfaW50ZXJ2YWxfdGlja2VyXzEuU2luZ2xlSW50ZXJ2YWxUaWNrZXI7XG52YXIgdGlja2VyXzEgPSByZXF1aXJlKFwiLi90aWNrZXJcIik7XG5leHBvcnRzLlRpY2tlciA9IHRpY2tlcl8xLlRpY2tlcjtcbnZhciB5ZWFyc190aWNrZXJfMSA9IHJlcXVpcmUoXCIuL3llYXJzX3RpY2tlclwiKTtcbmV4cG9ydHMuWWVhcnNUaWNrZXIgPSB5ZWFyc190aWNrZXJfMS5ZZWFyc1RpY2tlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbnZhciBhZGFwdGl2ZV90aWNrZXJfMSA9IHJlcXVpcmUoXCIuL2FkYXB0aXZlX3RpY2tlclwiKTtcbmV4cG9ydHMuTG9nVGlja2VyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExvZ1RpY2tlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTG9nVGlja2VyKCkge1xuICAgICAgICByZXR1cm4gTG9nVGlja2VyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMb2dUaWNrZXIucHJvdG90eXBlLnR5cGUgPSAnTG9nVGlja2VyJztcbiAgICBMb2dUaWNrZXIub3ZlcnJpZGUoe1xuICAgICAgICBtYW50aXNzYXM6IFsxLCA1XVxuICAgIH0pO1xuICAgIExvZ1RpY2tlci5wcm90b3R5cGUuZ2V0X3RpY2tzX25vX2RlZmF1bHRzID0gZnVuY3Rpb24gKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGNyb3NzX2xvYywgZGVzaXJlZF9uX3RpY2tzKSB7XG4gICAgICAgIHZhciBiYXNlLCBlbmRfZmFjdG9yLCBlbmRsb2csIGZhY3RvciwgZmFjdG9ycywgaSwgaW50ZXJ2YWwsIGosIGssIGwsIGxlbiwgbGVuMSwgbGVuMiwgbGVuMywgbGVuNCwgbGVuNSwgbG9nX2hpZ2gsIGxvZ19pbnRlcnZhbCwgbG9nX2xvdywgbSwgbWlub3JfaW50ZXJ2YWwsIG1pbm9yX29mZnNldHMsIG1pbm9yX3RpY2tzLCBuLCBudW1fbWlub3JfdGlja3MsIG8sIHJlZiwgc3RhcnRfZmFjdG9yLCBzdGFydGxvZywgdGljaywgdGlja3MsIHg7XG4gICAgICAgIG51bV9taW5vcl90aWNrcyA9IHRoaXMubnVtX21pbm9yX3RpY2tzO1xuICAgICAgICBtaW5vcl90aWNrcyA9IFtdO1xuICAgICAgICBiYXNlID0gdGhpcy5iYXNlO1xuICAgICAgICBsb2dfbG93ID0gTWF0aC5sb2coZGF0YV9sb3cpIC8gTWF0aC5sb2coYmFzZSk7XG4gICAgICAgIGxvZ19oaWdoID0gTWF0aC5sb2coZGF0YV9oaWdoKSAvIE1hdGgubG9nKGJhc2UpO1xuICAgICAgICBsb2dfaW50ZXJ2YWwgPSBsb2dfaGlnaCAtIGxvZ19sb3c7XG4gICAgICAgIGlmICghaXNGaW5pdGUobG9nX2ludGVydmFsKSkge1xuICAgICAgICAgICAgdGlja3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsb2dfaW50ZXJ2YWwgPCAyKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCA9IHRoaXMuZ2V0X2ludGVydmFsKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGRlc2lyZWRfbl90aWNrcyk7XG4gICAgICAgICAgICBzdGFydF9mYWN0b3IgPSBNYXRoLmZsb29yKGRhdGFfbG93IC8gaW50ZXJ2YWwpO1xuICAgICAgICAgICAgZW5kX2ZhY3RvciA9IE1hdGguY2VpbChkYXRhX2hpZ2ggLyBpbnRlcnZhbCk7XG4gICAgICAgICAgICBmYWN0b3JzID0gYXJyYXlfMS5yYW5nZShzdGFydF9mYWN0b3IsIGVuZF9mYWN0b3IgKyAxKTtcbiAgICAgICAgICAgIHRpY2tzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBmYWN0b3JzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhY3RvciA9IGZhY3RvcnNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWN0b3IgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmYWN0b3IgKiBpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgdGlja3MgPSB0aWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRpY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGRhdGFfbG93IDw9IHRpY2sgJiYgdGljayA8PSBkYXRhX2hpZ2gpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobnVtX21pbm9yX3RpY2tzID4gMCAmJiB0aWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWlub3JfaW50ZXJ2YWwgPSBpbnRlcnZhbCAvIG51bV9taW5vcl90aWNrcztcbiAgICAgICAgICAgICAgICBtaW5vcl9vZmZzZXRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGosIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gbnVtX21pbm9yX3RpY2tzOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChpICogbWlub3JfaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgcmVmID0gbWlub3Jfb2Zmc2V0cy5zbGljZSgxLCArbWlub3Jfb2Zmc2V0cy5sZW5ndGggKyAxIHx8IDllOSk7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSByZWZbal07XG4gICAgICAgICAgICAgICAgICAgIG1pbm9yX3RpY2tzLnB1c2godGlja3NbMF0gLSB4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuMSA9IHRpY2tzLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB0aWNrID0gdGlja3Nba107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobCA9IDAsIGxlbjIgPSBtaW5vcl9vZmZzZXRzLmxlbmd0aDsgbCA8IGxlbjI7IGwrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IG1pbm9yX29mZnNldHNbbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5vcl90aWNrcy5wdXNoKHRpY2sgKyB4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0bG9nID0gTWF0aC5jZWlsKGxvZ19sb3cgKiAwLjk5OTk5OSk7XG4gICAgICAgICAgICBlbmRsb2cgPSBNYXRoLmZsb29yKGxvZ19oaWdoICogMS4wMDAwMDEpO1xuICAgICAgICAgICAgaW50ZXJ2YWwgPSBNYXRoLmNlaWwoKGVuZGxvZyAtIHN0YXJ0bG9nKSAvIDkuMCk7XG4gICAgICAgICAgICB0aWNrcyA9IGFycmF5XzEucmFuZ2Uoc3RhcnRsb2csIGVuZGxvZyArIDEsIGludGVydmFsKTtcbiAgICAgICAgICAgIHRpY2tzID0gdGlja3MubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KGJhc2UsIGkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aWNrcyA9IHRpY2tzLmZpbHRlcihmdW5jdGlvbiAodGljaykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZGF0YV9sb3cgPD0gdGljayAmJiB0aWNrIDw9IGRhdGFfaGlnaCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChudW1fbWlub3JfdGlja3MgPiAwICYmIHRpY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtaW5vcl9pbnRlcnZhbCA9IE1hdGgucG93KGJhc2UsIGludGVydmFsKSAvIG51bV9taW5vcl90aWNrcztcbiAgICAgICAgICAgICAgICBtaW5vcl9vZmZzZXRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0sIHJlZjEsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gbSA9IDEsIHJlZjEgPSBudW1fbWlub3JfdGlja3M7IDEgPD0gcmVmMSA/IG0gPD0gcmVmMSA6IG0gPj0gcmVmMTsgaSA9IDEgPD0gcmVmMSA/ICsrbSA6IC0tbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGkgKiBtaW5vcl9pbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICBmb3IgKG0gPSAwLCBsZW4zID0gbWlub3Jfb2Zmc2V0cy5sZW5ndGg7IG0gPCBsZW4zOyBtKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IG1pbm9yX29mZnNldHNbbV07XG4gICAgICAgICAgICAgICAgICAgIG1pbm9yX3RpY2tzLnB1c2godGlja3NbMF0gLyB4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWlub3JfdGlja3MucHVzaCh0aWNrc1swXSk7XG4gICAgICAgICAgICAgICAgZm9yIChuID0gMCwgbGVuNCA9IHRpY2tzLmxlbmd0aDsgbiA8IGxlbjQ7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICB0aWNrID0gdGlja3Nbbl07XG4gICAgICAgICAgICAgICAgICAgIGZvciAobyA9IDAsIGxlbjUgPSBtaW5vcl9vZmZzZXRzLmxlbmd0aDsgbyA8IGxlbjU7IG8rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IG1pbm9yX29mZnNldHNbb107XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5vcl90aWNrcy5wdXNoKHRpY2sgKiB4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFqb3I6IHRpY2tzLFxuICAgICAgICAgICAgbWlub3I6IG1pbm9yX3RpY2tzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTG9nVGlja2VyO1xufSkoYWRhcHRpdmVfdGlja2VyXzEuQWRhcHRpdmVUaWNrZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGJhc2ljX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vYmFzaWNfdGlja2VyXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHByb2o0XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3Byb2o0XCIpO1xuZXhwb3J0cy5NZXJjYXRvclRpY2tlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChNZXJjYXRvclRpY2tlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTWVyY2F0b3JUaWNrZXIoKSB7XG4gICAgICAgIHJldHVybiBNZXJjYXRvclRpY2tlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWVyY2F0b3JUaWNrZXIucHJvdG90eXBlLnR5cGUgPSAnTWVyY2F0b3JUaWNrZXInO1xuICAgIE1lcmNhdG9yVGlja2VyLmRlZmluZSh7XG4gICAgICAgIGRpbWVuc2lvbjogW3AuTGF0TG9uXVxuICAgIH0pO1xuICAgIE1lcmNhdG9yVGlja2VyLnByb3RvdHlwZS5nZXRfdGlja3Nfbm9fZGVmYXVsdHMgPSBmdW5jdGlvbiAoZGF0YV9sb3csIGRhdGFfaGlnaCwgY3Jvc3NfbG9jLCBkZXNpcmVkX25fdGlja3MpIHtcbiAgICAgICAgdmFyIF8sIGksIGosIGssIGwsIGxhdCwgbGVuLCBsZW4xLCBsZW4yLCBsZW4zLCBsb24sIHByb2pfY3Jvc3NfbG9jLCBwcm9qX2hpZ2gsIHByb2pfbG93LCBwcm9qX3RpY2tzLCByZWYsIHJlZjEsIHJlZjEwLCByZWYxMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVmNSwgcmVmNiwgcmVmNywgcmVmOCwgcmVmOSwgdGljaywgdGlja3M7XG4gICAgICAgIGlmICh0aGlzLmRpbWVuc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXJjYXRvclRpY2tlci5kaW1lbnNpb24gbm90IGNvbmZpZ3VyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGltZW5zaW9uID09PSBcImxvblwiKSB7XG4gICAgICAgICAgICByZWYgPSBwcm9qNF8xLnByb2o0KHByb2o0XzEubWVyY2F0b3IpLmludmVyc2UoW2RhdGFfbG93LCBjcm9zc19sb2NdKSwgcHJval9sb3cgPSByZWZbMF0sIHByb2pfY3Jvc3NfbG9jID0gcmVmWzFdO1xuICAgICAgICAgICAgcmVmMSA9IHByb2o0XzEucHJvajQocHJvajRfMS5tZXJjYXRvcikuaW52ZXJzZShbZGF0YV9oaWdoLCBjcm9zc19sb2NdKSwgcHJval9oaWdoID0gcmVmMVswXSwgcHJval9jcm9zc19sb2MgPSByZWYxWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmMiA9IHByb2o0XzEucHJvajQocHJvajRfMS5tZXJjYXRvcikuaW52ZXJzZShbY3Jvc3NfbG9jLCBkYXRhX2xvd10pLCBwcm9qX2Nyb3NzX2xvYyA9IHJlZjJbMF0sIHByb2pfbG93ID0gcmVmMlsxXTtcbiAgICAgICAgICAgIHJlZjMgPSBwcm9qNF8xLnByb2o0KHByb2o0XzEubWVyY2F0b3IpLmludmVyc2UoW2Nyb3NzX2xvYywgZGF0YV9oaWdoXSksIHByb2pfY3Jvc3NfbG9jID0gcmVmM1swXSwgcHJval9oaWdoID0gcmVmM1sxXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9qX3RpY2tzID0gTWVyY2F0b3JUaWNrZXIuX19zdXBlcl9fLmdldF90aWNrc19ub19kZWZhdWx0cy5jYWxsKHRoaXMsIHByb2pfbG93LCBwcm9qX2hpZ2gsIGNyb3NzX2xvYywgZGVzaXJlZF9uX3RpY2tzKTtcbiAgICAgICAgdGlja3MgPSB7XG4gICAgICAgICAgICBtYWpvcjogW10sXG4gICAgICAgICAgICBtaW5vcjogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZGltZW5zaW9uID09PSBcImxvblwiKSB7XG4gICAgICAgICAgICByZWY0ID0gcHJval90aWNrcy5tYWpvcjtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZjQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aWNrID0gcmVmNFtpXTtcbiAgICAgICAgICAgICAgICByZWY1ID0gcHJvajRfMS5wcm9qNChwcm9qNF8xLm1lcmNhdG9yKS5mb3J3YXJkKFt0aWNrLCBwcm9qX2Nyb3NzX2xvY10pLCBsb24gPSByZWY1WzBdLCBfID0gcmVmNVsxXTtcbiAgICAgICAgICAgICAgICB0aWNrcy5tYWpvci5wdXNoKGxvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWY2ID0gcHJval90aWNrcy5taW5vcjtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSByZWY2Lmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgICAgICAgIHRpY2sgPSByZWY2W2pdO1xuICAgICAgICAgICAgICAgIHJlZjcgPSBwcm9qNF8xLnByb2o0KHByb2o0XzEubWVyY2F0b3IpLmZvcndhcmQoW3RpY2ssIHByb2pfY3Jvc3NfbG9jXSksIGxvbiA9IHJlZjdbMF0sIF8gPSByZWY3WzFdO1xuICAgICAgICAgICAgICAgIHRpY2tzLm1pbm9yLnB1c2gobG9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZjggPSBwcm9qX3RpY2tzLm1ham9yO1xuICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuMiA9IHJlZjgubGVuZ3RoOyBrIDwgbGVuMjsgaysrKSB7XG4gICAgICAgICAgICAgICAgdGljayA9IHJlZjhba107XG4gICAgICAgICAgICAgICAgcmVmOSA9IHByb2o0XzEucHJvajQocHJvajRfMS5tZXJjYXRvcikuZm9yd2FyZChbcHJval9jcm9zc19sb2MsIHRpY2tdKSwgXyA9IHJlZjlbMF0sIGxhdCA9IHJlZjlbMV07XG4gICAgICAgICAgICAgICAgdGlja3MubWFqb3IucHVzaChsYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmMTAgPSBwcm9qX3RpY2tzLm1pbm9yO1xuICAgICAgICAgICAgZm9yIChsID0gMCwgbGVuMyA9IHJlZjEwLmxlbmd0aDsgbCA8IGxlbjM7IGwrKykge1xuICAgICAgICAgICAgICAgIHRpY2sgPSByZWYxMFtsXTtcbiAgICAgICAgICAgICAgICByZWYxMSA9IHByb2o0XzEucHJvajQocHJvajRfMS5tZXJjYXRvcikuZm9yd2FyZChbcHJval9jcm9zc19sb2MsIHRpY2tdKSwgXyA9IHJlZjExWzBdLCBsYXQgPSByZWYxMVsxXTtcbiAgICAgICAgICAgICAgICB0aWNrcy5taW5vci5wdXNoKGxhdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH07XG4gICAgcmV0dXJuIE1lcmNhdG9yVGlja2VyO1xufSkoYmFzaWNfdGlja2VyXzEuQmFzaWNUaWNrZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgT05FX01PTlRILCBjb3B5X2RhdGUsIGRhdGVfcmFuZ2VfYnlfeWVhciwgbGFzdF95ZWFyX25vX2xhdGVyX3RoYW4sIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBzaW5nbGVfaW50ZXJ2YWxfdGlja2VyXzEgPSByZXF1aXJlKFwiLi9zaW5nbGVfaW50ZXJ2YWxfdGlja2VyXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xuY29weV9kYXRlID0gdXRpbC5jb3B5X2RhdGU7XG5sYXN0X3llYXJfbm9fbGF0ZXJfdGhhbiA9IHV0aWwubGFzdF95ZWFyX25vX2xhdGVyX3RoYW47XG5PTkVfTU9OVEggPSB1dGlsLk9ORV9NT05USDtcbmRhdGVfcmFuZ2VfYnlfeWVhciA9IGZ1bmN0aW9uIChzdGFydF90aW1lLCBlbmRfdGltZSkge1xuICAgIHZhciBkYXRlLCBkYXRlcywgZW5kX2RhdGUsIHN0YXJ0X2RhdGU7XG4gICAgc3RhcnRfZGF0ZSA9IGxhc3RfeWVhcl9ub19sYXRlcl90aGFuKG5ldyBEYXRlKHN0YXJ0X3RpbWUpKTtcbiAgICBlbmRfZGF0ZSA9IGxhc3RfeWVhcl9ub19sYXRlcl90aGFuKG5ldyBEYXRlKGVuZF90aW1lKSk7XG4gICAgZW5kX2RhdGUuc2V0VVRDRnVsbFllYXIoZW5kX2RhdGUuZ2V0VVRDRnVsbFllYXIoKSArIDEpO1xuICAgIGRhdGVzID0gW107XG4gICAgZGF0ZSA9IHN0YXJ0X2RhdGU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgZGF0ZXMucHVzaChjb3B5X2RhdGUoZGF0ZSkpO1xuICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIDEpO1xuICAgICAgICBpZiAoZGF0ZSA+IGVuZF9kYXRlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0ZXM7XG59O1xuZXhwb3J0cy5Nb250aHNUaWNrZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTW9udGhzVGlja2VyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBNb250aHNUaWNrZXIoKSB7XG4gICAgICAgIHJldHVybiBNb250aHNUaWNrZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1vbnRoc1RpY2tlci5wcm90b3R5cGUudHlwZSA9ICdNb250aHNUaWNrZXInO1xuICAgIE1vbnRoc1RpY2tlci5kZWZpbmUoe1xuICAgICAgICBtb250aHM6IFtwLkFycmF5LCBbXV1cbiAgICB9KTtcbiAgICBNb250aHNUaWNrZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGludGVydmFsLCBtb250aHM7XG4gICAgICAgIE1vbnRoc1RpY2tlci5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgbW9udGhzID0gdGhpcy5tb250aHM7XG4gICAgICAgIGludGVydmFsID0gbW9udGhzLmxlbmd0aCA+IDEgPyAobW9udGhzWzFdIC0gbW9udGhzWzBdKSAqIE9ORV9NT05USCA6IDEyICogT05FX01PTlRIO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbCA9IGludGVydmFsO1xuICAgIH07XG4gICAgTW9udGhzVGlja2VyLnByb3RvdHlwZS5nZXRfdGlja3Nfbm9fZGVmYXVsdHMgPSBmdW5jdGlvbiAoZGF0YV9sb3csIGRhdGFfaGlnaCwgY3Jvc3NfbG9jLCBkZXNpcmVkX25fdGlja3MpIHtcbiAgICAgICAgdmFyIGFsbF90aWNrcywgZGF0ZSwgbW9udGhfZGF0ZSwgbW9udGhfZGF0ZXMsIG1vbnRocywgbW9udGhzX29mX3llYXIsIHRpY2tzX2luX3JhbmdlLCB5ZWFyX2RhdGVzO1xuICAgICAgICB5ZWFyX2RhdGVzID0gZGF0ZV9yYW5nZV9ieV95ZWFyKGRhdGFfbG93LCBkYXRhX2hpZ2gpO1xuICAgICAgICBtb250aHMgPSB0aGlzLm1vbnRocztcbiAgICAgICAgbW9udGhzX29mX3llYXIgPSBmdW5jdGlvbiAoeWVhcl9kYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9udGhzLm1hcChmdW5jdGlvbiAobW9udGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGhfZGF0ZTtcbiAgICAgICAgICAgICAgICBtb250aF9kYXRlID0gY29weV9kYXRlKHllYXJfZGF0ZSk7XG4gICAgICAgICAgICAgICAgbW9udGhfZGF0ZS5zZXRVVENNb250aChtb250aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRoX2RhdGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgbW9udGhfZGF0ZXMgPSBhcnJheV8xLmNvbmNhdCgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHllYXJfZGF0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkYXRlID0geWVhcl9kYXRlc1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobW9udGhzX29mX3llYXIoZGF0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCkpO1xuICAgICAgICBhbGxfdGlja3MgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG1vbnRoX2RhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbW9udGhfZGF0ZSA9IG1vbnRoX2RhdGVzW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChtb250aF9kYXRlLmdldFRpbWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgdGlja3NfaW5fcmFuZ2UgPSBhbGxfdGlja3MuZmlsdGVyKGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gKGRhdGFfbG93IDw9IHRpY2sgJiYgdGljayA8PSBkYXRhX2hpZ2gpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwibWFqb3JcIjogdGlja3NfaW5fcmFuZ2UsXG4gICAgICAgICAgICBcIm1pbm9yXCI6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTW9udGhzVGlja2VyO1xufSkoc2luZ2xlX2ludGVydmFsX3RpY2tlcl8xLlNpbmdsZUludGVydmFsVGlja2VyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBjb250aW51b3VzX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vY29udGludW91c190aWNrZXJcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLlNpbmdsZUludGVydmFsVGlja2VyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFNpbmdsZUludGVydmFsVGlja2VyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTaW5nbGVJbnRlcnZhbFRpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIFNpbmdsZUludGVydmFsVGlja2VyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTaW5nbGVJbnRlcnZhbFRpY2tlci5wcm90b3R5cGUudHlwZSA9ICdTaW5nbGVJbnRlcnZhbFRpY2tlcic7XG4gICAgU2luZ2xlSW50ZXJ2YWxUaWNrZXIuZGVmaW5lKHtcbiAgICAgICAgaW50ZXJ2YWw6IFtwLk51bWJlcl1cbiAgICB9KTtcbiAgICBTaW5nbGVJbnRlcnZhbFRpY2tlci5nZXR0ZXJzKHtcbiAgICAgICAgbWluX2ludGVydmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgbWF4X2ludGVydmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFNpbmdsZUludGVydmFsVGlja2VyLnByb3RvdHlwZS5nZXRfaW50ZXJ2YWwgPSBmdW5jdGlvbiAoZGF0YV9sb3csIGRhdGFfaGlnaCwgbl9kZXNpcmVkX3RpY2tzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVydmFsO1xuICAgIH07XG4gICAgcmV0dXJuIFNpbmdsZUludGVydmFsVGlja2VyO1xufSkoY29udGludW91c190aWNrZXJfMS5Db250aW51b3VzVGlja2VyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xuZXhwb3J0cy5UaWNrZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVGlja2VyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUaWNrZXIoKSB7XG4gICAgICAgIHJldHVybiBUaWNrZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRpY2tlci5wcm90b3R5cGUudHlwZSA9ICdUaWNrZXInO1xuICAgIFRpY2tlci5wcm90b3R5cGUuZ2V0X3RpY2tzID0gZnVuY3Rpb24gKGRhdGFfbG93LCBkYXRhX2hpZ2gsIHJhbmdlLCBjcm9zc19sb2MsIGFyZykge1xuICAgICAgICB2YXIgZGVzaXJlZF9uX3RpY2tzO1xuICAgICAgICBkZXNpcmVkX25fdGlja3MgPSBhcmcuZGVzaXJlZF9uX3RpY2tzO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRfdGlja3Nfbm9fZGVmYXVsdHMoZGF0YV9sb3csIGRhdGFfaGlnaCwgY3Jvc3NfbG9jLCB0aGlzLmRlc2lyZWRfbnVtX3RpY2tzKTtcbiAgICB9O1xuICAgIFRpY2tlci5wcm90b3R5cGUuZ2V0X3RpY2tzX25vX2RlZmF1bHRzID0gZnVuY3Rpb24gKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGNyb3NzX2xvYywgZGVzaXJlZF9uX3RpY2tzKSB7XG4gICAgICAgIHZhciBlbmRfZmFjdG9yLCBmYWN0b3IsIGZhY3RvcnMsIGksIGludGVydmFsLCBqLCBrLCBsLCBsZW4sIGxlbjEsIGxlbjIsIG1pbm9yX2ludGVydmFsLCBtaW5vcl9vZmZzZXRzLCBtaW5vcl90aWNrcywgbnVtX21pbm9yX3RpY2tzLCByZWYsIHN0YXJ0X2ZhY3RvciwgdGljaywgdGlja3MsIHg7XG4gICAgICAgIGludGVydmFsID0gdGhpcy5nZXRfaW50ZXJ2YWwoZGF0YV9sb3csIGRhdGFfaGlnaCwgZGVzaXJlZF9uX3RpY2tzKTtcbiAgICAgICAgc3RhcnRfZmFjdG9yID0gTWF0aC5mbG9vcihkYXRhX2xvdyAvIGludGVydmFsKTtcbiAgICAgICAgZW5kX2ZhY3RvciA9IE1hdGguY2VpbChkYXRhX2hpZ2ggLyBpbnRlcnZhbCk7XG4gICAgICAgIGlmICh0eXBlc18xLmlzU3RyaWN0TmFOKHN0YXJ0X2ZhY3RvcikgfHwgdHlwZXNfMS5pc1N0cmljdE5hTihlbmRfZmFjdG9yKSkge1xuICAgICAgICAgICAgZmFjdG9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmFjdG9ycyA9IGFycmF5XzEucmFuZ2Uoc3RhcnRfZmFjdG9yLCBlbmRfZmFjdG9yICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGlja3MgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGosIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGZhY3RvcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBmYWN0b3IgPSBmYWN0b3JzW2pdO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmYWN0b3IgKiBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgdGlja3MgPSB0aWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRpY2spIHtcbiAgICAgICAgICAgIHJldHVybiAoZGF0YV9sb3cgPD0gdGljayAmJiB0aWNrIDw9IGRhdGFfaGlnaCk7XG4gICAgICAgIH0pO1xuICAgICAgICBudW1fbWlub3JfdGlja3MgPSB0aGlzLm51bV9taW5vcl90aWNrcztcbiAgICAgICAgbWlub3JfdGlja3MgPSBbXTtcbiAgICAgICAgaWYgKG51bV9taW5vcl90aWNrcyA+IDAgJiYgdGlja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbWlub3JfaW50ZXJ2YWwgPSBpbnRlcnZhbCAvIG51bV9taW5vcl90aWNrcztcbiAgICAgICAgICAgIG1pbm9yX29mZnNldHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBudW1fbWlub3JfdGlja3M7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goaSAqIG1pbm9yX2ludGVydmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcmVmID0gbWlub3Jfb2Zmc2V0cy5zbGljZSgxLCArbWlub3Jfb2Zmc2V0cy5sZW5ndGggKyAxIHx8IDllOSk7XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICB4ID0gcmVmW2pdO1xuICAgICAgICAgICAgICAgIG1pbm9yX3RpY2tzLnB1c2godGlja3NbMF0gLSB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoayA9IDAsIGxlbjEgPSB0aWNrcy5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgICAgICAgICB0aWNrID0gdGlja3Nba107XG4gICAgICAgICAgICAgICAgZm9yIChsID0gMCwgbGVuMiA9IG1pbm9yX29mZnNldHMubGVuZ3RoOyBsIDwgbGVuMjsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBtaW5vcl9vZmZzZXRzW2xdO1xuICAgICAgICAgICAgICAgICAgICBtaW5vcl90aWNrcy5wdXNoKHRpY2sgKyB4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwibWFqb3JcIjogdGlja3MsXG4gICAgICAgICAgICBcIm1pbm9yXCI6IG1pbm9yX3RpY2tzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGlja2VyO1xufSkobW9kZWxfMS5Nb2RlbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT05FX01JTExJID0gMS4wO1xuZXhwb3J0cy5PTkVfU0VDT05EID0gMTAwMC4wO1xuZXhwb3J0cy5PTkVfTUlOVVRFID0gNjAuMCAqIGV4cG9ydHMuT05FX1NFQ09ORDtcbmV4cG9ydHMuT05FX0hPVVIgPSA2MCAqIGV4cG9ydHMuT05FX01JTlVURTtcbmV4cG9ydHMuT05FX0RBWSA9IDI0ICogZXhwb3J0cy5PTkVfSE9VUjtcbmV4cG9ydHMuT05FX01PTlRIID0gMzAgKiBleHBvcnRzLk9ORV9EQVk7XG5leHBvcnRzLk9ORV9ZRUFSID0gMzY1ICogZXhwb3J0cy5PTkVfREFZO1xuZXhwb3J0cy5jb3B5X2RhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XG59O1xuZXhwb3J0cy5sYXN0X21vbnRoX25vX2xhdGVyX3RoYW4gPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIGRhdGUgPSBleHBvcnRzLmNvcHlfZGF0ZShkYXRlKTtcbiAgICBkYXRlLnNldFVUQ0RhdGUoMSk7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwKTtcbiAgICBkYXRlLnNldFVUQ01pbnV0ZXMoMCk7XG4gICAgZGF0ZS5zZXRVVENTZWNvbmRzKDApO1xuICAgIGRhdGUuc2V0VVRDTWlsbGlzZWNvbmRzKDApO1xuICAgIHJldHVybiBkYXRlO1xufTtcbmV4cG9ydHMubGFzdF95ZWFyX25vX2xhdGVyX3RoYW4gPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIGRhdGUgPSBleHBvcnRzLmxhc3RfbW9udGhfbm9fbGF0ZXJfdGhhbihkYXRlKTtcbiAgICBkYXRlLnNldFVUQ01vbnRoKDApO1xuICAgIHJldHVybiBkYXRlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE9ORV9ZRUFSLCBsYXN0X3llYXJfbm9fbGF0ZXJfdGhhbiwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGJhc2ljX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vYmFzaWNfdGlja2VyXCIpO1xudmFyIHNpbmdsZV9pbnRlcnZhbF90aWNrZXJfMSA9IHJlcXVpcmUoXCIuL3NpbmdsZV9pbnRlcnZhbF90aWNrZXJcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5sYXN0X3llYXJfbm9fbGF0ZXJfdGhhbiA9IHV0aWwubGFzdF95ZWFyX25vX2xhdGVyX3RoYW47XG5PTkVfWUVBUiA9IHV0aWwuT05FX1lFQVI7XG5leHBvcnRzLlllYXJzVGlja2VyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFllYXJzVGlja2VyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBZZWFyc1RpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIFllYXJzVGlja2VyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBZZWFyc1RpY2tlci5wcm90b3R5cGUudHlwZSA9ICdZZWFyc1RpY2tlcic7XG4gICAgWWVhcnNUaWNrZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgWWVhcnNUaWNrZXIuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBPTkVfWUVBUjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzaWNfdGlja2VyID0gbmV3IGJhc2ljX3RpY2tlcl8xLkJhc2ljVGlja2VyKHtcbiAgICAgICAgICAgIG51bV9taW5vcl90aWNrczogMFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFllYXJzVGlja2VyLnByb3RvdHlwZS5nZXRfdGlja3Nfbm9fZGVmYXVsdHMgPSBmdW5jdGlvbiAoZGF0YV9sb3csIGRhdGFfaGlnaCwgY3Jvc3NfbG9jLCBkZXNpcmVkX25fdGlja3MpIHtcbiAgICAgICAgdmFyIGFsbF90aWNrcywgZW5kX3llYXIsIHN0YXJ0X3llYXIsIHRpY2tzX2luX3JhbmdlLCB5ZWFyLCB5ZWFycztcbiAgICAgICAgc3RhcnRfeWVhciA9IGxhc3RfeWVhcl9ub19sYXRlcl90aGFuKG5ldyBEYXRlKGRhdGFfbG93KSkuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgZW5kX3llYXIgPSBsYXN0X3llYXJfbm9fbGF0ZXJfdGhhbihuZXcgRGF0ZShkYXRhX2hpZ2gpKS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICB5ZWFycyA9IHRoaXMuYmFzaWNfdGlja2VyLmdldF90aWNrc19ub19kZWZhdWx0cyhzdGFydF95ZWFyLCBlbmRfeWVhciwgY3Jvc3NfbG9jLCBkZXNpcmVkX25fdGlja3MpLm1ham9yO1xuICAgICAgICBhbGxfdGlja3MgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHllYXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeWVhciA9IHllYXJzW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChEYXRlLlVUQyh5ZWFyLCAwLCAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgdGlja3NfaW5fcmFuZ2UgPSBhbGxfdGlja3MuZmlsdGVyKGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gKGRhdGFfbG93IDw9IHRpY2sgJiYgdGljayA8PSBkYXRhX2hpZ2gpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ham9yOiB0aWNrc19pbl9yYW5nZSxcbiAgICAgICAgICAgIG1pbm9yOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFllYXJzVGlja2VyO1xufSkoc2luZ2xlX2ludGVydmFsX3RpY2tlcl8xLlNpbmdsZUludGVydmFsVGlja2VyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtZXJjYXRvcl90aWxlX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vbWVyY2F0b3JfdGlsZV9zb3VyY2VcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkJCb3hUaWxlU291cmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEJCb3hUaWxlU291cmNlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBCQm94VGlsZVNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIEJCb3hUaWxlU291cmNlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCQm94VGlsZVNvdXJjZS5wcm90b3R5cGUudHlwZSA9ICdCQm94VGlsZVNvdXJjZSc7XG4gICAgQkJveFRpbGVTb3VyY2UuZGVmaW5lKHtcbiAgICAgICAgdXNlX2xhdGxvbjogW3AuQm9vbCwgZmFsc2VdXG4gICAgfSk7XG4gICAgQkJveFRpbGVTb3VyY2UucHJvdG90eXBlLmdldF9pbWFnZV91cmwgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICB2YXIgaW1hZ2VfdXJsLCByZWYsIHJlZjEsIHhtYXgsIHhtaW4sIHltYXgsIHltaW47XG4gICAgICAgIGltYWdlX3VybCA9IHRoaXMuc3RyaW5nX2xvb2t1cF9yZXBsYWNlKHRoaXMudXJsLCB0aGlzLmV4dHJhX3VybF92YXJzKTtcbiAgICAgICAgaWYgKHRoaXMudXNlX2xhdGxvbikge1xuICAgICAgICAgICAgcmVmID0gdGhpcy5nZXRfdGlsZV9nZW9ncmFwaGljX2JvdW5kcyh4LCB5LCB6KSwgeG1pbiA9IHJlZlswXSwgeW1pbiA9IHJlZlsxXSwgeG1heCA9IHJlZlsyXSwgeW1heCA9IHJlZlszXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZjEgPSB0aGlzLmdldF90aWxlX21ldGVyX2JvdW5kcyh4LCB5LCB6KSwgeG1pbiA9IHJlZjFbMF0sIHltaW4gPSByZWYxWzFdLCB4bWF4ID0gcmVmMVsyXSwgeW1heCA9IHJlZjFbM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltYWdlX3VybC5yZXBsYWNlKFwie1hNSU59XCIsIHhtaW4pLnJlcGxhY2UoXCJ7WU1JTn1cIiwgeW1pbikucmVwbGFjZShcIntYTUFYfVwiLCB4bWF4KS5yZXBsYWNlKFwie1lNQVh9XCIsIHltYXgpO1xuICAgIH07XG4gICAgcmV0dXJuIEJCb3hUaWxlU291cmNlO1xufSkobWVyY2F0b3JfdGlsZV9zb3VyY2VfMS5NZXJjYXRvclRpbGVTb3VyY2UpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmluZCA9IGZ1bmN0aW9uIChmbiwgbWUpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuLi9yZW5kZXJlcnMvcmVuZGVyZXJcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuRHluYW1pY0ltYWdlVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEeW5hbWljSW1hZ2VWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBEeW5hbWljSW1hZ2VWaWV3KCkge1xuICAgICAgICB0aGlzLl9vbl9pbWFnZV9lcnJvciA9IGJpbmQodGhpcy5fb25faW1hZ2VfZXJyb3IsIHRoaXMpO1xuICAgICAgICB0aGlzLl9vbl9pbWFnZV9sb2FkID0gYmluZCh0aGlzLl9vbl9pbWFnZV9sb2FkLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIER5bmFtaWNJbWFnZVZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIER5bmFtaWNJbWFnZVZpZXcucHJvdG90eXBlLmNvbm5lY3Rfc2lnbmFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgRHluYW1pY0ltYWdlVmlldy5fX3N1cGVyX18uY29ubmVjdF9zaWduYWxzLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5jaGFuZ2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRHluYW1pY0ltYWdlVmlldy5wcm90b3R5cGUuZ2V0X2V4dGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnhfcmFuZ2Uuc3RhcnQsIHRoaXMueV9yYW5nZS5zdGFydCwgdGhpcy54X3JhbmdlLmVuZCwgdGhpcy55X3JhbmdlLmVuZF07XG4gICAgfTtcbiAgICBEeW5hbWljSW1hZ2VWaWV3LnByb3RvdHlwZS5fc2V0X2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWFwX3Bsb3QgPSB0aGlzLnBsb3Rfdmlldy5tb2RlbC5wbG90O1xuICAgICAgICB0aGlzLm1hcF9jYW52YXMgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgIHRoaXMubWFwX2ZyYW1lID0gdGhpcy5wbG90X3ZpZXcuZnJhbWU7XG4gICAgICAgIHRoaXMueF9yYW5nZSA9IHRoaXMubWFwX3Bsb3QueF9yYW5nZTtcbiAgICAgICAgdGhpcy55X3JhbmdlID0gdGhpcy5tYXBfcGxvdC55X3JhbmdlO1xuICAgICAgICB0aGlzLmxhc3RJbWFnZSA9IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW50ID0gdGhpcy5nZXRfZXh0ZW50KCk7XG4gICAgfTtcbiAgICBEeW5hbWljSW1hZ2VWaWV3LnByb3RvdHlwZS5fbWFwX2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxfZXh0ZW50ID0gdGhpcy5nZXRfZXh0ZW50KCk7XG4gICAgfTtcbiAgICBEeW5hbWljSW1hZ2VWaWV3LnByb3RvdHlwZS5fb25faW1hZ2VfbG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBpbWFnZV9kYXRhO1xuICAgICAgICBpbWFnZV9kYXRhID0gZS50YXJnZXQuaW1hZ2VfZGF0YTtcbiAgICAgICAgaW1hZ2VfZGF0YS5pbWcgPSBlLnRhcmdldDtcbiAgICAgICAgaW1hZ2VfZGF0YS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RJbWFnZSA9IGltYWdlX2RhdGE7XG4gICAgICAgIGlmICh0aGlzLmdldF9leHRlbnQoKS5qb2luKCc6JykgPT09IGltYWdlX2RhdGEuY2FjaGVfa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEeW5hbWljSW1hZ2VWaWV3LnByb3RvdHlwZS5fb25faW1hZ2VfZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaW1hZ2VfZGF0YTtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIkVycm9yIGxvYWRpbmcgaW1hZ2U6IFwiICsgZS50YXJnZXQuc3JjKTtcbiAgICAgICAgaW1hZ2VfZGF0YSA9IGUudGFyZ2V0LmltYWdlX2RhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmltYWdlX3NvdXJjZS5yZW1vdmVfaW1hZ2UoaW1hZ2VfZGF0YSk7XG4gICAgfTtcbiAgICBEeW5hbWljSW1hZ2VWaWV3LnByb3RvdHlwZS5fY3JlYXRlX2ltYWdlID0gZnVuY3Rpb24gKGJvdW5kcykge1xuICAgICAgICB2YXIgaW1hZ2U7XG4gICAgICAgIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltYWdlLm9ubG9hZCA9IHRoaXMuX29uX2ltYWdlX2xvYWQ7XG4gICAgICAgIGltYWdlLm9uZXJyb3IgPSB0aGlzLl9vbl9pbWFnZV9lcnJvcjtcbiAgICAgICAgaW1hZ2UuYWx0ID0gJyc7XG4gICAgICAgIGltYWdlLmltYWdlX2RhdGEgPSB7XG4gICAgICAgICAgICBib3VuZHM6IGJvdW5kcyxcbiAgICAgICAgICAgIGxvYWRlZDogZmFsc2UsXG4gICAgICAgICAgICBjYWNoZV9rZXk6IGJvdW5kcy5qb2luKCc6JylcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb2RlbC5pbWFnZV9zb3VyY2UuYWRkX2ltYWdlKGltYWdlLmltYWdlX2RhdGEpO1xuICAgICAgICBpbWFnZS5zcmMgPSB0aGlzLm1vZGVsLmltYWdlX3NvdXJjZS5nZXRfaW1hZ2VfdXJsKGJvdW5kc1swXSwgYm91bmRzWzFdLCBib3VuZHNbMl0sIGJvdW5kc1szXSwgTWF0aC5jZWlsKHRoaXMubWFwX2ZyYW1lLl9oZWlnaHQudmFsdWUpLCBNYXRoLmNlaWwodGhpcy5tYXBfZnJhbWUuX3dpZHRoLnZhbHVlKSk7XG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9O1xuICAgIER5bmFtaWNJbWFnZVZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGV4dGVudCwgaW1hZ2Vfb2JqO1xuICAgICAgICBpZiAodGhpcy5tYXBfaW5pdGlhbGl6ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0X2RhdGEoKTtcbiAgICAgICAgICAgIHRoaXMuX21hcF9kYXRhKCk7XG4gICAgICAgICAgICB0aGlzLm1hcF9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW50ID0gdGhpcy5nZXRfZXh0ZW50KCk7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcl90aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVuZGVyX3RpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpbWFnZV9vYmogPSB0aGlzLm1vZGVsLmltYWdlX3NvdXJjZS5pbWFnZXNbZXh0ZW50LmpvaW4oJzonKV07XG4gICAgICAgIGlmICgoaW1hZ2Vfb2JqICE9IG51bGwpICYmIGltYWdlX29iai5sb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdfaW1hZ2UoZXh0ZW50LmpvaW4oJzonKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGFzdEltYWdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdfaW1hZ2UodGhpcy5sYXN0SW1hZ2UuY2FjaGVfa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1hZ2Vfb2JqID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcl90aW1lciA9IHNldFRpbWVvdXQoKChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NyZWF0ZV9pbWFnZShleHRlbnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSh0aGlzKSksIDEyNSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIER5bmFtaWNJbWFnZVZpZXcucHJvdG90eXBlLl9kcmF3X2ltYWdlID0gZnVuY3Rpb24gKGltYWdlX2tleSkge1xuICAgICAgICB2YXIgaW1hZ2Vfb2JqLCByZWYsIHJlZjEsIHNoLCBzdywgc3gsIHN4bWF4LCBzeG1pbiwgc3ksIHN5bWF4LCBzeW1pbjtcbiAgICAgICAgaW1hZ2Vfb2JqID0gdGhpcy5tb2RlbC5pbWFnZV9zb3VyY2UuaW1hZ2VzW2ltYWdlX2tleV07XG4gICAgICAgIGlmIChpbWFnZV9vYmogIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tYXBfY2FudmFzLnNhdmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldF9yZWN0KCk7XG4gICAgICAgICAgICB0aGlzLm1hcF9jYW52YXMuZ2xvYmFsQWxwaGEgPSB0aGlzLm1vZGVsLmFscGhhO1xuICAgICAgICAgICAgcmVmID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUubWFwX3RvX3NjcmVlbihbaW1hZ2Vfb2JqLmJvdW5kc1swXV0sIFtpbWFnZV9vYmouYm91bmRzWzNdXSwgdGhpcy5wbG90X3ZpZXcuY2FudmFzKSwgc3htaW4gPSByZWZbMF0sIHN5bWluID0gcmVmWzFdO1xuICAgICAgICAgICAgcmVmMSA9IHRoaXMucGxvdF92aWV3LmZyYW1lLm1hcF90b19zY3JlZW4oW2ltYWdlX29iai5ib3VuZHNbMl1dLCBbaW1hZ2Vfb2JqLmJvdW5kc1sxXV0sIHRoaXMucGxvdF92aWV3LmNhbnZhcyksIHN4bWF4ID0gcmVmMVswXSwgc3ltYXggPSByZWYxWzFdO1xuICAgICAgICAgICAgc3htaW4gPSBzeG1pblswXTtcbiAgICAgICAgICAgIHN5bWluID0gc3ltaW5bMF07XG4gICAgICAgICAgICBzeG1heCA9IHN4bWF4WzBdO1xuICAgICAgICAgICAgc3ltYXggPSBzeW1heFswXTtcbiAgICAgICAgICAgIHN3ID0gc3htYXggLSBzeG1pbjtcbiAgICAgICAgICAgIHNoID0gc3ltYXggLSBzeW1pbjtcbiAgICAgICAgICAgIHN4ID0gc3htaW47XG4gICAgICAgICAgICBzeSA9IHN5bWluO1xuICAgICAgICAgICAgdGhpcy5tYXBfY2FudmFzLmRyYXdJbWFnZShpbWFnZV9vYmouaW1nLCBzeCwgc3ksIHN3LCBzaCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBfY2FudmFzLnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHluYW1pY0ltYWdlVmlldy5wcm90b3R5cGUuX3NldF9yZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaCwgbCwgb3V0bGluZV93aWR0aCwgdCwgdztcbiAgICAgICAgb3V0bGluZV93aWR0aCA9IHRoaXMucGxvdF9tb2RlbC5wbG90LnByb3BlcnRpZXMub3V0bGluZV9saW5lX3dpZHRoLnZhbHVlKCk7XG4gICAgICAgIGwgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXMudnhfdG9fc3godGhpcy5tYXBfZnJhbWUuX2xlZnQudmFsdWUpICsgKG91dGxpbmVfd2lkdGggLyAyKTtcbiAgICAgICAgdCA9IHRoaXMucGxvdF92aWV3LmNhbnZhcy52eV90b19zeSh0aGlzLm1hcF9mcmFtZS5fdG9wLnZhbHVlKSArIChvdXRsaW5lX3dpZHRoIC8gMik7XG4gICAgICAgIHcgPSB0aGlzLm1hcF9mcmFtZS5fd2lkdGgudmFsdWUgLSBvdXRsaW5lX3dpZHRoO1xuICAgICAgICBoID0gdGhpcy5tYXBfZnJhbWUuX2hlaWdodC52YWx1ZSAtIG91dGxpbmVfd2lkdGg7XG4gICAgICAgIHRoaXMubWFwX2NhbnZhcy5yZWN0KGwsIHQsIHcsIGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBfY2FudmFzLmNsaXAoKTtcbiAgICB9O1xuICAgIHJldHVybiBEeW5hbWljSW1hZ2VWaWV3O1xufSkocmVuZGVyZXJfMS5SZW5kZXJlclZpZXcpO1xuZXhwb3J0cy5EeW5hbWljSW1hZ2VSZW5kZXJlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEeW5hbWljSW1hZ2VSZW5kZXJlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRHluYW1pY0ltYWdlUmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiBEeW5hbWljSW1hZ2VSZW5kZXJlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRHluYW1pY0ltYWdlUmVuZGVyZXIucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuRHluYW1pY0ltYWdlVmlldztcbiAgICBEeW5hbWljSW1hZ2VSZW5kZXJlci5wcm90b3R5cGUudHlwZSA9ICdEeW5hbWljSW1hZ2VSZW5kZXJlcic7XG4gICAgRHluYW1pY0ltYWdlUmVuZGVyZXIuZGVmaW5lKHtcbiAgICAgICAgYWxwaGE6IFtwLk51bWJlciwgMS4wXSxcbiAgICAgICAgaW1hZ2Vfc291cmNlOiBbcC5JbnN0YW5jZV0sXG4gICAgICAgIHJlbmRlcl9wYXJlbnRzOiBbcC5Cb29sLCB0cnVlXVxuICAgIH0pO1xuICAgIER5bmFtaWNJbWFnZVJlbmRlcmVyLm92ZXJyaWRlKHtcbiAgICAgICAgbGV2ZWw6ICd1bmRlcmxheSdcbiAgICB9KTtcbiAgICByZXR1cm4gRHluYW1pY0ltYWdlUmVuZGVyZXI7XG59KShyZW5kZXJlcl8xLlJlbmRlcmVyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbWFnZVBvb2wgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEltYWdlUG9vbCgpIHtcbiAgICAgICAgdGhpcy5pbWFnZXMgPSBbXTtcbiAgICB9XG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbWc7XG4gICAgICAgIGltZyA9IHRoaXMuaW1hZ2VzLnBvcCgpO1xuICAgICAgICBpZiAoaW1nICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEltYWdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEltYWdlUG9vbC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2VzLmxlbmd0aCA+IDUwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltZy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLmltYWdlcywgaW1nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmltYWdlcy5wdXNoKGltZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbWFnZVBvb2w7XG59KSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxcIik7XG5leHBvcnRzLkltYWdlU291cmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEltYWdlU291cmNlLCBzdXBlckNsYXNzKTtcbiAgICBJbWFnZVNvdXJjZS5wcm90b3R5cGUudHlwZSA9ICdJbWFnZVNvdXJjZSc7XG4gICAgSW1hZ2VTb3VyY2UuZGVmaW5lKHtcbiAgICAgICAgdXJsOiBbcC5TdHJpbmcsICcnXSxcbiAgICAgICAgZXh0cmFfdXJsX3ZhcnM6IFtwLkFueSwge31dXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gSW1hZ2VTb3VyY2Uob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgSW1hZ2VTb3VyY2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaW1hZ2VzID0ge307XG4gICAgICAgIHRoaXMubm9ybWFsaXplX2Nhc2UoKTtcbiAgICB9XG4gICAgSW1hZ2VTb3VyY2UucHJvdG90eXBlLm5vcm1hbGl6ZV9jYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAnTm90ZTogc2hvdWxkIHByb2JhYmx5IGJlIHJlZmFjdG9yZWQgaW50byBzdWJjbGFzc2VzLic7XG4gICAgICAgIHZhciB1cmw7XG4gICAgICAgIHVybCA9IHRoaXMudXJsO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3htaW59JywgJ3tYTUlOfScpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3ltaW59JywgJ3tZTUlOfScpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3htYXh9JywgJ3tYTUFYfScpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3ltYXh9JywgJ3tZTUFYfScpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne2hlaWdodH0nLCAne0hFSUdIVH0nKTtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ3t3aWR0aH0nLCAne1dJRFRIfScpO1xuICAgICAgICByZXR1cm4gdGhpcy51cmwgPSB1cmw7XG4gICAgfTtcbiAgICBJbWFnZVNvdXJjZS5wcm90b3R5cGUuc3RyaW5nX2xvb2t1cF9yZXBsYWNlID0gZnVuY3Rpb24gKHN0ciwgbG9va3VwKSB7XG4gICAgICAgIHZhciBrZXksIHJlc3VsdF9zdHIsIHZhbHVlO1xuICAgICAgICByZXN1bHRfc3RyID0gc3RyO1xuICAgICAgICBmb3IgKGtleSBpbiBsb29rdXApIHtcbiAgICAgICAgICAgIHZhbHVlID0gbG9va3VwW2tleV07XG4gICAgICAgICAgICByZXN1bHRfc3RyID0gcmVzdWx0X3N0ci5yZXBsYWNlKCd7JyArIGtleSArICd9JywgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdF9zdHI7XG4gICAgfTtcbiAgICBJbWFnZVNvdXJjZS5wcm90b3R5cGUuYWRkX2ltYWdlID0gZnVuY3Rpb24gKGltYWdlX29iaikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZXNbaW1hZ2Vfb2JqLmNhY2hlX2tleV0gPSBpbWFnZV9vYmo7XG4gICAgfTtcbiAgICBJbWFnZVNvdXJjZS5wcm90b3R5cGUucmVtb3ZlX2ltYWdlID0gZnVuY3Rpb24gKGltYWdlX29iaikge1xuICAgICAgICByZXR1cm4gZGVsZXRlIHRoaXMuaW1hZ2VzW2ltYWdlX29iai5jYWNoZV9rZXldO1xuICAgIH07XG4gICAgSW1hZ2VTb3VyY2UucHJvdG90eXBlLmdldF9pbWFnZV91cmwgPSBmdW5jdGlvbiAoeG1pbiwgeW1pbiwgeG1heCwgeW1heCwgaGVpZ2h0LCB3aWR0aCkge1xuICAgICAgICB2YXIgaW1hZ2VfdXJsO1xuICAgICAgICBpbWFnZV91cmwgPSB0aGlzLnN0cmluZ19sb29rdXBfcmVwbGFjZSh0aGlzLnVybCwgdGhpcy5leHRyYV91cmxfdmFycyk7XG4gICAgICAgIHJldHVybiBpbWFnZV91cmwucmVwbGFjZShcIntYTUlOfVwiLCB4bWluKS5yZXBsYWNlKFwie1lNSU59XCIsIHltaW4pLnJlcGxhY2UoXCJ7WE1BWH1cIiwgeG1heCkucmVwbGFjZShcIntZTUFYfVwiLCB5bWF4KS5yZXBsYWNlKFwie1dJRFRIfVwiLCB3aWR0aCkucmVwbGFjZShcIntIRUlHSFR9XCIsIGhlaWdodCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW1hZ2VTb3VyY2U7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJib3hfdGlsZV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuL2Jib3hfdGlsZV9zb3VyY2VcIik7XG5leHBvcnRzLkJCb3hUaWxlU291cmNlID0gYmJveF90aWxlX3NvdXJjZV8xLkJCb3hUaWxlU291cmNlO1xudmFyIGR5bmFtaWNfaW1hZ2VfcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL2R5bmFtaWNfaW1hZ2VfcmVuZGVyZXJcIik7XG5leHBvcnRzLkR5bmFtaWNJbWFnZVJlbmRlcmVyID0gZHluYW1pY19pbWFnZV9yZW5kZXJlcl8xLkR5bmFtaWNJbWFnZVJlbmRlcmVyO1xudmFyIGltYWdlX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vaW1hZ2Vfc291cmNlXCIpO1xuZXhwb3J0cy5JbWFnZVNvdXJjZSA9IGltYWdlX3NvdXJjZV8xLkltYWdlU291cmNlO1xudmFyIG1lcmNhdG9yX3RpbGVfc291cmNlXzEgPSByZXF1aXJlKFwiLi9tZXJjYXRvcl90aWxlX3NvdXJjZVwiKTtcbmV4cG9ydHMuTWVyY2F0b3JUaWxlU291cmNlID0gbWVyY2F0b3JfdGlsZV9zb3VyY2VfMS5NZXJjYXRvclRpbGVTb3VyY2U7XG52YXIgcXVhZGtleV90aWxlX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vcXVhZGtleV90aWxlX3NvdXJjZVwiKTtcbmV4cG9ydHMuUVVBREtFWVRpbGVTb3VyY2UgPSBxdWFka2V5X3RpbGVfc291cmNlXzEuUVVBREtFWVRpbGVTb3VyY2U7XG52YXIgdGlsZV9yZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vdGlsZV9yZW5kZXJlclwiKTtcbmV4cG9ydHMuVGlsZVJlbmRlcmVyID0gdGlsZV9yZW5kZXJlcl8xLlRpbGVSZW5kZXJlcjtcbnZhciB0aWxlX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vdGlsZV9zb3VyY2VcIik7XG5leHBvcnRzLlRpbGVTb3VyY2UgPSB0aWxlX3NvdXJjZV8xLlRpbGVTb3VyY2U7XG52YXIgdG1zX3RpbGVfc291cmNlXzEgPSByZXF1aXJlKFwiLi90bXNfdGlsZV9zb3VyY2VcIik7XG5leHBvcnRzLlRNU1RpbGVTb3VyY2UgPSB0bXNfdGlsZV9zb3VyY2VfMS5UTVNUaWxlU291cmNlO1xudmFyIHdtdHNfdGlsZV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuL3dtdHNfdGlsZV9zb3VyY2VcIik7XG5leHBvcnRzLldNVFNUaWxlU291cmNlID0gd210c190aWxlX3NvdXJjZV8xLldNVFNUaWxlU291cmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKVxuICAgICAgICByZXR1cm4gaTtcbn0gcmV0dXJuIC0xOyB9O1xudmFyIHRpbGVfc291cmNlXzEgPSByZXF1aXJlKFwiLi90aWxlX3NvdXJjZVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuTWVyY2F0b3JUaWxlU291cmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE1lcmNhdG9yVGlsZVNvdXJjZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTWVyY2F0b3JUaWxlU291cmNlKCkge1xuICAgICAgICByZXR1cm4gTWVyY2F0b3JUaWxlU291cmNlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLnR5cGUgPSAnTWVyY2F0b3JUaWxlU291cmNlJztcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UuZGVmaW5lKHtcbiAgICAgICAgd3JhcF9hcm91bmQ6IFtwLkJvb2wsIHRydWVdXG4gICAgfSk7XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLm92ZXJyaWRlKHtcbiAgICAgICAgeF9vcmlnaW5fb2Zmc2V0OiAyMDAzNzUwOC4zNCxcbiAgICAgICAgeV9vcmlnaW5fb2Zmc2V0OiAyMDAzNzUwOC4zNCxcbiAgICAgICAgaW5pdGlhbF9yZXNvbHV0aW9uOiAxNTY1NDMuMDMzOTI4MDQwOTdcbiAgICB9KTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgejtcbiAgICAgICAgTWVyY2F0b3JUaWxlU291cmNlLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9ucyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoeiA9IGogPSAwOyBqIDw9IDMwOyB6ID0gKytqKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZ2V0X3Jlc29sdXRpb24oeikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLl9jb21wdXRlZF9pbml0aWFsX3Jlc29sdXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxfcmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsX3Jlc29sdXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMiAqIE1hdGguUEkgKiA2Mzc4MTM3IC8gdGhpcy50aWxlX3NpemU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUuaXNfdmFsaWRfdGlsZSA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgIGlmICghdGhpcy53cmFwX2Fyb3VuZCkge1xuICAgICAgICAgICAgaWYgKHggPCAwIHx8IHggPj0gTWF0aC5wb3coMiwgeikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPCAwIHx8IHkgPj0gTWF0aC5wb3coMiwgeikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUucmV0YWluX2NoaWxkcmVuID0gZnVuY3Rpb24gKHJlZmVyZW5jZV90aWxlKSB7XG4gICAgICAgIHZhciBrZXksIG1heF96b29tLCBtaW5fem9vbSwgcXVhZGtleSwgcmVmLCByZXN1bHRzLCB0aWxlO1xuICAgICAgICBxdWFka2V5ID0gcmVmZXJlbmNlX3RpbGUucXVhZGtleTtcbiAgICAgICAgbWluX3pvb20gPSBxdWFka2V5Lmxlbmd0aDtcbiAgICAgICAgbWF4X3pvb20gPSBtaW5fem9vbSArIDM7XG4gICAgICAgIHJlZiA9IHRoaXMudGlsZXM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgICAgICB0aWxlID0gcmVmW2tleV07XG4gICAgICAgICAgICBpZiAodGlsZS5xdWFka2V5LmluZGV4T2YocXVhZGtleSkgPT09IDAgJiYgdGlsZS5xdWFka2V5Lmxlbmd0aCA+IG1pbl96b29tICYmIHRpbGUucXVhZGtleS5sZW5ndGggPD0gbWF4X3pvb20pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGlsZS5yZXRhaW4gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5yZXRhaW5fbmVpZ2hib3JzID0gZnVuY3Rpb24gKHJlZmVyZW5jZV90aWxlKSB7XG4gICAgICAgIHZhciBrZXksIG5laWdoYm9yX3JhZGl1cywgbmVpZ2hib3JfeCwgbmVpZ2hib3JfeSwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZXN1bHRzLCB0aWxlLCB0eCwgdHksIHR6LCB4LCB5O1xuICAgICAgICBuZWlnaGJvcl9yYWRpdXMgPSA0O1xuICAgICAgICByZWYgPSByZWZlcmVuY2VfdGlsZS50aWxlX2Nvb3JkcywgdHggPSByZWZbMF0sIHR5ID0gcmVmWzFdLCB0eiA9IHJlZlsyXTtcbiAgICAgICAgbmVpZ2hib3JfeCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaiwgcmVmMSwgcmVmMiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoeCA9IGogPSByZWYxID0gdHggLSBuZWlnaGJvcl9yYWRpdXMsIHJlZjIgPSB0eCArIG5laWdoYm9yX3JhZGl1czsgcmVmMSA8PSByZWYyID8gaiA8PSByZWYyIDogaiA+PSByZWYyOyB4ID0gcmVmMSA8PSByZWYyID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIG5laWdoYm9yX3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGosIHJlZjEsIHJlZjIsIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKHkgPSBqID0gcmVmMSA9IHR5IC0gbmVpZ2hib3JfcmFkaXVzLCByZWYyID0gdHkgKyBuZWlnaGJvcl9yYWRpdXM7IHJlZjEgPD0gcmVmMiA/IGogPD0gcmVmMiA6IGogPj0gcmVmMjsgeSA9IHJlZjEgPD0gcmVmMiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpO1xuICAgICAgICByZWYxID0gdGhpcy50aWxlcztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiByZWYxKSB7XG4gICAgICAgICAgICB0aWxlID0gcmVmMVtrZXldO1xuICAgICAgICAgICAgaWYgKHRpbGUudGlsZV9jb29yZHNbMl0gPT09IHR6ICYmIChyZWYyID0gdGlsZS50aWxlX2Nvb3Jkc1swXSwgaW5kZXhPZi5jYWxsKG5laWdoYm9yX3gsIHJlZjIpID49IDApICYmIChyZWYzID0gdGlsZS50aWxlX2Nvb3Jkc1sxXSwgaW5kZXhPZi5jYWxsKG5laWdoYm9yX3ksIHJlZjMpID49IDApKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRpbGUucmV0YWluID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUucmV0YWluX3BhcmVudHMgPSBmdW5jdGlvbiAocmVmZXJlbmNlX3RpbGUpIHtcbiAgICAgICAgdmFyIGtleSwgcXVhZGtleSwgcmVmLCByZXN1bHRzLCB0aWxlO1xuICAgICAgICBxdWFka2V5ID0gcmVmZXJlbmNlX3RpbGUucXVhZGtleTtcbiAgICAgICAgcmVmID0gdGhpcy50aWxlcztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiByZWYpIHtcbiAgICAgICAgICAgIHRpbGUgPSByZWZba2V5XTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aWxlLnJldGFpbiA9IHF1YWRrZXkuaW5kZXhPZih0aWxlLnF1YWRrZXkpID09PSAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUuY2hpbGRyZW5fYnlfdGlsZV94eXogPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICB2YXIgYiwgY2hpbGRfdGlsZV94eXosIGksIGosIHF1YWRfa2V5LCByZWYsIHJlZjEsIHJlZjIsIHdvcmxkX3g7XG4gICAgICAgIHdvcmxkX3ggPSB0aGlzLmNhbGN1bGF0ZV93b3JsZF94X2J5X3RpbGVfeHl6KHgsIHksIHopO1xuICAgICAgICBpZiAod29ybGRfeCAhPT0gMCkge1xuICAgICAgICAgICAgcmVmID0gdGhpcy5ub3JtYWxpemVfeHl6KHgsIHksIHopLCB4ID0gcmVmWzBdLCB5ID0gcmVmWzFdLCB6ID0gcmVmWzJdO1xuICAgICAgICB9XG4gICAgICAgIHF1YWRfa2V5ID0gdGhpcy50aWxlX3h5el90b19xdWFka2V5KHgsIHksIHopO1xuICAgICAgICBjaGlsZF90aWxlX3h5eiA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBqID0gMDsgaiA8PSAzOyBpID0gaiArPSAxKSB7XG4gICAgICAgICAgICByZWYxID0gdGhpcy5xdWFka2V5X3RvX3RpbGVfeHl6KHF1YWRfa2V5ICsgaS50b1N0cmluZygpKSwgeCA9IHJlZjFbMF0sIHkgPSByZWYxWzFdLCB6ID0gcmVmMVsyXTtcbiAgICAgICAgICAgIGlmICh3b3JsZF94ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVmMiA9IHRoaXMuZGVub3JtYWxpemVfeHl6KHgsIHksIHosIHdvcmxkX3gpLCB4ID0gcmVmMlswXSwgeSA9IHJlZjJbMV0sIHogPSByZWYyWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IHRoaXMuZ2V0X3RpbGVfbWV0ZXJfYm91bmRzKHgsIHksIHopO1xuICAgICAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoaWxkX3RpbGVfeHl6LnB1c2goW3gsIHksIHosIGJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRfdGlsZV94eXo7XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLnBhcmVudF9ieV90aWxlX3h5eiA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgIHZhciBwYXJlbnRfcXVhZF9rZXksIHF1YWRfa2V5O1xuICAgICAgICBxdWFkX2tleSA9IHRoaXMudGlsZV94eXpfdG9fcXVhZGtleSh4LCB5LCB6KTtcbiAgICAgICAgcGFyZW50X3F1YWRfa2V5ID0gcXVhZF9rZXkuc3Vic3RyaW5nKDAsIHF1YWRfa2V5Lmxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFka2V5X3RvX3RpbGVfeHl6KHBhcmVudF9xdWFkX2tleSk7XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLmdldF9yZXNvbHV0aW9uID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wdXRlZF9pbml0aWFsX3Jlc29sdXRpb24oKSAvIE1hdGgucG93KDIsIGxldmVsKTtcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0X3Jlc29sdXRpb25fYnlfZXh0ZW50ID0gZnVuY3Rpb24gKGV4dGVudCwgaGVpZ2h0LCB3aWR0aCkge1xuICAgICAgICB2YXIgeF9ycywgeV9ycztcbiAgICAgICAgeF9ycyA9IChleHRlbnRbMl0gLSBleHRlbnRbMF0pIC8gd2lkdGg7XG4gICAgICAgIHlfcnMgPSAoZXh0ZW50WzNdIC0gZXh0ZW50WzFdKSAvIGhlaWdodDtcbiAgICAgICAgcmV0dXJuIFt4X3JzLCB5X3JzXTtcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0X2xldmVsX2J5X2V4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIGhlaWdodCwgd2lkdGgpIHtcbiAgICAgICAgdmFyIGksIGosIGxlbiwgciwgcmVmLCByZXNvbHV0aW9uLCB4X3JzLCB5X3JzO1xuICAgICAgICB4X3JzID0gKGV4dGVudFsyXSAtIGV4dGVudFswXSkgLyB3aWR0aDtcbiAgICAgICAgeV9ycyA9IChleHRlbnRbM10gLSBleHRlbnRbMV0pIC8gaGVpZ2h0O1xuICAgICAgICByZXNvbHV0aW9uID0gTWF0aC5tYXgoeF9ycywgeV9ycyk7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICByZWYgPSB0aGlzLl9yZXNvbHV0aW9ucztcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByID0gcmVmW2pdO1xuICAgICAgICAgICAgaWYgKHJlc29sdXRpb24gPiByKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLmdldF9jbG9zZXN0X2xldmVsX2J5X2V4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIGhlaWdodCwgd2lkdGgpIHtcbiAgICAgICAgdmFyIGNsb3Nlc3QsIHJlc29sdXRpb24sIHJlc3MsIHhfcnMsIHlfcnM7XG4gICAgICAgIHhfcnMgPSAoZXh0ZW50WzJdIC0gZXh0ZW50WzBdKSAvIHdpZHRoO1xuICAgICAgICB5X3JzID0gKGV4dGVudFszXSAtIGV4dGVudFsxXSkgLyBoZWlnaHQ7XG4gICAgICAgIHJlc29sdXRpb24gPSBNYXRoLm1heCh4X3JzLCB5X3JzKTtcbiAgICAgICAgcmVzcyA9IHRoaXMuX3Jlc29sdXRpb25zO1xuICAgICAgICBjbG9zZXN0ID0gdGhpcy5fcmVzb2x1dGlvbnMucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGN1cnJlbnQgLSByZXNvbHV0aW9uKSA8IE1hdGguYWJzKHByZXZpb3VzIC0gcmVzb2x1dGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9ucy5pbmRleE9mKGNsb3Nlc3QpO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5zbmFwX3RvX3pvb20gPSBmdW5jdGlvbiAoZXh0ZW50LCBoZWlnaHQsIHdpZHRoLCBsZXZlbCkge1xuICAgICAgICB2YXIgZGVzaXJlZF9yZXMsIGRlc2lyZWRfeF9kZWx0YSwgZGVzaXJlZF95X2RlbHRhLCB4X2FkanVzdCwgeG1heCwgeG1pbiwgeV9hZGp1c3QsIHltYXgsIHltaW47XG4gICAgICAgIGRlc2lyZWRfcmVzID0gdGhpcy5fcmVzb2x1dGlvbnNbbGV2ZWxdO1xuICAgICAgICBkZXNpcmVkX3hfZGVsdGEgPSB3aWR0aCAqIGRlc2lyZWRfcmVzO1xuICAgICAgICBkZXNpcmVkX3lfZGVsdGEgPSBoZWlnaHQgKiBkZXNpcmVkX3JlcztcbiAgICAgICAgeG1pbiA9IGV4dGVudFswXSwgeW1pbiA9IGV4dGVudFsxXSwgeG1heCA9IGV4dGVudFsyXSwgeW1heCA9IGV4dGVudFszXTtcbiAgICAgICAgeF9hZGp1c3QgPSAoZGVzaXJlZF94X2RlbHRhIC0gKHhtYXggLSB4bWluKSkgLyAyO1xuICAgICAgICB5X2FkanVzdCA9IChkZXNpcmVkX3lfZGVsdGEgLSAoeW1heCAtIHltaW4pKSAvIDI7XG4gICAgICAgIHJldHVybiBbeG1pbiAtIHhfYWRqdXN0LCB5bWluIC0geV9hZGp1c3QsIHhtYXggKyB4X2FkanVzdCwgeW1heCArIHlfYWRqdXN0XTtcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUudG1zX3RvX3dtdHMgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICAnTm90ZSB0aGlzIHdvcmtzIGJvdGggd2F5cyc7XG4gICAgICAgIHJldHVybiBbeCwgTWF0aC5wb3coMiwgeikgLSAxIC0geSwgel07XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLndtdHNfdG9fdG1zID0gZnVuY3Rpb24gKHgsIHksIHopIHtcbiAgICAgICAgJ05vdGUgdGhpcyB3b3JrcyBib3RoIHdheXMnO1xuICAgICAgICByZXR1cm4gW3gsIE1hdGgucG93KDIsIHopIC0gMSAtIHksIHpdO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5waXhlbHNfdG9fbWV0ZXJzID0gZnVuY3Rpb24gKHB4LCBweSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIG14LCBteSwgcmVzO1xuICAgICAgICByZXMgPSB0aGlzLmdldF9yZXNvbHV0aW9uKGxldmVsKTtcbiAgICAgICAgbXggPSBweCAqIHJlcyAtIHRoaXMueF9vcmlnaW5fb2Zmc2V0O1xuICAgICAgICBteSA9IHB5ICogcmVzIC0gdGhpcy55X29yaWdpbl9vZmZzZXQ7XG4gICAgICAgIHJldHVybiBbbXgsIG15XTtcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUubWV0ZXJzX3RvX3BpeGVscyA9IGZ1bmN0aW9uIChteCwgbXksIGxldmVsKSB7XG4gICAgICAgIHZhciBweCwgcHksIHJlcztcbiAgICAgICAgcmVzID0gdGhpcy5nZXRfcmVzb2x1dGlvbihsZXZlbCk7XG4gICAgICAgIHB4ID0gKG14ICsgdGhpcy54X29yaWdpbl9vZmZzZXQpIC8gcmVzO1xuICAgICAgICBweSA9IChteSArIHRoaXMueV9vcmlnaW5fb2Zmc2V0KSAvIHJlcztcbiAgICAgICAgcmV0dXJuIFtweCwgcHldO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5waXhlbHNfdG9fdGlsZSA9IGZ1bmN0aW9uIChweCwgcHkpIHtcbiAgICAgICAgdmFyIHR4LCB0eTtcbiAgICAgICAgdHggPSBNYXRoLmNlaWwocHggLyBwYXJzZUZsb2F0KHRoaXMudGlsZV9zaXplKSk7XG4gICAgICAgIHR4ID0gdHggPT09IDAgPyB0eCA6IHR4IC0gMTtcbiAgICAgICAgdHkgPSBNYXRoLm1heChNYXRoLmNlaWwocHkgLyBwYXJzZUZsb2F0KHRoaXMudGlsZV9zaXplKSkgLSAxLCAwKTtcbiAgICAgICAgcmV0dXJuIFt0eCwgdHldO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5waXhlbHNfdG9fcmFzdGVyID0gZnVuY3Rpb24gKHB4LCBweSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIG1hcFNpemU7XG4gICAgICAgIG1hcFNpemUgPSB0aGlzLnRpbGVfc2l6ZSA8PCBsZXZlbDtcbiAgICAgICAgcmV0dXJuIFtweCwgbWFwU2l6ZSAtIHB5XTtcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUubWV0ZXJzX3RvX3RpbGUgPSBmdW5jdGlvbiAobXgsIG15LCBsZXZlbCkge1xuICAgICAgICB2YXIgcHgsIHB5LCByZWY7XG4gICAgICAgIHJlZiA9IHRoaXMubWV0ZXJzX3RvX3BpeGVscyhteCwgbXksIGxldmVsKSwgcHggPSByZWZbMF0sIHB5ID0gcmVmWzFdO1xuICAgICAgICByZXR1cm4gdGhpcy5waXhlbHNfdG9fdGlsZShweCwgcHkpO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5nZXRfdGlsZV9tZXRlcl9ib3VuZHMgPSBmdW5jdGlvbiAodHgsIHR5LCBsZXZlbCkge1xuICAgICAgICB2YXIgcmVmLCByZWYxLCB4bWF4LCB4bWluLCB5bWF4LCB5bWluO1xuICAgICAgICByZWYgPSB0aGlzLnBpeGVsc190b19tZXRlcnModHggKiB0aGlzLnRpbGVfc2l6ZSwgdHkgKiB0aGlzLnRpbGVfc2l6ZSwgbGV2ZWwpLCB4bWluID0gcmVmWzBdLCB5bWluID0gcmVmWzFdO1xuICAgICAgICByZWYxID0gdGhpcy5waXhlbHNfdG9fbWV0ZXJzKCh0eCArIDEpICogdGhpcy50aWxlX3NpemUsICh0eSArIDEpICogdGhpcy50aWxlX3NpemUsIGxldmVsKSwgeG1heCA9IHJlZjFbMF0sIHltYXggPSByZWYxWzFdO1xuICAgICAgICBpZiAoKHhtaW4gIT0gbnVsbCkgJiYgKHltaW4gIT0gbnVsbCkgJiYgKHhtYXggIT0gbnVsbCkgJiYgKHltYXggIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbeG1pbiwgeW1pbiwgeG1heCwgeW1heF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLmdldF90aWxlX2dlb2dyYXBoaWNfYm91bmRzID0gZnVuY3Rpb24gKHR4LCB0eSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIGJvdW5kcywgbWF4TGF0LCBtYXhMb24sIG1pbkxhdCwgbWluTG9uLCByZWY7XG4gICAgICAgIGJvdW5kcyA9IHRoaXMuZ2V0X3RpbGVfbWV0ZXJfYm91bmRzKHR4LCB0eSwgbGV2ZWwpO1xuICAgICAgICByZWYgPSB0aGlzLnV0aWxzLm1ldGVyc19leHRlbnRfdG9fZ2VvZ3JhcGhpYyhib3VuZHMpLCBtaW5Mb24gPSByZWZbMF0sIG1pbkxhdCA9IHJlZlsxXSwgbWF4TG9uID0gcmVmWzJdLCBtYXhMYXQgPSByZWZbM107XG4gICAgICAgIHJldHVybiBbbWluTG9uLCBtaW5MYXQsIG1heExvbiwgbWF4TGF0XTtcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0X3RpbGVzX2J5X2V4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIGxldmVsLCB0aWxlX2JvcmRlcikge1xuICAgICAgICB2YXIgaiwgaywgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZWY1LCB0aWxlcywgdHgsIHR4bWF4LCB0eG1pbiwgdHksIHR5bWF4LCB0eW1pbiwgeG1heCwgeG1pbiwgeW1heCwgeW1pbjtcbiAgICAgICAgaWYgKHRpbGVfYm9yZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbGVfYm9yZGVyID0gMTtcbiAgICAgICAgfVxuICAgICAgICB4bWluID0gZXh0ZW50WzBdLCB5bWluID0gZXh0ZW50WzFdLCB4bWF4ID0gZXh0ZW50WzJdLCB5bWF4ID0gZXh0ZW50WzNdO1xuICAgICAgICByZWYgPSB0aGlzLm1ldGVyc190b190aWxlKHhtaW4sIHltaW4sIGxldmVsKSwgdHhtaW4gPSByZWZbMF0sIHR5bWluID0gcmVmWzFdO1xuICAgICAgICByZWYxID0gdGhpcy5tZXRlcnNfdG9fdGlsZSh4bWF4LCB5bWF4LCBsZXZlbCksIHR4bWF4ID0gcmVmMVswXSwgdHltYXggPSByZWYxWzFdO1xuICAgICAgICB0eG1pbiAtPSB0aWxlX2JvcmRlcjtcbiAgICAgICAgdHltaW4gLT0gdGlsZV9ib3JkZXI7XG4gICAgICAgIHR4bWF4ICs9IHRpbGVfYm9yZGVyO1xuICAgICAgICB0eW1heCArPSB0aWxlX2JvcmRlcjtcbiAgICAgICAgdGlsZXMgPSBbXTtcbiAgICAgICAgZm9yICh0eSA9IGogPSByZWYyID0gdHltYXgsIHJlZjMgPSB0eW1pbjsgaiA+PSByZWYzOyB0eSA9IGogKz0gLTEpIHtcbiAgICAgICAgICAgIGZvciAodHggPSBrID0gcmVmNCA9IHR4bWluLCByZWY1ID0gdHhtYXg7IGsgPD0gcmVmNTsgdHggPSBrICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc192YWxpZF90aWxlKHR4LCB0eSwgbGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVzLnB1c2goW3R4LCB0eSwgbGV2ZWwsIHRoaXMuZ2V0X3RpbGVfbWV0ZXJfYm91bmRzKHR4LCB0eSwgbGV2ZWwpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRpbGVzID0gdGhpcy5zb3J0X3RpbGVzX2Zyb21fY2VudGVyKHRpbGVzLCBbdHhtaW4sIHR5bWluLCB0eG1heCwgdHltYXhdKTtcbiAgICAgICAgcmV0dXJuIHRpbGVzO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5xdWFka2V5X3RvX3RpbGVfeHl6ID0gZnVuY3Rpb24gKHF1YWRLZXkpIHtcbiAgICAgICAgJ0NvbXB1dGVzIHRpbGUgeCwgeSBhbmQgeiB2YWx1ZXMgYmFzZWQgb24gcXVhZEtleS4nO1xuICAgICAgICB2YXIgaSwgaiwgbWFzaywgcmVmLCB0aWxlWCwgdGlsZVksIHRpbGVaLCB2YWx1ZTtcbiAgICAgICAgdGlsZVggPSAwO1xuICAgICAgICB0aWxlWSA9IDA7XG4gICAgICAgIHRpbGVaID0gcXVhZEtleS5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IGogPSByZWYgPSB0aWxlWjsgaiA+IDA7IGkgPSBqICs9IC0xKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHF1YWRLZXkuY2hhckF0KHRpbGVaIC0gaSk7XG4gICAgICAgICAgICBtYXNrID0gMSA8PCAoaSAtIDEpO1xuICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICAgICAgICAgICAgdGlsZVggfD0gbWFzaztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnMic6XG4gICAgICAgICAgICAgICAgICAgIHRpbGVZIHw9IG1hc2s7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzMnOlxuICAgICAgICAgICAgICAgICAgICB0aWxlWCB8PSBtYXNrO1xuICAgICAgICAgICAgICAgICAgICB0aWxlWSB8PSBtYXNrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBRdWFka2V5OiBcIiArIHF1YWRLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGlsZVgsIHRpbGVZLCB0aWxlWl07XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLnRpbGVfeHl6X3RvX3F1YWRrZXkgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICAnQ29tcHV0ZXMgcXVhZGtleSB2YWx1ZSBiYXNlZCBvbiB0aWxlIHgsIHkgYW5kIHogdmFsdWVzLic7XG4gICAgICAgIHZhciBkaWdpdCwgaSwgaiwgbWFzaywgcXVhZEtleSwgcmVmO1xuICAgICAgICBxdWFkS2V5ID0gJyc7XG4gICAgICAgIGZvciAoaSA9IGogPSByZWYgPSB6OyBqID4gMDsgaSA9IGogKz0gLTEpIHtcbiAgICAgICAgICAgIGRpZ2l0ID0gMDtcbiAgICAgICAgICAgIG1hc2sgPSAxIDw8IChpIC0gMSk7XG4gICAgICAgICAgICBpZiAoKHggJiBtYXNrKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGRpZ2l0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHkgJiBtYXNrKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGRpZ2l0ICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWFkS2V5ICs9IGRpZ2l0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1YWRLZXk7XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLmNoaWxkcmVuX2J5X3RpbGVfeHl6ID0gZnVuY3Rpb24gKHgsIHksIHopIHtcbiAgICAgICAgdmFyIGIsIGNoaWxkX3RpbGVfeHl6LCBpLCBqLCBxdWFkX2tleSwgcmVmO1xuICAgICAgICBxdWFkX2tleSA9IHRoaXMudGlsZV94eXpfdG9fcXVhZGtleSh4LCB5LCB6KTtcbiAgICAgICAgY2hpbGRfdGlsZV94eXogPSBbXTtcbiAgICAgICAgZm9yIChpID0gaiA9IDA7IGogPD0gMzsgaSA9IGogKz0gMSkge1xuICAgICAgICAgICAgcmVmID0gdGhpcy5xdWFka2V5X3RvX3RpbGVfeHl6KHF1YWRfa2V5ICsgaS50b1N0cmluZygpKSwgeCA9IHJlZlswXSwgeSA9IHJlZlsxXSwgeiA9IHJlZlsyXTtcbiAgICAgICAgICAgIGIgPSB0aGlzLmdldF90aWxlX21ldGVyX2JvdW5kcyh4LCB5LCB6KTtcbiAgICAgICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGlsZF90aWxlX3h5ei5wdXNoKFt4LCB5LCB6LCBiXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkX3RpbGVfeHl6O1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5wYXJlbnRfYnlfdGlsZV94eXogPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICB2YXIgcGFyZW50X3F1YWRfa2V5LCBxdWFkX2tleTtcbiAgICAgICAgcXVhZF9rZXkgPSB0aGlzLnRpbGVfeHl6X3RvX3F1YWRrZXkoeCwgeSwgeik7XG4gICAgICAgIHBhcmVudF9xdWFkX2tleSA9IHF1YWRfa2V5LnN1YnN0cmluZygwLCBxdWFkX2tleS5sZW5ndGggLSAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZGtleV90b190aWxlX3h5eihwYXJlbnRfcXVhZF9rZXkpO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5nZXRfY2xvc2VzdF9wYXJlbnRfYnlfdGlsZV94eXogPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICB2YXIgcXVhZF9rZXksIHJlZiwgcmVmMSwgcmVmMiwgd29ybGRfeDtcbiAgICAgICAgd29ybGRfeCA9IHRoaXMuY2FsY3VsYXRlX3dvcmxkX3hfYnlfdGlsZV94eXooeCwgeSwgeik7XG4gICAgICAgIHJlZiA9IHRoaXMubm9ybWFsaXplX3h5eih4LCB5LCB6KSwgeCA9IHJlZlswXSwgeSA9IHJlZlsxXSwgeiA9IHJlZlsyXTtcbiAgICAgICAgcXVhZF9rZXkgPSB0aGlzLnRpbGVfeHl6X3RvX3F1YWRrZXkoeCwgeSwgeik7XG4gICAgICAgIHdoaWxlIChxdWFkX2tleS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBxdWFkX2tleSA9IHF1YWRfa2V5LnN1YnN0cmluZygwLCBxdWFkX2tleS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHJlZjEgPSB0aGlzLnF1YWRrZXlfdG9fdGlsZV94eXoocXVhZF9rZXkpLCB4ID0gcmVmMVswXSwgeSA9IHJlZjFbMV0sIHogPSByZWYxWzJdO1xuICAgICAgICAgICAgcmVmMiA9IHRoaXMuZGVub3JtYWxpemVfeHl6KHgsIHksIHosIHdvcmxkX3gpLCB4ID0gcmVmMlswXSwgeSA9IHJlZjJbMV0sIHogPSByZWYyWzJdO1xuICAgICAgICAgICAgaWYgKHRoaXMudGlsZV94eXpfdG9fa2V5KHgsIHksIHopIGluIHRoaXMudGlsZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3gsIHksIHpdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLm5vcm1hbGl6ZV94eXogPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICB2YXIgdGlsZV9jb3VudDtcbiAgICAgICAgaWYgKHRoaXMud3JhcF9hcm91bmQpIHtcbiAgICAgICAgICAgIHRpbGVfY291bnQgPSBNYXRoLnBvdygyLCB6KTtcbiAgICAgICAgICAgIHJldHVybiBbKCh4ICUgdGlsZV9jb3VudCkgKyB0aWxlX2NvdW50KSAlIHRpbGVfY291bnQsIHksIHpdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5kZW5vcm1hbGl6ZV94eXogPSBmdW5jdGlvbiAoeCwgeSwgeiwgd29ybGRfeCkge1xuICAgICAgICByZXR1cm4gW3ggKyB3b3JsZF94ICogTWF0aC5wb3coMiwgeiksIHksIHpdO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5kZW5vcm1hbGl6ZV9tZXRlcnMgPSBmdW5jdGlvbiAobWV0ZXJzX3gsIG1ldGVyc195LCBsZXZlbCwgd29ybGRfeCkge1xuICAgICAgICByZXR1cm4gW21ldGVyc194ICsgd29ybGRfeCAqIDIgKiBNYXRoLlBJICogNjM3ODEzNywgbWV0ZXJzX3ldO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5jYWxjdWxhdGVfd29ybGRfeF9ieV90aWxlX3h5eiA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHggLyBNYXRoLnBvdygyLCB6KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyY2F0b3JUaWxlU291cmNlO1xufSkodGlsZV9zb3VyY2VfMS5UaWxlU291cmNlKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtZXJjYXRvcl90aWxlX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vbWVyY2F0b3JfdGlsZV9zb3VyY2VcIik7XG5leHBvcnRzLlFVQURLRVlUaWxlU291cmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFFVQURLRVlUaWxlU291cmNlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBRVUFES0VZVGlsZVNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIFFVQURLRVlUaWxlU291cmNlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBRVUFES0VZVGlsZVNvdXJjZS5wcm90b3R5cGUudHlwZSA9ICdRVUFES0VZVGlsZVNvdXJjZSc7XG4gICAgUVVBREtFWVRpbGVTb3VyY2UucHJvdG90eXBlLmdldF9pbWFnZV91cmwgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICB2YXIgaW1hZ2VfdXJsLCBxdWFkS2V5LCByZWY7XG4gICAgICAgIGltYWdlX3VybCA9IHRoaXMuc3RyaW5nX2xvb2t1cF9yZXBsYWNlKHRoaXMudXJsLCB0aGlzLmV4dHJhX3VybF92YXJzKTtcbiAgICAgICAgcmVmID0gdGhpcy50bXNfdG9fd210cyh4LCB5LCB6KSwgeCA9IHJlZlswXSwgeSA9IHJlZlsxXSwgeiA9IHJlZlsyXTtcbiAgICAgICAgcXVhZEtleSA9IHRoaXMudGlsZV94eXpfdG9fcXVhZGtleSh4LCB5LCB6KTtcbiAgICAgICAgcmV0dXJuIGltYWdlX3VybC5yZXBsYWNlKFwie1F9XCIsIHF1YWRLZXkpO1xuICAgIH07XG4gICAgcmV0dXJuIFFVQURLRVlUaWxlU291cmNlO1xufSkobWVyY2F0b3JfdGlsZV9zb3VyY2VfMS5NZXJjYXRvclRpbGVTb3VyY2UpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmluZCA9IGZ1bmN0aW9uIChmbiwgbWUpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uIChpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pXG4gICAgICAgIHJldHVybiBpO1xufSByZXR1cm4gLTE7IH07XG52YXIgaW1hZ2VfcG9vbF8xID0gcmVxdWlyZShcIi4vaW1hZ2VfcG9vbFwiKTtcbnZhciB3bXRzX3RpbGVfc291cmNlXzEgPSByZXF1aXJlKFwiLi93bXRzX3RpbGVfc291cmNlXCIpO1xudmFyIHJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi4vcmVuZGVyZXJzL3JlbmRlcmVyXCIpO1xudmFyIGRvbV8xID0gcmVxdWlyZShcImNvcmUvZG9tXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xuZXhwb3J0cy5UaWxlUmVuZGVyZXJWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRpbGVSZW5kZXJlclZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRpbGVSZW5kZXJlclZpZXcoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSA9IGJpbmQodGhpcy5fdXBkYXRlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJlZmV0Y2hfdGlsZXMgPSBiaW5kKHRoaXMuX3ByZWZldGNoX3RpbGVzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fb25fdGlsZV9lcnJvciA9IGJpbmQodGhpcy5fb25fdGlsZV9lcnJvciwgdGhpcyk7XG4gICAgICAgIHRoaXMuX29uX3RpbGVfY2FjaGVfbG9hZCA9IGJpbmQodGhpcy5fb25fdGlsZV9jYWNoZV9sb2FkLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fb25fdGlsZV9sb2FkID0gYmluZCh0aGlzLl9vbl90aWxlX2xvYWQsIHRoaXMpO1xuICAgICAgICB0aGlzLl9hZGRfYXR0cmlidXRpb24gPSBiaW5kKHRoaXMuX2FkZF9hdHRyaWJ1dGlvbiwgdGhpcyk7XG4gICAgICAgIHJldHVybiBUaWxlUmVuZGVyZXJWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUaWxlUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGlvbkVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGlsZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIFRpbGVSZW5kZXJlclZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIFRpbGVSZW5kZXJlclZpZXcucHJvdG90eXBlLmNvbm5lY3Rfc2lnbmFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgVGlsZVJlbmRlcmVyVmlldy5fX3N1cGVyX18uY29ubmVjdF9zaWduYWxzLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5jaGFuZ2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGlsZVJlbmRlcmVyVmlldy5wcm90b3R5cGUuZ2V0X2V4dGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnhfcmFuZ2Uuc3RhcnQsIHRoaXMueV9yYW5nZS5zdGFydCwgdGhpcy54X3JhbmdlLmVuZCwgdGhpcy55X3JhbmdlLmVuZF07XG4gICAgfTtcbiAgICBUaWxlUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5fc2V0X2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucG9vbCA9IG5ldyBpbWFnZV9wb29sXzEuSW1hZ2VQb29sKCk7XG4gICAgICAgIHRoaXMubWFwX3Bsb3QgPSB0aGlzLnBsb3RfbW9kZWwucGxvdDtcbiAgICAgICAgdGhpcy5tYXBfY2FudmFzID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzX3ZpZXcuY3R4O1xuICAgICAgICB0aGlzLm1hcF9mcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgdGhpcy54X3JhbmdlID0gdGhpcy5tYXBfcGxvdC54X3JhbmdlO1xuICAgICAgICB0aGlzLnlfcmFuZ2UgPSB0aGlzLm1hcF9wbG90LnlfcmFuZ2U7XG4gICAgICAgIHRoaXMuZXh0ZW50ID0gdGhpcy5nZXRfZXh0ZW50KCk7XG4gICAgICAgIHRoaXMuX2xhc3RfaGVpZ2h0ID0gdm9pZCAwO1xuICAgICAgICByZXR1cm4gdGhpcy5fbGFzdF93aWR0aCA9IHZvaWQgMDtcbiAgICB9O1xuICAgIFRpbGVSZW5kZXJlclZpZXcucHJvdG90eXBlLl9hZGRfYXR0cmlidXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGlvbiwgYm9yZGVyX3dpZHRoLCBib3R0b21fb2Zmc2V0LCBtYXhfd2lkdGgsIG92ZXJsYXlzLCByaWdodF9vZmZzZXQ7XG4gICAgICAgIGF0dHJpYnV0aW9uID0gdGhpcy5tb2RlbC50aWxlX3NvdXJjZS5hdHRyaWJ1dGlvbjtcbiAgICAgICAgaWYgKHR5cGVzXzEuaXNTdHJpbmcoYXR0cmlidXRpb24pICYmIGF0dHJpYnV0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0aW9uRWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJvcmRlcl93aWR0aCA9IHRoaXMubWFwX3Bsb3Qub3V0bGluZV9saW5lX3dpZHRoO1xuICAgICAgICAgICAgICAgIGJvdHRvbV9vZmZzZXQgPSB0aGlzLm1hcF9wbG90Lm1pbl9ib3JkZXJfYm90dG9tICsgYm9yZGVyX3dpZHRoO1xuICAgICAgICAgICAgICAgIHJpZ2h0X29mZnNldCA9IHRoaXMubWFwX2ZyYW1lLl9yaWdodC52YWx1ZSAtIHRoaXMubWFwX2ZyYW1lLl93aWR0aC52YWx1ZTtcbiAgICAgICAgICAgICAgICBtYXhfd2lkdGggPSB0aGlzLm1hcF9mcmFtZS5fd2lkdGgudmFsdWUgLSBib3JkZXJfd2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGlvbkVsID0gZG9tXzEuZGl2KHtcbiAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiOiAnYmstdGlsZS1hdHRyaWJ1dGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogYm90dG9tX29mZnNldCArIFwicHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodF9vZmZzZXQgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4LXdpZHRoJzogbWF4X3dpZHRoICsgXCJweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAncmdiYSgyNTUsMjU1LDI1NSwwLjgpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb250LXNpemUnOiAnOXB0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb250LWZhbWlseSc6ICdzYW5zLXNlcmlmJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3ZlcmxheXMgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5ldmVudHNfZWw7XG4gICAgICAgICAgICAgICAgb3ZlcmxheXMuYXBwZW5kQ2hpbGQodGhpcy5hdHRyaWJ1dGlvbkVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0aW9uRWwuaW5uZXJIVE1MID0gYXR0cmlidXRpb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbGVSZW5kZXJlclZpZXcucHJvdG90eXBlLl9tYXBfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld19leHRlbnQsIHpvb21fbGV2ZWw7XG4gICAgICAgIHRoaXMuaW5pdGlhbF9leHRlbnQgPSB0aGlzLmdldF9leHRlbnQoKTtcbiAgICAgICAgem9vbV9sZXZlbCA9IHRoaXMubW9kZWwudGlsZV9zb3VyY2UuZ2V0X2xldmVsX2J5X2V4dGVudCh0aGlzLmluaXRpYWxfZXh0ZW50LCB0aGlzLm1hcF9mcmFtZS5faGVpZ2h0LnZhbHVlLCB0aGlzLm1hcF9mcmFtZS5fd2lkdGgudmFsdWUpO1xuICAgICAgICBuZXdfZXh0ZW50ID0gdGhpcy5tb2RlbC50aWxlX3NvdXJjZS5zbmFwX3RvX3pvb20odGhpcy5pbml0aWFsX2V4dGVudCwgdGhpcy5tYXBfZnJhbWUuX2hlaWdodC52YWx1ZSwgdGhpcy5tYXBfZnJhbWUuX3dpZHRoLnZhbHVlLCB6b29tX2xldmVsKTtcbiAgICAgICAgdGhpcy54X3JhbmdlLnN0YXJ0ID0gbmV3X2V4dGVudFswXTtcbiAgICAgICAgdGhpcy55X3JhbmdlLnN0YXJ0ID0gbmV3X2V4dGVudFsxXTtcbiAgICAgICAgdGhpcy54X3JhbmdlLmVuZCA9IG5ld19leHRlbnRbMl07XG4gICAgICAgIHRoaXMueV9yYW5nZS5lbmQgPSBuZXdfZXh0ZW50WzNdO1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkX2F0dHJpYnV0aW9uKCk7XG4gICAgfTtcbiAgICBUaWxlUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5fb25fdGlsZV9sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHRpbGVfZGF0YTtcbiAgICAgICAgdGlsZV9kYXRhID0gZS50YXJnZXQudGlsZV9kYXRhO1xuICAgICAgICB0aWxlX2RhdGEuaW1nID0gZS50YXJnZXQ7XG4gICAgICAgIHRpbGVfZGF0YS5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgdGlsZV9kYXRhLmxvYWRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgfTtcbiAgICBUaWxlUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5fb25fdGlsZV9jYWNoZV9sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHRpbGVfZGF0YTtcbiAgICAgICAgdGlsZV9kYXRhID0gZS50YXJnZXQudGlsZV9kYXRhO1xuICAgICAgICB0aWxlX2RhdGEuaW1nID0gZS50YXJnZXQ7XG4gICAgICAgIHRpbGVfZGF0YS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICB0aWxlX2RhdGEuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5ub3RpZnlfZmluaXNoZWQoKTtcbiAgICB9O1xuICAgIFRpbGVSZW5kZXJlclZpZXcucHJvdG90eXBlLl9vbl90aWxlX2Vycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHRpbGVfZGF0YTtcbiAgICAgICAgdGlsZV9kYXRhID0gZS50YXJnZXQudGlsZV9kYXRhO1xuICAgICAgICByZXR1cm4gdGlsZV9kYXRhLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFRpbGVSZW5kZXJlclZpZXcucHJvdG90eXBlLl9jcmVhdGVfdGlsZSA9IGZ1bmN0aW9uICh4LCB5LCB6LCBib3VuZHMsIGNhY2hlX29ubHkpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRfY29vcmRzLCByZWYsIHRpbGU7XG4gICAgICAgIGlmIChjYWNoZV9vbmx5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNhY2hlX29ubHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVkX2Nvb3JkcyA9IHRoaXMubW9kZWwudGlsZV9zb3VyY2Uubm9ybWFsaXplX3h5eih4LCB5LCB6KTtcbiAgICAgICAgdGlsZSA9IHRoaXMucG9vbC5wb3AoKTtcbiAgICAgICAgaWYgKGNhY2hlX29ubHkpIHtcbiAgICAgICAgICAgIHRpbGUub25sb2FkID0gdGhpcy5fb25fdGlsZV9jYWNoZV9sb2FkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGlsZS5vbmxvYWQgPSB0aGlzLl9vbl90aWxlX2xvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGlsZS5vbmVycm9yID0gdGhpcy5fb25fdGlsZV9lcnJvcjtcbiAgICAgICAgdGlsZS5hbHQgPSAnJztcbiAgICAgICAgdGlsZS50aWxlX2RhdGEgPSB7XG4gICAgICAgICAgICB0aWxlX2Nvb3JkczogW3gsIHksIHpdLFxuICAgICAgICAgICAgbm9ybWFsaXplZF9jb29yZHM6IG5vcm1hbGl6ZWRfY29vcmRzLFxuICAgICAgICAgICAgcXVhZGtleTogdGhpcy5tb2RlbC50aWxlX3NvdXJjZS50aWxlX3h5el90b19xdWFka2V5KHgsIHksIHopLFxuICAgICAgICAgICAgY2FjaGVfa2V5OiB0aGlzLm1vZGVsLnRpbGVfc291cmNlLnRpbGVfeHl6X3RvX2tleSh4LCB5LCB6KSxcbiAgICAgICAgICAgIGJvdW5kczogYm91bmRzLFxuICAgICAgICAgICAgbG9hZGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGZpbmlzaGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHhfY29vcmQ6IGJvdW5kc1swXSxcbiAgICAgICAgICAgIHlfY29vcmQ6IGJvdW5kc1szXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1vZGVsLnRpbGVfc291cmNlLnRpbGVzW3RpbGUudGlsZV9kYXRhLmNhY2hlX2tleV0gPSB0aWxlLnRpbGVfZGF0YTtcbiAgICAgICAgdGlsZS5zcmMgPSAocmVmID0gdGhpcy5tb2RlbC50aWxlX3NvdXJjZSkuZ2V0X2ltYWdlX3VybC5hcHBseShyZWYsIG5vcm1hbGl6ZWRfY29vcmRzKTtcbiAgICAgICAgdGhpcy5fdGlsZXMucHVzaCh0aWxlKTtcbiAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgfTtcbiAgICBUaWxlUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5fZW5mb3JjZV9hc3BlY3RfcmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBleHRlbnQsIG5ld19leHRlbnQsIHpvb21fbGV2ZWw7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0X2hlaWdodCAhPT0gdGhpcy5tYXBfZnJhbWUuX2hlaWdodC52YWx1ZSB8fCB0aGlzLl9sYXN0X3dpZHRoICE9PSB0aGlzLm1hcF9mcmFtZS5fd2lkdGgudmFsdWUpIHtcbiAgICAgICAgICAgIGV4dGVudCA9IHRoaXMuZ2V0X2V4dGVudCgpO1xuICAgICAgICAgICAgem9vbV9sZXZlbCA9IHRoaXMubW9kZWwudGlsZV9zb3VyY2UuZ2V0X2xldmVsX2J5X2V4dGVudChleHRlbnQsIHRoaXMubWFwX2ZyYW1lLl9oZWlnaHQudmFsdWUsIHRoaXMubWFwX2ZyYW1lLl93aWR0aC52YWx1ZSk7XG4gICAgICAgICAgICBuZXdfZXh0ZW50ID0gdGhpcy5tb2RlbC50aWxlX3NvdXJjZS5zbmFwX3RvX3pvb20oZXh0ZW50LCB0aGlzLm1hcF9mcmFtZS5faGVpZ2h0LnZhbHVlLCB0aGlzLm1hcF9mcmFtZS5fd2lkdGgudmFsdWUsIHpvb21fbGV2ZWwpO1xuICAgICAgICAgICAgdGhpcy54X3JhbmdlLnNldHYoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBuZXdfZXh0ZW50WzBdLFxuICAgICAgICAgICAgICAgIGVuZDogbmV3X2V4dGVudFsyXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnlfcmFuZ2Uuc2V0dih7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG5ld19leHRlbnRbMV0sXG4gICAgICAgICAgICAgICAgZW5kOiBuZXdfZXh0ZW50WzNdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW50ID0gbmV3X2V4dGVudDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RfaGVpZ2h0ID0gdGhpcy5tYXBfZnJhbWUuX2hlaWdodC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3Rfd2lkdGggPSB0aGlzLm1hcF9mcmFtZS5fd2lkdGgudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBUaWxlUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5oYXNfZmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLCBsZW4sIHJlZiwgdGlsZTtcbiAgICAgICAgaWYgKCFUaWxlUmVuZGVyZXJWaWV3Ll9fc3VwZXJfXy5oYXNfZmluaXNoZWQuY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90aWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZWYgPSB0aGlzLl90aWxlcztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aWxlID0gcmVmW2ldO1xuICAgICAgICAgICAgaWYgKCF0aWxlLnRpbGVfZGF0YS5maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFRpbGVSZW5kZXJlclZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwX2luaXRpYWxpemVkID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldF9kYXRhKCk7XG4gICAgICAgICAgICB0aGlzLl9tYXBfZGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5tYXBfaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lbmZvcmNlX2FzcGVjdF9yYXRpbygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLnByZWZldGNoX3RpbWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnByZWZldGNoX3RpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZWZldGNoX3RpbWVyID0gc2V0VGltZW91dCh0aGlzLl9wcmVmZXRjaF90aWxlcywgNTAwKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzX2ZpbmlzaGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vdGlmeV9maW5pc2hlZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaWxlUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5fZHJhd190aWxlID0gZnVuY3Rpb24gKHRpbGVfa2V5KSB7XG4gICAgICAgIHZhciByZWYsIHJlZjEsIHNoLCBzdywgc3gsIHN4bWF4LCBzeG1pbiwgc3ksIHN5bWF4LCBzeW1pbiwgdGlsZV9vYmo7XG4gICAgICAgIHRpbGVfb2JqID0gdGhpcy5tb2RlbC50aWxlX3NvdXJjZS50aWxlc1t0aWxlX2tleV07XG4gICAgICAgIGlmICh0aWxlX29iaiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZWYgPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS5tYXBfdG9fc2NyZWVuKFt0aWxlX29iai5ib3VuZHNbMF1dLCBbdGlsZV9vYmouYm91bmRzWzNdXSwgdGhpcy5wbG90X3ZpZXcuY2FudmFzKSwgc3htaW4gPSByZWZbMF0sIHN5bWluID0gcmVmWzFdO1xuICAgICAgICAgICAgcmVmMSA9IHRoaXMucGxvdF92aWV3LmZyYW1lLm1hcF90b19zY3JlZW4oW3RpbGVfb2JqLmJvdW5kc1syXV0sIFt0aWxlX29iai5ib3VuZHNbMV1dLCB0aGlzLnBsb3Rfdmlldy5jYW52YXMpLCBzeG1heCA9IHJlZjFbMF0sIHN5bWF4ID0gcmVmMVsxXTtcbiAgICAgICAgICAgIHN4bWluID0gc3htaW5bMF07XG4gICAgICAgICAgICBzeW1pbiA9IHN5bWluWzBdO1xuICAgICAgICAgICAgc3htYXggPSBzeG1heFswXTtcbiAgICAgICAgICAgIHN5bWF4ID0gc3ltYXhbMF07XG4gICAgICAgICAgICBzdyA9IHN4bWF4IC0gc3htaW47XG4gICAgICAgICAgICBzaCA9IHN5bWF4IC0gc3ltaW47XG4gICAgICAgICAgICBzeCA9IHN4bWluO1xuICAgICAgICAgICAgc3kgPSBzeW1pbjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcF9jYW52YXMuZHJhd0ltYWdlKHRpbGVfb2JqLmltZywgc3gsIHN5LCBzdywgc2gpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaWxlUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5fc2V0X3JlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoLCBsLCBvdXRsaW5lX3dpZHRoLCB0LCB3O1xuICAgICAgICBvdXRsaW5lX3dpZHRoID0gdGhpcy5wbG90X21vZGVsLnBsb3QucHJvcGVydGllcy5vdXRsaW5lX2xpbmVfd2lkdGgudmFsdWUoKTtcbiAgICAgICAgbCA9IHRoaXMucGxvdF92aWV3LmNhbnZhcy52eF90b19zeCh0aGlzLm1hcF9mcmFtZS5fbGVmdC52YWx1ZSkgKyAob3V0bGluZV93aWR0aCAvIDIpO1xuICAgICAgICB0ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzLnZ5X3RvX3N5KHRoaXMubWFwX2ZyYW1lLl90b3AudmFsdWUpICsgKG91dGxpbmVfd2lkdGggLyAyKTtcbiAgICAgICAgdyA9IHRoaXMubWFwX2ZyYW1lLl93aWR0aC52YWx1ZSAtIG91dGxpbmVfd2lkdGg7XG4gICAgICAgIGggPSB0aGlzLm1hcF9mcmFtZS5faGVpZ2h0LnZhbHVlIC0gb3V0bGluZV93aWR0aDtcbiAgICAgICAgdGhpcy5tYXBfY2FudmFzLnJlY3QobCwgdCwgdywgaCk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcF9jYW52YXMuY2xpcCgpO1xuICAgIH07XG4gICAgVGlsZVJlbmRlcmVyVmlldy5wcm90b3R5cGUuX3JlbmRlcl90aWxlcyA9IGZ1bmN0aW9uICh0aWxlX2tleXMpIHtcbiAgICAgICAgdmFyIGksIGxlbiwgdGlsZV9rZXk7XG4gICAgICAgIHRoaXMubWFwX2NhbnZhcy5zYXZlKCk7XG4gICAgICAgIHRoaXMuX3NldF9yZWN0KCk7XG4gICAgICAgIHRoaXMubWFwX2NhbnZhcy5nbG9iYWxBbHBoYSA9IHRoaXMubW9kZWwuYWxwaGE7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRpbGVfa2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGlsZV9rZXkgPSB0aWxlX2tleXNbaV07XG4gICAgICAgICAgICB0aGlzLl9kcmF3X3RpbGUodGlsZV9rZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hcF9jYW52YXMucmVzdG9yZSgpO1xuICAgIH07XG4gICAgVGlsZVJlbmRlcmVyVmlldy5wcm90b3R5cGUuX3ByZWZldGNoX3RpbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm91bmRzLCBjLCBjYm91bmRzLCBjaGlsZHJlbiwgY3gsIGN5LCBjeiwgZXh0ZW50LCBoLCBpLCByZWYsIHJlc3VsdHMsIHQsIHRpbGVfc291cmNlLCB0aWxlcywgdywgeCwgeSwgeiwgem9vbV9sZXZlbDtcbiAgICAgICAgdGlsZV9zb3VyY2UgPSB0aGlzLm1vZGVsLnRpbGVfc291cmNlO1xuICAgICAgICBleHRlbnQgPSB0aGlzLmdldF9leHRlbnQoKTtcbiAgICAgICAgaCA9IHRoaXMubWFwX2ZyYW1lLl9oZWlnaHQudmFsdWU7XG4gICAgICAgIHcgPSB0aGlzLm1hcF9mcmFtZS5fd2lkdGgudmFsdWU7XG4gICAgICAgIHpvb21fbGV2ZWwgPSB0aGlzLm1vZGVsLnRpbGVfc291cmNlLmdldF9sZXZlbF9ieV9leHRlbnQoZXh0ZW50LCBoLCB3KTtcbiAgICAgICAgdGlsZXMgPSB0aGlzLm1vZGVsLnRpbGVfc291cmNlLmdldF90aWxlc19ieV9leHRlbnQoZXh0ZW50LCB6b29tX2xldmVsKTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHQgPSBpID0gMCwgcmVmID0gTWF0aC5taW4oMTAsIHRpbGVzLmxlbmd0aCk7IGkgPD0gcmVmOyB0ID0gaSArPSAxKSB7XG4gICAgICAgICAgICB4ID0gdFswXSwgeSA9IHRbMV0sIHogPSB0WzJdLCBib3VuZHMgPSB0WzNdO1xuICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLm1vZGVsLnRpbGVfc291cmNlLmNoaWxkcmVuX2J5X3RpbGVfeHl6KHgsIHksIHopO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIGxlbiwgcmVzdWx0czE7XG4gICAgICAgICAgICAgICAgcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjID0gY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgICAgICAgIGN4ID0gY1swXSwgY3kgPSBjWzFdLCBjeiA9IGNbMl0sIGNib3VuZHMgPSBjWzNdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGlsZV9zb3VyY2UudGlsZV94eXpfdG9fa2V5KGN4LCBjeSwgY3opIGluIHRpbGVfc291cmNlLnRpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMxLnB1c2godGhpcy5fY3JlYXRlX3RpbGUoY3gsIGN5LCBjeiwgY2JvdW5kcywgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzMTtcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgVGlsZVJlbmRlcmVyVmlldy5wcm90b3R5cGUuX2ZldGNoX3RpbGVzID0gZnVuY3Rpb24gKHRpbGVzKSB7XG4gICAgICAgIHZhciBib3VuZHMsIGksIGxlbiwgcmVzdWx0cywgdCwgeCwgeSwgejtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdCA9IHRpbGVzW2ldO1xuICAgICAgICAgICAgeCA9IHRbMF0sIHkgPSB0WzFdLCB6ID0gdFsyXSwgYm91bmRzID0gdFszXTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLl9jcmVhdGVfdGlsZSh4LCB5LCB6LCBib3VuZHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIFRpbGVSZW5kZXJlclZpZXcucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBib3VuZHMsIGMsIGNhY2hlZCwgY2JvdW5kcywgY2hpbGRfa2V5LCBjaGlsZHJlbiwgY3gsIGN5LCBjeiwgZXh0ZW50LCBoLCBpLCBqLCBrLCBrZXksIGxlbiwgbGVuMSwgbGVuMiwgbWF4X3pvb20sIG1pbl96b29tLCBuZWVkX2xvYWQsIHBhcmVudF9rZXksIHBhcmVudF90aWxlLCBwYXJlbnRzLCBweCwgcHksIHB6LCByZWYsIHNuYXBfYmFjaywgdCwgdGlsZSwgdGlsZV9zb3VyY2UsIHRpbGVzLCB3LCB4LCB5LCB6LCB6b29tX2xldmVsLCB6b29taW5nX291dDtcbiAgICAgICAgdGlsZV9zb3VyY2UgPSB0aGlzLm1vZGVsLnRpbGVfc291cmNlO1xuICAgICAgICBtaW5fem9vbSA9IHRpbGVfc291cmNlLm1pbl96b29tO1xuICAgICAgICBtYXhfem9vbSA9IHRpbGVfc291cmNlLm1heF96b29tO1xuICAgICAgICB0aWxlX3NvdXJjZS51cGRhdGUoKTtcbiAgICAgICAgZXh0ZW50ID0gdGhpcy5nZXRfZXh0ZW50KCk7XG4gICAgICAgIHpvb21pbmdfb3V0ID0gdGhpcy5leHRlbnRbMl0gLSB0aGlzLmV4dGVudFswXSA8IGV4dGVudFsyXSAtIGV4dGVudFswXTtcbiAgICAgICAgaCA9IHRoaXMubWFwX2ZyYW1lLl9oZWlnaHQudmFsdWU7XG4gICAgICAgIHcgPSB0aGlzLm1hcF9mcmFtZS5fd2lkdGgudmFsdWU7XG4gICAgICAgIHpvb21fbGV2ZWwgPSB0aWxlX3NvdXJjZS5nZXRfbGV2ZWxfYnlfZXh0ZW50KGV4dGVudCwgaCwgdyk7XG4gICAgICAgIHNuYXBfYmFjayA9IGZhbHNlO1xuICAgICAgICBpZiAoem9vbV9sZXZlbCA8IG1pbl96b29tKSB7XG4gICAgICAgICAgICBleHRlbnQgPSB0aGlzLmV4dGVudDtcbiAgICAgICAgICAgIHpvb21fbGV2ZWwgPSBtaW5fem9vbTtcbiAgICAgICAgICAgIHNuYXBfYmFjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoem9vbV9sZXZlbCA+IG1heF96b29tKSB7XG4gICAgICAgICAgICBleHRlbnQgPSB0aGlzLmV4dGVudDtcbiAgICAgICAgICAgIHpvb21fbGV2ZWwgPSBtYXhfem9vbTtcbiAgICAgICAgICAgIHNuYXBfYmFjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNuYXBfYmFjaykge1xuICAgICAgICAgICAgdGhpcy54X3JhbmdlLnNldHYoe1xuICAgICAgICAgICAgICAgIHhfcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGV4dGVudFswXSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBleHRlbnRbMl1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMueV9yYW5nZS5zZXR2KHtcbiAgICAgICAgICAgICAgICBzdGFydDogZXh0ZW50WzFdLFxuICAgICAgICAgICAgICAgIGVuZDogZXh0ZW50WzNdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50O1xuICAgICAgICB0aWxlcyA9IHRpbGVfc291cmNlLmdldF90aWxlc19ieV9leHRlbnQoZXh0ZW50LCB6b29tX2xldmVsKTtcbiAgICAgICAgcGFyZW50cyA9IFtdO1xuICAgICAgICBuZWVkX2xvYWQgPSBbXTtcbiAgICAgICAgY2FjaGVkID0gW107XG4gICAgICAgIGNoaWxkcmVuID0gW107XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRpbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0ID0gdGlsZXNbaV07XG4gICAgICAgICAgICB4ID0gdFswXSwgeSA9IHRbMV0sIHogPSB0WzJdLCBib3VuZHMgPSB0WzNdO1xuICAgICAgICAgICAga2V5ID0gdGlsZV9zb3VyY2UudGlsZV94eXpfdG9fa2V5KHgsIHksIHopO1xuICAgICAgICAgICAgdGlsZSA9IHRpbGVfc291cmNlLnRpbGVzW2tleV07XG4gICAgICAgICAgICBpZiAoKHRpbGUgIT0gbnVsbCkgJiYgdGlsZS5sb2FkZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWQucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwucmVuZGVyX3BhcmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmID0gdGlsZV9zb3VyY2UuZ2V0X2Nsb3Nlc3RfcGFyZW50X2J5X3RpbGVfeHl6KHgsIHksIHopLCBweCA9IHJlZlswXSwgcHkgPSByZWZbMV0sIHB6ID0gcmVmWzJdO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRfa2V5ID0gdGlsZV9zb3VyY2UudGlsZV94eXpfdG9fa2V5KHB4LCBweSwgcHopO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRfdGlsZSA9IHRpbGVfc291cmNlLnRpbGVzW3BhcmVudF9rZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHBhcmVudF90aWxlICE9IG51bGwpICYmIHBhcmVudF90aWxlLmxvYWRlZCAmJiBpbmRleE9mLmNhbGwocGFyZW50cywgcGFyZW50X2tleSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2gocGFyZW50X2tleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHpvb21pbmdfb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRpbGVfc291cmNlLmNoaWxkcmVuX2J5X3RpbGVfeHl6KHgsIHksIHopO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuMSA9IGNoaWxkcmVuLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBjaGlsZHJlbltqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeCA9IGNbMF0sIGN5ID0gY1sxXSwgY3ogPSBjWzJdLCBjYm91bmRzID0gY1szXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZF9rZXkgPSB0aWxlX3NvdXJjZS50aWxlX3h5el90b19rZXkoY3gsIGN5LCBjeik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkX2tleSBpbiB0aWxlX3NvdXJjZS50aWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkX2tleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5lZWRfbG9hZC5wdXNoKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlcl90aWxlcyhwYXJlbnRzKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyX3RpbGVzKGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyX3RpbGVzKGNhY2hlZCk7XG4gICAgICAgIGZvciAoayA9IDAsIGxlbjIgPSBjYWNoZWQubGVuZ3RoOyBrIDwgbGVuMjsgaysrKSB7XG4gICAgICAgICAgICB0ID0gY2FjaGVkW2tdO1xuICAgICAgICAgICAgdGlsZV9zb3VyY2UudGlsZXNbdF0uY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVuZGVyX3RpbWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbmRlcl90aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyX3RpbWVyID0gc2V0VGltZW91dCgoKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2ZldGNoX3RpbGVzKG5lZWRfbG9hZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSksIDY1KTtcbiAgICB9O1xuICAgIHJldHVybiBUaWxlUmVuZGVyZXJWaWV3O1xufSkocmVuZGVyZXJfMS5SZW5kZXJlclZpZXcpO1xuZXhwb3J0cy5UaWxlUmVuZGVyZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVGlsZVJlbmRlcmVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUaWxlUmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiBUaWxlUmVuZGVyZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRpbGVSZW5kZXJlci5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5UaWxlUmVuZGVyZXJWaWV3O1xuICAgIFRpbGVSZW5kZXJlci5wcm90b3R5cGUudHlwZSA9ICdUaWxlUmVuZGVyZXInO1xuICAgIFRpbGVSZW5kZXJlci5kZWZpbmUoe1xuICAgICAgICBhbHBoYTogW3AuTnVtYmVyLCAxLjBdLFxuICAgICAgICB4X3JhbmdlX25hbWU6IFtwLlN0cmluZywgXCJkZWZhdWx0XCJdLFxuICAgICAgICB5X3JhbmdlX25hbWU6IFtwLlN0cmluZywgXCJkZWZhdWx0XCJdLFxuICAgICAgICB0aWxlX3NvdXJjZTogW1xuICAgICAgICAgICAgcC5JbnN0YW5jZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd210c190aWxlX3NvdXJjZV8xLldNVFNUaWxlU291cmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHJlbmRlcl9wYXJlbnRzOiBbcC5Cb29sLCB0cnVlXVxuICAgIH0pO1xuICAgIFRpbGVSZW5kZXJlci5vdmVycmlkZSh7XG4gICAgICAgIGxldmVsOiAndW5kZXJsYXknXG4gICAgfSk7XG4gICAgcmV0dXJuIFRpbGVSZW5kZXJlcjtcbn0pKHJlbmRlcmVyXzEuUmVuZGVyZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGltYWdlX3Bvb2xfMSA9IHJlcXVpcmUoXCIuL2ltYWdlX3Bvb2xcIik7XG52YXIgdGlsZV91dGlsc18xID0gcmVxdWlyZShcIi4vdGlsZV91dGlsc1wiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxcIik7XG5leHBvcnRzLlRpbGVTb3VyY2UgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVGlsZVNvdXJjZSwgc3VwZXJDbGFzcyk7XG4gICAgVGlsZVNvdXJjZS5wcm90b3R5cGUudHlwZSA9ICdUaWxlU291cmNlJztcbiAgICBUaWxlU291cmNlLmRlZmluZSh7XG4gICAgICAgIHVybDogW3AuU3RyaW5nLCAnJ10sXG4gICAgICAgIHRpbGVfc2l6ZTogW3AuTnVtYmVyLCAyNTZdLFxuICAgICAgICBtYXhfem9vbTogW3AuTnVtYmVyLCAzMF0sXG4gICAgICAgIG1pbl96b29tOiBbcC5OdW1iZXIsIDBdLFxuICAgICAgICBleHRyYV91cmxfdmFyczogW3AuQW55LCB7fV0sXG4gICAgICAgIGF0dHJpYnV0aW9uOiBbcC5TdHJpbmcsICcnXSxcbiAgICAgICAgeF9vcmlnaW5fb2Zmc2V0OiBbcC5OdW1iZXJdLFxuICAgICAgICB5X29yaWdpbl9vZmZzZXQ6IFtwLk51bWJlcl0sXG4gICAgICAgIGluaXRpYWxfcmVzb2x1dGlvbjogW3AuTnVtYmVyXVxuICAgIH0pO1xuICAgIFRpbGVTb3VyY2UucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBUaWxlU291cmNlLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZV9jYXNlKCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBUaWxlU291cmNlKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIFRpbGVTb3VyY2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudXRpbHMgPSBuZXcgdGlsZV91dGlsc18xLlByb2plY3Rpb25VdGlscygpO1xuICAgICAgICB0aGlzLnBvb2wgPSBuZXcgaW1hZ2VfcG9vbF8xLkltYWdlUG9vbCgpO1xuICAgICAgICB0aGlzLnRpbGVzID0ge307XG4gICAgICAgIHRoaXMubm9ybWFsaXplX2Nhc2UoKTtcbiAgICB9XG4gICAgVGlsZVNvdXJjZS5wcm90b3R5cGUuc3RyaW5nX2xvb2t1cF9yZXBsYWNlID0gZnVuY3Rpb24gKHN0ciwgbG9va3VwKSB7XG4gICAgICAgIHZhciBrZXksIHJlc3VsdF9zdHIsIHZhbHVlO1xuICAgICAgICByZXN1bHRfc3RyID0gc3RyO1xuICAgICAgICBmb3IgKGtleSBpbiBsb29rdXApIHtcbiAgICAgICAgICAgIHZhbHVlID0gbG9va3VwW2tleV07XG4gICAgICAgICAgICByZXN1bHRfc3RyID0gcmVzdWx0X3N0ci5yZXBsYWNlKCd7JyArIGtleSArICd9JywgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdF9zdHI7XG4gICAgfTtcbiAgICBUaWxlU291cmNlLnByb3RvdHlwZS5ub3JtYWxpemVfY2FzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJ05vdGU6IHNob3VsZCBwcm9iYWJseSBiZSByZWZhY3RvcmVkIGludG8gc3ViY2xhc3Nlcy4nO1xuICAgICAgICB2YXIgdXJsO1xuICAgICAgICB1cmwgPSB0aGlzLnVybDtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ3t4fScsICd7WH0nKTtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ3t5fScsICd7WX0nKTtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ3t6fScsICd7Wn0nKTtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ3txfScsICd7UX0nKTtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ3t4bWlufScsICd7WE1JTn0nKTtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ3t5bWlufScsICd7WU1JTn0nKTtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ3t4bWF4fScsICd7WE1BWH0nKTtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ3t5bWF4fScsICd7WU1BWH0nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsID0gdXJsO1xuICAgIH07XG4gICAgVGlsZVNvdXJjZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5LCByZWYsIHJlc3VsdHMsIHRpbGU7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJUaWxlU291cmNlOiB0aWxlIGNhY2hlIGNvdW50OiBcIiArIChPYmplY3Qua2V5cyh0aGlzLnRpbGVzKS5sZW5ndGgpKTtcbiAgICAgICAgcmVmID0gdGhpcy50aWxlcztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiByZWYpIHtcbiAgICAgICAgICAgIHRpbGUgPSByZWZba2V5XTtcbiAgICAgICAgICAgIHRpbGUuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRpbGUucmV0YWluID0gZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgVGlsZVNvdXJjZS5wcm90b3R5cGUudGlsZV94eXpfdG9fa2V5ID0gZnVuY3Rpb24gKHgsIHksIHopIHtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAga2V5ID0geCArIFwiOlwiICsgeSArIFwiOlwiICsgejtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICAgIFRpbGVTb3VyY2UucHJvdG90eXBlLmtleV90b190aWxlX3h5eiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVmID0ga2V5LnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjID0gcmVmW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChwYXJzZUludChjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICB9O1xuICAgIFRpbGVTb3VyY2UucHJvdG90eXBlLnNvcnRfdGlsZXNfZnJvbV9jZW50ZXIgPSBmdW5jdGlvbiAodGlsZXMsIHRpbGVfZXh0ZW50KSB7XG4gICAgICAgIHZhciBjZW50ZXJfeCwgY2VudGVyX3ksIHR4bWF4LCB0eG1pbiwgdHltYXgsIHR5bWluO1xuICAgICAgICB0eG1pbiA9IHRpbGVfZXh0ZW50WzBdLCB0eW1pbiA9IHRpbGVfZXh0ZW50WzFdLCB0eG1heCA9IHRpbGVfZXh0ZW50WzJdLCB0eW1heCA9IHRpbGVfZXh0ZW50WzNdO1xuICAgICAgICBjZW50ZXJfeCA9ICh0eG1heCAtIHR4bWluKSAvIDIgKyB0eG1pbjtcbiAgICAgICAgY2VudGVyX3kgPSAodHltYXggLSB0eW1pbikgLyAyICsgdHltaW47XG4gICAgICAgIHRpbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBhX2Rpc3RhbmNlLCBiX2Rpc3RhbmNlO1xuICAgICAgICAgICAgYV9kaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyhjZW50ZXJfeCAtIGFbMF0sIDIpICsgTWF0aC5wb3coY2VudGVyX3kgLSBhWzFdLCAyKSk7XG4gICAgICAgICAgICBiX2Rpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KGNlbnRlcl94IC0gYlswXSwgMikgKyBNYXRoLnBvdyhjZW50ZXJfeSAtIGJbMV0sIDIpKTtcbiAgICAgICAgICAgIHJldHVybiBhX2Rpc3RhbmNlIC0gYl9kaXN0YW5jZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aWxlcztcbiAgICB9O1xuICAgIFRpbGVTb3VyY2UucHJvdG90eXBlLnBydW5lX3RpbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5LCByZWYsIHJlZjEsIHJlc3VsdHMsIHRpbGU7XG4gICAgICAgIHJlZiA9IHRoaXMudGlsZXM7XG4gICAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICAgICAgdGlsZSA9IHJlZltrZXldO1xuICAgICAgICAgICAgdGlsZS5yZXRhaW4gPSB0aWxlLmN1cnJlbnQgfHwgdGlsZS50aWxlX2Nvb3Jkc1syXSA8IDM7XG4gICAgICAgICAgICBpZiAodGlsZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRhaW5fbmVpZ2hib3JzKHRpbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMucmV0YWluX2NoaWxkcmVuKHRpbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMucmV0YWluX3BhcmVudHModGlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVmMSA9IHRoaXMudGlsZXM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gcmVmMSkge1xuICAgICAgICAgICAgdGlsZSA9IHJlZjFba2V5XTtcbiAgICAgICAgICAgIGlmICghdGlsZS5yZXRhaW4pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5yZW1vdmVfdGlsZShrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgVGlsZVNvdXJjZS5wcm90b3R5cGUucmVtb3ZlX3RpbGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aWxlO1xuICAgICAgICB0aWxlID0gdGhpcy50aWxlc1trZXldO1xuICAgICAgICBpZiAodGlsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnBvb2wucHVzaCh0aWxlLmltZyk7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlIHRoaXMudGlsZXNba2V5XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0X2ltYWdlX3VybCA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgIHZhciBpbWFnZV91cmw7XG4gICAgICAgIGltYWdlX3VybCA9IHRoaXMuc3RyaW5nX2xvb2t1cF9yZXBsYWNlKHRoaXMudXJsLCB0aGlzLmV4dHJhX3VybF92YXJzKTtcbiAgICAgICAgcmV0dXJuIGltYWdlX3VybC5yZXBsYWNlKFwie1h9XCIsIHgpLnJlcGxhY2UoJ3tZfScsIHkpLnJlcGxhY2UoXCJ7Wn1cIiwgeik7XG4gICAgfTtcbiAgICBUaWxlU291cmNlLnByb3RvdHlwZS5yZXRhaW5fbmVpZ2hib3JzID0gZnVuY3Rpb24gKHJlZmVyZW5jZV90aWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBJbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xuICAgIFRpbGVTb3VyY2UucHJvdG90eXBlLnJldGFpbl9wYXJlbnRzID0gZnVuY3Rpb24gKHJlZmVyZW5jZV90aWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBJbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xuICAgIFRpbGVTb3VyY2UucHJvdG90eXBlLnJldGFpbl9jaGlsZHJlbiA9IGZ1bmN0aW9uIChyZWZlcmVuY2VfdGlsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgSW1wbGVtZW50ZWRcIik7XG4gICAgfTtcbiAgICBUaWxlU291cmNlLnByb3RvdHlwZS50aWxlX3h5el90b19xdWFka2V5ID0gZnVuY3Rpb24gKHgsIHksIHopIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IEltcGxlbWVudGVkXCIpO1xuICAgIH07XG4gICAgVGlsZVNvdXJjZS5wcm90b3R5cGUucXVhZGtleV90b190aWxlX3h5eiA9IGZ1bmN0aW9uIChxdWFka2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBJbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xuICAgIHJldHVybiBUaWxlU291cmNlO1xufSkobW9kZWxfMS5Nb2RlbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcm9qNF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9wcm9qNFwiKTtcbmV4cG9ydHMuUHJvamVjdGlvblV0aWxzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm9qZWN0aW9uVXRpbHMoKSB7XG4gICAgICAgIHRoaXMub3JpZ2luX3NoaWZ0ID0gMiAqIE1hdGguUEkgKiA2Mzc4MTM3IC8gMi4wO1xuICAgIH1cbiAgICBQcm9qZWN0aW9uVXRpbHMucHJvdG90eXBlLmdlb2dyYXBoaWNfdG9fbWV0ZXJzID0gZnVuY3Rpb24gKHhMb24sIHlMYXQpIHtcbiAgICAgICAgcmV0dXJuIHByb2o0XzEucHJvajQocHJvajRfMS53Z3M4NCwgcHJvajRfMS5tZXJjYXRvciwgW3hMb24sIHlMYXRdKTtcbiAgICB9O1xuICAgIFByb2plY3Rpb25VdGlscy5wcm90b3R5cGUubWV0ZXJzX3RvX2dlb2dyYXBoaWMgPSBmdW5jdGlvbiAobXgsIG15KSB7XG4gICAgICAgIHJldHVybiBwcm9qNF8xLnByb2o0KHByb2o0XzEubWVyY2F0b3IsIHByb2o0XzEud2dzODQsIFtteCwgbXldKTtcbiAgICB9O1xuICAgIFByb2plY3Rpb25VdGlscy5wcm90b3R5cGUuZ2VvZ3JhcGhpY19leHRlbnRfdG9fbWV0ZXJzID0gZnVuY3Rpb24gKGV4dGVudCkge1xuICAgICAgICB2YXIgcmVmLCByZWYxLCB4bWF4LCB4bWluLCB5bWF4LCB5bWluO1xuICAgICAgICB4bWluID0gZXh0ZW50WzBdLCB5bWluID0gZXh0ZW50WzFdLCB4bWF4ID0gZXh0ZW50WzJdLCB5bWF4ID0gZXh0ZW50WzNdO1xuICAgICAgICByZWYgPSB0aGlzLmdlb2dyYXBoaWNfdG9fbWV0ZXJzKHhtaW4sIHltaW4pLCB4bWluID0gcmVmWzBdLCB5bWluID0gcmVmWzFdO1xuICAgICAgICByZWYxID0gdGhpcy5nZW9ncmFwaGljX3RvX21ldGVycyh4bWF4LCB5bWF4KSwgeG1heCA9IHJlZjFbMF0sIHltYXggPSByZWYxWzFdO1xuICAgICAgICByZXR1cm4gW3htaW4sIHltaW4sIHhtYXgsIHltYXhdO1xuICAgIH07XG4gICAgUHJvamVjdGlvblV0aWxzLnByb3RvdHlwZS5tZXRlcnNfZXh0ZW50X3RvX2dlb2dyYXBoaWMgPSBmdW5jdGlvbiAoZXh0ZW50KSB7XG4gICAgICAgIHZhciByZWYsIHJlZjEsIHhtYXgsIHhtaW4sIHltYXgsIHltaW47XG4gICAgICAgIHhtaW4gPSBleHRlbnRbMF0sIHltaW4gPSBleHRlbnRbMV0sIHhtYXggPSBleHRlbnRbMl0sIHltYXggPSBleHRlbnRbM107XG4gICAgICAgIHJlZiA9IHRoaXMubWV0ZXJzX3RvX2dlb2dyYXBoaWMoeG1pbiwgeW1pbiksIHhtaW4gPSByZWZbMF0sIHltaW4gPSByZWZbMV07XG4gICAgICAgIHJlZjEgPSB0aGlzLm1ldGVyc190b19nZW9ncmFwaGljKHhtYXgsIHltYXgpLCB4bWF4ID0gcmVmMVswXSwgeW1heCA9IHJlZjFbMV07XG4gICAgICAgIHJldHVybiBbeG1pbiwgeW1pbiwgeG1heCwgeW1heF07XG4gICAgfTtcbiAgICByZXR1cm4gUHJvamVjdGlvblV0aWxzO1xufSkoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtZXJjYXRvcl90aWxlX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vbWVyY2F0b3JfdGlsZV9zb3VyY2VcIik7XG5leHBvcnRzLlRNU1RpbGVTb3VyY2UgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVE1TVGlsZVNvdXJjZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVE1TVGlsZVNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIFRNU1RpbGVTb3VyY2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRNU1RpbGVTb3VyY2UucHJvdG90eXBlLnR5cGUgPSAnVE1TVGlsZVNvdXJjZSc7XG4gICAgVE1TVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0X2ltYWdlX3VybCA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgIHZhciBpbWFnZV91cmw7XG4gICAgICAgIGltYWdlX3VybCA9IHRoaXMuc3RyaW5nX2xvb2t1cF9yZXBsYWNlKHRoaXMudXJsLCB0aGlzLmV4dHJhX3VybF92YXJzKTtcbiAgICAgICAgcmV0dXJuIGltYWdlX3VybC5yZXBsYWNlKFwie1h9XCIsIHgpLnJlcGxhY2UoJ3tZfScsIHkpLnJlcGxhY2UoXCJ7Wn1cIiwgeik7XG4gICAgfTtcbiAgICByZXR1cm4gVE1TVGlsZVNvdXJjZTtcbn0pKG1lcmNhdG9yX3RpbGVfc291cmNlXzEuTWVyY2F0b3JUaWxlU291cmNlKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtZXJjYXRvcl90aWxlX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vbWVyY2F0b3JfdGlsZV9zb3VyY2VcIik7XG5leHBvcnRzLldNVFNUaWxlU291cmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFdNVFNUaWxlU291cmNlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBXTVRTVGlsZVNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIFdNVFNUaWxlU291cmNlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBXTVRTVGlsZVNvdXJjZS5wcm90b3R5cGUudHlwZSA9ICdXTVRTVGlsZVNvdXJjZSc7XG4gICAgV01UU1RpbGVTb3VyY2UucHJvdG90eXBlLmdldF9pbWFnZV91cmwgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICB2YXIgaW1hZ2VfdXJsLCByZWY7XG4gICAgICAgIGltYWdlX3VybCA9IHRoaXMuc3RyaW5nX2xvb2t1cF9yZXBsYWNlKHRoaXMudXJsLCB0aGlzLmV4dHJhX3VybF92YXJzKTtcbiAgICAgICAgcmVmID0gdGhpcy50bXNfdG9fd210cyh4LCB5LCB6KSwgeCA9IHJlZlswXSwgeSA9IHJlZlsxXSwgeiA9IHJlZlsyXTtcbiAgICAgICAgcmV0dXJuIGltYWdlX3VybC5yZXBsYWNlKFwie1h9XCIsIHgpLnJlcGxhY2UoJ3tZfScsIHkpLnJlcGxhY2UoXCJ7Wn1cIiwgeik7XG4gICAgfTtcbiAgICByZXR1cm4gV01UU1RpbGVTb3VyY2U7XG59KShtZXJjYXRvcl90aWxlX3NvdXJjZV8xLk1lcmNhdG9yVGlsZVNvdXJjZSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYnV0dG9uX3Rvb2xfMSA9IHJlcXVpcmUoXCIuLi9idXR0b25fdG9vbFwiKTtcbnZhciBzaWduYWxpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL3NpZ25hbGluZ1wiKTtcbmV4cG9ydHMuQWN0aW9uVG9vbEJ1dHRvblZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQWN0aW9uVG9vbEJ1dHRvblZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFjdGlvblRvb2xCdXR0b25WaWV3KCkge1xuICAgICAgICByZXR1cm4gQWN0aW9uVG9vbEJ1dHRvblZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjdGlvblRvb2xCdXR0b25WaWV3LnByb3RvdHlwZS5fY2xpY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxbXCJkb1wiXS5lbWl0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gQWN0aW9uVG9vbEJ1dHRvblZpZXc7XG59KShidXR0b25fdG9vbF8xLkJ1dHRvblRvb2xCdXR0b25WaWV3KTtcbmV4cG9ydHMuQWN0aW9uVG9vbFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQWN0aW9uVG9vbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFjdGlvblRvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gQWN0aW9uVG9vbFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjdGlvblRvb2xWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgQWN0aW9uVG9vbFZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsW1wiZG9cIl0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvaXQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQWN0aW9uVG9vbFZpZXc7XG59KShidXR0b25fdG9vbF8xLkJ1dHRvblRvb2xWaWV3KTtcbmV4cG9ydHMuQWN0aW9uVG9vbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBY3Rpb25Ub29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBY3Rpb25Ub29sKCkge1xuICAgICAgICByZXR1cm4gQWN0aW9uVG9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWN0aW9uVG9vbC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBBY3Rpb25Ub29sLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpc1tcImRvXCJdID0gbmV3IHNpZ25hbGluZ18xLlNpZ25hbCh0aGlzLCBcImRvXCIpO1xuICAgIH07XG4gICAgcmV0dXJuIEFjdGlvblRvb2w7XG59KShidXR0b25fdG9vbF8xLkJ1dHRvblRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFjdGlvbl90b29sXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25fdG9vbFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuSGVscFRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEhlbHBUb29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSGVscFRvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gSGVscFRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBIZWxwVG9vbFZpZXcucHJvdG90eXBlLmRvaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cub3Blbih0aGlzLm1vZGVsLnJlZGlyZWN0KTtcbiAgICB9O1xuICAgIHJldHVybiBIZWxwVG9vbFZpZXc7XG59KShhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2xWaWV3KTtcbmV4cG9ydHMuSGVscFRvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSGVscFRvb2wsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEhlbHBUb29sKCkge1xuICAgICAgICByZXR1cm4gSGVscFRvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEhlbHBUb29sLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkhlbHBUb29sVmlldztcbiAgICBIZWxwVG9vbC5wcm90b3R5cGUudHlwZSA9IFwiSGVscFRvb2xcIjtcbiAgICBIZWxwVG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJIZWxwXCI7XG4gICAgSGVscFRvb2wucHJvdG90eXBlLmljb24gPSBcImJrLXRvb2wtaWNvbi1oZWxwXCI7XG4gICAgSGVscFRvb2wuZGVmaW5lKHtcbiAgICAgICAgaGVscF90b29sdGlwOiBbcC5TdHJpbmcsICdDbGljayB0aGUgcXVlc3Rpb24gbWFyayB0byBsZWFybiBtb3JlIGFib3V0IEJva2VoIHBsb3QgdG9vbHMuJ10sXG4gICAgICAgIHJlZGlyZWN0OiBbcC5TdHJpbmcsICdodHRwOi8vYm9rZWgucHlkYXRhLm9yZy9lbi9sYXRlc3QvZG9jcy91c2VyX2d1aWRlL3Rvb2xzLmh0bWwjYnVpbHQtaW4tdG9vbHMnXVxuICAgIH0pO1xuICAgIEhlbHBUb29sLmdldHRlcnMoe1xuICAgICAgICB0b29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWxwX3Rvb2x0aXA7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gSGVscFRvb2w7XG59KShhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFjdGlvbl90b29sXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25fdG9vbFwiKTtcbmV4cG9ydHMuUmVkb1Rvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJlZG9Ub29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUmVkb1Rvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gUmVkb1Rvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZWRvVG9vbFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBSZWRvVG9vbFZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCh0aGlzLnBsb3Rfdmlldy5zdGF0ZV9jaGFuZ2VkLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5tb2RlbC5kaXNhYmxlZCA9ICFfdGhpcy5wbG90X3ZpZXcuY2FuX3JlZG8oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuICAgIFJlZG9Ub29sVmlldy5wcm90b3R5cGUuZG9pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3LnJlZG8oKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWRvVG9vbFZpZXc7XG59KShhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2xWaWV3KTtcbmV4cG9ydHMuUmVkb1Rvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmVkb1Rvb2wsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFJlZG9Ub29sKCkge1xuICAgICAgICByZXR1cm4gUmVkb1Rvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJlZG9Ub29sLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlJlZG9Ub29sVmlldztcbiAgICBSZWRvVG9vbC5wcm90b3R5cGUudHlwZSA9IFwiUmVkb1Rvb2xcIjtcbiAgICBSZWRvVG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJSZWRvXCI7XG4gICAgUmVkb1Rvb2wucHJvdG90eXBlLmljb24gPSBcImJrLXRvb2wtaWNvbi1yZWRvXCI7XG4gICAgUmVkb1Rvb2wub3ZlcnJpZGUoe1xuICAgICAgICBkaXNhYmxlZDogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBSZWRvVG9vbDtcbn0pKGFjdGlvbl90b29sXzEuQWN0aW9uVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYWN0aW9uX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbl90b29sXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5SZXNldFRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJlc2V0VG9vbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFJlc2V0VG9vbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBSZXNldFRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZXNldFRvb2xWaWV3LnByb3RvdHlwZS5kb2l0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5jbGVhcl9zdGF0ZSgpO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5yZXNldF9yYW5nZSgpO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5yZXNldF9zZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucmVzZXRfc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3LnJlc2V0X2RpbWVuc2lvbnMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlc2V0VG9vbFZpZXc7XG59KShhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2xWaWV3KTtcbmV4cG9ydHMuUmVzZXRUb29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJlc2V0VG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUmVzZXRUb29sKCkge1xuICAgICAgICByZXR1cm4gUmVzZXRUb29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZXNldFRvb2wucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUmVzZXRUb29sVmlldztcbiAgICBSZXNldFRvb2wucHJvdG90eXBlLnR5cGUgPSBcIlJlc2V0VG9vbFwiO1xuICAgIFJlc2V0VG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJSZXNldFwiO1xuICAgIFJlc2V0VG9vbC5wcm90b3R5cGUuaWNvbiA9IFwiYmstdG9vbC1pY29uLXJlc2V0XCI7XG4gICAgUmVzZXRUb29sLmRlZmluZSh7XG4gICAgICAgIHJlc2V0X3NpemU6IFtwLkJvb2wsIHRydWVdXG4gICAgfSk7XG4gICAgcmV0dXJuIFJlc2V0VG9vbDtcbn0pKGFjdGlvbl90b29sXzEuQWN0aW9uVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYWN0aW9uX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbl90b29sXCIpO1xuZXhwb3J0cy5TYXZlVG9vbFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU2F2ZVRvb2xWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTYXZlVG9vbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBTYXZlVG9vbFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNhdmVUb29sVmlldy5wcm90b3R5cGUuZG9pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3LnNhdmUoXCJib2tlaF9wbG90XCIpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhdmVUb29sVmlldztcbn0pKGFjdGlvbl90b29sXzEuQWN0aW9uVG9vbFZpZXcpO1xuZXhwb3J0cy5TYXZlVG9vbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTYXZlVG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gU2F2ZVRvb2woKSB7XG4gICAgICAgIHJldHVybiBTYXZlVG9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2F2ZVRvb2wucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuU2F2ZVRvb2xWaWV3O1xuICAgIFNhdmVUb29sLnByb3RvdHlwZS50eXBlID0gXCJTYXZlVG9vbFwiO1xuICAgIFNhdmVUb29sLnByb3RvdHlwZS50b29sX25hbWUgPSBcIlNhdmVcIjtcbiAgICBTYXZlVG9vbC5wcm90b3R5cGUuaWNvbiA9IFwiYmstdG9vbC1pY29uLXNhdmVcIjtcbiAgICByZXR1cm4gU2F2ZVRvb2w7XG59KShhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFjdGlvbl90b29sXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25fdG9vbFwiKTtcbmV4cG9ydHMuVW5kb1Rvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFVuZG9Ub29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVW5kb1Rvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gVW5kb1Rvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBVbmRvVG9vbFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBVbmRvVG9vbFZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCh0aGlzLnBsb3Rfdmlldy5zdGF0ZV9jaGFuZ2VkLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5tb2RlbC5kaXNhYmxlZCA9ICFfdGhpcy5wbG90X3ZpZXcuY2FuX3VuZG8oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuICAgIFVuZG9Ub29sVmlldy5wcm90b3R5cGUuZG9pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3LnVuZG8oKTtcbiAgICB9O1xuICAgIHJldHVybiBVbmRvVG9vbFZpZXc7XG59KShhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2xWaWV3KTtcbmV4cG9ydHMuVW5kb1Rvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVW5kb1Rvb2wsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFVuZG9Ub29sKCkge1xuICAgICAgICByZXR1cm4gVW5kb1Rvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFVuZG9Ub29sLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlVuZG9Ub29sVmlldztcbiAgICBVbmRvVG9vbC5wcm90b3R5cGUudHlwZSA9IFwiVW5kb1Rvb2xcIjtcbiAgICBVbmRvVG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJVbmRvXCI7XG4gICAgVW5kb1Rvb2wucHJvdG90eXBlLmljb24gPSBcImJrLXRvb2wtaWNvbi11bmRvXCI7XG4gICAgVW5kb1Rvb2wub3ZlcnJpZGUoe1xuICAgICAgICBkaXNhYmxlZDogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBVbmRvVG9vbDtcbn0pKGFjdGlvbl90b29sXzEuQWN0aW9uVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYWN0aW9uX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbl90b29sXCIpO1xudmFyIHpvb21fMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvem9vbVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuWm9vbUluVG9vbFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWm9vbUluVG9vbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFpvb21JblRvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gWm9vbUluVG9vbFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFpvb21JblRvb2xWaWV3LnByb3RvdHlwZS5kb2l0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGltcywgZnJhbWUsIGhfYXhpcywgdl9heGlzLCB6b29tX2luZm87XG4gICAgICAgIGZyYW1lID0gdGhpcy5wbG90X21vZGVsLmZyYW1lO1xuICAgICAgICBkaW1zID0gdGhpcy5tb2RlbC5kaW1lbnNpb25zO1xuICAgICAgICBoX2F4aXMgPSBkaW1zID09PSAnd2lkdGgnIHx8IGRpbXMgPT09ICdib3RoJztcbiAgICAgICAgdl9heGlzID0gZGltcyA9PT0gJ2hlaWdodCcgfHwgZGltcyA9PT0gJ2JvdGgnO1xuICAgICAgICB6b29tX2luZm8gPSB6b29tXzEuc2NhbGVfcmFuZ2UoZnJhbWUsIHRoaXMubW9kZWwuZmFjdG9yLCBoX2F4aXMsIHZfYXhpcyk7XG4gICAgICAgIHRoaXMucGxvdF92aWV3LnB1c2hfc3RhdGUoJ3pvb21fb3V0Jywge1xuICAgICAgICAgICAgcmFuZ2U6IHpvb21faW5mb1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wbG90X3ZpZXcudXBkYXRlX3JhbmdlKHpvb21faW5mbywgZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5pbnRlcmFjdGl2ZV90aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBab29tSW5Ub29sVmlldztcbn0pKGFjdGlvbl90b29sXzEuQWN0aW9uVG9vbFZpZXcpO1xuZXhwb3J0cy5ab29tSW5Ub29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFpvb21JblRvb2wsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFpvb21JblRvb2woKSB7XG4gICAgICAgIHJldHVybiBab29tSW5Ub29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBab29tSW5Ub29sLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlpvb21JblRvb2xWaWV3O1xuICAgIFpvb21JblRvb2wucHJvdG90eXBlLnR5cGUgPSBcIlpvb21JblRvb2xcIjtcbiAgICBab29tSW5Ub29sLnByb3RvdHlwZS50b29sX25hbWUgPSBcIlpvb20gSW5cIjtcbiAgICBab29tSW5Ub29sLnByb3RvdHlwZS5pY29uID0gXCJiay10b29sLWljb24tem9vbS1pblwiO1xuICAgIFpvb21JblRvb2wuZ2V0dGVycyh7XG4gICAgICAgIHRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRfZGltX3Rvb2x0aXAodGhpcy50b29sX25hbWUsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBab29tSW5Ub29sLmRlZmluZSh7XG4gICAgICAgIGZhY3RvcjogW3AuUGVyY2VudCwgMC4xXSxcbiAgICAgICAgZGltZW5zaW9uczogW3AuRGltZW5zaW9ucywgXCJib3RoXCJdXG4gICAgfSk7XG4gICAgcmV0dXJuIFpvb21JblRvb2w7XG59KShhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFjdGlvbl90b29sXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25fdG9vbFwiKTtcbnZhciB6b29tXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3pvb21cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLlpvb21PdXRUb29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChab29tT3V0VG9vbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFpvb21PdXRUb29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFpvb21PdXRUb29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgWm9vbU91dFRvb2xWaWV3LnByb3RvdHlwZS5kb2l0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGltcywgZnJhbWUsIGhfYXhpcywgdl9heGlzLCB6b29tX2luZm87XG4gICAgICAgIGZyYW1lID0gdGhpcy5wbG90X21vZGVsLmZyYW1lO1xuICAgICAgICBkaW1zID0gdGhpcy5tb2RlbC5kaW1lbnNpb25zO1xuICAgICAgICBoX2F4aXMgPSBkaW1zID09PSAnd2lkdGgnIHx8IGRpbXMgPT09ICdib3RoJztcbiAgICAgICAgdl9heGlzID0gZGltcyA9PT0gJ2hlaWdodCcgfHwgZGltcyA9PT0gJ2JvdGgnO1xuICAgICAgICB6b29tX2luZm8gPSB6b29tXzEuc2NhbGVfcmFuZ2UoZnJhbWUsIC10aGlzLm1vZGVsLmZhY3RvciwgaF9heGlzLCB2X2F4aXMpO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5wdXNoX3N0YXRlKCd6b29tX291dCcsIHtcbiAgICAgICAgICAgIHJhbmdlOiB6b29tX2luZm9cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGxvdF92aWV3LnVwZGF0ZV9yYW5nZSh6b29tX2luZm8sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5wbG90X3ZpZXcuaW50ZXJhY3RpdmVfdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gWm9vbU91dFRvb2xWaWV3O1xufSkoYWN0aW9uX3Rvb2xfMS5BY3Rpb25Ub29sVmlldyk7XG5leHBvcnRzLlpvb21PdXRUb29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFpvb21PdXRUb29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBab29tT3V0VG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIFpvb21PdXRUb29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBab29tT3V0VG9vbC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5ab29tT3V0VG9vbFZpZXc7XG4gICAgWm9vbU91dFRvb2wucHJvdG90eXBlLnR5cGUgPSBcIlpvb21PdXRUb29sXCI7XG4gICAgWm9vbU91dFRvb2wucHJvdG90eXBlLnRvb2xfbmFtZSA9IFwiWm9vbSBPdXRcIjtcbiAgICBab29tT3V0VG9vbC5wcm90b3R5cGUuaWNvbiA9IFwiYmstdG9vbC1pY29uLXpvb20tb3V0XCI7XG4gICAgWm9vbU91dFRvb2wuZ2V0dGVycyh7XG4gICAgICAgIHRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRfZGltX3Rvb2x0aXAodGhpcy50b29sX25hbWUsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBab29tT3V0VG9vbC5kZWZpbmUoe1xuICAgICAgICBmYWN0b3I6IFtwLlBlcmNlbnQsIDAuMV0sXG4gICAgICAgIGRpbWVuc2lvbnM6IFtwLkRpbWVuc2lvbnMsIFwiYm90aFwiXVxuICAgIH0pO1xuICAgIHJldHVybiBab29tT3V0VG9vbDtcbn0pKGFjdGlvbl90b29sXzEuQWN0aW9uVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgZG9tX3ZpZXdfMSA9IHJlcXVpcmUoXCJjb3JlL2RvbV92aWV3XCIpO1xudmFyIHRvb2xfMSA9IHJlcXVpcmUoXCIuL3Rvb2xcIik7XG52YXIgZG9tXzEgPSByZXF1aXJlKFwiY29yZS9kb21cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkJ1dHRvblRvb2xCdXR0b25WaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEJ1dHRvblRvb2xCdXR0b25WaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBCdXR0b25Ub29sQnV0dG9uVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEJ1dHRvblRvb2xCdXR0b25WaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCdXR0b25Ub29sQnV0dG9uVmlldy5wcm90b3R5cGUuY2xhc3NOYW1lID0gXCJiay10b29sYmFyLWJ1dHRvblwiO1xuICAgIEJ1dHRvblRvb2xCdXR0b25WaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgQnV0dG9uVG9vbEJ1dHRvblZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMubW9kZWwuY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jbGlja2VkKGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIEJ1dHRvblRvb2xCdXR0b25WaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpY29uLCB0aXA7XG4gICAgICAgIGRvbV8xLmVtcHR5KHRoaXMuZWwpO1xuICAgICAgICB0aGlzLmVsLmRpc2FibGVkID0gdGhpcy5tb2RlbC5kaXNhYmxlZDtcbiAgICAgICAgaWNvbiA9IGRvbV8xLmRpdih7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFsnYmstYnRuLWljb24nLCB0aGlzLm1vZGVsLmljb25dXG4gICAgICAgIH0pO1xuICAgICAgICB0aXAgPSBkb21fMS5zcGFuKHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogJ2JrLXRpcCdcbiAgICAgICAgfSwgdGhpcy5tb2RlbC50b29sdGlwKTtcbiAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZChpY29uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGlwKTtcbiAgICB9O1xuICAgIEJ1dHRvblRvb2xCdXR0b25WaWV3LnByb3RvdHlwZS5fY2xpY2tlZCA9IGZ1bmN0aW9uIChlKSB7IH07XG4gICAgcmV0dXJuIEJ1dHRvblRvb2xCdXR0b25WaWV3O1xufSkoZG9tX3ZpZXdfMS5ET01WaWV3KTtcbmV4cG9ydHMuQnV0dG9uVG9vbFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQnV0dG9uVG9vbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEJ1dHRvblRvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gQnV0dG9uVG9vbFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBCdXR0b25Ub29sVmlldztcbn0pKHRvb2xfMS5Ub29sVmlldyk7XG5leHBvcnRzLkJ1dHRvblRvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQnV0dG9uVG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQnV0dG9uVG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIEJ1dHRvblRvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJ1dHRvblRvb2wucHJvdG90eXBlLmljb24gPSBudWxsO1xuICAgIEJ1dHRvblRvb2wuZ2V0dGVycyh7XG4gICAgICAgIHRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvb2xfbmFtZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIEJ1dHRvblRvb2wuaW50ZXJuYWwoe1xuICAgICAgICBkaXNhYmxlZDogW3AuQm9vbGVhbiwgZmFsc2VdXG4gICAgfSk7XG4gICAgcmV0dXJuIEJ1dHRvblRvb2w7XG59KSh0b29sXzEuVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBERUZBVUxUX0JPWF9PVkVSTEFZLCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgc2VsZWN0X3Rvb2xfMSA9IHJlcXVpcmUoXCIuL3NlbGVjdF90b29sXCIpO1xudmFyIGJveF9hbm5vdGF0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vYW5ub3RhdGlvbnMvYm94X2Fubm90YXRpb25cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkJveFNlbGVjdFRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEJveFNlbGVjdFRvb2xWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBCb3hTZWxlY3RUb29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEJveFNlbGVjdFRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCb3hTZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX3Bhbl9zdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjYW52YXM7XG4gICAgICAgIGNhbnZhcyA9IHRoaXMucGxvdF92aWV3LmNhbnZhcztcbiAgICAgICAgdGhpcy5fYmFzZWJvaW50ID0gW2NhbnZhcy5zeF90b192eChlLmJva2VoLnN4KSwgY2FudmFzLnN5X3RvX3Z5KGUuYm9rZWguc3kpXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBCb3hTZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX3BhbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBhcHBlbmQsIGNhbnZhcywgY3VycG9pbnQsIGRpbXMsIGZyYW1lLCByZWYsIHJlZjEsIHZ4bGltLCB2eWxpbTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzO1xuICAgICAgICBjdXJwb2ludCA9IFtjYW52YXMuc3hfdG9fdngoZS5ib2tlaC5zeCksIGNhbnZhcy5zeV90b192eShlLmJva2VoLnN5KV07XG4gICAgICAgIGZyYW1lID0gdGhpcy5wbG90X21vZGVsLmZyYW1lO1xuICAgICAgICBkaW1zID0gdGhpcy5tb2RlbC5kaW1lbnNpb25zO1xuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLl9nZXRfZGltX2xpbWl0cyh0aGlzLl9iYXNlYm9pbnQsIGN1cnBvaW50LCBmcmFtZSwgZGltcyksIHZ4bGltID0gcmVmWzBdLCB2eWxpbSA9IHJlZlsxXTtcbiAgICAgICAgdGhpcy5tb2RlbC5vdmVybGF5LnVwZGF0ZSh7XG4gICAgICAgICAgICBsZWZ0OiB2eGxpbVswXSxcbiAgICAgICAgICAgIHJpZ2h0OiB2eGxpbVsxXSxcbiAgICAgICAgICAgIHRvcDogdnlsaW1bMV0sXG4gICAgICAgICAgICBib3R0b206IHZ5bGltWzBdXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5zZWxlY3RfZXZlcnlfbW91c2Vtb3ZlKSB7XG4gICAgICAgICAgICBhcHBlbmQgPSAocmVmMSA9IGUuc3JjRXZlbnQuc2hpZnRLZXkpICE9IG51bGwgPyByZWYxIDogZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3QodnhsaW0sIHZ5bGltLCBmYWxzZSwgYXBwZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEJveFNlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5fcGFuX2VuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBhcHBlbmQsIGNhbnZhcywgY3VycG9pbnQsIGRpbXMsIGZyYW1lLCByZWYsIHJlZjEsIHZ4bGltLCB2eWxpbTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzO1xuICAgICAgICBjdXJwb2ludCA9IFtjYW52YXMuc3hfdG9fdngoZS5ib2tlaC5zeCksIGNhbnZhcy5zeV90b192eShlLmJva2VoLnN5KV07XG4gICAgICAgIGZyYW1lID0gdGhpcy5wbG90X21vZGVsLmZyYW1lO1xuICAgICAgICBkaW1zID0gdGhpcy5tb2RlbC5kaW1lbnNpb25zO1xuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLl9nZXRfZGltX2xpbWl0cyh0aGlzLl9iYXNlYm9pbnQsIGN1cnBvaW50LCBmcmFtZSwgZGltcyksIHZ4bGltID0gcmVmWzBdLCB2eWxpbSA9IHJlZlsxXTtcbiAgICAgICAgYXBwZW5kID0gKHJlZjEgPSBlLnNyY0V2ZW50LnNoaWZ0S2V5KSAhPSBudWxsID8gcmVmMSA6IGZhbHNlO1xuICAgICAgICB0aGlzLl9zZWxlY3QodnhsaW0sIHZ5bGltLCB0cnVlLCBhcHBlbmQpO1xuICAgICAgICB0aGlzLm1vZGVsLm92ZXJsYXkudXBkYXRlKHtcbiAgICAgICAgICAgIGxlZnQ6IG51bGwsXG4gICAgICAgICAgICByaWdodDogbnVsbCxcbiAgICAgICAgICAgIHRvcDogbnVsbCxcbiAgICAgICAgICAgIGJvdHRvbTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYmFzZWJvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wbG90X3ZpZXcucHVzaF9zdGF0ZSgnYm94X3NlbGVjdCcsIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogdGhpcy5wbG90X3ZpZXcuZ2V0X3NlbGVjdGlvbigpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEJveFNlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5fc2VsZWN0ID0gZnVuY3Rpb24gKGFyZywgYXJnMSwgZmluYWwsIGFwcGVuZCkge1xuICAgICAgICB2YXIgZHMsIGdlb21ldHJ5LCByLCByZW5kZXJlcnMsIHJlbmRlcmVyc19ieV9zb3VyY2UsIHNtLCB2eDAsIHZ4MSwgdnkwLCB2eTE7XG4gICAgICAgIHZ4MCA9IGFyZ1swXSwgdngxID0gYXJnWzFdO1xuICAgICAgICB2eTAgPSBhcmcxWzBdLCB2eTEgPSBhcmcxWzFdO1xuICAgICAgICBpZiAoYXBwZW5kID09IG51bGwpIHtcbiAgICAgICAgICAgIGFwcGVuZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGdlb21ldHJ5ID0ge1xuICAgICAgICAgICAgdHlwZTogJ3JlY3QnLFxuICAgICAgICAgICAgdngwOiB2eDAsXG4gICAgICAgICAgICB2eDE6IHZ4MSxcbiAgICAgICAgICAgIHZ5MDogdnkwLFxuICAgICAgICAgICAgdnkxOiB2eTFcbiAgICAgICAgfTtcbiAgICAgICAgcmVuZGVyZXJzX2J5X3NvdXJjZSA9IHRoaXMubW9kZWwuX2NvbXB1dGVkX3JlbmRlcmVyc19ieV9kYXRhX3NvdXJjZSgpO1xuICAgICAgICBmb3IgKGRzIGluIHJlbmRlcmVyc19ieV9zb3VyY2UpIHtcbiAgICAgICAgICAgIHJlbmRlcmVycyA9IHJlbmRlcmVyc19ieV9zb3VyY2VbZHNdO1xuICAgICAgICAgICAgc20gPSByZW5kZXJlcnNbMF0uZGF0YV9zb3VyY2Uuc2VsZWN0aW9uX21hbmFnZXI7XG4gICAgICAgICAgICBzbS5zZWxlY3QodGhpcywgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZW5kZXJlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHJlbmRlcmVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMucGxvdF92aWV3LnJlbmRlcmVyX3ZpZXdzW3IuaWRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMpLCBnZW9tZXRyeSwgZmluYWwsIGFwcGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwuY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZW1pdF9jYWxsYmFjayhnZW9tZXRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2F2ZV9nZW9tZXRyeShnZW9tZXRyeSwgZmluYWwsIGFwcGVuZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQm94U2VsZWN0VG9vbFZpZXcucHJvdG90eXBlLl9lbWl0X2NhbGxiYWNrID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBjYW52YXMsIGZyYW1lLCByLCB4c2NhbGUsIHlzY2FsZTtcbiAgICAgICAgciA9IHRoaXMubW9kZWwuY29tcHV0ZWRfcmVuZGVyZXJzWzBdO1xuICAgICAgICBjYW52YXMgPSB0aGlzLnBsb3RfbW9kZWwuY2FudmFzO1xuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgZ2VvbWV0cnlbJ3N4MCddID0gY2FudmFzLnZ4X3RvX3N4KGdlb21ldHJ5LnZ4MCk7XG4gICAgICAgIGdlb21ldHJ5WydzeDEnXSA9IGNhbnZhcy52eF90b19zeChnZW9tZXRyeS52eDEpO1xuICAgICAgICBnZW9tZXRyeVsnc3kwJ10gPSBjYW52YXMudnlfdG9fc3koZ2VvbWV0cnkudnkwKTtcbiAgICAgICAgZ2VvbWV0cnlbJ3N5MSddID0gY2FudmFzLnZ5X3RvX3N5KGdlb21ldHJ5LnZ5MSk7XG4gICAgICAgIHhzY2FsZSA9IGZyYW1lLnhzY2FsZXNbci54X3JhbmdlX25hbWVdO1xuICAgICAgICB5c2NhbGUgPSBmcmFtZS55c2NhbGVzW3IueV9yYW5nZV9uYW1lXTtcbiAgICAgICAgZ2VvbWV0cnlbJ3gwJ10gPSB4c2NhbGUuaW52ZXJ0KGdlb21ldHJ5LnZ4MCk7XG4gICAgICAgIGdlb21ldHJ5Wyd4MSddID0geHNjYWxlLmludmVydChnZW9tZXRyeS52eDEpO1xuICAgICAgICBnZW9tZXRyeVsneTAnXSA9IHlzY2FsZS5pbnZlcnQoZ2VvbWV0cnkudnkwKTtcbiAgICAgICAgZ2VvbWV0cnlbJ3kxJ10gPSB5c2NhbGUuaW52ZXJ0KGdlb21ldHJ5LnZ5MSk7XG4gICAgICAgIHRoaXMubW9kZWwuY2FsbGJhY2suZXhlY3V0ZSh0aGlzLm1vZGVsLCB7XG4gICAgICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnlcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQm94U2VsZWN0VG9vbFZpZXc7XG59KShzZWxlY3RfdG9vbF8xLlNlbGVjdFRvb2xWaWV3KTtcbkRFRkFVTFRfQk9YX09WRVJMQVkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBib3hfYW5ub3RhdGlvbl8xLkJveEFubm90YXRpb24oe1xuICAgICAgICBsZXZlbDogXCJvdmVybGF5XCIsXG4gICAgICAgIHJlbmRlcl9tb2RlOiBcImNzc1wiLFxuICAgICAgICB0b3BfdW5pdHM6IFwic2NyZWVuXCIsXG4gICAgICAgIGxlZnRfdW5pdHM6IFwic2NyZWVuXCIsXG4gICAgICAgIGJvdHRvbV91bml0czogXCJzY3JlZW5cIixcbiAgICAgICAgcmlnaHRfdW5pdHM6IFwic2NyZWVuXCIsXG4gICAgICAgIGZpbGxfY29sb3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBcImxpZ2h0Z3JleVwiXG4gICAgICAgIH0sXG4gICAgICAgIGZpbGxfYWxwaGE6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwLjVcbiAgICAgICAgfSxcbiAgICAgICAgbGluZV9jb2xvcjoge1xuICAgICAgICAgICAgdmFsdWU6IFwiYmxhY2tcIlxuICAgICAgICB9LFxuICAgICAgICBsaW5lX2FscGhhOiB7XG4gICAgICAgICAgICB2YWx1ZTogMS4wXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVfd2lkdGg6IHtcbiAgICAgICAgICAgIHZhbHVlOiAyXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVfZGFzaDoge1xuICAgICAgICAgICAgdmFsdWU6IFs0LCA0XVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuZXhwb3J0cy5Cb3hTZWxlY3RUb29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEJveFNlbGVjdFRvb2wsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEJveFNlbGVjdFRvb2woKSB7XG4gICAgICAgIHJldHVybiBCb3hTZWxlY3RUb29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCb3hTZWxlY3RUb29sLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkJveFNlbGVjdFRvb2xWaWV3O1xuICAgIEJveFNlbGVjdFRvb2wucHJvdG90eXBlLnR5cGUgPSBcIkJveFNlbGVjdFRvb2xcIjtcbiAgICBCb3hTZWxlY3RUb29sLnByb3RvdHlwZS50b29sX25hbWUgPSBcIkJveCBTZWxlY3RcIjtcbiAgICBCb3hTZWxlY3RUb29sLnByb3RvdHlwZS5pY29uID0gXCJiay10b29sLWljb24tYm94LXNlbGVjdFwiO1xuICAgIEJveFNlbGVjdFRvb2wucHJvdG90eXBlLmV2ZW50X3R5cGUgPSBcInBhblwiO1xuICAgIEJveFNlbGVjdFRvb2wucHJvdG90eXBlLmRlZmF1bHRfb3JkZXIgPSAzMDtcbiAgICBCb3hTZWxlY3RUb29sLmRlZmluZSh7XG4gICAgICAgIGRpbWVuc2lvbnM6IFtwLkRpbWVuc2lvbnMsIFwiYm90aFwiXSxcbiAgICAgICAgc2VsZWN0X2V2ZXJ5X21vdXNlbW92ZTogW3AuQm9vbCwgZmFsc2VdLFxuICAgICAgICBjYWxsYmFjazogW3AuSW5zdGFuY2VdLFxuICAgICAgICBvdmVybGF5OiBbcC5JbnN0YW5jZSwgREVGQVVMVF9CT1hfT1ZFUkxBWV1cbiAgICB9KTtcbiAgICBCb3hTZWxlY3RUb29sLmdldHRlcnMoe1xuICAgICAgICB0b29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0X2RpbV90b29sdGlwKHRoaXMudG9vbF9uYW1lLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEJveFNlbGVjdFRvb2w7XG59KShzZWxlY3RfdG9vbF8xLlNlbGVjdFRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgREVGQVVMVF9CT1hfT1ZFUkxBWSwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGdlc3R1cmVfdG9vbF8xID0gcmVxdWlyZShcIi4vZ2VzdHVyZV90b29sXCIpO1xudmFyIGJveF9hbm5vdGF0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vYW5ub3RhdGlvbnMvYm94X2Fubm90YXRpb25cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkJveFpvb21Ub29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChCb3hab29tVG9vbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEJveFpvb21Ub29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEJveFpvb21Ub29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQm94Wm9vbVRvb2xWaWV3LnByb3RvdHlwZS5fbWF0Y2hfYXNwZWN0ID0gZnVuY3Rpb24gKGJhc2Vwb2ludCwgY3VycG9pbnQsIGZyYW1lKSB7XG4gICAgICAgIHZhciBhLCBib3R0b20sIGgsIGhlbmQsIGhzdGFydCwgbGVmdCwgcmVmLCByZWYxLCByaWdodCwgdG9wLCB2YSwgdmVuZCwgdmgsIHZzdGFydCwgdncsIHcsIHhtb2QsIHltb2Q7XG4gICAgICAgIGhlbmQgPSBmcmFtZS5oX3JhbmdlLmVuZDtcbiAgICAgICAgaHN0YXJ0ID0gZnJhbWUuaF9yYW5nZS5zdGFydDtcbiAgICAgICAgdmVuZCA9IGZyYW1lLnZfcmFuZ2UuZW5kO1xuICAgICAgICB2c3RhcnQgPSBmcmFtZS52X3JhbmdlLnN0YXJ0O1xuICAgICAgICB3ID0gaGVuZCAtIGhzdGFydDtcbiAgICAgICAgaCA9IHZlbmQgLSB2c3RhcnQ7XG4gICAgICAgIGEgPSB3IC8gaDtcbiAgICAgICAgdncgPSBNYXRoLmFicyhiYXNlcG9pbnRbMF0gLSBjdXJwb2ludFswXSk7XG4gICAgICAgIHZoID0gTWF0aC5hYnMoYmFzZXBvaW50WzFdIC0gY3VycG9pbnRbMV0pO1xuICAgICAgICBpZiAodmggPT09IDApIHtcbiAgICAgICAgICAgIHZhID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhID0gdncgLyB2aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmEgPj0gYSkge1xuICAgICAgICAgICAgcmVmID0gWzEsIHZhIC8gYV0sIHhtb2QgPSByZWZbMF0sIHltb2QgPSByZWZbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYxID0gW2EgLyB2YSwgMV0sIHhtb2QgPSByZWYxWzBdLCB5bW9kID0gcmVmMVsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZXBvaW50WzBdIDw9IGN1cnBvaW50WzBdKSB7XG4gICAgICAgICAgICBsZWZ0ID0gYmFzZXBvaW50WzBdO1xuICAgICAgICAgICAgcmlnaHQgPSBiYXNlcG9pbnRbMF0gKyB2dyAqIHhtb2Q7XG4gICAgICAgICAgICBpZiAocmlnaHQgPiBoZW5kKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBoZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmlnaHQgPSBiYXNlcG9pbnRbMF07XG4gICAgICAgICAgICBsZWZ0ID0gYmFzZXBvaW50WzBdIC0gdncgKiB4bW9kO1xuICAgICAgICAgICAgaWYgKGxlZnQgPCBoc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gaHN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZ3ID0gTWF0aC5hYnMocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgaWYgKGJhc2Vwb2ludFsxXSA8PSBjdXJwb2ludFsxXSkge1xuICAgICAgICAgICAgYm90dG9tID0gYmFzZXBvaW50WzFdO1xuICAgICAgICAgICAgdG9wID0gYmFzZXBvaW50WzFdICsgdncgLyBhO1xuICAgICAgICAgICAgaWYgKHRvcCA+IHZlbmQpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSB2ZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9wID0gYmFzZXBvaW50WzFdO1xuICAgICAgICAgICAgYm90dG9tID0gYmFzZXBvaW50WzFdIC0gdncgLyBhO1xuICAgICAgICAgICAgaWYgKGJvdHRvbSA8IHZzdGFydCkge1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IHZzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aCA9IE1hdGguYWJzKHRvcCAtIGJvdHRvbSk7XG4gICAgICAgIGlmIChiYXNlcG9pbnRbMF0gPD0gY3VycG9pbnRbMF0pIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gYmFzZXBvaW50WzBdICsgYSAqIHZoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVmdCA9IGJhc2Vwb2ludFswXSAtIGEgKiB2aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1tsZWZ0LCByaWdodF0sIFtib3R0b20sIHRvcF1dO1xuICAgIH07XG4gICAgQm94Wm9vbVRvb2xWaWV3LnByb3RvdHlwZS5fcGFuX3N0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGNhbnZhcztcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzO1xuICAgICAgICB0aGlzLl9iYXNlYm9pbnQgPSBbY2FudmFzLnN4X3RvX3Z4KGUuYm9rZWguc3gpLCBjYW52YXMuc3lfdG9fdnkoZS5ib2tlaC5zeSldO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEJveFpvb21Ub29sVmlldy5wcm90b3R5cGUuX3BhbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjYW52YXMsIGN1cnBvaW50LCBkaW1zLCBmcmFtZSwgcmVmLCByZWYxLCB2eCwgdnk7XG4gICAgICAgIGNhbnZhcyA9IHRoaXMucGxvdF92aWV3LmNhbnZhcztcbiAgICAgICAgY3VycG9pbnQgPSBbY2FudmFzLnN4X3RvX3Z4KGUuYm9rZWguc3gpLCBjYW52YXMuc3lfdG9fdnkoZS5ib2tlaC5zeSldO1xuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgZGltcyA9IHRoaXMubW9kZWwuZGltZW5zaW9ucztcbiAgICAgICAgaWYgKHRoaXMubW9kZWwubWF0Y2hfYXNwZWN0ICYmIGRpbXMgPT09ICdib3RoJykge1xuICAgICAgICAgICAgcmVmID0gdGhpcy5fbWF0Y2hfYXNwZWN0KHRoaXMuX2Jhc2Vib2ludCwgY3VycG9pbnQsIGZyYW1lKSwgdnggPSByZWZbMF0sIHZ5ID0gcmVmWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmMSA9IHRoaXMubW9kZWwuX2dldF9kaW1fbGltaXRzKHRoaXMuX2Jhc2Vib2ludCwgY3VycG9pbnQsIGZyYW1lLCBkaW1zKSwgdnggPSByZWYxWzBdLCB2eSA9IHJlZjFbMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5vdmVybGF5LnVwZGF0ZSh7XG4gICAgICAgICAgICBsZWZ0OiB2eFswXSxcbiAgICAgICAgICAgIHJpZ2h0OiB2eFsxXSxcbiAgICAgICAgICAgIHRvcDogdnlbMV0sXG4gICAgICAgICAgICBib3R0b206IHZ5WzBdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEJveFpvb21Ub29sVmlldy5wcm90b3R5cGUuX3Bhbl9lbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgY2FudmFzLCBjdXJwb2ludCwgZGltcywgZnJhbWUsIHJlZiwgcmVmMSwgdngsIHZ5O1xuICAgICAgICBjYW52YXMgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXM7XG4gICAgICAgIGN1cnBvaW50ID0gW2NhbnZhcy5zeF90b192eChlLmJva2VoLnN4KSwgY2FudmFzLnN5X3RvX3Z5KGUuYm9rZWguc3kpXTtcbiAgICAgICAgZnJhbWUgPSB0aGlzLnBsb3RfbW9kZWwuZnJhbWU7XG4gICAgICAgIGRpbXMgPSB0aGlzLm1vZGVsLmRpbWVuc2lvbnM7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLm1hdGNoX2FzcGVjdCAmJiBkaW1zID09PSAnYm90aCcpIHtcbiAgICAgICAgICAgIHJlZiA9IHRoaXMuX21hdGNoX2FzcGVjdCh0aGlzLl9iYXNlYm9pbnQsIGN1cnBvaW50LCBmcmFtZSksIHZ4ID0gcmVmWzBdLCB2eSA9IHJlZlsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZjEgPSB0aGlzLm1vZGVsLl9nZXRfZGltX2xpbWl0cyh0aGlzLl9iYXNlYm9pbnQsIGN1cnBvaW50LCBmcmFtZSwgZGltcyksIHZ4ID0gcmVmMVswXSwgdnkgPSByZWYxWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZSh2eCwgdnkpO1xuICAgICAgICB0aGlzLm1vZGVsLm92ZXJsYXkudXBkYXRlKHtcbiAgICAgICAgICAgIGxlZnQ6IG51bGwsXG4gICAgICAgICAgICByaWdodDogbnVsbCxcbiAgICAgICAgICAgIHRvcDogbnVsbCxcbiAgICAgICAgICAgIGJvdHRvbTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYmFzZWJvaW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBCb3hab29tVG9vbFZpZXcucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodngsIHZ5KSB7XG4gICAgICAgIHZhciBlbmQsIG5hbWUsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgc2NhbGUsIHN0YXJ0LCB4cnMsIHlycywgem9vbV9pbmZvO1xuICAgICAgICBpZiAoTWF0aC5hYnModnhbMV0gLSB2eFswXSkgPD0gNSB8fCBNYXRoLmFicyh2eVsxXSAtIHZ5WzBdKSA8PSA1KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgeHJzID0ge307XG4gICAgICAgIHJlZiA9IHRoaXMucGxvdF92aWV3LmZyYW1lLnhzY2FsZXM7XG4gICAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcbiAgICAgICAgICAgIHNjYWxlID0gcmVmW25hbWVdO1xuICAgICAgICAgICAgcmVmMSA9IHNjYWxlLnZfaW52ZXJ0KHZ4LCB0cnVlKSwgc3RhcnQgPSByZWYxWzBdLCBlbmQgPSByZWYxWzFdO1xuICAgICAgICAgICAgeHJzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB5cnMgPSB7fTtcbiAgICAgICAgcmVmMiA9IHRoaXMucGxvdF92aWV3LmZyYW1lLnlzY2FsZXM7XG4gICAgICAgIGZvciAobmFtZSBpbiByZWYyKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHJlZjJbbmFtZV07XG4gICAgICAgICAgICByZWYzID0gc2NhbGUudl9pbnZlcnQodnksIHRydWUpLCBzdGFydCA9IHJlZjNbMF0sIGVuZCA9IHJlZjNbMV07XG4gICAgICAgICAgICB5cnNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogZW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHpvb21faW5mbyA9IHtcbiAgICAgICAgICAgIHhyczogeHJzLFxuICAgICAgICAgICAgeXJzOiB5cnNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wbG90X3ZpZXcucHVzaF9zdGF0ZSgnYm94X3pvb20nLCB7XG4gICAgICAgICAgICByYW5nZTogem9vbV9pbmZvXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wbG90X3ZpZXcudXBkYXRlX3JhbmdlKHpvb21faW5mbyk7XG4gICAgfTtcbiAgICByZXR1cm4gQm94Wm9vbVRvb2xWaWV3O1xufSkoZ2VzdHVyZV90b29sXzEuR2VzdHVyZVRvb2xWaWV3KTtcbkRFRkFVTFRfQk9YX09WRVJMQVkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBib3hfYW5ub3RhdGlvbl8xLkJveEFubm90YXRpb24oe1xuICAgICAgICBsZXZlbDogXCJvdmVybGF5XCIsXG4gICAgICAgIHJlbmRlcl9tb2RlOiBcImNzc1wiLFxuICAgICAgICB0b3BfdW5pdHM6IFwic2NyZWVuXCIsXG4gICAgICAgIGxlZnRfdW5pdHM6IFwic2NyZWVuXCIsXG4gICAgICAgIGJvdHRvbV91bml0czogXCJzY3JlZW5cIixcbiAgICAgICAgcmlnaHRfdW5pdHM6IFwic2NyZWVuXCIsXG4gICAgICAgIGZpbGxfY29sb3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBcImxpZ2h0Z3JleVwiXG4gICAgICAgIH0sXG4gICAgICAgIGZpbGxfYWxwaGE6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwLjVcbiAgICAgICAgfSxcbiAgICAgICAgbGluZV9jb2xvcjoge1xuICAgICAgICAgICAgdmFsdWU6IFwiYmxhY2tcIlxuICAgICAgICB9LFxuICAgICAgICBsaW5lX2FscGhhOiB7XG4gICAgICAgICAgICB2YWx1ZTogMS4wXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVfd2lkdGg6IHtcbiAgICAgICAgICAgIHZhbHVlOiAyXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVfZGFzaDoge1xuICAgICAgICAgICAgdmFsdWU6IFs0LCA0XVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuZXhwb3J0cy5Cb3hab29tVG9vbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChCb3hab29tVG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQm94Wm9vbVRvb2woKSB7XG4gICAgICAgIHJldHVybiBCb3hab29tVG9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQm94Wm9vbVRvb2wucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuQm94Wm9vbVRvb2xWaWV3O1xuICAgIEJveFpvb21Ub29sLnByb3RvdHlwZS50eXBlID0gXCJCb3hab29tVG9vbFwiO1xuICAgIEJveFpvb21Ub29sLnByb3RvdHlwZS50b29sX25hbWUgPSBcIkJveCBab29tXCI7XG4gICAgQm94Wm9vbVRvb2wucHJvdG90eXBlLmljb24gPSBcImJrLXRvb2wtaWNvbi1ib3gtem9vbVwiO1xuICAgIEJveFpvb21Ub29sLnByb3RvdHlwZS5ldmVudF90eXBlID0gXCJwYW5cIjtcbiAgICBCb3hab29tVG9vbC5wcm90b3R5cGUuZGVmYXVsdF9vcmRlciA9IDIwO1xuICAgIEJveFpvb21Ub29sLmdldHRlcnMoe1xuICAgICAgICB0b29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0X2RpbV90b29sdGlwKHRoaXMudG9vbF9uYW1lLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgQm94Wm9vbVRvb2wuZGVmaW5lKHtcbiAgICAgICAgZGltZW5zaW9uczogW3AuRGltZW5zaW9ucywgXCJib3RoXCJdLFxuICAgICAgICBvdmVybGF5OiBbcC5JbnN0YW5jZSwgREVGQVVMVF9CT1hfT1ZFUkxBWV0sXG4gICAgICAgIG1hdGNoX2FzcGVjdDogW3AuQm9vbCwgZmFsc2VdXG4gICAgfSk7XG4gICAgcmV0dXJuIEJveFpvb21Ub29sO1xufSkoZ2VzdHVyZV90b29sXzEuR2VzdHVyZVRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGJ1dHRvbl90b29sXzEgPSByZXF1aXJlKFwiLi4vYnV0dG9uX3Rvb2xcIik7XG5leHBvcnRzLkdlc3R1cmVUb29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChHZXN0dXJlVG9vbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEdlc3R1cmVUb29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEdlc3R1cmVUb29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIEdlc3R1cmVUb29sVmlldztcbn0pKGJ1dHRvbl90b29sXzEuQnV0dG9uVG9vbFZpZXcpO1xuZXhwb3J0cy5HZXN0dXJlVG9vbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChHZXN0dXJlVG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gR2VzdHVyZVRvb2woKSB7XG4gICAgICAgIHJldHVybiBHZXN0dXJlVG9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgR2VzdHVyZVRvb2wucHJvdG90eXBlLmV2ZW50X3R5cGUgPSBudWxsO1xuICAgIEdlc3R1cmVUb29sLnByb3RvdHlwZS5kZWZhdWx0X29yZGVyID0gbnVsbDtcbiAgICByZXR1cm4gR2VzdHVyZVRvb2w7XG59KShidXR0b25fdG9vbF8xLkJ1dHRvblRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgREVGQVVMVF9QT0xZX09WRVJMQVksIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBzZWxlY3RfdG9vbF8xID0gcmVxdWlyZShcIi4vc2VsZWN0X3Rvb2xcIik7XG52YXIgcG9seV9hbm5vdGF0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vYW5ub3RhdGlvbnMvcG9seV9hbm5vdGF0aW9uXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5MYXNzb1NlbGVjdFRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExhc3NvU2VsZWN0VG9vbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExhc3NvU2VsZWN0VG9vbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBMYXNzb1NlbGVjdFRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMYXNzb1NlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgTGFzc29TZWxlY3RUb29sVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLmFjdGl2ZS5jaGFuZ2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVfY2hhbmdlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhID0gbnVsbDtcbiAgICB9O1xuICAgIExhc3NvU2VsZWN0VG9vbFZpZXcucHJvdG90eXBlLl9hY3RpdmVfY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xlYXJfb3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXNzb1NlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5fa2V5dXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsZWFyX292ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGFzc29TZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX3Bhbl9zdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjYW52YXMsIHZ4LCB2eTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzO1xuICAgICAgICB2eCA9IGNhbnZhcy5zeF90b192eChlLmJva2VoLnN4KTtcbiAgICAgICAgdnkgPSBjYW52YXMuc3lfdG9fdnkoZS5ib2tlaC5zeSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgICAgICAgIHZ4OiBbdnhdLFxuICAgICAgICAgICAgdnk6IFt2eV1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMYXNzb1NlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5fcGFuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGFwcGVuZCwgY2FudmFzLCBoX3JhbmdlLCBvdmVybGF5LCByZWYsIHZfcmFuZ2UsIHZ4LCB2eTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzO1xuICAgICAgICB2eCA9IGNhbnZhcy5zeF90b192eChlLmJva2VoLnN4KTtcbiAgICAgICAgdnkgPSBjYW52YXMuc3lfdG9fdnkoZS5ib2tlaC5zeSk7XG4gICAgICAgIGhfcmFuZ2UgPSB0aGlzLnBsb3RfbW9kZWwuZnJhbWUuaF9yYW5nZTtcbiAgICAgICAgdl9yYW5nZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZS52X3JhbmdlO1xuICAgICAgICBpZiAodnggPiBoX3JhbmdlLmVuZCkge1xuICAgICAgICAgICAgdnggPSBoX3JhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodnggPCBoX3JhbmdlLnN0YXJ0KSB7XG4gICAgICAgICAgICB2eCA9IGhfcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZ5ID4gdl9yYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHZ5ID0gdl9yYW5nZS5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZ5IDwgdl9yYW5nZS5zdGFydCkge1xuICAgICAgICAgICAgdnkgPSB2X3JhbmdlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YS52eC5wdXNoKHZ4KTtcbiAgICAgICAgdGhpcy5kYXRhLnZ5LnB1c2godnkpO1xuICAgICAgICBvdmVybGF5ID0gdGhpcy5tb2RlbC5vdmVybGF5O1xuICAgICAgICBvdmVybGF5LnVwZGF0ZSh7XG4gICAgICAgICAgICB4czogdGhpcy5kYXRhLnZ4LFxuICAgICAgICAgICAgeXM6IHRoaXMuZGF0YS52eVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuc2VsZWN0X2V2ZXJ5X21vdXNlbW92ZSkge1xuICAgICAgICAgICAgYXBwZW5kID0gKHJlZiA9IGUuc3JjRXZlbnQuc2hpZnRLZXkpICE9IG51bGwgPyByZWYgOiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3QodGhpcy5kYXRhLnZ4LCB0aGlzLmRhdGEudnksIGZhbHNlLCBhcHBlbmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXNzb1NlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5fcGFuX2VuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBhcHBlbmQsIHJlZjtcbiAgICAgICAgdGhpcy5fY2xlYXJfb3ZlcmxheSgpO1xuICAgICAgICBhcHBlbmQgPSAocmVmID0gZS5zcmNFdmVudC5zaGlmdEtleSkgIT0gbnVsbCA/IHJlZiA6IGZhbHNlO1xuICAgICAgICB0aGlzLl9zZWxlY3QodGhpcy5kYXRhLnZ4LCB0aGlzLmRhdGEudnksIHRydWUsIGFwcGVuZCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5wdXNoX3N0YXRlKCdsYXNzb19zZWxlY3QnLCB7XG4gICAgICAgICAgICBzZWxlY3Rpb246IHRoaXMucGxvdF92aWV3LmdldF9zZWxlY3Rpb24oKVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExhc3NvU2VsZWN0VG9vbFZpZXcucHJvdG90eXBlLl9jbGVhcl9vdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5vdmVybGF5LnVwZGF0ZSh7XG4gICAgICAgICAgICB4czogW10sXG4gICAgICAgICAgICB5czogW11cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMYXNzb1NlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5fc2VsZWN0ID0gZnVuY3Rpb24gKHZ4LCB2eSwgZmluYWwsIGFwcGVuZCkge1xuICAgICAgICB2YXIgZHMsIGdlb21ldHJ5LCByLCByZW5kZXJlcnMsIHJlbmRlcmVyc19ieV9zb3VyY2UsIHNtO1xuICAgICAgICBnZW9tZXRyeSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdwb2x5JyxcbiAgICAgICAgICAgIHZ4OiB2eCxcbiAgICAgICAgICAgIHZ5OiB2eVxuICAgICAgICB9O1xuICAgICAgICByZW5kZXJlcnNfYnlfc291cmNlID0gdGhpcy5tb2RlbC5fY29tcHV0ZWRfcmVuZGVyZXJzX2J5X2RhdGFfc291cmNlKCk7XG4gICAgICAgIGZvciAoZHMgaW4gcmVuZGVyZXJzX2J5X3NvdXJjZSkge1xuICAgICAgICAgICAgcmVuZGVyZXJzID0gcmVuZGVyZXJzX2J5X3NvdXJjZVtkc107XG4gICAgICAgICAgICBzbSA9IHJlbmRlcmVyc1swXS5kYXRhX3NvdXJjZS5zZWxlY3Rpb25fbWFuYWdlcjtcbiAgICAgICAgICAgIHNtLnNlbGVjdCh0aGlzLCAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlbmRlcmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByID0gcmVuZGVyZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5wbG90X3ZpZXcucmVuZGVyZXJfdmlld3Nbci5pZF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcyksIGdlb21ldHJ5LCBmaW5hbCwgYXBwZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbC5jYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0X2NhbGxiYWNrKGdlb21ldHJ5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zYXZlX2dlb21ldHJ5KGdlb21ldHJ5LCBmaW5hbCwgYXBwZW5kKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMYXNzb1NlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5fZW1pdF9jYWxsYmFjayA9IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICB2YXIgY2FudmFzLCBmcmFtZSwgciwgeHNjYWxlLCB5c2NhbGU7XG4gICAgICAgIHIgPSB0aGlzLm1vZGVsLmNvbXB1dGVkX3JlbmRlcmVyc1swXTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcztcbiAgICAgICAgZnJhbWUgPSB0aGlzLnBsb3RfbW9kZWwuZnJhbWU7XG4gICAgICAgIGdlb21ldHJ5WydzeCddID0gY2FudmFzLnZfdnhfdG9fc3goZ2VvbWV0cnkudngpO1xuICAgICAgICBnZW9tZXRyeVsnc3knXSA9IGNhbnZhcy52X3Z5X3RvX3N5KGdlb21ldHJ5LnZ5KTtcbiAgICAgICAgeHNjYWxlID0gZnJhbWUueHNjYWxlc1tyLnhfcmFuZ2VfbmFtZV07XG4gICAgICAgIHlzY2FsZSA9IGZyYW1lLnlzY2FsZXNbci55X3JhbmdlX25hbWVdO1xuICAgICAgICBnZW9tZXRyeVsneCddID0geHNjYWxlLnZfaW52ZXJ0KGdlb21ldHJ5LnZ4KTtcbiAgICAgICAgZ2VvbWV0cnlbJ3knXSA9IHlzY2FsZS52X2ludmVydChnZW9tZXRyeS52eSk7XG4gICAgICAgIHRoaXMubW9kZWwuY2FsbGJhY2suZXhlY3V0ZSh0aGlzLm1vZGVsLCB7XG4gICAgICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnlcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGFzc29TZWxlY3RUb29sVmlldztcbn0pKHNlbGVjdF90b29sXzEuU2VsZWN0VG9vbFZpZXcpO1xuREVGQVVMVF9QT0xZX09WRVJMQVkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBwb2x5X2Fubm90YXRpb25fMS5Qb2x5QW5ub3RhdGlvbih7XG4gICAgICAgIGxldmVsOiBcIm92ZXJsYXlcIixcbiAgICAgICAgeHNfdW5pdHM6IFwic2NyZWVuXCIsXG4gICAgICAgIHlzX3VuaXRzOiBcInNjcmVlblwiLFxuICAgICAgICBmaWxsX2NvbG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogXCJsaWdodGdyZXlcIlxuICAgICAgICB9LFxuICAgICAgICBmaWxsX2FscGhhOiB7XG4gICAgICAgICAgICB2YWx1ZTogMC41XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVfY29sb3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBcImJsYWNrXCJcbiAgICAgICAgfSxcbiAgICAgICAgbGluZV9hbHBoYToge1xuICAgICAgICAgICAgdmFsdWU6IDEuMFxuICAgICAgICB9LFxuICAgICAgICBsaW5lX3dpZHRoOiB7XG4gICAgICAgICAgICB2YWx1ZTogMlxuICAgICAgICB9LFxuICAgICAgICBsaW5lX2Rhc2g6IHtcbiAgICAgICAgICAgIHZhbHVlOiBbNCwgNF1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmV4cG9ydHMuTGFzc29TZWxlY3RUb29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExhc3NvU2VsZWN0VG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGFzc29TZWxlY3RUb29sKCkge1xuICAgICAgICByZXR1cm4gTGFzc29TZWxlY3RUb29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMYXNzb1NlbGVjdFRvb2wucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuTGFzc29TZWxlY3RUb29sVmlldztcbiAgICBMYXNzb1NlbGVjdFRvb2wucHJvdG90eXBlLnR5cGUgPSBcIkxhc3NvU2VsZWN0VG9vbFwiO1xuICAgIExhc3NvU2VsZWN0VG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJMYXNzbyBTZWxlY3RcIjtcbiAgICBMYXNzb1NlbGVjdFRvb2wucHJvdG90eXBlLmljb24gPSBcImJrLXRvb2wtaWNvbi1sYXNzby1zZWxlY3RcIjtcbiAgICBMYXNzb1NlbGVjdFRvb2wucHJvdG90eXBlLmV2ZW50X3R5cGUgPSBcInBhblwiO1xuICAgIExhc3NvU2VsZWN0VG9vbC5wcm90b3R5cGUuZGVmYXVsdF9vcmRlciA9IDEyO1xuICAgIExhc3NvU2VsZWN0VG9vbC5kZWZpbmUoe1xuICAgICAgICBzZWxlY3RfZXZlcnlfbW91c2Vtb3ZlOiBbcC5Cb29sLCB0cnVlXSxcbiAgICAgICAgY2FsbGJhY2s6IFtwLkluc3RhbmNlXSxcbiAgICAgICAgb3ZlcmxheTogW3AuSW5zdGFuY2UsIERFRkFVTFRfUE9MWV9PVkVSTEFZXVxuICAgIH0pO1xuICAgIHJldHVybiBMYXNzb1NlbGVjdFRvb2w7XG59KShzZWxlY3RfdG9vbF8xLlNlbGVjdFRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGdlc3R1cmVfdG9vbF8xID0gcmVxdWlyZShcIi4vZ2VzdHVyZV90b29sXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5QYW5Ub29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQYW5Ub29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUGFuVG9vbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBQYW5Ub29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGFuVG9vbFZpZXcucHJvdG90eXBlLl9wYW5fc3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgY2FudmFzLCBmcmFtZSwgaHIsIHZyLCB2eCwgdnk7XG4gICAgICAgIHRoaXMubGFzdF9keCA9IDA7XG4gICAgICAgIHRoaXMubGFzdF9keSA9IDA7XG4gICAgICAgIGNhbnZhcyA9IHRoaXMucGxvdF92aWV3LmNhbnZhcztcbiAgICAgICAgZnJhbWUgPSB0aGlzLnBsb3Rfdmlldy5mcmFtZTtcbiAgICAgICAgdnggPSBjYW52YXMuc3hfdG9fdngoZS5ib2tlaC5zeCk7XG4gICAgICAgIHZ5ID0gY2FudmFzLnN5X3RvX3Z5KGUuYm9rZWguc3kpO1xuICAgICAgICBpZiAoIWZyYW1lLmNvbnRhaW5zKHZ4LCB2eSkpIHtcbiAgICAgICAgICAgIGhyID0gZnJhbWUuaF9yYW5nZTtcbiAgICAgICAgICAgIHZyID0gZnJhbWUudl9yYW5nZTtcbiAgICAgICAgICAgIGlmICh2eCA8IGhyLnN0YXJ0IHx8IHZ4ID4gaHIuZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52X2F4aXNfb25seSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodnkgPCB2ci5zdGFydCB8fCB2eSA+IHZyLmVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaF9heGlzX29ubHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5pbnRlcmFjdGl2ZV90aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIH07XG4gICAgUGFuVG9vbFZpZXcucHJvdG90eXBlLl9wYW4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUoZS5kZWx0YVgsIC1lLmRlbHRhWSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5pbnRlcmFjdGl2ZV90aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIH07XG4gICAgUGFuVG9vbFZpZXcucHJvdG90eXBlLl9wYW5fZW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5oX2F4aXNfb25seSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZfYXhpc19vbmx5ID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnBhbl9pbmZvICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5wdXNoX3N0YXRlKCdwYW4nLCB7XG4gICAgICAgICAgICAgICAgcmFuZ2U6IHRoaXMucGFuX2luZm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYW5Ub29sVmlldy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICAgICAgdmFyIGRpbXMsIGVuZCwgZnJhbWUsIGhyLCBpc19wYW5uaW5nLCBuYW1lLCBuZXdfZHgsIG5ld19keSwgcmVmLCByZWYxLCByZWYyLCByZWYzLCBzY2FsZSwgc2R4LCBzZHksIHN0YXJ0LCBzeDAsIHN4MSwgc3hfaGlnaCwgc3hfbG93LCBzeTAsIHN5MSwgc3lfaGlnaCwgc3lfbG93LCB2ciwgeHJzLCB5cnM7XG4gICAgICAgIGZyYW1lID0gdGhpcy5wbG90X3ZpZXcuZnJhbWU7XG4gICAgICAgIG5ld19keCA9IGR4IC0gdGhpcy5sYXN0X2R4O1xuICAgICAgICBuZXdfZHkgPSBkeSAtIHRoaXMubGFzdF9keTtcbiAgICAgICAgaHIgPSBmcmFtZS5oX3JhbmdlO1xuICAgICAgICBzeF9sb3cgPSBoci5zdGFydCAtIG5ld19keDtcbiAgICAgICAgc3hfaGlnaCA9IGhyLmVuZCAtIG5ld19keDtcbiAgICAgICAgdnIgPSBmcmFtZS52X3JhbmdlO1xuICAgICAgICBzeV9sb3cgPSB2ci5zdGFydCAtIG5ld19keTtcbiAgICAgICAgc3lfaGlnaCA9IHZyLmVuZCAtIG5ld19keTtcbiAgICAgICAgZGltcyA9IHRoaXMubW9kZWwuZGltZW5zaW9ucztcbiAgICAgICAgaWYgKChkaW1zID09PSAnd2lkdGgnIHx8IGRpbXMgPT09ICdib3RoJykgJiYgIXRoaXMudl9heGlzX29ubHkpIHtcbiAgICAgICAgICAgIHN4MCA9IHN4X2xvdztcbiAgICAgICAgICAgIHN4MSA9IHN4X2hpZ2g7XG4gICAgICAgICAgICBzZHggPSAtbmV3X2R4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3gwID0gaHIuc3RhcnQ7XG4gICAgICAgICAgICBzeDEgPSBoci5lbmQ7XG4gICAgICAgICAgICBzZHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZGltcyA9PT0gJ2hlaWdodCcgfHwgZGltcyA9PT0gJ2JvdGgnKSAmJiAhdGhpcy5oX2F4aXNfb25seSkge1xuICAgICAgICAgICAgc3kwID0gc3lfbG93O1xuICAgICAgICAgICAgc3kxID0gc3lfaGlnaDtcbiAgICAgICAgICAgIHNkeSA9IG5ld19keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN5MCA9IHZyLnN0YXJ0O1xuICAgICAgICAgICAgc3kxID0gdnIuZW5kO1xuICAgICAgICAgICAgc2R5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RfZHggPSBkeDtcbiAgICAgICAgdGhpcy5sYXN0X2R5ID0gZHk7XG4gICAgICAgIHhycyA9IHt9O1xuICAgICAgICByZWYgPSBmcmFtZS54c2NhbGVzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHJlZltuYW1lXTtcbiAgICAgICAgICAgIHJlZjEgPSBzY2FsZS52X2ludmVydChbc3gwLCBzeDFdLCB0cnVlKSwgc3RhcnQgPSByZWYxWzBdLCBlbmQgPSByZWYxWzFdO1xuICAgICAgICAgICAgeHJzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB5cnMgPSB7fTtcbiAgICAgICAgcmVmMiA9IGZyYW1lLnlzY2FsZXM7XG4gICAgICAgIGZvciAobmFtZSBpbiByZWYyKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHJlZjJbbmFtZV07XG4gICAgICAgICAgICByZWYzID0gc2NhbGUudl9pbnZlcnQoW3N5MCwgc3kxXSwgdHJ1ZSksIHN0YXJ0ID0gcmVmM1swXSwgZW5kID0gcmVmM1sxXTtcbiAgICAgICAgICAgIHlyc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYW5faW5mbyA9IHtcbiAgICAgICAgICAgIHhyczogeHJzLFxuICAgICAgICAgICAgeXJzOiB5cnMsXG4gICAgICAgICAgICBzZHg6IHNkeCxcbiAgICAgICAgICAgIHNkeTogc2R5XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGxvdF92aWV3LnVwZGF0ZV9yYW5nZSh0aGlzLnBhbl9pbmZvLCBpc19wYW5uaW5nID0gdHJ1ZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFBhblRvb2xWaWV3O1xufSkoZ2VzdHVyZV90b29sXzEuR2VzdHVyZVRvb2xWaWV3KTtcbmV4cG9ydHMuUGFuVG9vbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQYW5Ub29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBQYW5Ub29sKCkge1xuICAgICAgICByZXR1cm4gUGFuVG9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGFuVG9vbC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5QYW5Ub29sVmlldztcbiAgICBQYW5Ub29sLnByb3RvdHlwZS50eXBlID0gXCJQYW5Ub29sXCI7XG4gICAgUGFuVG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJQYW5cIjtcbiAgICBQYW5Ub29sLnByb3RvdHlwZS5ldmVudF90eXBlID0gXCJwYW5cIjtcbiAgICBQYW5Ub29sLnByb3RvdHlwZS5kZWZhdWx0X29yZGVyID0gMTA7XG4gICAgUGFuVG9vbC5kZWZpbmUoe1xuICAgICAgICBkaW1lbnNpb25zOiBbcC5EaW1lbnNpb25zLCBcImJvdGhcIl1cbiAgICB9KTtcbiAgICBQYW5Ub29sLmdldHRlcnMoe1xuICAgICAgICB0b29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0X2RpbV90b29sdGlwKFwiUGFuXCIsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIGljb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdWZmaXg7XG4gICAgICAgICAgICBzdWZmaXggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kaW1lbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib3RoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwYW5cIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ4cGFuXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJoZWlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInlwYW5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIFwiYmstdG9vbC1pY29uLVwiICsgc3VmZml4O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFBhblRvb2w7XG59KShnZXN0dXJlX3Rvb2xfMS5HZXN0dXJlVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBERUZBVUxUX1BPTFlfT1ZFUkxBWSwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHNlbGVjdF90b29sXzEgPSByZXF1aXJlKFwiLi9zZWxlY3RfdG9vbFwiKTtcbnZhciBwb2x5X2Fubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9hbm5vdGF0aW9ucy9wb2x5X2Fubm90YXRpb25cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG5leHBvcnRzLlBvbHlTZWxlY3RUb29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQb2x5U2VsZWN0VG9vbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFBvbHlTZWxlY3RUb29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFBvbHlTZWxlY3RUb29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUG9seVNlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgUG9seVNlbGVjdFRvb2xWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnByb3BlcnRpZXMuYWN0aXZlLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZV9jaGFuZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEgPSB7XG4gICAgICAgICAgICB2eDogW10sXG4gICAgICAgICAgICB2eTogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFBvbHlTZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX2FjdGl2ZV9jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC5hY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGVhcl9kYXRhKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvbHlTZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX2tleXVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGVhcl9kYXRhKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvbHlTZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX2RvdWJsZXRhcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBhcHBlbmQsIHJlZjtcbiAgICAgICAgYXBwZW5kID0gKHJlZiA9IGUuc3JjRXZlbnQuc2hpZnRLZXkpICE9IG51bGwgPyByZWYgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2VsZWN0KHRoaXMuZGF0YS52eCwgdGhpcy5kYXRhLnZ5LCB0cnVlLCBhcHBlbmQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xlYXJfZGF0YSgpO1xuICAgIH07XG4gICAgUG9seVNlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5fY2xlYXJfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kYXRhID0ge1xuICAgICAgICAgICAgdng6IFtdLFxuICAgICAgICAgICAgdnk6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm92ZXJsYXkudXBkYXRlKHtcbiAgICAgICAgICAgIHhzOiBbXSxcbiAgICAgICAgICAgIHlzOiBbXVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBvbHlTZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX3RhcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjYW52YXMsIHZ4LCB2eTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzO1xuICAgICAgICB2eCA9IGNhbnZhcy5zeF90b192eChlLmJva2VoLnN4KTtcbiAgICAgICAgdnkgPSBjYW52YXMuc3lfdG9fdnkoZS5ib2tlaC5zeSk7XG4gICAgICAgIHRoaXMuZGF0YS52eC5wdXNoKHZ4KTtcbiAgICAgICAgdGhpcy5kYXRhLnZ5LnB1c2godnkpO1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5vdmVybGF5LnVwZGF0ZSh7XG4gICAgICAgICAgICB4czogYXJyYXlfMS5jb3B5KHRoaXMuZGF0YS52eCksXG4gICAgICAgICAgICB5czogYXJyYXlfMS5jb3B5KHRoaXMuZGF0YS52eSlcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQb2x5U2VsZWN0VG9vbFZpZXcucHJvdG90eXBlLl9zZWxlY3QgPSBmdW5jdGlvbiAodngsIHZ5LCBmaW5hbCwgYXBwZW5kKSB7XG4gICAgICAgIHZhciBkcywgZ2VvbWV0cnksIHIsIHJlbmRlcmVycywgcmVuZGVyZXJzX2J5X3NvdXJjZSwgc207XG4gICAgICAgIGdlb21ldHJ5ID0ge1xuICAgICAgICAgICAgdHlwZTogJ3BvbHknLFxuICAgICAgICAgICAgdng6IHZ4LFxuICAgICAgICAgICAgdnk6IHZ5XG4gICAgICAgIH07XG4gICAgICAgIHJlbmRlcmVyc19ieV9zb3VyY2UgPSB0aGlzLm1vZGVsLl9jb21wdXRlZF9yZW5kZXJlcnNfYnlfZGF0YV9zb3VyY2UoKTtcbiAgICAgICAgZm9yIChkcyBpbiByZW5kZXJlcnNfYnlfc291cmNlKSB7XG4gICAgICAgICAgICByZW5kZXJlcnMgPSByZW5kZXJlcnNfYnlfc291cmNlW2RzXTtcbiAgICAgICAgICAgIHNtID0gcmVuZGVyZXJzWzBdLmRhdGFfc291cmNlLnNlbGVjdGlvbl9tYW5hZ2VyO1xuICAgICAgICAgICAgc20uc2VsZWN0KHRoaXMsIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVuZGVyZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByZW5kZXJlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnBsb3Rfdmlldy5yZW5kZXJlcl92aWV3c1tyLmlkXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzKSwgZ2VvbWV0cnksIGZpbmFsLCBhcHBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NhdmVfZ2VvbWV0cnkoZ2VvbWV0cnksIGZpbmFsLCBhcHBlbmQpO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5wdXNoX3N0YXRlKCdwb2x5X3NlbGVjdCcsIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogdGhpcy5wbG90X3ZpZXcuZ2V0X3NlbGVjdGlvbigpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQb2x5U2VsZWN0VG9vbFZpZXc7XG59KShzZWxlY3RfdG9vbF8xLlNlbGVjdFRvb2xWaWV3KTtcbkRFRkFVTFRfUE9MWV9PVkVSTEFZID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgcG9seV9hbm5vdGF0aW9uXzEuUG9seUFubm90YXRpb24oe1xuICAgICAgICBsZXZlbDogXCJvdmVybGF5XCIsXG4gICAgICAgIHhzX3VuaXRzOiBcInNjcmVlblwiLFxuICAgICAgICB5c191bml0czogXCJzY3JlZW5cIixcbiAgICAgICAgZmlsbF9jb2xvcjoge1xuICAgICAgICAgICAgdmFsdWU6IFwibGlnaHRncmV5XCJcbiAgICAgICAgfSxcbiAgICAgICAgZmlsbF9hbHBoYToge1xuICAgICAgICAgICAgdmFsdWU6IDAuNVxuICAgICAgICB9LFxuICAgICAgICBsaW5lX2NvbG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogXCJibGFja1wiXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVfYWxwaGE6IHtcbiAgICAgICAgICAgIHZhbHVlOiAxLjBcbiAgICAgICAgfSxcbiAgICAgICAgbGluZV93aWR0aDoge1xuICAgICAgICAgICAgdmFsdWU6IDJcbiAgICAgICAgfSxcbiAgICAgICAgbGluZV9kYXNoOiB7XG4gICAgICAgICAgICB2YWx1ZTogWzQsIDRdXG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5leHBvcnRzLlBvbHlTZWxlY3RUb29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFBvbHlTZWxlY3RUb29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBQb2x5U2VsZWN0VG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIFBvbHlTZWxlY3RUb29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQb2x5U2VsZWN0VG9vbC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5Qb2x5U2VsZWN0VG9vbFZpZXc7XG4gICAgUG9seVNlbGVjdFRvb2wucHJvdG90eXBlLnR5cGUgPSBcIlBvbHlTZWxlY3RUb29sXCI7XG4gICAgUG9seVNlbGVjdFRvb2wucHJvdG90eXBlLnRvb2xfbmFtZSA9IFwiUG9seSBTZWxlY3RcIjtcbiAgICBQb2x5U2VsZWN0VG9vbC5wcm90b3R5cGUuaWNvbiA9IFwiYmstdG9vbC1pY29uLXBvbHlnb24tc2VsZWN0XCI7XG4gICAgUG9seVNlbGVjdFRvb2wucHJvdG90eXBlLmV2ZW50X3R5cGUgPSBcInRhcFwiO1xuICAgIFBvbHlTZWxlY3RUb29sLnByb3RvdHlwZS5kZWZhdWx0X29yZGVyID0gMTE7XG4gICAgUG9seVNlbGVjdFRvb2wuZGVmaW5lKHtcbiAgICAgICAgb3ZlcmxheTogW3AuSW5zdGFuY2UsIERFRkFVTFRfUE9MWV9PVkVSTEFZXVxuICAgIH0pO1xuICAgIHJldHVybiBQb2x5U2VsZWN0VG9vbDtcbn0pKHNlbGVjdF90b29sXzEuU2VsZWN0VG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgZ2VzdHVyZV90b29sXzEgPSByZXF1aXJlKFwiLi9nZXN0dXJlX3Rvb2xcIik7XG52YXIgZG9tXzEgPSByZXF1aXJlKFwiY29yZS9kb21cIik7XG5leHBvcnRzLlJlc2l6ZVRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJlc2l6ZVRvb2xWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBSZXNpemVUb29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFJlc2l6ZVRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZXNpemVUb29sVmlldy5wcm90b3R5cGUuY2xhc3NOYW1lID0gXCJiay1yZXNpemUtcG9wdXBcIjtcbiAgICBSZXNpemVUb29sVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciB3cmFwcGVyO1xuICAgICAgICBSZXNpemVUb29sVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBkb21fMS5kaXYoKTtcbiAgICAgICAgd3JhcHBlciA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmVsO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMub3ZlcmxheSk7XG4gICAgICAgIGRvbV8xLmhpZGUodGhpcy5vdmVybGF5KTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZXNpemVUb29sVmlldy5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZXNpemVUb29sVmlldy5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZXNpemVUb29sVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgY2FudmFzLCBmcmFtZSwgbGVmdCwgdG9wO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGNhbnZhcyA9IHRoaXMucGxvdF92aWV3LmNhbnZhcztcbiAgICAgICAgICAgIGZyYW1lID0gdGhpcy5wbG90X3ZpZXcuZnJhbWU7XG4gICAgICAgICAgICBsZWZ0ID0gY2FudmFzLnZ4X3RvX3N4KGZyYW1lLmhfcmFuZ2UuZW5kIC0gNDApO1xuICAgICAgICAgICAgdG9wID0gY2FudmFzLnZ5X3RvX3N5KGZyYW1lLnZfcmFuZ2Uuc3RhcnQgKyA0MCk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5LnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgZG9tXzEuc2hvdyh0aGlzLm92ZXJsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG9tXzEuaGlkZSh0aGlzLm92ZXJsYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUmVzaXplVG9vbFZpZXcucHJvdG90eXBlLl9wYW5fc3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgY2FudmFzO1xuICAgICAgICBjYW52YXMgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXM7XG4gICAgICAgIHRoaXMuY2ggPSBjYW52YXMuX2hlaWdodC52YWx1ZTtcbiAgICAgICAgdGhpcy5jdyA9IGNhbnZhcy5fd2lkdGgudmFsdWU7XG4gICAgICAgIHRoaXMucGxvdF92aWV3LmludGVyYWN0aXZlX3RpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVzaXplVG9vbFZpZXcucHJvdG90eXBlLl9wYW4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUoZS5kZWx0YVgsIGUuZGVsdGFZKTtcbiAgICAgICAgdGhpcy5wbG90X3ZpZXcuaW50ZXJhY3RpdmVfdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZXNpemVUb29sVmlldy5wcm90b3R5cGUuX3Bhbl9lbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wbG90X3ZpZXcucHVzaF9zdGF0ZShcInJlc2l6ZVwiLCB7XG4gICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMucGxvdF92aWV3LmNhbnZhcy5fd2lkdGgudmFsdWUsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnBsb3Rfdmlldy5jYW52YXMuX2hlaWdodC52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlc2l6ZVRvb2xWaWV3LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgICB2YXIgbmV3X2hlaWdodCwgbmV3X3dpZHRoO1xuICAgICAgICBuZXdfd2lkdGggPSB0aGlzLmN3ICsgZHg7XG4gICAgICAgIG5ld19oZWlnaHQgPSB0aGlzLmNoICsgZHk7XG4gICAgICAgIGlmIChuZXdfd2lkdGggPCAxMDAgfHwgbmV3X2hlaWdodCA8IDEwMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxvdF92aWV3LnVwZGF0ZV9kaW1lbnNpb25zKG5ld193aWR0aCwgbmV3X2hlaWdodCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzaXplVG9vbFZpZXc7XG59KShnZXN0dXJlX3Rvb2xfMS5HZXN0dXJlVG9vbFZpZXcpO1xuZXhwb3J0cy5SZXNpemVUb29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJlc2l6ZVRvb2wsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFJlc2l6ZVRvb2woKSB7XG4gICAgICAgIHJldHVybiBSZXNpemVUb29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZXNpemVUb29sLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlJlc2l6ZVRvb2xWaWV3O1xuICAgIFJlc2l6ZVRvb2wucHJvdG90eXBlLnR5cGUgPSBcIlJlc2l6ZVRvb2xcIjtcbiAgICBSZXNpemVUb29sLnByb3RvdHlwZS50b29sX25hbWUgPSBcIlJlc2l6ZVwiO1xuICAgIFJlc2l6ZVRvb2wucHJvdG90eXBlLmljb24gPSBcImJrLXRvb2wtaWNvbi1yZXNpemVcIjtcbiAgICBSZXNpemVUb29sLnByb3RvdHlwZS5ldmVudF90eXBlID0gXCJwYW5cIjtcbiAgICBSZXNpemVUb29sLnByb3RvdHlwZS5kZWZhdWx0X29yZGVyID0gNDA7XG4gICAgcmV0dXJuIFJlc2l6ZVRvb2w7XG59KShnZXN0dXJlX3Rvb2xfMS5HZXN0dXJlVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgZ2VzdHVyZV90b29sXzEgPSByZXF1aXJlKFwiLi9nZXN0dXJlX3Rvb2xcIik7XG52YXIgZ2x5cGhfcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJlcnMvZ2x5cGhfcmVuZGVyZXJcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvb2JqZWN0XCIpO1xuZXhwb3J0cy5TZWxlY3RUb29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTZWxlY3RUb29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gU2VsZWN0VG9vbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBTZWxlY3RUb29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2VsZWN0VG9vbFZpZXcucHJvdG90eXBlLl9rZXl1cCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBkcywgaiwgbGVuLCByLCByZWYsIHJlc3VsdHMsIHNtO1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5jb21wdXRlZF9yZW5kZXJlcnM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICByID0gcmVmW2pdO1xuICAgICAgICAgICAgICAgIGRzID0gci5kYXRhX3NvdXJjZTtcbiAgICAgICAgICAgICAgICBzbSA9IGRzLnNlbGVjdGlvbl9tYW5hZ2VyO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChzbS5jbGVhcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX3NhdmVfZ2VvbWV0cnkgPSBmdW5jdGlvbiAoZ2VvbWV0cnksIGZpbmFsLCBhcHBlbmQpIHtcbiAgICAgICAgdmFyIGcsIGdlb21zLCBpLCBqLCByZWYsIHRvb2xfZXZlbnRzLCB4bSwgeW07XG4gICAgICAgIGcgPSBvYmplY3RfMS5jbG9uZShnZW9tZXRyeSk7XG4gICAgICAgIHhtID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueHNjYWxlc1snZGVmYXVsdCddO1xuICAgICAgICB5bSA9IHRoaXMucGxvdF92aWV3LmZyYW1lLnlzY2FsZXNbJ2RlZmF1bHQnXTtcbiAgICAgICAgc3dpdGNoIChnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3BvaW50JzpcbiAgICAgICAgICAgICAgICBnLnggPSB4bS5pbnZlcnQoZy52eCk7XG4gICAgICAgICAgICAgICAgZy55ID0geW0uaW52ZXJ0KGcudnkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVjdCc6XG4gICAgICAgICAgICAgICAgZy54MCA9IHhtLmludmVydChnLnZ4MCk7XG4gICAgICAgICAgICAgICAgZy55MCA9IHltLmludmVydChnLnZ5MCk7XG4gICAgICAgICAgICAgICAgZy54MSA9IHhtLmludmVydChnLnZ4MSk7XG4gICAgICAgICAgICAgICAgZy55MSA9IHltLmludmVydChnLnZ5MSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwb2x5JzpcbiAgICAgICAgICAgICAgICBnLnggPSBuZXcgQXJyYXkoZy52eC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGcueSA9IG5ldyBBcnJheShnLnZ5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGcudngubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgZy54W2ldID0geG0uaW52ZXJ0KGcudnhbaV0pO1xuICAgICAgICAgICAgICAgICAgICBnLnlbaV0gPSB5bS5pbnZlcnQoZy52eVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiVW5yZWNvZ25pemVkIHNlbGVjdGlvbiBnZW9tZXRyeSB0eXBlOiAnXCIgKyBnLnR5cGUgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICB0b29sX2V2ZW50cyA9IHRoaXMucGxvdF9tb2RlbC5wbG90LnRvb2xfZXZlbnRzO1xuICAgICAgICAgICAgaWYgKGFwcGVuZCkge1xuICAgICAgICAgICAgICAgIGdlb21zID0gdG9vbF9ldmVudHMuZ2VvbWV0cmllcztcbiAgICAgICAgICAgICAgICBnZW9tcy5wdXNoKGcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VvbXMgPSBbZ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b29sX2V2ZW50cy5nZW9tZXRyaWVzID0gZ2VvbXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0VG9vbFZpZXc7XG59KShnZXN0dXJlX3Rvb2xfMS5HZXN0dXJlVG9vbFZpZXcpO1xuZXhwb3J0cy5TZWxlY3RUb29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFNlbGVjdFRvb2wsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFNlbGVjdFRvb2woKSB7XG4gICAgICAgIHJldHVybiBTZWxlY3RUb29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTZWxlY3RUb29sLmRlZmluZSh7XG4gICAgICAgIHJlbmRlcmVyczogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgbmFtZXM6IFtwLkFycmF5LCBbXV1cbiAgICB9KTtcbiAgICBTZWxlY3RUb29sLmludGVybmFsKHtcbiAgICAgICAgbXVsdGlfc2VsZWN0X21vZGlmaWVyOiBbcC5TdHJpbmcsIFwic2hpZnRcIl1cbiAgICB9KTtcbiAgICBTZWxlY3RUb29sLnByb3RvdHlwZS5jb25uZWN0X3NpZ25hbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFNlbGVjdFRvb2wuX19zdXBlcl9fLmNvbm5lY3Rfc2lnbmFscy5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5wcm9wZXJ0aWVzLnJlbmRlcmVycy5jaGFuZ2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wdXRlZF9yZW5kZXJlcnMgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMucHJvcGVydGllcy5uYW1lcy5jaGFuZ2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wdXRlZF9yZW5kZXJlcnMgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCh0aGlzLnByb3BlcnRpZXMucGxvdC5jaGFuZ2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wdXRlZF9yZW5kZXJlcnMgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlbGVjdFRvb2wucHJvdG90eXBlLl9jb21wdXRlX3JlbmRlcmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFsbF9yZW5kZXJlcnMsIG5hbWVzLCByLCByZW5kZXJlcnM7XG4gICAgICAgIHJlbmRlcmVycyA9IHRoaXMucmVuZGVyZXJzO1xuICAgICAgICBuYW1lcyA9IHRoaXMubmFtZXM7XG4gICAgICAgIGlmIChyZW5kZXJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBhbGxfcmVuZGVyZXJzID0gdGhpcy5wbG90LnJlbmRlcmVycztcbiAgICAgICAgICAgIHJlbmRlcmVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gYWxsX3JlbmRlcmVycy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICByID0gYWxsX3JlbmRlcmVyc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBnbHlwaF9yZW5kZXJlcl8xLkdseXBoUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlbmRlcmVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVuZGVyZXJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByZW5kZXJlcnNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lcy5pbmRleE9mKHIubmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZXJzO1xuICAgIH07XG4gICAgU2VsZWN0VG9vbC5nZXR0ZXJzKHtcbiAgICAgICAgY29tcHV0ZWRfcmVuZGVyZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcHV0ZWRfcmVuZGVyZXJzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wdXRlZF9yZW5kZXJlcnMgPSB0aGlzLl9jb21wdXRlX3JlbmRlcmVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXB1dGVkX3JlbmRlcmVycztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFNlbGVjdFRvb2wucHJvdG90eXBlLl9jb21wdXRlZF9yZW5kZXJlcnNfYnlfZGF0YV9zb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBqLCBsZW4sIHIsIHJlZiwgcmVuZGVyZXJzX2J5X3NvdXJjZTtcbiAgICAgICAgcmVuZGVyZXJzX2J5X3NvdXJjZSA9IHt9O1xuICAgICAgICByZWYgPSB0aGlzLmNvbXB1dGVkX3JlbmRlcmVycztcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByID0gcmVmW2pdO1xuICAgICAgICAgICAgaWYgKCEoci5kYXRhX3NvdXJjZS5pZCBpbiByZW5kZXJlcnNfYnlfc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyc19ieV9zb3VyY2Vbci5kYXRhX3NvdXJjZS5pZF0gPSBbcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlcnNfYnlfc291cmNlW3IuZGF0YV9zb3VyY2UuaWRdID0gcmVuZGVyZXJzX2J5X3NvdXJjZVtyLmRhdGFfc291cmNlLmlkXS5jb25jYXQoW3JdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZXJzX2J5X3NvdXJjZTtcbiAgICB9O1xuICAgIHJldHVybiBTZWxlY3RUb29sO1xufSkoZ2VzdHVyZV90b29sXzEuR2VzdHVyZVRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHNlbGVjdF90b29sXzEgPSByZXF1aXJlKFwiLi9zZWxlY3RfdG9vbFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90eXBlc1wiKTtcbmV4cG9ydHMuVGFwVG9vbFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVGFwVG9vbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRhcFRvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gVGFwVG9vbFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRhcFRvb2xWaWV3LnByb3RvdHlwZS5fdGFwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGFwcGVuZCwgY2FudmFzLCByZWYsIHZ4LCB2eTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzO1xuICAgICAgICB2eCA9IGNhbnZhcy5zeF90b192eChlLmJva2VoLnN4KTtcbiAgICAgICAgdnkgPSBjYW52YXMuc3lfdG9fdnkoZS5ib2tlaC5zeSk7XG4gICAgICAgIGFwcGVuZCA9IChyZWYgPSBlLnNyY0V2ZW50LnNoaWZ0S2V5KSAhPSBudWxsID8gcmVmIDogZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3QodngsIHZ5LCB0cnVlLCBhcHBlbmQpO1xuICAgIH07XG4gICAgVGFwVG9vbFZpZXcucHJvdG90eXBlLl9zZWxlY3QgPSBmdW5jdGlvbiAodngsIHZ5LCBmaW5hbCwgYXBwZW5kKSB7XG4gICAgICAgIHZhciBfLCBjYWxsYmFjaywgY2JfZGF0YSwgZGlkX2hpdCwgZHMsIGdlb21ldHJ5LCBpLCBsZW4sIHIsIHJlZiwgcmVuZGVyZXJzLCByZW5kZXJlcnNfYnlfc291cmNlLCBzbSwgdmlldztcbiAgICAgICAgZ2VvbWV0cnkgPSB7XG4gICAgICAgICAgICB0eXBlOiAncG9pbnQnLFxuICAgICAgICAgICAgdng6IHZ4LFxuICAgICAgICAgICAgdnk6IHZ5XG4gICAgICAgIH07XG4gICAgICAgIGNhbGxiYWNrID0gdGhpcy5tb2RlbC5jYWxsYmFjaztcbiAgICAgICAgdGhpcy5fc2F2ZV9nZW9tZXRyeShnZW9tZXRyeSwgZmluYWwsIGFwcGVuZCk7XG4gICAgICAgIGNiX2RhdGEgPSB7XG4gICAgICAgICAgICBnZW9tZXRyaWVzOiB0aGlzLnBsb3RfbW9kZWwucGxvdC50b29sX2V2ZW50cy5nZW9tZXRyaWVzXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmJlaGF2aW9yID09PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgICByZW5kZXJlcnNfYnlfc291cmNlID0gdGhpcy5tb2RlbC5fY29tcHV0ZWRfcmVuZGVyZXJzX2J5X2RhdGFfc291cmNlKCk7XG4gICAgICAgICAgICBmb3IgKF8gaW4gcmVuZGVyZXJzX2J5X3NvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVycyA9IHJlbmRlcmVyc19ieV9zb3VyY2VbX107XG4gICAgICAgICAgICAgICAgZHMgPSByZW5kZXJlcnNbMF0uZGF0YV9zb3VyY2U7XG4gICAgICAgICAgICAgICAgc20gPSBkcy5zZWxlY3Rpb25fbWFuYWdlcjtcbiAgICAgICAgICAgICAgICBkaWRfaGl0ID0gc20uc2VsZWN0KHRoaXMsIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVuZGVyZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByID0gcmVuZGVyZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMucGxvdF92aWV3LnJlbmRlcmVyX3ZpZXdzW3IuaWRdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9KS5jYWxsKHRoaXMpLCBnZW9tZXRyeSwgZmluYWwsIGFwcGVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZF9oaXQgJiYgKGNhbGxiYWNrICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlc18xLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkcywgY2JfZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5leGVjdXRlKGRzLCBjYl9kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGxvdF92aWV3LnB1c2hfc3RhdGUoJ3RhcCcsIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IHRoaXMucGxvdF92aWV3LmdldF9zZWxlY3Rpb24oKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYgPSB0aGlzLm1vZGVsLmNvbXB1dGVkX3JlbmRlcmVycztcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHIgPSByZWZbaV07XG4gICAgICAgICAgICAgICAgZHMgPSByLmRhdGFfc291cmNlO1xuICAgICAgICAgICAgICAgIHNtID0gZHMuc2VsZWN0aW9uX21hbmFnZXI7XG4gICAgICAgICAgICAgICAgdmlldyA9IHRoaXMucGxvdF92aWV3LnJlbmRlcmVyX3ZpZXdzW3IuaWRdO1xuICAgICAgICAgICAgICAgIGRpZF9oaXQgPSBzbS5pbnNwZWN0KHRoaXMsIHZpZXcsIGdlb21ldHJ5LCB7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChkaWRfaGl0ICYmIChjYWxsYmFjayAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZXNfMS5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZHMsIGNiX2RhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suZXhlY3V0ZShkcywgY2JfZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gVGFwVG9vbFZpZXc7XG59KShzZWxlY3RfdG9vbF8xLlNlbGVjdFRvb2xWaWV3KTtcbmV4cG9ydHMuVGFwVG9vbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUYXBUb29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUYXBUb29sKCkge1xuICAgICAgICByZXR1cm4gVGFwVG9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGFwVG9vbC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5UYXBUb29sVmlldztcbiAgICBUYXBUb29sLnByb3RvdHlwZS50eXBlID0gXCJUYXBUb29sXCI7XG4gICAgVGFwVG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJUYXBcIjtcbiAgICBUYXBUb29sLnByb3RvdHlwZS5pY29uID0gXCJiay10b29sLWljb24tdGFwLXNlbGVjdFwiO1xuICAgIFRhcFRvb2wucHJvdG90eXBlLmV2ZW50X3R5cGUgPSBcInRhcFwiO1xuICAgIFRhcFRvb2wucHJvdG90eXBlLmRlZmF1bHRfb3JkZXIgPSAxMDtcbiAgICBUYXBUb29sLmRlZmluZSh7XG4gICAgICAgIGJlaGF2aW9yOiBbcC5TdHJpbmcsIFwic2VsZWN0XCJdLFxuICAgICAgICBjYWxsYmFjazogW3AuQW55XVxuICAgIH0pO1xuICAgIHJldHVybiBUYXBUb29sO1xufSkoc2VsZWN0X3Rvb2xfMS5TZWxlY3RUb29sKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBnZXN0dXJlX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2dlc3R1cmVfdG9vbFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuV2hlZWxQYW5Ub29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChXaGVlbFBhblRvb2xWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBXaGVlbFBhblRvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gV2hlZWxQYW5Ub29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgV2hlZWxQYW5Ub29sVmlldy5wcm90b3R5cGUuX3Njcm9sbCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBmYWN0b3I7XG4gICAgICAgIGZhY3RvciA9IHRoaXMubW9kZWwuc3BlZWQgKiBlLmJva2VoLmRlbHRhO1xuICAgICAgICBpZiAoZmFjdG9yID4gMC45KSB7XG4gICAgICAgICAgICBmYWN0b3IgPSAwLjk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmFjdG9yIDwgLTAuOSkge1xuICAgICAgICAgICAgZmFjdG9yID0gLTAuOTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlX3JhbmdlcyhmYWN0b3IpO1xuICAgIH07XG4gICAgV2hlZWxQYW5Ub29sVmlldy5wcm90b3R5cGUuX3VwZGF0ZV9yYW5nZXMgPSBmdW5jdGlvbiAoZmFjdG9yKSB7XG4gICAgICAgIHZhciBlbmQsIGZyYW1lLCBociwgbmFtZSwgcGFuX2luZm8sIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVmNSwgc2NhbGUsIHN0YXJ0LCBzeDAsIHN4MSwgc3kwLCBzeTEsIHZyLCB2eF9oaWdoLCB2eF9sb3csIHZ4X3JhbmdlLCB2eV9oaWdoLCB2eV9sb3csIHZ5X3JhbmdlLCB4cnMsIHlycztcbiAgICAgICAgZnJhbWUgPSB0aGlzLnBsb3RfbW9kZWwuZnJhbWU7XG4gICAgICAgIGhyID0gZnJhbWUuaF9yYW5nZTtcbiAgICAgICAgdnIgPSBmcmFtZS52X3JhbmdlO1xuICAgICAgICByZWYgPSBbaHIuc3RhcnQsIGhyLmVuZF0sIHZ4X2xvdyA9IHJlZlswXSwgdnhfaGlnaCA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IFt2ci5zdGFydCwgdnIuZW5kXSwgdnlfbG93ID0gcmVmMVswXSwgdnlfaGlnaCA9IHJlZjFbMV07XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5kaW1lbnNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJoZWlnaHRcIjpcbiAgICAgICAgICAgICAgICB2eV9yYW5nZSA9IE1hdGguYWJzKHZ5X2hpZ2ggLSB2eV9sb3cpO1xuICAgICAgICAgICAgICAgIHN4MCA9IHZ4X2xvdztcbiAgICAgICAgICAgICAgICBzeDEgPSB2eF9oaWdoO1xuICAgICAgICAgICAgICAgIHN5MCA9IHZ5X2xvdyArIHZ5X3JhbmdlICogZmFjdG9yO1xuICAgICAgICAgICAgICAgIHN5MSA9IHZ5X2hpZ2ggKyB2eV9yYW5nZSAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICAgICAgICAgIHZ4X3JhbmdlID0gTWF0aC5hYnModnhfaGlnaCAtIHZ4X2xvdyk7XG4gICAgICAgICAgICAgICAgc3gwID0gdnhfbG93IC0gdnhfcmFuZ2UgKiBmYWN0b3I7XG4gICAgICAgICAgICAgICAgc3gxID0gdnhfaGlnaCAtIHZ4X3JhbmdlICogZmFjdG9yO1xuICAgICAgICAgICAgICAgIHN5MCA9IHZ5X2xvdztcbiAgICAgICAgICAgICAgICBzeTEgPSB2eV9oaWdoO1xuICAgICAgICB9XG4gICAgICAgIHhycyA9IHt9O1xuICAgICAgICByZWYyID0gZnJhbWUueHNjYWxlcztcbiAgICAgICAgZm9yIChuYW1lIGluIHJlZjIpIHtcbiAgICAgICAgICAgIHNjYWxlID0gcmVmMltuYW1lXTtcbiAgICAgICAgICAgIHJlZjMgPSBzY2FsZS52X2ludmVydChbc3gwLCBzeDFdLCB0cnVlKSwgc3RhcnQgPSByZWYzWzBdLCBlbmQgPSByZWYzWzFdO1xuICAgICAgICAgICAgeHJzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB5cnMgPSB7fTtcbiAgICAgICAgcmVmNCA9IGZyYW1lLnlzY2FsZXM7XG4gICAgICAgIGZvciAobmFtZSBpbiByZWY0KSB7XG4gICAgICAgICAgICBzY2FsZSA9IHJlZjRbbmFtZV07XG4gICAgICAgICAgICByZWY1ID0gc2NhbGUudl9pbnZlcnQoW3N5MCwgc3kxXSwgdHJ1ZSksIHN0YXJ0ID0gcmVmNVswXSwgZW5kID0gcmVmNVsxXTtcbiAgICAgICAgICAgIHlyc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcGFuX2luZm8gPSB7XG4gICAgICAgICAgICB4cnM6IHhycyxcbiAgICAgICAgICAgIHlyczogeXJzLFxuICAgICAgICAgICAgZmFjdG9yOiBmYWN0b3JcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wbG90X3ZpZXcucHVzaF9zdGF0ZSgnd2hlZWxfcGFuJywge1xuICAgICAgICAgICAgcmFuZ2U6IHBhbl9pbmZvXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy51cGRhdGVfcmFuZ2UocGFuX2luZm8sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5wbG90X3ZpZXcuaW50ZXJhY3RpdmVfdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gV2hlZWxQYW5Ub29sVmlldztcbn0pKGdlc3R1cmVfdG9vbF8xLkdlc3R1cmVUb29sVmlldyk7XG5leHBvcnRzLldoZWVsUGFuVG9vbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChXaGVlbFBhblRvb2wsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFdoZWVsUGFuVG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIFdoZWVsUGFuVG9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgV2hlZWxQYW5Ub29sLnByb3RvdHlwZS50eXBlID0gJ1doZWVsUGFuVG9vbCc7XG4gICAgV2hlZWxQYW5Ub29sLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLldoZWVsUGFuVG9vbFZpZXc7XG4gICAgV2hlZWxQYW5Ub29sLnByb3RvdHlwZS50b29sX25hbWUgPSBcIldoZWVsIFBhblwiO1xuICAgIFdoZWVsUGFuVG9vbC5wcm90b3R5cGUuaWNvbiA9IFwiYmstdG9vbC1pY29uLXdoZWVsLXBhblwiO1xuICAgIFdoZWVsUGFuVG9vbC5wcm90b3R5cGUuZXZlbnRfdHlwZSA9ICdzY3JvbGwnO1xuICAgIFdoZWVsUGFuVG9vbC5wcm90b3R5cGUuZGVmYXVsdF9vcmRlciA9IDEyO1xuICAgIFdoZWVsUGFuVG9vbC5nZXR0ZXJzKHtcbiAgICAgICAgdG9vbHRpcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9kaW1fdG9vbHRpcCh0aGlzLnRvb2xfbmFtZSwgdGhpcy5kaW1lbnNpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgV2hlZWxQYW5Ub29sLmRlZmluZSh7XG4gICAgICAgIGRpbWVuc2lvbjogW3AuRGltZW5zaW9uLCBcIndpZHRoXCJdXG4gICAgfSk7XG4gICAgV2hlZWxQYW5Ub29sLmludGVybmFsKHtcbiAgICAgICAgc3BlZWQ6IFtwLk51bWJlciwgMSAvIDEwMDBdXG4gICAgfSk7XG4gICAgcmV0dXJuIFdoZWVsUGFuVG9vbDtcbn0pKGdlc3R1cmVfdG9vbF8xLkdlc3R1cmVUb29sKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY3VtZW50LCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgZ2VzdHVyZV90b29sXzEgPSByZXF1aXJlKFwiLi9nZXN0dXJlX3Rvb2xcIik7XG52YXIgem9vbV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC96b29tXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBkb2N1bWVudCA9PT0gbnVsbCkge1xuICAgIGRvY3VtZW50ID0ge307XG59XG5leHBvcnRzLldoZWVsWm9vbVRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFdoZWVsWm9vbVRvb2xWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBXaGVlbFpvb21Ub29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFdoZWVsWm9vbVRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBXaGVlbFpvb21Ub29sVmlldy5wcm90b3R5cGUuX3BpbmNoID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGRlbHRhO1xuICAgICAgICBpZiAoZS5zY2FsZSA+PSAxKSB7XG4gICAgICAgICAgICBkZWx0YSA9IChlLnNjYWxlIC0gMSkgKiAyMC4wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsdGEgPSAtMjAuMCAvIGUuc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgZS5ib2tlaC5kZWx0YSA9IGRlbHRhO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsKGUpO1xuICAgIH07XG4gICAgV2hlZWxab29tVG9vbFZpZXcucHJvdG90eXBlLl9zY3JvbGwgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZGltcywgZmFjdG9yLCBmcmFtZSwgaF9heGlzLCBociwgdl9heGlzLCB2ciwgdngsIHZ5LCB6b29tX2luZm87XG4gICAgICAgIGZyYW1lID0gdGhpcy5wbG90X21vZGVsLmZyYW1lO1xuICAgICAgICBociA9IGZyYW1lLmhfcmFuZ2U7XG4gICAgICAgIHZyID0gZnJhbWUudl9yYW5nZTtcbiAgICAgICAgdnggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXMuc3hfdG9fdngoZS5ib2tlaC5zeCk7XG4gICAgICAgIHZ5ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzLnN5X3RvX3Z5KGUuYm9rZWguc3kpO1xuICAgICAgICBkaW1zID0gdGhpcy5tb2RlbC5kaW1lbnNpb25zO1xuICAgICAgICBoX2F4aXMgPSAoZGltcyA9PT0gJ3dpZHRoJyB8fCBkaW1zID09PSAnYm90aCcpICYmIChoci5taW4gPCB2eCAmJiB2eCA8IGhyLm1heCk7XG4gICAgICAgIHZfYXhpcyA9IChkaW1zID09PSAnaGVpZ2h0JyB8fCBkaW1zID09PSAnYm90aCcpICYmICh2ci5taW4gPCB2eSAmJiB2eSA8IHZyLm1heCk7XG4gICAgICAgIGZhY3RvciA9IHRoaXMubW9kZWwuc3BlZWQgKiBlLmJva2VoLmRlbHRhO1xuICAgICAgICB6b29tX2luZm8gPSB6b29tXzEuc2NhbGVfcmFuZ2UoZnJhbWUsIGZhY3RvciwgaF9heGlzLCB2X2F4aXMsIHtcbiAgICAgICAgICAgIHg6IHZ4LFxuICAgICAgICAgICAgeTogdnlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGxvdF92aWV3LnB1c2hfc3RhdGUoJ3doZWVsX3pvb20nLCB7XG4gICAgICAgICAgICByYW5nZTogem9vbV9pbmZvXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy51cGRhdGVfcmFuZ2Uoem9vbV9pbmZvLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMucGxvdF92aWV3LmludGVyYWN0aXZlX3RpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFdoZWVsWm9vbVRvb2xWaWV3O1xufSkoZ2VzdHVyZV90b29sXzEuR2VzdHVyZVRvb2xWaWV3KTtcbmV4cG9ydHMuV2hlZWxab29tVG9vbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChXaGVlbFpvb21Ub29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBXaGVlbFpvb21Ub29sKCkge1xuICAgICAgICByZXR1cm4gV2hlZWxab29tVG9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgV2hlZWxab29tVG9vbC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5XaGVlbFpvb21Ub29sVmlldztcbiAgICBXaGVlbFpvb21Ub29sLnByb3RvdHlwZS50eXBlID0gXCJXaGVlbFpvb21Ub29sXCI7XG4gICAgV2hlZWxab29tVG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJXaGVlbCBab29tXCI7XG4gICAgV2hlZWxab29tVG9vbC5wcm90b3R5cGUuaWNvbiA9IFwiYmstdG9vbC1pY29uLXdoZWVsLXpvb21cIjtcbiAgICBXaGVlbFpvb21Ub29sLnByb3RvdHlwZS5ldmVudF90eXBlID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwKSA/ICdwaW5jaCcgOiAnc2Nyb2xsJztcbiAgICBXaGVlbFpvb21Ub29sLnByb3RvdHlwZS5kZWZhdWx0X29yZGVyID0gMTA7XG4gICAgV2hlZWxab29tVG9vbC5nZXR0ZXJzKHtcbiAgICAgICAgdG9vbHRpcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9kaW1fdG9vbHRpcCh0aGlzLnRvb2xfbmFtZSwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFdoZWVsWm9vbVRvb2wuZGVmaW5lKHtcbiAgICAgICAgZGltZW5zaW9uczogW3AuRGltZW5zaW9ucywgXCJib3RoXCJdXG4gICAgfSk7XG4gICAgV2hlZWxab29tVG9vbC5pbnRlcm5hbCh7XG4gICAgICAgIHNwZWVkOiBbcC5OdW1iZXIsIDEgLyA2MDBdXG4gICAgfSk7XG4gICAgcmV0dXJuIFdoZWVsWm9vbVRvb2w7XG59KShnZXN0dXJlX3Rvb2xfMS5HZXN0dXJlVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhY3Rpb25fdG9vbF8xID0gcmVxdWlyZShcIi4vYWN0aW9ucy9hY3Rpb25fdG9vbFwiKTtcbmV4cG9ydHMuQWN0aW9uVG9vbCA9IGFjdGlvbl90b29sXzEuQWN0aW9uVG9vbDtcbnZhciBoZWxwX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbnMvaGVscF90b29sXCIpO1xuZXhwb3J0cy5IZWxwVG9vbCA9IGhlbHBfdG9vbF8xLkhlbHBUb29sO1xudmFyIHJlZG9fdG9vbF8xID0gcmVxdWlyZShcIi4vYWN0aW9ucy9yZWRvX3Rvb2xcIik7XG5leHBvcnRzLlJlZG9Ub29sID0gcmVkb190b29sXzEuUmVkb1Rvb2w7XG52YXIgcmVzZXRfdG9vbF8xID0gcmVxdWlyZShcIi4vYWN0aW9ucy9yZXNldF90b29sXCIpO1xuZXhwb3J0cy5SZXNldFRvb2wgPSByZXNldF90b29sXzEuUmVzZXRUb29sO1xudmFyIHNhdmVfdG9vbF8xID0gcmVxdWlyZShcIi4vYWN0aW9ucy9zYXZlX3Rvb2xcIik7XG5leHBvcnRzLlNhdmVUb29sID0gc2F2ZV90b29sXzEuU2F2ZVRvb2w7XG52YXIgdW5kb190b29sXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25zL3VuZG9fdG9vbFwiKTtcbmV4cG9ydHMuVW5kb1Rvb2wgPSB1bmRvX3Rvb2xfMS5VbmRvVG9vbDtcbnZhciB6b29tX2luX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbnMvem9vbV9pbl90b29sXCIpO1xuZXhwb3J0cy5ab29tSW5Ub29sID0gem9vbV9pbl90b29sXzEuWm9vbUluVG9vbDtcbnZhciB6b29tX291dF90b29sXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25zL3pvb21fb3V0X3Rvb2xcIik7XG5leHBvcnRzLlpvb21PdXRUb29sID0gem9vbV9vdXRfdG9vbF8xLlpvb21PdXRUb29sO1xudmFyIGJ1dHRvbl90b29sXzEgPSByZXF1aXJlKFwiLi9idXR0b25fdG9vbFwiKTtcbmV4cG9ydHMuQnV0dG9uVG9vbCA9IGJ1dHRvbl90b29sXzEuQnV0dG9uVG9vbDtcbnZhciBib3hfc2VsZWN0X3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2dlc3R1cmVzL2JveF9zZWxlY3RfdG9vbFwiKTtcbmV4cG9ydHMuQm94U2VsZWN0VG9vbCA9IGJveF9zZWxlY3RfdG9vbF8xLkJveFNlbGVjdFRvb2w7XG52YXIgYm94X3pvb21fdG9vbF8xID0gcmVxdWlyZShcIi4vZ2VzdHVyZXMvYm94X3pvb21fdG9vbFwiKTtcbmV4cG9ydHMuQm94Wm9vbVRvb2wgPSBib3hfem9vbV90b29sXzEuQm94Wm9vbVRvb2w7XG52YXIgZ2VzdHVyZV90b29sXzEgPSByZXF1aXJlKFwiLi9nZXN0dXJlcy9nZXN0dXJlX3Rvb2xcIik7XG5leHBvcnRzLkdlc3R1cmVUb29sID0gZ2VzdHVyZV90b29sXzEuR2VzdHVyZVRvb2w7XG52YXIgbGFzc29fc2VsZWN0X3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2dlc3R1cmVzL2xhc3NvX3NlbGVjdF90b29sXCIpO1xuZXhwb3J0cy5MYXNzb1NlbGVjdFRvb2wgPSBsYXNzb19zZWxlY3RfdG9vbF8xLkxhc3NvU2VsZWN0VG9vbDtcbnZhciBwYW5fdG9vbF8xID0gcmVxdWlyZShcIi4vZ2VzdHVyZXMvcGFuX3Rvb2xcIik7XG5leHBvcnRzLlBhblRvb2wgPSBwYW5fdG9vbF8xLlBhblRvb2w7XG52YXIgcG9seV9zZWxlY3RfdG9vbF8xID0gcmVxdWlyZShcIi4vZ2VzdHVyZXMvcG9seV9zZWxlY3RfdG9vbFwiKTtcbmV4cG9ydHMuUG9seVNlbGVjdFRvb2wgPSBwb2x5X3NlbGVjdF90b29sXzEuUG9seVNlbGVjdFRvb2w7XG52YXIgcmVzaXplX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2dlc3R1cmVzL3Jlc2l6ZV90b29sXCIpO1xuZXhwb3J0cy5SZXNpemVUb29sID0gcmVzaXplX3Rvb2xfMS5SZXNpemVUb29sO1xudmFyIHNlbGVjdF90b29sXzEgPSByZXF1aXJlKFwiLi9nZXN0dXJlcy9zZWxlY3RfdG9vbFwiKTtcbmV4cG9ydHMuU2VsZWN0VG9vbCA9IHNlbGVjdF90b29sXzEuU2VsZWN0VG9vbDtcbnZhciB0YXBfdG9vbF8xID0gcmVxdWlyZShcIi4vZ2VzdHVyZXMvdGFwX3Rvb2xcIik7XG5leHBvcnRzLlRhcFRvb2wgPSB0YXBfdG9vbF8xLlRhcFRvb2w7XG52YXIgd2hlZWxfcGFuX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2dlc3R1cmVzL3doZWVsX3Bhbl90b29sXCIpO1xuZXhwb3J0cy5XaGVlbFBhblRvb2wgPSB3aGVlbF9wYW5fdG9vbF8xLldoZWVsUGFuVG9vbDtcbnZhciB3aGVlbF96b29tX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2dlc3R1cmVzL3doZWVsX3pvb21fdG9vbFwiKTtcbmV4cG9ydHMuV2hlZWxab29tVG9vbCA9IHdoZWVsX3pvb21fdG9vbF8xLldoZWVsWm9vbVRvb2w7XG52YXIgY3Jvc3NoYWlyX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2luc3BlY3RvcnMvY3Jvc3NoYWlyX3Rvb2xcIik7XG5leHBvcnRzLkNyb3NzaGFpclRvb2wgPSBjcm9zc2hhaXJfdG9vbF8xLkNyb3NzaGFpclRvb2w7XG52YXIgaG92ZXJfdG9vbF8xID0gcmVxdWlyZShcIi4vaW5zcGVjdG9ycy9ob3Zlcl90b29sXCIpO1xuZXhwb3J0cy5Ib3ZlclRvb2wgPSBob3Zlcl90b29sXzEuSG92ZXJUb29sO1xudmFyIGluc3BlY3RfdG9vbF8xID0gcmVxdWlyZShcIi4vaW5zcGVjdG9ycy9pbnNwZWN0X3Rvb2xcIik7XG5leHBvcnRzLkluc3BlY3RUb29sID0gaW5zcGVjdF90b29sXzEuSW5zcGVjdFRvb2w7XG52YXIgdG9vbF8xID0gcmVxdWlyZShcIi4vdG9vbFwiKTtcbmV4cG9ydHMuVG9vbCA9IHRvb2xfMS5Ub29sO1xudmFyIHRvb2xfZXZlbnRzXzEgPSByZXF1aXJlKFwiLi90b29sX2V2ZW50c1wiKTtcbmV4cG9ydHMuVG9vbEV2ZW50cyA9IHRvb2xfZXZlbnRzXzEuVG9vbEV2ZW50cztcbnZhciB0b29sX3Byb3h5XzEgPSByZXF1aXJlKFwiLi90b29sX3Byb3h5XCIpO1xuZXhwb3J0cy5Ub29sUHJveHkgPSB0b29sX3Byb3h5XzEuVG9vbFByb3h5O1xudmFyIHRvb2xiYXJfMSA9IHJlcXVpcmUoXCIuL3Rvb2xiYXJcIik7XG5leHBvcnRzLlRvb2xiYXIgPSB0b29sYmFyXzEuVG9vbGJhcjtcbnZhciB0b29sYmFyX2Jhc2VfMSA9IHJlcXVpcmUoXCIuL3Rvb2xiYXJfYmFzZVwiKTtcbmV4cG9ydHMuVG9vbGJhckJhc2UgPSB0b29sYmFyX2Jhc2VfMS5Ub29sYmFyQmFzZTtcbnZhciB0b29sYmFyX2JveF8xID0gcmVxdWlyZShcIi4vdG9vbGJhcl9ib3hcIik7XG5leHBvcnRzLlRvb2xiYXJCb3hUb29sYmFyID0gdG9vbGJhcl9ib3hfMS5Ub29sYmFyQm94VG9vbGJhcjtcbnZhciB0b29sYmFyX2JveF8yID0gcmVxdWlyZShcIi4vdG9vbGJhcl9ib3hcIik7XG5leHBvcnRzLlRvb2xiYXJCb3ggPSB0b29sYmFyX2JveF8yLlRvb2xiYXJCb3g7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgaW5zcGVjdF90b29sXzEgPSByZXF1aXJlKFwiLi9pbnNwZWN0X3Rvb2xcIik7XG52YXIgc3Bhbl8xID0gcmVxdWlyZShcIi4uLy4uL2Fubm90YXRpb25zL3NwYW5cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL29iamVjdFwiKTtcbmV4cG9ydHMuQ3Jvc3NoYWlyVG9vbFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ3Jvc3NoYWlyVG9vbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENyb3NzaGFpclRvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gQ3Jvc3NoYWlyVG9vbFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENyb3NzaGFpclRvb2xWaWV3LnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjYW52YXMsIGZyYW1lLCB2eCwgdnk7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC5hY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcztcbiAgICAgICAgdnggPSBjYW52YXMuc3hfdG9fdngoZS5ib2tlaC5zeCk7XG4gICAgICAgIHZ5ID0gY2FudmFzLnN5X3RvX3Z5KGUuYm9rZWguc3kpO1xuICAgICAgICBpZiAoIWZyYW1lLmNvbnRhaW5zKHZ4LCB2eSkpIHtcbiAgICAgICAgICAgIHZ4ID0gdnkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVfc3BhbnModngsIHZ5KTtcbiAgICB9O1xuICAgIENyb3NzaGFpclRvb2xWaWV3LnByb3RvdHlwZS5fbW92ZV9leGl0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZV9zcGFucyhudWxsLCBudWxsKTtcbiAgICB9O1xuICAgIENyb3NzaGFpclRvb2xWaWV3LnByb3RvdHlwZS5fdXBkYXRlX3NwYW5zID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIGRpbXM7XG4gICAgICAgIGRpbXMgPSB0aGlzLm1vZGVsLmRpbWVuc2lvbnM7XG4gICAgICAgIGlmIChkaW1zID09PSAnd2lkdGgnIHx8IGRpbXMgPT09ICdib3RoJykge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5zcGFucy53aWR0aC5jb21wdXRlZF9sb2NhdGlvbiA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpbXMgPT09ICdoZWlnaHQnIHx8IGRpbXMgPT09ICdib3RoJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuc3BhbnMuaGVpZ2h0LmNvbXB1dGVkX2xvY2F0aW9uID0geDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENyb3NzaGFpclRvb2xWaWV3O1xufSkoaW5zcGVjdF90b29sXzEuSW5zcGVjdFRvb2xWaWV3KTtcbmV4cG9ydHMuQ3Jvc3NoYWlyVG9vbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDcm9zc2hhaXJUb29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDcm9zc2hhaXJUb29sKCkge1xuICAgICAgICByZXR1cm4gQ3Jvc3NoYWlyVG9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ3Jvc3NoYWlyVG9vbC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5Dcm9zc2hhaXJUb29sVmlldztcbiAgICBDcm9zc2hhaXJUb29sLnByb3RvdHlwZS50eXBlID0gXCJDcm9zc2hhaXJUb29sXCI7XG4gICAgQ3Jvc3NoYWlyVG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJDcm9zc2hhaXJcIjtcbiAgICBDcm9zc2hhaXJUb29sLnByb3RvdHlwZS5pY29uID0gXCJiay10b29sLWljb24tY3Jvc3NoYWlyXCI7XG4gICAgQ3Jvc3NoYWlyVG9vbC5kZWZpbmUoe1xuICAgICAgICBkaW1lbnNpb25zOiBbcC5EaW1lbnNpb25zLCBcImJvdGhcIl0sXG4gICAgICAgIGxpbmVfY29sb3I6IFtwLkNvbG9yLCAnYmxhY2snXSxcbiAgICAgICAgbGluZV93aWR0aDogW3AuTnVtYmVyLCAxXSxcbiAgICAgICAgbGluZV9hbHBoYTogW3AuTnVtYmVyLCAxLjBdXG4gICAgfSk7XG4gICAgQ3Jvc3NoYWlyVG9vbC5pbnRlcm5hbCh7XG4gICAgICAgIGxvY2F0aW9uX3VuaXRzOiBbcC5TcGF0aWFsVW5pdHMsIFwic2NyZWVuXCJdLFxuICAgICAgICByZW5kZXJfbW9kZTogW3AuUmVuZGVyTW9kZSwgXCJjc3NcIl0sXG4gICAgICAgIHNwYW5zOiBbcC5BbnldXG4gICAgfSk7XG4gICAgQ3Jvc3NoYWlyVG9vbC5nZXR0ZXJzKHtcbiAgICAgICAgdG9vbHRpcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9kaW1fdG9vbHRpcChcIkNyb3NzaGFpclwiLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBzeW50aGV0aWNfcmVuZGVyZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0XzEudmFsdWVzKHRoaXMuc3BhbnMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgQ3Jvc3NoYWlyVG9vbC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBDcm9zc2hhaXJUb29sLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFucyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBuZXcgc3Bhbl8xLlNwYW4oe1xuICAgICAgICAgICAgICAgIGZvcl9ob3ZlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb246IFwid2lkdGhcIixcbiAgICAgICAgICAgICAgICByZW5kZXJfbW9kZTogdGhpcy5yZW5kZXJfbW9kZSxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbl91bml0czogdGhpcy5sb2NhdGlvbl91bml0cyxcbiAgICAgICAgICAgICAgICBsaW5lX2NvbG9yOiB0aGlzLmxpbmVfY29sb3IsXG4gICAgICAgICAgICAgICAgbGluZV93aWR0aDogdGhpcy5saW5lX3dpZHRoLFxuICAgICAgICAgICAgICAgIGxpbmVfYWxwaGE6IHRoaXMubGluZV9hbHBoYVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBoZWlnaHQ6IG5ldyBzcGFuXzEuU3Bhbih7XG4gICAgICAgICAgICAgICAgZm9yX2hvdmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogXCJoZWlnaHRcIixcbiAgICAgICAgICAgICAgICByZW5kZXJfbW9kZTogdGhpcy5yZW5kZXJfbW9kZSxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbl91bml0czogdGhpcy5sb2NhdGlvbl91bml0cyxcbiAgICAgICAgICAgICAgICBsaW5lX2NvbG9yOiB0aGlzLmxpbmVfY29sb3IsXG4gICAgICAgICAgICAgICAgbGluZV93aWR0aDogdGhpcy5saW5lX3dpZHRoLFxuICAgICAgICAgICAgICAgIGxpbmVfYWxwaGE6IHRoaXMubGluZV9hbHBoYVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDcm9zc2hhaXJUb29sO1xufSkoaW5zcGVjdF90b29sXzEuSW5zcGVjdFRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX2NvbG9yX3RvX2hleCwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGluc3BlY3RfdG9vbF8xID0gcmVxdWlyZShcIi4vaW5zcGVjdF90b29sXCIpO1xudmFyIHRvb2x0aXBfMSA9IHJlcXVpcmUoXCIuLi8uLi9hbm5vdGF0aW9ucy90b29sdGlwXCIpO1xudmFyIGdseXBoX3JlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi4vLi4vcmVuZGVyZXJzL2dseXBoX3JlbmRlcmVyXCIpO1xudmFyIGhpdHRlc3QgPSByZXF1aXJlKFwiY29yZS9oaXR0ZXN0XCIpO1xudmFyIHRlbXBsYXRpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdGVtcGxhdGluZ1wiKTtcbnZhciBkb21fMSA9IHJlcXVpcmUoXCJjb3JlL2RvbVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvb2JqZWN0XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xudmFyIGJ1aWxkX3ZpZXdzXzEgPSByZXF1aXJlKFwiY29yZS9idWlsZF92aWV3c1wiKTtcbl9jb2xvcl90b19oZXggPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICB2YXIgYmx1ZSwgZGlnaXRzLCBncmVlbiwgcmVkLCByZ2I7XG4gICAgaWYgKGNvbG9yLnN1YnN0cigwLCAxKSA9PT0gJyMnKSB7XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgZGlnaXRzID0gLyguKj8pcmdiXFwoKFxcZCspLCAoXFxkKyksIChcXGQrKVxcKS8uZXhlYyhjb2xvcik7XG4gICAgcmVkID0gcGFyc2VJbnQoZGlnaXRzWzJdKTtcbiAgICBncmVlbiA9IHBhcnNlSW50KGRpZ2l0c1szXSk7XG4gICAgYmx1ZSA9IHBhcnNlSW50KGRpZ2l0c1s0XSk7XG4gICAgcmdiID0gYmx1ZSB8IChncmVlbiA8PCA4KSB8IChyZWQgPDwgMTYpO1xuICAgIHJldHVybiBkaWdpdHNbMV0gKyAnIycgKyByZ2IudG9TdHJpbmcoMTYpO1xufTtcbmV4cG9ydHMuSG92ZXJUb29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChIb3ZlclRvb2xWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBIb3ZlclRvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gSG92ZXJUb29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgSG92ZXJUb29sVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIEhvdmVyVG9vbFZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHR2aWV3cyA9IHt9O1xuICAgIH07XG4gICAgSG92ZXJUb29sVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBidWlsZF92aWV3c18xLnJlbW92ZV92aWV3cyh0aGlzLnR0dmlld3MpO1xuICAgICAgICByZXR1cm4gSG92ZXJUb29sVmlldy5fX3N1cGVyX18ucmVtb3ZlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBIb3ZlclRvb2xWaWV3LnByb3RvdHlwZS5jb25uZWN0X3NpZ25hbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrLCBsZW4sIHIsIHJlZjtcbiAgICAgICAgSG92ZXJUb29sVmlldy5fX3N1cGVyX18uY29ubmVjdF9zaWduYWxzLmNhbGwodGhpcyk7XG4gICAgICAgIHJlZiA9IHRoaXMuY29tcHV0ZWRfcmVuZGVyZXJzO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgIHIgPSByZWZba107XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Qoci5kYXRhX3NvdXJjZS5pbnNwZWN0LCB0aGlzLl91cGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnByb3BlcnRpZXMucmVuZGVyZXJzLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXB1dGVkX3JlbmRlcmVycyA9IHRoaXMuX3R0bW9kZWxzID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLnByb3BlcnRpZXMubmFtZXMuY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcHV0ZWRfcmVuZGVyZXJzID0gdGhpcy5fdHRtb2RlbHMgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMubW9kZWwucHJvcGVydGllcy5wbG90LmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXB1dGVkX3JlbmRlcmVycyA9IHRoaXMuX3R0bW9kZWxzID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLnRvb2x0aXBzLmNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R0bW9kZWxzID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIb3ZlclRvb2xWaWV3LnByb3RvdHlwZS5fY29tcHV0ZV9yZW5kZXJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbGxfcmVuZGVyZXJzLCBuYW1lcywgciwgcmVuZGVyZXJzO1xuICAgICAgICByZW5kZXJlcnMgPSB0aGlzLm1vZGVsLnJlbmRlcmVycztcbiAgICAgICAgbmFtZXMgPSB0aGlzLm1vZGVsLm5hbWVzO1xuICAgICAgICBpZiAocmVuZGVyZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgYWxsX3JlbmRlcmVycyA9IHRoaXMubW9kZWwucGxvdC5yZW5kZXJlcnM7XG4gICAgICAgICAgICByZW5kZXJlcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBrLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDAsIGxlbiA9IGFsbF9yZW5kZXJlcnMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IGFsbF9yZW5kZXJlcnNba107XG4gICAgICAgICAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgZ2x5cGhfcmVuZGVyZXJfMS5HbHlwaFJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZW5kZXJlcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBrLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDAsIGxlbiA9IHJlbmRlcmVycy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgICAgICAgICByID0gcmVuZGVyZXJzW2tdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZXMuaW5kZXhPZihyLm5hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVycztcbiAgICB9O1xuICAgIEhvdmVyVG9vbFZpZXcucHJvdG90eXBlLl9jb21wdXRlX3R0bW9kZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaywgbCwgbGVuLCBsZW4xLCBuZXdfdmlld3MsIHIsIHJlZiwgdG9vbHRpcCwgdG9vbHRpcHMsIHR0bW9kZWxzLCB2aWV3O1xuICAgICAgICB0dG1vZGVscyA9IHt9O1xuICAgICAgICB0b29sdGlwcyA9IHRoaXMubW9kZWwudG9vbHRpcHM7XG4gICAgICAgIGlmICh0b29sdGlwcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZWYgPSB0aGlzLmNvbXB1dGVkX3JlbmRlcmVycztcbiAgICAgICAgICAgIGZvciAoayA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgICAgIHIgPSByZWZba107XG4gICAgICAgICAgICAgICAgdG9vbHRpcCA9IG5ldyB0b29sdGlwXzEuVG9vbHRpcCh7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbTogdHlwZXNfMS5pc1N0cmluZyh0b29sdGlwcykgfHwgdHlwZXNfMS5pc0Z1bmN0aW9uKHRvb2x0aXBzKSxcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudDogdGhpcy5tb2RlbC5hdHRhY2htZW50LFxuICAgICAgICAgICAgICAgICAgICBzaG93X2Fycm93OiB0aGlzLm1vZGVsLnNob3dfYXJyb3dcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0dG1vZGVsc1tyLmlkXSA9IHRvb2x0aXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3X3ZpZXdzID0gYnVpbGRfdmlld3NfMS5idWlsZF92aWV3cyh0aGlzLnR0dmlld3MsIG9iamVjdF8xLnZhbHVlcyh0dG1vZGVscyksIHtcbiAgICAgICAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgICAgICAgIHBsb3RfdmlldzogdGhpcy5wbG90X3ZpZXdcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobCA9IDAsIGxlbjEgPSBuZXdfdmlld3MubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICB2aWV3ID0gbmV3X3ZpZXdzW2xdO1xuICAgICAgICAgICAgdmlldy5jb25uZWN0X3NpZ25hbHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHRtb2RlbHM7XG4gICAgfTtcbiAgICBIb3ZlclRvb2xWaWV3LmdldHRlcnMoe1xuICAgICAgICBjb21wdXRlZF9yZW5kZXJlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb21wdXRlZF9yZW5kZXJlcnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVkX3JlbmRlcmVycyA9IHRoaXMuX2NvbXB1dGVfcmVuZGVyZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcHV0ZWRfcmVuZGVyZXJzO1xuICAgICAgICB9LFxuICAgICAgICB0dG1vZGVsczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3R0bW9kZWxzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90dG1vZGVscyA9IHRoaXMuX2NvbXB1dGVfdHRtb2RlbHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90dG1vZGVscztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIEhvdmVyVG9vbFZpZXcucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlZiwgcmVzdWx0cywgcmlkLCB0dDtcbiAgICAgICAgdGhpcy5faW5zcGVjdCgyZTMwOCwgMmUzMDgpO1xuICAgICAgICByZWYgPSB0aGlzLnR0bW9kZWxzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAocmlkIGluIHJlZikge1xuICAgICAgICAgICAgdHQgPSByZWZbcmlkXTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0dC5jbGVhcigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEhvdmVyVG9vbFZpZXcucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGNhbnZhcywgdngsIHZ5O1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzO1xuICAgICAgICB2eCA9IGNhbnZhcy5zeF90b192eChlLmJva2VoLnN4KTtcbiAgICAgICAgdnkgPSBjYW52YXMuc3lfdG9fdnkoZS5ib2tlaC5zeSk7XG4gICAgICAgIGlmICghdGhpcy5wbG90X3ZpZXcuZnJhbWUuY29udGFpbnModngsIHZ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zcGVjdCh2eCwgdnkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIb3ZlclRvb2xWaWV3LnByb3RvdHlwZS5fbW92ZV9leGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xlYXIoKTtcbiAgICB9O1xuICAgIEhvdmVyVG9vbFZpZXcucHJvdG90eXBlLl9pbnNwZWN0ID0gZnVuY3Rpb24gKHZ4LCB2eSwgZSkge1xuICAgICAgICB2YXIgZ2VvbWV0cnksIGhvdmVyZWRfaW5kZXhlcywgaG92ZXJlZF9yZW5kZXJlcnMsIGssIGxlbiwgciwgcmVmLCBzbTtcbiAgICAgICAgZ2VvbWV0cnkgPSB7XG4gICAgICAgICAgICB0eXBlOiAncG9pbnQnLFxuICAgICAgICAgICAgdng6IHZ4LFxuICAgICAgICAgICAgdnk6IHZ5XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLm1vZGUgPT09ICdtb3VzZScpIHtcbiAgICAgICAgICAgIGdlb21ldHJ5Wyd0eXBlJ10gPSAncG9pbnQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VvbWV0cnlbJ3R5cGUnXSA9ICdzcGFuJztcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLm1vZGUgPT09ICd2bGluZScpIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5kaXJlY3Rpb24gPSAnaCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5kaXJlY3Rpb24gPSAndic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaG92ZXJlZF9pbmRleGVzID0gW107XG4gICAgICAgIGhvdmVyZWRfcmVuZGVyZXJzID0gW107XG4gICAgICAgIHJlZiA9IHRoaXMuY29tcHV0ZWRfcmVuZGVyZXJzO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgIHIgPSByZWZba107XG4gICAgICAgICAgICBzbSA9IHIuZGF0YV9zb3VyY2Uuc2VsZWN0aW9uX21hbmFnZXI7XG4gICAgICAgICAgICBzbS5pbnNwZWN0KHRoaXMsIHRoaXMucGxvdF92aWV3LnJlbmRlcmVyX3ZpZXdzW3IuaWRdLCBnZW9tZXRyeSwge1xuICAgICAgICAgICAgICAgIFwiZ2VvbWV0cnlcIjogZ2VvbWV0cnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRfY2FsbGJhY2soZ2VvbWV0cnkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIb3ZlclRvb2xWaWV3LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgY2FudmFzLCBkMXgsIGQxeSwgZDJ4LCBkMnksIGRhdGFfeCwgZGF0YV95LCBkaXN0MSwgZGlzdDIsIGRzLCBmcmFtZSwgZ2VvbWV0cnksIGksIGlpLCBpbmRpY2VzLCBqLCBqaiwgaywgbCwgbGVuLCBsZW4xLCBwdCwgcmVmLCByZWYxLCByZWYxMCwgcmVmMTEsIHJlZjEyLCByZWYxMywgcmVmMTQsIHJlZjIsIHJlZjMsIHJlZjQsIHJlZjUsIHJlZjYsIHJlZjcsIHJlZjgsIHJlZjksIHJlbmRlcmVyLCByeCwgcnksIHNkYXRheCwgc2RhdGF5LCBzeCwgc3ksIHRvb2wsIHRvb2x0aXAsIHZhcnMsIHZ4LCB2eSwgeCwgeHNjYWxlLCB5LCB5c2NhbGU7XG4gICAgICAgIGluZGljZXMgPSBhcmdbMF0sIHRvb2wgPSBhcmdbMV0sIHJlbmRlcmVyID0gYXJnWzJdLCBkcyA9IGFyZ1szXSwgKHJlZiA9IGFyZ1s0XSwgZ2VvbWV0cnkgPSByZWYuZ2VvbWV0cnkpO1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdG9vbHRpcCA9IChyZWYxID0gdGhpcy50dG1vZGVsc1tyZW5kZXJlci5tb2RlbC5pZF0pICE9IG51bGwgPyByZWYxIDogbnVsbDtcbiAgICAgICAgaWYgKHRvb2x0aXAgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRvb2x0aXAuY2xlYXIoKTtcbiAgICAgICAgaWYgKGluZGljZXNbJzBkJ10uZ2x5cGggPT09IG51bGwgJiYgaW5kaWNlc1snMWQnXS5pbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZ4ID0gZ2VvbWV0cnkudng7XG4gICAgICAgIHZ5ID0gZ2VvbWV0cnkudnk7XG4gICAgICAgIGNhbnZhcyA9IHRoaXMucGxvdF9tb2RlbC5jYW52YXM7XG4gICAgICAgIGZyYW1lID0gdGhpcy5wbG90X21vZGVsLmZyYW1lO1xuICAgICAgICBzeCA9IGNhbnZhcy52eF90b19zeCh2eCk7XG4gICAgICAgIHN5ID0gY2FudmFzLnZ5X3RvX3N5KHZ5KTtcbiAgICAgICAgeHNjYWxlID0gZnJhbWUueHNjYWxlc1tyZW5kZXJlci5tb2RlbC54X3JhbmdlX25hbWVdO1xuICAgICAgICB5c2NhbGUgPSBmcmFtZS55c2NhbGVzW3JlbmRlcmVyLm1vZGVsLnlfcmFuZ2VfbmFtZV07XG4gICAgICAgIHggPSB4c2NhbGUuaW52ZXJ0KHZ4KTtcbiAgICAgICAgeSA9IHlzY2FsZS5pbnZlcnQodnkpO1xuICAgICAgICByZWYyID0gaW5kaWNlc1snMGQnXS5pbmRpY2VzO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSByZWYyLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICBpID0gcmVmMltrXTtcbiAgICAgICAgICAgIGRhdGFfeCA9IHJlbmRlcmVyLmdseXBoLl94W2kgKyAxXTtcbiAgICAgICAgICAgIGRhdGFfeSA9IHJlbmRlcmVyLmdseXBoLl95W2kgKyAxXTtcbiAgICAgICAgICAgIGlpID0gaTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5saW5lX3BvbGljeSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpbnRlcnBcIjpcbiAgICAgICAgICAgICAgICAgICAgcmVmMyA9IHJlbmRlcmVyLmdseXBoLmdldF9pbnRlcnBvbGF0aW9uX2hpdChpLCBnZW9tZXRyeSksIGRhdGFfeCA9IHJlZjNbMF0sIGRhdGFfeSA9IHJlZjNbMV07XG4gICAgICAgICAgICAgICAgICAgIHJ4ID0geHNjYWxlLmNvbXB1dGUoZGF0YV94KTtcbiAgICAgICAgICAgICAgICAgICAgcnkgPSB5c2NhbGUuY29tcHV0ZShkYXRhX3kpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicHJldlwiOlxuICAgICAgICAgICAgICAgICAgICByeCA9IGNhbnZhcy5zeF90b192eChyZW5kZXJlci5nbHlwaC5zeFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJ5ID0gY2FudmFzLnN5X3RvX3Z5KHJlbmRlcmVyLmdseXBoLnN5W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5leHRcIjpcbiAgICAgICAgICAgICAgICAgICAgcnggPSBjYW52YXMuc3hfdG9fdngocmVuZGVyZXIuZ2x5cGguc3hbaSArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgcnkgPSBjYW52YXMuc3lfdG9fdnkocmVuZGVyZXIuZ2x5cGguc3lbaSArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWkgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5lYXJlc3RcIjpcbiAgICAgICAgICAgICAgICAgICAgZDF4ID0gcmVuZGVyZXIuZ2x5cGguc3hbaV07XG4gICAgICAgICAgICAgICAgICAgIGQxeSA9IHJlbmRlcmVyLmdseXBoLnN5W2ldO1xuICAgICAgICAgICAgICAgICAgICBkaXN0MSA9IGhpdHRlc3QuZGlzdF8yX3B0cyhkMXgsIGQxeSwgc3gsIHN5KTtcbiAgICAgICAgICAgICAgICAgICAgZDJ4ID0gcmVuZGVyZXIuZ2x5cGguc3hbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBkMnkgPSByZW5kZXJlci5nbHlwaC5zeVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGRpc3QyID0gaGl0dGVzdC5kaXN0XzJfcHRzKGQyeCwgZDJ5LCBzeCwgc3kpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdDEgPCBkaXN0Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmNCA9IFtkMXgsIGQxeV0sIHNkYXRheCA9IHJlZjRbMF0sIHNkYXRheSA9IHJlZjRbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWY1ID0gW2QyeCwgZDJ5XSwgc2RhdGF4ID0gcmVmNVswXSwgc2RhdGF5ID0gcmVmNVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlpID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YV94ID0gcmVuZGVyZXIuZ2x5cGguX3hbaV07XG4gICAgICAgICAgICAgICAgICAgIGRhdGFfeSA9IHJlbmRlcmVyLmdseXBoLl95W2ldO1xuICAgICAgICAgICAgICAgICAgICByeCA9IGNhbnZhcy5zeF90b192eChzZGF0YXgpO1xuICAgICAgICAgICAgICAgICAgICByeSA9IGNhbnZhcy5zeV90b192eShzZGF0YXkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWY2ID0gW3Z4LCB2eV0sIHJ4ID0gcmVmNlswXSwgcnkgPSByZWY2WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFycyA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogaWksXG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgIHZ4OiB2eCxcbiAgICAgICAgICAgICAgICB2eTogdnksXG4gICAgICAgICAgICAgICAgc3g6IHN4LFxuICAgICAgICAgICAgICAgIHN5OiBzeSxcbiAgICAgICAgICAgICAgICBkYXRhX3g6IGRhdGFfeCxcbiAgICAgICAgICAgICAgICBkYXRhX3k6IGRhdGFfeSxcbiAgICAgICAgICAgICAgICByeDogcngsXG4gICAgICAgICAgICAgICAgcnk6IHJ5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdG9vbHRpcC5hZGQocngsIHJ5LCB0aGlzLl9yZW5kZXJfdG9vbHRpcHMoZHMsIGlpLCB2YXJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVmNyA9IGluZGljZXNbJzFkJ10uaW5kaWNlcztcbiAgICAgICAgZm9yIChsID0gMCwgbGVuMSA9IHJlZjcubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICBpID0gcmVmN1tsXTtcbiAgICAgICAgICAgIGlmICghb2JqZWN0XzEuaXNFbXB0eShpbmRpY2VzWycyZCddLmluZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVmOCA9IGluZGljZXNbJzJkJ10uaW5kaWNlcztcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gcmVmOCkge1xuICAgICAgICAgICAgICAgICAgICBqID0gcmVmOFtpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YV94ID0gcmVuZGVyZXIuZ2x5cGguX3hzW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhX3kgPSByZW5kZXJlci5nbHlwaC5feXNbaV1bal07XG4gICAgICAgICAgICAgICAgICAgIGpqID0gajtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVsLmxpbmVfcG9saWN5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW50ZXJwXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOSA9IHJlbmRlcmVyLmdseXBoLmdldF9pbnRlcnBvbGF0aW9uX2hpdChpLCBqLCBnZW9tZXRyeSksIGRhdGFfeCA9IHJlZjlbMF0sIGRhdGFfeSA9IHJlZjlbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnggPSB4c2NhbGUuY29tcHV0ZShkYXRhX3gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ5ID0geXNjYWxlLmNvbXB1dGUoZGF0YV95KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwcmV2XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnggPSBjYW52YXMuc3hfdG9fdngocmVuZGVyZXIuZ2x5cGguc3hzW2ldW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByeSA9IGNhbnZhcy5zeV90b192eShyZW5kZXJlci5nbHlwaC5zeXNbaV1bal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5leHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByeCA9IGNhbnZhcy5zeF90b192eChyZW5kZXJlci5nbHlwaC5zeHNbaV1baiArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByeSA9IGNhbnZhcy5zeV90b192eShyZW5kZXJlci5nbHlwaC5zeXNbaV1baiArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqaiA9IGogKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5lYXJlc3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMXggPSByZW5kZXJlci5nbHlwaC5zeHNbaV1bal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDF5ID0gcmVuZGVyZXIuZ2x5cGguc3lzW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QxID0gaGl0dGVzdC5kaXN0XzJfcHRzKGQxeCwgZDF5LCBzeCwgc3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQyeCA9IHJlbmRlcmVyLmdseXBoLnN4c1tpXVtqICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDJ5ID0gcmVuZGVyZXIuZ2x5cGguc3lzW2ldW2ogKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0MiA9IGhpdHRlc3QuZGlzdF8yX3B0cyhkMngsIGQyeSwgc3gsIHN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdDEgPCBkaXN0Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYxMCA9IFtkMXgsIGQxeV0sIHNkYXRheCA9IHJlZjEwWzBdLCBzZGF0YXkgPSByZWYxMFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjExID0gW2QyeCwgZDJ5XSwgc2RhdGF4ID0gcmVmMTFbMF0sIHNkYXRheSA9IHJlZjExWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqaiA9IGogKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhX3ggPSByZW5kZXJlci5nbHlwaC5feHNbaV1bal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YV95ID0gcmVuZGVyZXIuZ2x5cGguX3lzW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ4ID0gY2FudmFzLnN4X3RvX3Z4KHNkYXRheCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnkgPSBjYW52YXMuc3lfdG9fdnkoc2RhdGF5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50X2luZGV4OiBqaixcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdng6IHZ4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdnk6IHZ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3g6IHN4LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3k6IHN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YV94OiBkYXRhX3gsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhX3k6IGRhdGFfeVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwLmFkZChyeCwgcnksIHRoaXMuX3JlbmRlcl90b29sdGlwcyhkcywgaSwgdmFycykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFfeCA9IChyZWYxMiA9IHJlbmRlcmVyLmdseXBoLl94KSAhPSBudWxsID8gcmVmMTJbaV0gOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgZGF0YV95ID0gKHJlZjEzID0gcmVuZGVyZXIuZ2x5cGguX3kpICE9IG51bGwgPyByZWYxM1tpXSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5wb2ludF9wb2xpY3kgPT09ICdzbmFwX3RvX2RhdGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIHB0ID0gcmVuZGVyZXIuZ2x5cGguZ2V0X2FuY2hvcl9wb2ludCh0aGlzLm1vZGVsLmFuY2hvciwgaSwgW3N4LCBzeV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHQgPSByZW5kZXJlci5nbHlwaC5nZXRfYW5jaG9yX3BvaW50KFwiY2VudGVyXCIsIGksIFtzeCwgc3ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByeCA9IGNhbnZhcy5zeF90b192eChwdC54KTtcbiAgICAgICAgICAgICAgICAgICAgcnkgPSBjYW52YXMuc3lfdG9fdnkocHQueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWYxNCA9IFt2eCwgdnldLCByeCA9IHJlZjE0WzBdLCByeSA9IHJlZjE0WzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXJzID0ge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICAgICAgdng6IHZ4LFxuICAgICAgICAgICAgICAgICAgICB2eTogdnksXG4gICAgICAgICAgICAgICAgICAgIHN4OiBzeCxcbiAgICAgICAgICAgICAgICAgICAgc3k6IHN5LFxuICAgICAgICAgICAgICAgICAgICBkYXRhX3g6IGRhdGFfeCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YV95OiBkYXRhX3lcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRvb2x0aXAuYWRkKHJ4LCByeSwgdGhpcy5fcmVuZGVyX3Rvb2x0aXBzKGRzLCBpLCB2YXJzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBIb3ZlclRvb2xWaWV3LnByb3RvdHlwZS5fZW1pdF9jYWxsYmFjayA9IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICB2YXIgY2FsbGJhY2ssIGNhbnZhcywgZGF0YSwgZnJhbWUsIGluZGljZXMsIG9iaiwgciwgcmVmLCB4c2NhbGUsIHlzY2FsZTtcbiAgICAgICAgciA9IHRoaXMuY29tcHV0ZWRfcmVuZGVyZXJzWzBdO1xuICAgICAgICBpbmRpY2VzID0gdGhpcy5wbG90X3ZpZXcucmVuZGVyZXJfdmlld3Nbci5pZF0uaGl0X3Rlc3QoZ2VvbWV0cnkpO1xuICAgICAgICBjYW52YXMgPSB0aGlzLnBsb3RfbW9kZWwuY2FudmFzO1xuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgZ2VvbWV0cnlbJ3N4J10gPSBjYW52YXMudnhfdG9fc3goZ2VvbWV0cnkudngpO1xuICAgICAgICBnZW9tZXRyeVsnc3knXSA9IGNhbnZhcy52eV90b19zeShnZW9tZXRyeS52eSk7XG4gICAgICAgIHhzY2FsZSA9IGZyYW1lLnhzY2FsZXNbci54X3JhbmdlX25hbWVdO1xuICAgICAgICB5c2NhbGUgPSBmcmFtZS55c2NhbGVzW3IueV9yYW5nZV9uYW1lXTtcbiAgICAgICAgZ2VvbWV0cnlbJ3gnXSA9IHhzY2FsZS5pbnZlcnQoZ2VvbWV0cnkudngpO1xuICAgICAgICBnZW9tZXRyeVsneSddID0geXNjYWxlLmludmVydChnZW9tZXRyeS52eSk7XG4gICAgICAgIGNhbGxiYWNrID0gdGhpcy5tb2RlbC5jYWxsYmFjaztcbiAgICAgICAgcmVmID0gW1xuICAgICAgICAgICAgY2FsbGJhY2ssIHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kaWNlcyxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSwgb2JqID0gcmVmWzBdLCBkYXRhID0gcmVmWzFdO1xuICAgICAgICBpZiAodHlwZXNfMS5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sob2JqLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmV4ZWN1dGUob2JqLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSG92ZXJUb29sVmlldy5wcm90b3R5cGUuX3JlbmRlcl90b29sdGlwcyA9IGZ1bmN0aW9uIChkcywgaSwgdmFycykge1xuICAgICAgICB2YXIgY2VsbCwgY29sbmFtZSwgY29sb3IsIGNvbHVtbiwgZWwsIGhleCwgaywgbGFiZWwsIGxlbiwgbWF0Y2gsIG9wdHMsIHJlZiwgcmVmMSwgcm93LCByb3dzLCBzd2F0Y2gsIHRvb2x0aXBzLCB2YWx1ZTtcbiAgICAgICAgdG9vbHRpcHMgPSB0aGlzLm1vZGVsLnRvb2x0aXBzO1xuICAgICAgICBpZiAodHlwZXNfMS5pc1N0cmluZyh0b29sdGlwcykpIHtcbiAgICAgICAgICAgIGVsID0gZG9tXzEuZGl2KCk7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSB0ZW1wbGF0aW5nXzEucmVwbGFjZV9wbGFjZWhvbGRlcnModG9vbHRpcHMsIGRzLCBpLCB0aGlzLm1vZGVsLmZvcm1hdHRlcnMsIHZhcnMpO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNGdW5jdGlvbih0b29sdGlwcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0b29sdGlwcyhkcywgdmFycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3dzID0gZG9tXzEuZGl2KHtcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcInRhYmxlXCIsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclNwYWNpbmc6IFwiMnB4XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAoayA9IDAsIGxlbiA9IHRvb2x0aXBzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgcmVmID0gdG9vbHRpcHNba10sIGxhYmVsID0gcmVmWzBdLCB2YWx1ZSA9IHJlZlsxXTtcbiAgICAgICAgICAgICAgICByb3cgPSBkb21fMS5kaXYoe1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJ0YWJsZS1yb3dcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcm93cy5hcHBlbmRDaGlsZChyb3cpO1xuICAgICAgICAgICAgICAgIGNlbGwgPSBkb21fMS5kaXYoe1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJ0YWJsZS1jZWxsXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiOiAnYmstdG9vbHRpcC1yb3ctbGFiZWwnXG4gICAgICAgICAgICAgICAgfSwgbGFiZWwgKyBcIjogXCIpO1xuICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChjZWxsKTtcbiAgICAgICAgICAgICAgICBjZWxsID0gZG9tXzEuZGl2KHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwidGFibGUtY2VsbFwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogJ2JrLXRvb2x0aXAtcm93LXZhbHVlJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChjZWxsKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5kZXhPZihcIiRjb2xvclwiKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjEgPSB2YWx1ZS5tYXRjaCgvXFwkY29sb3IoXFxbLipcXF0pPzooXFx3KikvKSwgbWF0Y2ggPSByZWYxWzBdLCBvcHRzID0gcmVmMVsxXSwgY29sbmFtZSA9IHJlZjFbMl07XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGRzLmdldF9jb2x1bW4oY29sbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBkb21fMS5zcGFuKHt9LCBjb2xuYW1lICsgXCIgdW5rbm93blwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGV4ID0gKG9wdHMgIT0gbnVsbCA/IG9wdHMuaW5kZXhPZihcImhleFwiKSA6IHZvaWQgMCkgPj0gMDtcbiAgICAgICAgICAgICAgICAgICAgc3dhdGNoID0gKG9wdHMgIT0gbnVsbCA/IG9wdHMuaW5kZXhPZihcInN3YXRjaFwiKSA6IHZvaWQgMCkgPj0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBjb2x1bW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGRvbV8xLnNwYW4oe30sIFwiKG51bGwpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IF9jb2xvcl90b19oZXgoY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsID0gZG9tXzEuc3Bhbih7fSwgY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBjZWxsLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN3YXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBkb21fMS5zcGFuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6ICdiay10b29sdGlwLWNvbG9yLWJsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShcIiR+XCIsIFwiJGRhdGFfXCIpO1xuICAgICAgICAgICAgICAgICAgICBlbCA9IGRvbV8xLnNwYW4oKTtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gdGVtcGxhdGluZ18xLnJlcGxhY2VfcGxhY2Vob2xkZXJzKHZhbHVlLCBkcywgaSwgdGhpcy5tb2RlbC5mb3JtYXR0ZXJzLCB2YXJzKTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBIb3ZlclRvb2xWaWV3O1xufSkoaW5zcGVjdF90b29sXzEuSW5zcGVjdFRvb2xWaWV3KTtcbmV4cG9ydHMuSG92ZXJUb29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEhvdmVyVG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSG92ZXJUb29sKCkge1xuICAgICAgICByZXR1cm4gSG92ZXJUb29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBIb3ZlclRvb2wucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuSG92ZXJUb29sVmlldztcbiAgICBIb3ZlclRvb2wucHJvdG90eXBlLnR5cGUgPSBcIkhvdmVyVG9vbFwiO1xuICAgIEhvdmVyVG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJIb3ZlclwiO1xuICAgIEhvdmVyVG9vbC5wcm90b3R5cGUuaWNvbiA9IFwiYmstdG9vbC1pY29uLWhvdmVyXCI7XG4gICAgSG92ZXJUb29sLmRlZmluZSh7XG4gICAgICAgIHRvb2x0aXBzOiBbcC5BbnksIFtbXCJpbmRleFwiLCBcIiRpbmRleFwiXSwgW1wiZGF0YSAoeCwgeSlcIiwgXCIoJHgsICR5KVwiXSwgW1wiY2FudmFzICh4LCB5KVwiLCBcIigkc3gsICRzeSlcIl1dXSxcbiAgICAgICAgZm9ybWF0dGVyczogW3AuQW55LCB7fV0sXG4gICAgICAgIHJlbmRlcmVyczogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgbmFtZXM6IFtwLkFycmF5LCBbXV0sXG4gICAgICAgIG1vZGU6IFtwLlN0cmluZywgJ21vdXNlJ10sXG4gICAgICAgIHBvaW50X3BvbGljeTogW3AuU3RyaW5nLCAnc25hcF90b19kYXRhJ10sXG4gICAgICAgIGxpbmVfcG9saWN5OiBbcC5TdHJpbmcsICduZWFyZXN0J10sXG4gICAgICAgIHNob3dfYXJyb3c6IFtwLkJvb2xlYW4sIHRydWVdLFxuICAgICAgICBhbmNob3I6IFtwLlN0cmluZywgJ2NlbnRlciddLFxuICAgICAgICBhdHRhY2htZW50OiBbcC5TdHJpbmcsICdob3Jpem9udGFsJ10sXG4gICAgICAgIGNhbGxiYWNrOiBbcC5BbnldXG4gICAgfSk7XG4gICAgcmV0dXJuIEhvdmVyVG9vbDtcbn0pKGluc3BlY3RfdG9vbF8xLkluc3BlY3RUb29sKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBidXR0b25fdG9vbF8xID0gcmVxdWlyZShcIi4uL2J1dHRvbl90b29sXCIpO1xuZXhwb3J0cy5JbnNwZWN0VG9vbFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSW5zcGVjdFRvb2xWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBJbnNwZWN0VG9vbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBJbnNwZWN0VG9vbFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBJbnNwZWN0VG9vbFZpZXc7XG59KShidXR0b25fdG9vbF8xLkJ1dHRvblRvb2xWaWV3KTtcbmV4cG9ydHMuSW5zcGVjdFRvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSW5zcGVjdFRvb2wsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEluc3BlY3RUb29sKCkge1xuICAgICAgICByZXR1cm4gSW5zcGVjdFRvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEluc3BlY3RUb29sLnByb3RvdHlwZS5ldmVudF90eXBlID0gXCJtb3ZlXCI7XG4gICAgSW5zcGVjdFRvb2wuZGVmaW5lKHtcbiAgICAgICAgdG9nZ2xlYWJsZTogW3AuQm9vbCwgdHJ1ZV1cbiAgICB9KTtcbiAgICBJbnNwZWN0VG9vbC5vdmVycmlkZSh7XG4gICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBJbnNwZWN0VG9vbDtcbn0pKGJ1dHRvbl90b29sXzEuQnV0dG9uVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYnV0dG9uX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2J1dHRvbl90b29sXCIpO1xuZXhwb3J0cy5Pbk9mZkJ1dHRvblZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoT25PZmZCdXR0b25WaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBPbk9mZkJ1dHRvblZpZXcoKSB7XG4gICAgICAgIHJldHVybiBPbk9mZkJ1dHRvblZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE9uT2ZmQnV0dG9uVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBPbk9mZkJ1dHRvblZpZXcuX19zdXBlcl9fLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5hY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2JrLWFjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgnYmstYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9uT2ZmQnV0dG9uVmlldy5wcm90b3R5cGUuX2NsaWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhY3RpdmU7XG4gICAgICAgIGFjdGl2ZSA9IHRoaXMubW9kZWwuYWN0aXZlO1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5hY3RpdmUgPSAhYWN0aXZlO1xuICAgIH07XG4gICAgcmV0dXJuIE9uT2ZmQnV0dG9uVmlldztcbn0pKGJ1dHRvbl90b29sXzEuQnV0dG9uVG9vbEJ1dHRvblZpZXcpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHZpZXdfMSA9IHJlcXVpcmUoXCJjb3JlL3ZpZXdcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbFwiKTtcbmV4cG9ydHMuVG9vbFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9vbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gVG9vbFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvb2xWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgVG9vbFZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3ID0gb3B0aW9ucy5wbG90X3ZpZXc7XG4gICAgfTtcbiAgICBUb29sVmlldy5nZXR0ZXJzKHtcbiAgICAgICAgcGxvdF9tb2RlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3Lm1vZGVsO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgVG9vbFZpZXcucHJvdG90eXBlLmNvbm5lY3Rfc2lnbmFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgVG9vbFZpZXcuX19zdXBlcl9fLmNvbm5lY3Rfc2lnbmFscy5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMubW9kZWwucHJvcGVydGllcy5hY3RpdmUuY2hhbmdlLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5tb2RlbC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuICAgIFRvb2xWaWV3LnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBUb29sVmlldy5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gVG9vbFZpZXc7XG59KSh2aWV3XzEuVmlldyk7XG5leHBvcnRzLlRvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIFRvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvb2wuZ2V0dGVycyh7XG4gICAgICAgIHN5bnRoZXRpY19yZW5kZXJlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFRvb2wuZGVmaW5lKHtcbiAgICAgICAgcGxvdDogW3AuSW5zdGFuY2VdXG4gICAgfSk7XG4gICAgVG9vbC5pbnRlcm5hbCh7XG4gICAgICAgIGFjdGl2ZTogW3AuQm9vbGVhbiwgZmFsc2VdXG4gICAgfSk7XG4gICAgVG9vbC5wcm90b3R5cGUuX2dldF9kaW1fdG9vbHRpcCA9IGZ1bmN0aW9uIChuYW1lLCBkaW1zKSB7XG4gICAgICAgIHN3aXRjaCAoZGltcykge1xuICAgICAgICAgICAgY2FzZSAnd2lkdGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lICsgXCIgKHgtYXhpcylcIjtcbiAgICAgICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgKyBcIiAoeS1heGlzKVwiO1xuICAgICAgICAgICAgY2FzZSAnYm90aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2wucHJvdG90eXBlLl9nZXRfZGltX2xpbWl0cyA9IGZ1bmN0aW9uIChhcmcsIGFyZzEsIGZyYW1lLCBkaW1zKSB7XG4gICAgICAgIHZhciBociwgdnIsIHZ4MCwgdngxLCB2eGxpbSwgdnkwLCB2eTEsIHZ5bGltO1xuICAgICAgICB2eDAgPSBhcmdbMF0sIHZ5MCA9IGFyZ1sxXTtcbiAgICAgICAgdngxID0gYXJnMVswXSwgdnkxID0gYXJnMVsxXTtcbiAgICAgICAgaHIgPSBmcmFtZS5oX3JhbmdlO1xuICAgICAgICBpZiAoZGltcyA9PT0gJ3dpZHRoJyB8fCBkaW1zID09PSAnYm90aCcpIHtcbiAgICAgICAgICAgIHZ4bGltID0gW2FycmF5XzEubWluKFt2eDAsIHZ4MV0pLCBhcnJheV8xLm1heChbdngwLCB2eDFdKV07XG4gICAgICAgICAgICB2eGxpbSA9IFthcnJheV8xLm1heChbdnhsaW1bMF0sIGhyLm1pbl0pLCBhcnJheV8xLm1pbihbdnhsaW1bMV0sIGhyLm1heF0pXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZ4bGltID0gW2hyLm1pbiwgaHIubWF4XTtcbiAgICAgICAgfVxuICAgICAgICB2ciA9IGZyYW1lLnZfcmFuZ2U7XG4gICAgICAgIGlmIChkaW1zID09PSAnaGVpZ2h0JyB8fCBkaW1zID09PSAnYm90aCcpIHtcbiAgICAgICAgICAgIHZ5bGltID0gW2FycmF5XzEubWluKFt2eTAsIHZ5MV0pLCBhcnJheV8xLm1heChbdnkwLCB2eTFdKV07XG4gICAgICAgICAgICB2eWxpbSA9IFthcnJheV8xLm1heChbdnlsaW1bMF0sIHZyLm1pbl0pLCBhcnJheV8xLm1pbihbdnlsaW1bMV0sIHZyLm1heF0pXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZ5bGltID0gW3ZyLm1pbiwgdnIubWF4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3Z4bGltLCB2eWxpbV07XG4gICAgfTtcbiAgICByZXR1cm4gVG9vbDtcbn0pKG1vZGVsXzEuTW9kZWwpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLlRvb2xFdmVudHMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9vbEV2ZW50cywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVG9vbEV2ZW50cygpIHtcbiAgICAgICAgcmV0dXJuIFRvb2xFdmVudHMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvb2xFdmVudHMucHJvdG90eXBlLnR5cGUgPSAnVG9vbEV2ZW50cyc7XG4gICAgVG9vbEV2ZW50cy5kZWZpbmUoe1xuICAgICAgICBnZW9tZXRyaWVzOiBbcC5BcnJheSwgW11dXG4gICAgfSk7XG4gICAgcmV0dXJuIFRvb2xFdmVudHM7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBzaWduYWxpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL3NpZ25hbGluZ1wiKTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xuZXhwb3J0cy5Ub29sUHJveHkgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9vbFByb3h5LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUb29sUHJveHkoKSB7XG4gICAgICAgIHJldHVybiBUb29sUHJveHkuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvb2xQcm94eS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIFRvb2xQcm94eS5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzW1wiZG9cIl0gPSBuZXcgc2lnbmFsaW5nXzEuU2lnbmFsKHRoaXMsIFwiZG9cIik7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzW1wiZG9cIl0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvaXQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5wcm9wZXJ0aWVzLmFjdGl2ZS5jaGFuZ2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldF9hY3RpdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUb29sUHJveHkucHJvdG90eXBlLmRvaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLCBsZW4sIHJlZiwgdG9vbDtcbiAgICAgICAgcmVmID0gdGhpcy50b29scztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0b29sID0gcmVmW2ldO1xuICAgICAgICAgICAgdG9vbFtcImRvXCJdLmVtaXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRvb2xQcm94eS5wcm90b3R5cGUuc2V0X2FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGksIGxlbiwgcmVmLCB0b29sO1xuICAgICAgICByZWYgPSB0aGlzLnRvb2xzO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRvb2wgPSByZWZbaV07XG4gICAgICAgICAgICB0b29sLmFjdGl2ZSA9IHRoaXMuYWN0aXZlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVG9vbFByb3h5LmRlZmluZSh7XG4gICAgICAgIHRvb2xzOiBbcC5BcnJheSwgW11dLFxuICAgICAgICBhY3RpdmU6IFtwLkJvb2wsIGZhbHNlXSxcbiAgICAgICAgdG9vbHRpcDogW3AuU3RyaW5nXSxcbiAgICAgICAgdG9vbF9uYW1lOiBbcC5TdHJpbmddLFxuICAgICAgICBkaXNhYmxlZDogW3AuQm9vbCwgZmFsc2VdLFxuICAgICAgICBldmVudF90eXBlOiBbcC5TdHJpbmddLFxuICAgICAgICBpY29uOiBbcC5TdHJpbmddXG4gICAgfSk7XG4gICAgVG9vbFByb3h5LnByb3RvdHlwZS5fY2xpY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZTtcbiAgICAgICAgYWN0aXZlID0gdGhpcy5tb2RlbC5hY3RpdmU7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmFjdGl2ZSA9ICFhY3RpdmU7XG4gICAgfTtcbiAgICByZXR1cm4gVG9vbFByb3h5O1xufSkobW9kZWxfMS5Nb2RlbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uIChpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pXG4gICAgICAgIHJldHVybiBpO1xufSByZXR1cm4gLTE7IH07XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG52YXIgYWN0aW9uX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbnMvYWN0aW9uX3Rvb2xcIik7XG52YXIgaGVscF90b29sXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25zL2hlbHBfdG9vbFwiKTtcbnZhciBnZXN0dXJlX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2dlc3R1cmVzL2dlc3R1cmVfdG9vbFwiKTtcbnZhciBpbnNwZWN0X3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2luc3BlY3RvcnMvaW5zcGVjdF90b29sXCIpO1xudmFyIHRvb2xiYXJfYmFzZV8xID0gcmVxdWlyZShcIi4vdG9vbGJhcl9iYXNlXCIpO1xuZXhwb3J0cy5Ub29sYmFyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRvb2xiYXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRvb2xiYXIoKSB7XG4gICAgICAgIHJldHVybiBUb29sYmFyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUb29sYmFyLnByb3RvdHlwZS50eXBlID0gJ1Rvb2xiYXInO1xuICAgIFRvb2xiYXIucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IHRvb2xiYXJfYmFzZV8xLlRvb2xiYXJCYXNlVmlldztcbiAgICBUb29sYmFyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIFRvb2xiYXIuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLnByb3BlcnRpZXMudG9vbHMuY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5pdF90b29scygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRfdG9vbHMoKTtcbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLl9pbml0X3Rvb2xzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXQsIGksIGxlbiwgcmVmLCByZXN1bHRzLCB0b29sLCB0b29scztcbiAgICAgICAgcmVmID0gdGhpcy50b29scztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0b29sID0gcmVmW2ldO1xuICAgICAgICAgICAgaWYgKHRvb2wgaW5zdGFuY2VvZiBpbnNwZWN0X3Rvb2xfMS5JbnNwZWN0VG9vbCkge1xuICAgICAgICAgICAgICAgIGlmICghYXJyYXlfMS5hbnkodGhpcy5pbnNwZWN0b3JzLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuaWQgPT09IHRvb2wuaWQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkodGhpcykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zcGVjdG9ycyA9IHRoaXMuaW5zcGVjdG9ycy5jb25jYXQoW3Rvb2xdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b29sIGluc3RhbmNlb2YgaGVscF90b29sXzEuSGVscFRvb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFycmF5XzEuYW55KHRoaXMuaGVscCwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmlkID09PSB0b29sLmlkO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKHRoaXMpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlbHAgPSB0aGlzLmhlbHAuY29uY2F0KFt0b29sXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9vbCBpbnN0YW5jZW9mIGFjdGlvbl90b29sXzEuQWN0aW9uVG9vbCkge1xuICAgICAgICAgICAgICAgIGlmICghYXJyYXlfMS5hbnkodGhpcy5hY3Rpb25zLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuaWQgPT09IHRvb2wuaWQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkodGhpcykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucyA9IHRoaXMuYWN0aW9ucy5jb25jYXQoW3Rvb2xdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b29sIGluc3RhbmNlb2YgZ2VzdHVyZV90b29sXzEuR2VzdHVyZVRvb2wpIHtcbiAgICAgICAgICAgICAgICBldCA9IHRvb2wuZXZlbnRfdHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoIShldCBpbiB0aGlzLmdlc3R1cmVzKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIlRvb2xiYXI6IHVua25vd24gZXZlbnQgdHlwZSAnXCIgKyBldCArIFwiJyBmb3IgdG9vbDogXCIgKyB0b29sLnR5cGUgKyBcIiAoXCIgKyB0b29sLmlkICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFhcnJheV8xLmFueSh0aGlzLmdlc3R1cmVzW2V0XS50b29scywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmlkID09PSB0b29sLmlkO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKHRoaXMpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlc3R1cmVzW2V0XS50b29scyA9IHRoaXMuZ2VzdHVyZXNbZXRdLnRvb2xzLmNvbmNhdChbdG9vbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QodG9vbC5wcm9wZXJ0aWVzLmFjdGl2ZS5jaGFuZ2UsIHRoaXMuX2FjdGl2ZV9jaGFuZ2UuYmluZChudWxsLCB0b29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlX2luc3BlY3QgPT09ICdhdXRvJykge1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlX2luc3BlY3QgaW5zdGFuY2VvZiBpbnNwZWN0X3Rvb2xfMS5JbnNwZWN0VG9vbCkge1xuICAgICAgICAgICAgdGhpcy5pbnNwZWN0b3JzLm1hcCgoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpbnNwZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3BlY3RvciAhPT0gX3RoaXMuYWN0aXZlX2luc3BlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnNwZWN0b3IuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlX2luc3BlY3QgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5pbnNwZWN0b3JzLm1hcCgoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpbnNwZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4T2YuY2FsbChfdGhpcy5hY3RpdmVfaW5zcGVjdCwgaW5zcGVjdG9yKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnNwZWN0b3IuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlX2luc3BlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zcGVjdG9ycy5tYXAoZnVuY3Rpb24gKGluc3BlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnNwZWN0b3IuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoZXQgaW4gdGhpcy5nZXN0dXJlcykge1xuICAgICAgICAgICAgdG9vbHMgPSB0aGlzLmdlc3R1cmVzW2V0XS50b29scztcbiAgICAgICAgICAgIGlmICh0b29scy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2VzdHVyZXNbZXRdLnRvb2xzID0gYXJyYXlfMS5zb3J0QnkodG9vbHMsIGZ1bmN0aW9uICh0b29sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2wuZGVmYXVsdF9vcmRlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGV0ID09PSAndGFwJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZV90YXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZV90YXAgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlc3R1cmVzW2V0XS50b29sc1swXS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVfdGFwLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV0ID09PSAncGFuJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZV9kcmFnID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVfZHJhZyA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VzdHVyZXNbZXRdLnRvb2xzWzBdLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZV9kcmFnLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV0ID09PSAncGluY2gnIHx8IGV0ID09PSAnc2Nyb2xsJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZV9zY3JvbGwgPT09IG51bGwgfHwgdGhpcy5hY3RpdmVfc2Nyb2xsID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmFjdGl2ZV9zY3JvbGwuYWN0aXZlID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIFRvb2xiYXIuZGVmaW5lKHtcbiAgICAgICAgYWN0aXZlX2RyYWc6IFtwLkFueSwgJ2F1dG8nXSxcbiAgICAgICAgYWN0aXZlX2luc3BlY3Q6IFtwLkFueSwgJ2F1dG8nXSxcbiAgICAgICAgYWN0aXZlX3Njcm9sbDogW3AuQW55LCAnYXV0byddLFxuICAgICAgICBhY3RpdmVfdGFwOiBbcC5BbnksICdhdXRvJ11cbiAgICB9KTtcbiAgICByZXR1cm4gVG9vbGJhcjtcbn0pKHRvb2xiYXJfYmFzZV8xLlRvb2xiYXJCYXNlKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSwgYmluZCA9IGZ1bmN0aW9uIChmbiwgbWUpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL2xvZ2dpbmdcIik7XG52YXIgc29sdmVyXzEgPSByZXF1aXJlKFwiY29yZS9sYXlvdXQvc29sdmVyXCIpO1xudmFyIGRvbV8xID0gcmVxdWlyZShcImNvcmUvZG9tXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGxheW91dF9kb21fMSA9IHJlcXVpcmUoXCIuLi9sYXlvdXRzL2xheW91dF9kb21cIik7XG52YXIgYWN0aW9uX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbnMvYWN0aW9uX3Rvb2xcIik7XG52YXIgb25fb2ZmX2J1dHRvbl8xID0gcmVxdWlyZShcIi4vb25fb2ZmX2J1dHRvblwiKTtcbnZhciB0b29sYmFyX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi90b29sYmFyX3RlbXBsYXRlXCIpO1xuZXhwb3J0cy5Ub29sYmFyQmFzZVZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9vbGJhckJhc2VWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUb29sYmFyQmFzZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBUb29sYmFyQmFzZVZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvb2xiYXJCYXNlVmlldy5wcm90b3R5cGUuY2xhc3NOYW1lID0gXCJiay10b29sYmFyLXdyYXBwZXJcIjtcbiAgICBUb29sYmFyQmFzZVZpZXcucHJvdG90eXBlLnRlbXBsYXRlID0gdG9vbGJhcl90ZW1wbGF0ZV8xLmRlZmF1bHQ7XG4gICAgVG9vbGJhckJhc2VWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidXR0b25zLCBldCwgZ2VzdHVyZXMsIGksIGosIGssIGwsIGxlbiwgbGVuMSwgbGVuMiwgbGVuMywgb2JqLCByZWYsIHJlZjEsIHJlZjIsIHJlZjM7XG4gICAgICAgIGRvbV8xLmVtcHR5KHRoaXMuZWwpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5zaXppbmdfbW9kZSAhPT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5sZWZ0ID0gdGhpcy5tb2RlbC5fZG9tX2xlZnQudmFsdWUgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnRvcCA9IHRoaXMubW9kZWwuX2RvbV90b3AudmFsdWUgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gdGhpcy5tb2RlbC5fd2lkdGgudmFsdWUgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmhlaWdodCA9IHRoaXMubW9kZWwuX2hlaWdodC52YWx1ZSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMudGVtcGxhdGUoe1xuICAgICAgICAgICAgbG9nbzogdGhpcy5tb2RlbC5sb2dvLFxuICAgICAgICAgICAgbG9jYXRpb246IHRoaXMubW9kZWwudG9vbGJhcl9sb2NhdGlvbixcbiAgICAgICAgICAgIHN0aWNreTogdGhpcy5tb2RlbC50b29sYmFyX3N0aWNreSA/ICdzdGlja3knIDogJ25vdC1zdGlja3knXG4gICAgICAgIH0pKTtcbiAgICAgICAgYnV0dG9ucyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5iay1idXR0b24tYmFyLWxpc3RbdHlwZT0naW5zcGVjdG9ycyddXCIpO1xuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLmluc3BlY3RvcnM7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgb2JqID0gcmVmW2ldO1xuICAgICAgICAgICAgaWYgKG9iai50b2dnbGVhYmxlKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9ucy5hcHBlbmRDaGlsZChuZXcgb25fb2ZmX2J1dHRvbl8xLk9uT2ZmQnV0dG9uVmlldyh7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBvYmosXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgICAgICAgICAgIH0pLmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidXR0b25zID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiLmJrLWJ1dHRvbi1iYXItbGlzdFt0eXBlPSdoZWxwJ11cIik7XG4gICAgICAgIHJlZjEgPSB0aGlzLm1vZGVsLmhlbHA7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSByZWYxLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgICAgb2JqID0gcmVmMVtqXTtcbiAgICAgICAgICAgIGJ1dHRvbnMuYXBwZW5kQ2hpbGQobmV3IGFjdGlvbl90b29sXzEuQWN0aW9uVG9vbEJ1dHRvblZpZXcoe1xuICAgICAgICAgICAgICAgIG1vZGVsOiBvYmosXG4gICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzXG4gICAgICAgICAgICB9KS5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgYnV0dG9ucyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5iay1idXR0b24tYmFyLWxpc3RbdHlwZT0nYWN0aW9ucyddXCIpO1xuICAgICAgICByZWYyID0gdGhpcy5tb2RlbC5hY3Rpb25zO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4yID0gcmVmMi5sZW5ndGg7IGsgPCBsZW4yOyBrKyspIHtcbiAgICAgICAgICAgIG9iaiA9IHJlZjJba107XG4gICAgICAgICAgICBidXR0b25zLmFwcGVuZENoaWxkKG5ldyBhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2xCdXR0b25WaWV3KHtcbiAgICAgICAgICAgICAgICBtb2RlbDogb2JqLFxuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgICAgICAgfSkuZWwpO1xuICAgICAgICB9XG4gICAgICAgIGdlc3R1cmVzID0gdGhpcy5tb2RlbC5nZXN0dXJlcztcbiAgICAgICAgZm9yIChldCBpbiBnZXN0dXJlcykge1xuICAgICAgICAgICAgYnV0dG9ucyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5iay1idXR0b24tYmFyLWxpc3RbdHlwZT0nXCIgKyBldCArIFwiJ11cIik7XG4gICAgICAgICAgICByZWYzID0gZ2VzdHVyZXNbZXRdLnRvb2xzO1xuICAgICAgICAgICAgZm9yIChsID0gMCwgbGVuMyA9IHJlZjMubGVuZ3RoOyBsIDwgbGVuMzsgbCsrKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gcmVmM1tsXTtcbiAgICAgICAgICAgICAgICBidXR0b25zLmFwcGVuZENoaWxkKG5ldyBvbl9vZmZfYnV0dG9uXzEuT25PZmZCdXR0b25WaWV3KHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IG9iaixcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzXG4gICAgICAgICAgICAgICAgfSkuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFRvb2xiYXJCYXNlVmlldztcbn0pKGxheW91dF9kb21fMS5MYXlvdXRET01WaWV3KTtcbmV4cG9ydHMuVG9vbGJhckJhc2UgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9vbGJhckJhc2UsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRvb2xiYXJCYXNlKCkge1xuICAgICAgICB0aGlzLl9hY3RpdmVfY2hhbmdlID0gYmluZCh0aGlzLl9hY3RpdmVfY2hhbmdlLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIFRvb2xiYXJCYXNlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUb29sYmFyQmFzZS5wcm90b3R5cGUudHlwZSA9ICdUb29sYmFyQmFzZSc7XG4gICAgVG9vbGJhckJhc2UucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuVG9vbGJhckJhc2VWaWV3O1xuICAgIFRvb2xiYXJCYXNlLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIFRvb2xiYXJCYXNlLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zZXRfc2l6ZWFibGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCh0aGlzLnByb3BlcnRpZXMudG9vbGJhcl9sb2NhdGlvbi5jaGFuZ2UsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9zZXRfc2l6ZWFibGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuICAgIFRvb2xiYXJCYXNlLnByb3RvdHlwZS5fc2V0X3NpemVhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaG9yaXpvbnRhbCwgcmVmO1xuICAgICAgICBob3Jpem9udGFsID0gKHJlZiA9IHRoaXMudG9vbGJhcl9sb2NhdGlvbikgPT09ICdsZWZ0JyB8fCByZWYgPT09ICdyaWdodCc7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplYWJsZSA9ICFob3Jpem9udGFsID8gdGhpcy5faGVpZ2h0IDogdGhpcy5fd2lkdGg7XG4gICAgfTtcbiAgICBUb29sYmFyQmFzZS5wcm90b3R5cGUuX2FjdGl2ZV9jaGFuZ2UgPSBmdW5jdGlvbiAodG9vbCkge1xuICAgICAgICB2YXIgY3VycmVudGx5X2FjdGl2ZV90b29sLCBldmVudF90eXBlO1xuICAgICAgICBldmVudF90eXBlID0gdG9vbC5ldmVudF90eXBlO1xuICAgICAgICBpZiAodG9vbC5hY3RpdmUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRseV9hY3RpdmVfdG9vbCA9IHRoaXMuZ2VzdHVyZXNbZXZlbnRfdHlwZV0uYWN0aXZlO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRseV9hY3RpdmVfdG9vbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcIlRvb2xiYXI6IGRlYWN0aXZhdGluZyB0b29sOiBcIiArIGN1cnJlbnRseV9hY3RpdmVfdG9vbC50eXBlICsgXCIgKFwiICsgY3VycmVudGx5X2FjdGl2ZV90b29sLmlkICsgXCIpIGZvciBldmVudCB0eXBlICdcIiArIGV2ZW50X3R5cGUgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5X2FjdGl2ZV90b29sLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nZXN0dXJlc1tldmVudF90eXBlXS5hY3RpdmUgPSB0b29sO1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcIlRvb2xiYXI6IGFjdGl2YXRpbmcgdG9vbDogXCIgKyB0b29sLnR5cGUgKyBcIiAoXCIgKyB0b29sLmlkICsgXCIpIGZvciBldmVudCB0eXBlICdcIiArIGV2ZW50X3R5cGUgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdlc3R1cmVzW2V2ZW50X3R5cGVdLmFjdGl2ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUb29sYmFyQmFzZS5wcm90b3R5cGUuZ2V0X2NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gVG9vbGJhckJhc2UuX19zdXBlcl9fLmdldF9jb25zdHJhaW50cy5jYWxsKHRoaXMpLmNvbmNhdChbc29sdmVyXzEuRVEodGhpcy5fc2l6ZWFibGUsIC0zMCldKTtcbiAgICB9O1xuICAgIFRvb2xiYXJCYXNlLmRlZmluZSh7XG4gICAgICAgIHRvb2xzOiBbcC5BcnJheSwgW11dLFxuICAgICAgICBsb2dvOiBbcC5TdHJpbmcsICdub3JtYWwnXVxuICAgIH0pO1xuICAgIFRvb2xiYXJCYXNlLmludGVybmFsKHtcbiAgICAgICAgZ2VzdHVyZXM6IFtcbiAgICAgICAgICAgIHAuQW55LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdGFwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZG91YmxldGFwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGluY2g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcmVzczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBhY3Rpb25zOiBbcC5BcnJheSwgW11dLFxuICAgICAgICBpbnNwZWN0b3JzOiBbcC5BcnJheSwgW11dLFxuICAgICAgICBoZWxwOiBbcC5BcnJheSwgW11dLFxuICAgICAgICB0b29sYmFyX2xvY2F0aW9uOiBbcC5Mb2NhdGlvbiwgJ3JpZ2h0J10sXG4gICAgICAgIHRvb2xiYXJfc3RpY2t5OiBbcC5Cb29sXVxuICAgIH0pO1xuICAgIFRvb2xiYXJCYXNlLm92ZXJyaWRlKHtcbiAgICAgICAgc2l6aW5nX21vZGU6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4gVG9vbGJhckJhc2U7XG59KShsYXlvdXRfZG9tXzEuTGF5b3V0RE9NKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSwgaW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSlcbiAgICAgICAgcmV0dXJuIGk7XG59IHJldHVybiAtMTsgfTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbnZhciBhY3Rpb25fdG9vbF8xID0gcmVxdWlyZShcIi4vYWN0aW9ucy9hY3Rpb25fdG9vbFwiKTtcbnZhciBoZWxwX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbnMvaGVscF90b29sXCIpO1xudmFyIGdlc3R1cmVfdG9vbF8xID0gcmVxdWlyZShcIi4vZ2VzdHVyZXMvZ2VzdHVyZV90b29sXCIpO1xudmFyIGluc3BlY3RfdG9vbF8xID0gcmVxdWlyZShcIi4vaW5zcGVjdG9ycy9pbnNwZWN0X3Rvb2xcIik7XG52YXIgdG9vbGJhcl9iYXNlXzEgPSByZXF1aXJlKFwiLi90b29sYmFyX2Jhc2VcIik7XG52YXIgdG9vbF9wcm94eV8xID0gcmVxdWlyZShcIi4vdG9vbF9wcm94eVwiKTtcbnZhciBib3hfMSA9IHJlcXVpcmUoXCIuLi9sYXlvdXRzL2JveFwiKTtcbmV4cG9ydHMuVG9vbGJhckJveFRvb2xiYXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9vbGJhckJveFRvb2xiYXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRvb2xiYXJCb3hUb29sYmFyKCkge1xuICAgICAgICByZXR1cm4gVG9vbGJhckJveFRvb2xiYXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvb2xiYXJCb3hUb29sYmFyLnByb3RvdHlwZS50eXBlID0gJ1Rvb2xiYXJCb3hUb29sYmFyJztcbiAgICBUb29sYmFyQm94VG9vbGJhci5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gdG9vbGJhcl9iYXNlXzEuVG9vbGJhckJhc2VWaWV3O1xuICAgIFRvb2xiYXJCb3hUb29sYmFyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgVG9vbGJhckJveFRvb2xiYXIuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faW5pdF90b29scygpO1xuICAgICAgICBpZiAodGhpcy5tZXJnZV90b29scyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lcmdlX3Rvb2xzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2xiYXJCb3hUb29sYmFyLmRlZmluZSh7XG4gICAgICAgIG1lcmdlX3Rvb2xzOiBbcC5Cb29sLCB0cnVlXVxuICAgIH0pO1xuICAgIFRvb2xiYXJCb3hUb29sYmFyLnByb3RvdHlwZS5faW5pdF90b29scyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV0LCBpLCBsZW4sIHJlZiwgcmVzdWx0cywgdG9vbDtcbiAgICAgICAgcmVmID0gdGhpcy50b29scztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRvb2wgPSByZWZbaV07XG4gICAgICAgICAgICBpZiAodG9vbCBpbnN0YW5jZW9mIGluc3BlY3RfdG9vbF8xLkluc3BlY3RUb29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhcnJheV8xLmFueSh0aGlzLmluc3BlY3RvcnMsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5pZCA9PT0gdG9vbC5pZDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSh0aGlzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuaW5zcGVjdG9ycyA9IHRoaXMuaW5zcGVjdG9ycy5jb25jYXQoW3Rvb2xdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b29sIGluc3RhbmNlb2YgaGVscF90b29sXzEuSGVscFRvb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFycmF5XzEuYW55KHRoaXMuaGVscCwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmlkID09PSB0b29sLmlkO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKHRoaXMpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5oZWxwID0gdGhpcy5oZWxwLmNvbmNhdChbdG9vbF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvb2wgaW5zdGFuY2VvZiBhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFycmF5XzEuYW55KHRoaXMuYWN0aW9ucywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmlkID09PSB0b29sLmlkO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKHRoaXMpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5hY3Rpb25zID0gdGhpcy5hY3Rpb25zLmNvbmNhdChbdG9vbF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvb2wgaW5zdGFuY2VvZiBnZXN0dXJlX3Rvb2xfMS5HZXN0dXJlVG9vbCkge1xuICAgICAgICAgICAgICAgIGV0ID0gdG9vbC5ldmVudF90eXBlO1xuICAgICAgICAgICAgICAgIGlmICghYXJyYXlfMS5hbnkodGhpcy5nZXN0dXJlc1tldF0udG9vbHMsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5pZCA9PT0gdG9vbC5pZDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSh0aGlzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZ2VzdHVyZXNbZXRdLnRvb2xzID0gdGhpcy5nZXN0dXJlc1tldF0udG9vbHMuY29uY2F0KFt0b29sXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBUb29sYmFyQm94VG9vbGJhci5wcm90b3R5cGUuX21lcmdlX3Rvb2xzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWN0aW9ucywgYWN0aXZlLCBldCwgZXZlbnRfdHlwZSwgZ2VzdHVyZXMsIGhlbHB0b29sLCBpLCBpbmZvLCBpbnNwZWN0b3JzLCBqLCBrLCBsLCBsZW4sIGxlbjEsIGxlbjIsIGxlbjMsIG1ha2VfcHJveHksIG5ld19oZWxwX3Rvb2xzLCBuZXdfaGVscF91cmxzLCBwcm94eSwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZWY1LCByZWY2LCByZXN1bHRzLCB0b29sLCB0b29sX3R5cGUsIHRvb2xzO1xuICAgICAgICBpbnNwZWN0b3JzID0ge307XG4gICAgICAgIGFjdGlvbnMgPSB7fTtcbiAgICAgICAgZ2VzdHVyZXMgPSB7fTtcbiAgICAgICAgbmV3X2hlbHBfdG9vbHMgPSBbXTtcbiAgICAgICAgbmV3X2hlbHBfdXJscyA9IFtdO1xuICAgICAgICByZWYgPSB0aGlzLmhlbHA7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaGVscHRvb2wgPSByZWZbaV07XG4gICAgICAgICAgICBpZiAocmVmMSA9IGhlbHB0b29sLnJlZGlyZWN0LCBpbmRleE9mLmNhbGwobmV3X2hlbHBfdXJscywgcmVmMSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbmV3X2hlbHBfdG9vbHMucHVzaChoZWxwdG9vbCk7XG4gICAgICAgICAgICAgICAgbmV3X2hlbHBfdXJscy5wdXNoKGhlbHB0b29sLnJlZGlyZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlbHAgPSBuZXdfaGVscF90b29scztcbiAgICAgICAgcmVmMiA9IHRoaXMuZ2VzdHVyZXM7XG4gICAgICAgIGZvciAoZXZlbnRfdHlwZSBpbiByZWYyKSB7XG4gICAgICAgICAgICBpbmZvID0gcmVmMltldmVudF90eXBlXTtcbiAgICAgICAgICAgIGlmICghKGV2ZW50X3R5cGUgaW4gZ2VzdHVyZXMpKSB7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZXNbZXZlbnRfdHlwZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZjMgPSBpbmZvLnRvb2xzO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuMSA9IHJlZjMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgdG9vbCA9IHJlZjNbal07XG4gICAgICAgICAgICAgICAgaWYgKCEodG9vbC50eXBlIGluIGdlc3R1cmVzW2V2ZW50X3R5cGVdKSkge1xuICAgICAgICAgICAgICAgICAgICBnZXN0dXJlc1tldmVudF90eXBlXVt0b29sLnR5cGVdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdlc3R1cmVzW2V2ZW50X3R5cGVdW3Rvb2wudHlwZV0ucHVzaCh0b29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWY0ID0gdGhpcy5pbnNwZWN0b3JzO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4yID0gcmVmNC5sZW5ndGg7IGsgPCBsZW4yOyBrKyspIHtcbiAgICAgICAgICAgIHRvb2wgPSByZWY0W2tdO1xuICAgICAgICAgICAgaWYgKCEodG9vbC50eXBlIGluIGluc3BlY3RvcnMpKSB7XG4gICAgICAgICAgICAgICAgaW5zcGVjdG9yc1t0b29sLnR5cGVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnNwZWN0b3JzW3Rvb2wudHlwZV0ucHVzaCh0b29sKTtcbiAgICAgICAgfVxuICAgICAgICByZWY1ID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICBmb3IgKGwgPSAwLCBsZW4zID0gcmVmNS5sZW5ndGg7IGwgPCBsZW4zOyBsKyspIHtcbiAgICAgICAgICAgIHRvb2wgPSByZWY1W2xdO1xuICAgICAgICAgICAgaWYgKCEodG9vbC50eXBlIGluIGFjdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uc1t0b29sLnR5cGVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3Rpb25zW3Rvb2wudHlwZV0ucHVzaCh0b29sKTtcbiAgICAgICAgfVxuICAgICAgICBtYWtlX3Byb3h5ID0gZnVuY3Rpb24gKHRvb2xzLCBhY3RpdmUpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0b29sX3Byb3h5XzEuVG9vbFByb3h5KHtcbiAgICAgICAgICAgICAgICB0b29sczogdG9vbHMsXG4gICAgICAgICAgICAgICAgZXZlbnRfdHlwZTogdG9vbHNbMF0uZXZlbnRfdHlwZSxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiB0b29sc1swXS50b29sX25hbWUsXG4gICAgICAgICAgICAgICAgdG9vbF9uYW1lOiB0b29sc1swXS50b29sX25hbWUsXG4gICAgICAgICAgICAgICAgaWNvbjogdG9vbHNbMF0uaWNvbixcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGFjdGl2ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoZXZlbnRfdHlwZSBpbiBnZXN0dXJlcykge1xuICAgICAgICAgICAgdGhpcy5nZXN0dXJlc1tldmVudF90eXBlXS50b29scyA9IFtdO1xuICAgICAgICAgICAgcmVmNiA9IGdlc3R1cmVzW2V2ZW50X3R5cGVdO1xuICAgICAgICAgICAgZm9yICh0b29sX3R5cGUgaW4gcmVmNikge1xuICAgICAgICAgICAgICAgIHRvb2xzID0gcmVmNlt0b29sX3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmICh0b29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3h5ID0gbWFrZV9wcm94eSh0b29scyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VzdHVyZXNbZXZlbnRfdHlwZV0udG9vbHMucHVzaChwcm94eSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdChwcm94eS5wcm9wZXJ0aWVzLmFjdGl2ZS5jaGFuZ2UsIHRoaXMuX2FjdGl2ZV9jaGFuZ2UuYmluZChudWxsLCBwcm94eSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh0b29sX3R5cGUgaW4gYWN0aW9ucykge1xuICAgICAgICAgICAgdG9vbHMgPSBhY3Rpb25zW3Rvb2xfdHlwZV07XG4gICAgICAgICAgICBpZiAodG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5wdXNoKG1ha2VfcHJveHkodG9vbHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluc3BlY3RvcnMgPSBbXTtcbiAgICAgICAgZm9yICh0b29sX3R5cGUgaW4gaW5zcGVjdG9ycykge1xuICAgICAgICAgICAgdG9vbHMgPSBpbnNwZWN0b3JzW3Rvb2xfdHlwZV07XG4gICAgICAgICAgICBpZiAodG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zcGVjdG9ycy5wdXNoKG1ha2VfcHJveHkodG9vbHMsIGFjdGl2ZSA9IHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoZXQgaW4gdGhpcy5nZXN0dXJlcykge1xuICAgICAgICAgICAgdG9vbHMgPSB0aGlzLmdlc3R1cmVzW2V0XS50b29scztcbiAgICAgICAgICAgIGlmICh0b29scy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2VzdHVyZXNbZXRdLnRvb2xzID0gYXJyYXlfMS5zb3J0QnkodG9vbHMsIGZ1bmN0aW9uICh0b29sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2wuZGVmYXVsdF9vcmRlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGV0ICE9PSAncGluY2gnICYmIGV0ICE9PSAnc2Nyb2xsJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmdlc3R1cmVzW2V0XS50b29sc1swXS5hY3RpdmUgPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgcmV0dXJuIFRvb2xiYXJCb3hUb29sYmFyO1xufSkodG9vbGJhcl9iYXNlXzEuVG9vbGJhckJhc2UpO1xuZXhwb3J0cy5Ub29sYmFyQm94VmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUb29sYmFyQm94Vmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVG9vbGJhckJveFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBUb29sYmFyQm94Vmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVG9vbGJhckJveFZpZXcucHJvdG90eXBlLmNsYXNzTmFtZSA9ICdiay10b29sYmFyLWJveCc7XG4gICAgVG9vbGJhckJveFZpZXcucHJvdG90eXBlLmdldF93aWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuX2hvcml6b250YWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiAzMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sYmFyQm94Vmlldy5wcm90b3R5cGUuZ2V0X2hlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDMwO1xuICAgIH07XG4gICAgcmV0dXJuIFRvb2xiYXJCb3hWaWV3O1xufSkoYm94XzEuQm94Vmlldyk7XG5leHBvcnRzLlRvb2xiYXJCb3ggPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9vbGJhckJveCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVG9vbGJhckJveCgpIHtcbiAgICAgICAgcmV0dXJuIFRvb2xiYXJCb3guX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvb2xiYXJCb3gucHJvdG90eXBlLnR5cGUgPSAnVG9vbGJhckJveCc7XG4gICAgVG9vbGJhckJveC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5Ub29sYmFyQm94VmlldztcbiAgICBUb29sYmFyQm94LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgVG9vbGJhckJveC5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl90b29sYmFyID0gbmV3IGV4cG9ydHMuVG9vbGJhckJveFRvb2xiYXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2hvcml6b250YWwgPSAocmVmID0gdGhpcy50b29sYmFyX2xvY2F0aW9uKSA9PT0gJ2xlZnQnIHx8IHJlZiA9PT0gJ3JpZ2h0JztcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemVhYmxlID0gIXRoaXMuX2hvcml6b250YWwgPyB0aGlzLl9oZWlnaHQgOiB0aGlzLl93aWR0aDtcbiAgICB9O1xuICAgIFRvb2xiYXJCb3gucHJvdG90eXBlLl9kb2NfYXR0YWNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Rvb2xiYXIuYXR0YWNoX2RvY3VtZW50KHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICByZXR1cm4gVG9vbGJhckJveC5fX3N1cGVyX18uX2RvY19hdHRhY2hlZC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgVG9vbGJhckJveC5wcm90b3R5cGUuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5fdG9vbGJhcl07XG4gICAgfTtcbiAgICBUb29sYmFyQm94LmRlZmluZSh7XG4gICAgICAgIHRvb2xiYXJfbG9jYXRpb246IFtwLkxvY2F0aW9uLCBcInJpZ2h0XCJdLFxuICAgICAgICBtZXJnZV90b29sczogW3AuQm9vbCwgdHJ1ZV0sXG4gICAgICAgIHRvb2xzOiBbcC5BbnksIFtdXSxcbiAgICAgICAgbG9nbzogW3AuU3RyaW5nLCBcIm5vcm1hbFwiXVxuICAgIH0pO1xuICAgIHJldHVybiBUb29sYmFyQm94O1xufSkoYm94XzEuQm94KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERPTSA9IHJlcXVpcmUoXCJjb3JlL2RvbVwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBsb2dvO1xuICAgIGlmIChwcm9wcy5sb2dvICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGNscyA9IHByb3BzLmxvZ28gPT09IFwiZ3JleVwiID8gXCJiay1ncmV5XCIgOiBudWxsO1xuICAgICAgICBsb2dvID0gRE9NLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgaHJlZjogXCJodHRwOi8vYm9rZWgucHlkYXRhLm9yZy9cIiwgdGFyZ2V0OiBcIl9ibGFua1wiLCBjbGFzczogW1wiYmstbG9nb1wiLCBcImJrLWxvZ28tc21hbGxcIiwgY2xzXSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIChET00uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzOiBbXCJiay10b29sYmFyLVwiICsgcHJvcHMubG9jYXRpb24sIFwiYmstdG9vbGJhci1cIiArIHByb3BzLnN0aWNreV0gfSxcbiAgICAgICAgbG9nbyxcbiAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzczogJ2JrLWJ1dHRvbi1iYXInIH0sXG4gICAgICAgICAgICBET00uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzOiAnYmstYnV0dG9uLWJhci1saXN0JywgdHlwZTogXCJwYW5cIiB9KSxcbiAgICAgICAgICAgIERPTS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3M6ICdiay1idXR0b24tYmFyLWxpc3QnLCB0eXBlOiBcInNjcm9sbFwiIH0pLFxuICAgICAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzczogJ2JrLWJ1dHRvbi1iYXItbGlzdCcsIHR5cGU6IFwicGluY2hcIiB9KSxcbiAgICAgICAgICAgIERPTS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3M6ICdiay1idXR0b24tYmFyLWxpc3QnLCB0eXBlOiBcInRhcFwiIH0pLFxuICAgICAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzczogJ2JrLWJ1dHRvbi1iYXItbGlzdCcsIHR5cGU6IFwicHJlc3NcIiB9KSxcbiAgICAgICAgICAgIERPTS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3M6ICdiay1idXR0b24tYmFyLWxpc3QnLCB0eXBlOiBcInJvdGF0ZVwiIH0pLFxuICAgICAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzczogJ2JrLWJ1dHRvbi1iYXItbGlzdCcsIHR5cGU6IFwiYWN0aW9uc1wiIH0pLFxuICAgICAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzczogJ2JrLWJ1dHRvbi1iYXItbGlzdCcsIHR5cGU6IFwiaW5zcGVjdG9yc1wiIH0pLFxuICAgICAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzczogJ2JrLWJ1dHRvbi1iYXItbGlzdCcsIHR5cGU6IFwiaGVscFwiIH0pKSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSwgc2xpY2UgPSBbXS5zbGljZTtcbnZhciB0cmFuc2Zvcm1fMSA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvb2JqZWN0XCIpO1xuZXhwb3J0cy5DdXN0b21KU1RyYW5zZm9ybSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDdXN0b21KU1RyYW5zZm9ybSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ3VzdG9tSlNUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHJldHVybiBDdXN0b21KU1RyYW5zZm9ybS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ3VzdG9tSlNUcmFuc2Zvcm0ucHJvdG90eXBlLnR5cGUgPSAnQ3VzdG9tSlNUcmFuc2Zvcm0nO1xuICAgIEN1c3RvbUpTVHJhbnNmb3JtLmRlZmluZSh7XG4gICAgICAgIGFyZ3M6IFtwLkFueSwge31dLFxuICAgICAgICBmdW5jOiBbcC5TdHJpbmcsIFwiXCJdLFxuICAgICAgICB2X2Z1bmM6IFtwLlN0cmluZywgXCJcIl1cbiAgICB9KTtcbiAgICBDdXN0b21KU1RyYW5zZm9ybS5nZXR0ZXJzKHtcbiAgICAgICAgdmFsdWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFrZV92YWx1ZXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGFyX3RyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21ha2VfdHJhbnNmb3JtKFwieFwiLCB0aGlzLmZ1bmMpO1xuICAgICAgICB9LFxuICAgICAgICB2ZWN0b3JfdHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFrZV90cmFuc2Zvcm0oXCJ4c1wiLCB0aGlzLnZfZnVuYyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBDdXN0b21KU1RyYW5zZm9ybS5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxhcl90cmFuc2Zvcm0uYXBwbHkodGhpcywgc2xpY2UuY2FsbCh0aGlzLnZhbHVlcykuY29uY2F0KFt4XSwgW3JlcXVpcmVdLCBbZXhwb3J0c10pKTtcbiAgICB9O1xuICAgIEN1c3RvbUpTVHJhbnNmb3JtLnByb3RvdHlwZS52X2NvbXB1dGUgPSBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVjdG9yX3RyYW5zZm9ybS5hcHBseSh0aGlzLCBzbGljZS5jYWxsKHRoaXMudmFsdWVzKS5jb25jYXQoW3hzXSwgW3JlcXVpcmVdLCBbZXhwb3J0c10pKTtcbiAgICB9O1xuICAgIEN1c3RvbUpTVHJhbnNmb3JtLnByb3RvdHlwZS5fbWFrZV90cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsLCBmbikge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChmdW5jLCBhcmdzLCBjdG9yKSB7XG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbmV3IGN0b3IsIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY2hpbGQsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChyZXN1bHQpID09PSByZXN1bHQgPyByZXN1bHQgOiBjaGlsZDtcbiAgICAgICAgfSkoRnVuY3Rpb24sIHNsaWNlLmNhbGwoT2JqZWN0LmtleXModGhpcy5hcmdzKSkuY29uY2F0KFt2YWxdLCBbXCJyZXF1aXJlXCJdLCBbXCJleHBvcnRzXCJdLCBbZm5dKSwgZnVuY3Rpb24gKCkgeyB9KTtcbiAgICB9O1xuICAgIEN1c3RvbUpTVHJhbnNmb3JtLnByb3RvdHlwZS5fbWFrZV92YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RfMS52YWx1ZXModGhpcy5hcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiBDdXN0b21KU1RyYW5zZm9ybTtcbn0pKHRyYW5zZm9ybV8xLlRyYW5zZm9ybSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjdXN0b21qc190cmFuc2Zvcm1fMSA9IHJlcXVpcmUoXCIuL2N1c3RvbWpzX3RyYW5zZm9ybVwiKTtcbmV4cG9ydHMuQ3VzdG9tSlNUcmFuc2Zvcm0gPSBjdXN0b21qc190cmFuc2Zvcm1fMS5DdXN0b21KU1RyYW5zZm9ybTtcbnZhciBpbnRlcnBvbGF0b3JfMSA9IHJlcXVpcmUoXCIuL2ludGVycG9sYXRvclwiKTtcbmV4cG9ydHMuSW50ZXJwb2xhdG9yID0gaW50ZXJwb2xhdG9yXzEuSW50ZXJwb2xhdG9yO1xudmFyIGppdHRlcl8xID0gcmVxdWlyZShcIi4vaml0dGVyXCIpO1xuZXhwb3J0cy5KaXR0ZXIgPSBqaXR0ZXJfMS5KaXR0ZXI7XG52YXIgbGluZWFyX2ludGVycG9sYXRvcl8xID0gcmVxdWlyZShcIi4vbGluZWFyX2ludGVycG9sYXRvclwiKTtcbmV4cG9ydHMuTGluZWFySW50ZXJwb2xhdG9yID0gbGluZWFyX2ludGVycG9sYXRvcl8xLkxpbmVhckludGVycG9sYXRvcjtcbnZhciBzdGVwX2ludGVycG9sYXRvcl8xID0gcmVxdWlyZShcIi4vc3RlcF9pbnRlcnBvbGF0b3JcIik7XG5leHBvcnRzLlN0ZXBJbnRlcnBvbGF0b3IgPSBzdGVwX2ludGVycG9sYXRvcl8xLlN0ZXBJbnRlcnBvbGF0b3I7XG52YXIgdHJhbnNmb3JtXzEgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1cIik7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHRyYW5zZm9ybV8xLlRyYW5zZm9ybTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSwgaW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSlcbiAgICAgICAgcmV0dXJuIGk7XG59IHJldHVybiAtMTsgfTtcbnZhciB0cmFuc2Zvcm1fMSA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuSW50ZXJwb2xhdG9yID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEludGVycG9sYXRvciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSW50ZXJwb2xhdG9yKCkge1xuICAgICAgICByZXR1cm4gSW50ZXJwb2xhdG9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBJbnRlcnBvbGF0b3IucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgSW50ZXJwb2xhdG9yLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl94X3NvcnRlZCA9IFtdO1xuICAgICAgICB0aGlzLl95X3NvcnRlZCA9IFtdO1xuICAgICAgICB0aGlzLl9zb3J0ZWRfZGlydHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMuY2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc29ydGVkX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbnRlcnBvbGF0b3IuZGVmaW5lKHtcbiAgICAgICAgeDogW3AuQW55XSxcbiAgICAgICAgeTogW3AuQW55XSxcbiAgICAgICAgZGF0YTogW3AuQW55XSxcbiAgICAgICAgY2xpcDogW3AuQm9vbCwgdHJ1ZV1cbiAgICB9KTtcbiAgICBJbnRlcnBvbGF0b3IucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiAoZGVzY2VuZGluZykge1xuICAgICAgICB2YXIgY29sdW1uX25hbWVzLCBkYXRhLCBpLCBqLCBrLCBsaXN0LCByZWYsIHJlZjEsIHJlZjIsIHRzeCwgdHN5O1xuICAgICAgICBpZiAoZGVzY2VuZGluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZXNjZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnggIT09IHR5cGVvZiB0aGlzLnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBhcmFtZXRlcnMgZm9yIHggYW5kIHkgbXVzdCBiZSBvZiB0aGUgc2FtZSB0eXBlLCBlaXRoZXIgYm90aCBzdHJpbmdzIHdoaWNoIGRlZmluZSBhIGNvbHVtbiBpbiB0aGUgZGF0YSBzb3VyY2Ugb3IgYm90aCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMueCA9PT0gJ3N0cmluZycgJiYgdGhpcy5kYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZiB0aGUgeCBhbmQgeSBwYXJhbWV0ZXJzIGFyZSBub3Qgc3BlY2lmaWVkIGFzIGFuIGFycmF5LCB0aGUgZGF0YSBwYXJhbWV0ZXIgaXMgcmVxaXJlZC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3NvcnRlZF9kaXJ0eSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0c3ggPSBbXTtcbiAgICAgICAgdHN5ID0gW107XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy54ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGNvbHVtbl9uYW1lcyA9IGRhdGEuY29sdW1ucygpO1xuICAgICAgICAgICAgaWYgKHJlZiA9IHRoaXMueCwgaW5kZXhPZi5jYWxsKGNvbHVtbl9uYW1lcywgcmVmKSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB4IHBhcmFtZXRlciBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGEgdmFsaWQgY29sdW1uIG5hbWUgZGVmaW5lZCBpbiB0aGUgZGF0YSBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWYxID0gdGhpcy55LCBpbmRleE9mLmNhbGwoY29sdW1uX25hbWVzLCByZWYxKSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB4IHBhcmFtZXRlciBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGEgdmFsaWQgY29sdW1uIG5hbWUgZGVmaW5lZCBpbiB0aGUgZGF0YSBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRzeCA9IGRhdGEuZ2V0X2NvbHVtbih0aGlzLngpO1xuICAgICAgICAgICAgdHN5ID0gZGF0YS5nZXRfY29sdW1uKHRoaXMueSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0c3ggPSB0aGlzLng7XG4gICAgICAgICAgICB0c3kgPSB0aGlzLnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRzeC5sZW5ndGggIT09IHRzeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGxlbmd0aCBmb3IgeCBhbmQgeSBkbyBub3QgbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHN4Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCBhbmQgeSBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIGVsZW1lbnRzIHRvIHN1cHBvcnQgaW50ZXJwb2xhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGxpc3QgPSBbXTtcbiAgICAgICAgZm9yIChqIGluIHRzeCkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAneCc6IHRzeFtqXSxcbiAgICAgICAgICAgICAgICAneSc6IHRzeVtqXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2NlbmRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciByZWYyLCByZWYzO1xuICAgICAgICAgICAgICAgIHJldHVybiAocmVmMiA9IGEueCA8IGIueCkgIT0gbnVsbCA/IHJlZjIgOiAte1xuICAgICAgICAgICAgICAgICAgICAxOiAocmVmMyA9IGEueCA9PT0gYi54KSAhPSBudWxsID8gcmVmMyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIDA6IDFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciByZWYyLCByZWYzO1xuICAgICAgICAgICAgICAgIHJldHVybiAocmVmMiA9IGEueCA+IGIueCkgIT0gbnVsbCA/IHJlZjIgOiAte1xuICAgICAgICAgICAgICAgICAgICAxOiAocmVmMyA9IGEueCA9PT0gYi54KSAhPSBudWxsID8gcmVmMyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIDA6IDFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGsgPSBpID0gMCwgcmVmMiA9IGxpc3QubGVuZ3RoOyAwIDw9IHJlZjIgPyBpIDwgcmVmMiA6IGkgPiByZWYyOyBrID0gMCA8PSByZWYyID8gKytpIDogLS1pKSB7XG4gICAgICAgICAgICB0aGlzLl94X3NvcnRlZFtrXSA9IGxpc3Rba10ueDtcbiAgICAgICAgICAgIHRoaXMuX3lfc29ydGVkW2tdID0gbGlzdFtrXS55O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3J0ZWRfZGlydHkgPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBJbnRlcnBvbGF0b3I7XG59KSh0cmFuc2Zvcm1fMS5UcmFuc2Zvcm0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHRyYW5zZm9ybV8xID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGJva2VoX21hdGggPSByZXF1aXJlKFwiY29yZS91dGlsL21hdGhcIik7XG5leHBvcnRzLkppdHRlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChKaXR0ZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEppdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIEppdHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgSml0dGVyLmRlZmluZSh7XG4gICAgICAgIG1lYW46IFtwLk51bWJlciwgMF0sXG4gICAgICAgIHdpZHRoOiBbcC5OdW1iZXIsIDFdLFxuICAgICAgICBkaXN0cmlidXRpb246IFtwLkRpc3RyaWJ1dGlvbiwgJ3VuaWZvcm0nXVxuICAgIH0pO1xuICAgIEppdHRlci5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc3RyaWJ1dGlvbiA9PT0gJ3VuaWZvcm0nKSB7XG4gICAgICAgICAgICByZXR1cm4geCArIHRoaXMubWVhbiArICgoYm9rZWhfbWF0aC5yYW5kb20oKSAtIDAuNSkgKiB0aGlzLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXN0cmlidXRpb24gPT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4geCArIGJva2VoX21hdGgucm5vcm0odGhpcy5tZWFuLCB0aGlzLndpZHRoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSml0dGVyLnByb3RvdHlwZS52X2NvbXB1dGUgPSBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgdmFyIGksIGlkeCwgbGVuLCByZXN1bHQsIHg7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDY0QXJyYXkoeHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpZHggPSBpID0gMCwgbGVuID0geHMubGVuZ3RoOyBpIDwgbGVuOyBpZHggPSArK2kpIHtcbiAgICAgICAgICAgIHggPSB4c1tpZHhdO1xuICAgICAgICAgICAgcmVzdWx0W2lkeF0gPSB0aGlzLmNvbXB1dGUoeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBKaXR0ZXI7XG59KSh0cmFuc2Zvcm1fMS5UcmFuc2Zvcm0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIGludGVycG9sYXRvcl8xID0gcmVxdWlyZShcIi4vaW50ZXJwb2xhdG9yXCIpO1xuZXhwb3J0cy5MaW5lYXJJbnRlcnBvbGF0b3IgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTGluZWFySW50ZXJwb2xhdG9yLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMaW5lYXJJbnRlcnBvbGF0b3IoKSB7XG4gICAgICAgIHJldHVybiBMaW5lYXJJbnRlcnBvbGF0b3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExpbmVhckludGVycG9sYXRvci5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBkZXNjZW5kaW5nLCBpbmQsIHJldCwgeDEsIHgyLCB5MSwgeTI7XG4gICAgICAgIHRoaXMuc29ydChkZXNjZW5kaW5nID0gZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jbGlwID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoeCA8IHRoaXMuX3hfc29ydGVkWzBdIHx8IHggPiB0aGlzLl94X3NvcnRlZFt0aGlzLl94X3NvcnRlZC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHggPCB0aGlzLl94X3NvcnRlZFswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95X3NvcnRlZFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID4gdGhpcy5feF9zb3J0ZWRbdGhpcy5feF9zb3J0ZWQubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feV9zb3J0ZWRbdGhpcy5feV9zb3J0ZWQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPT09IHRoaXMuX3hfc29ydGVkWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feV9zb3J0ZWRbMF07XG4gICAgICAgIH1cbiAgICAgICAgaW5kID0gYXJyYXlfMS5maW5kTGFzdEluZGV4KHRoaXMuX3hfc29ydGVkLCBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtIDwgeDtcbiAgICAgICAgfSk7XG4gICAgICAgIHgxID0gdGhpcy5feF9zb3J0ZWRbaW5kXTtcbiAgICAgICAgeDIgPSB0aGlzLl94X3NvcnRlZFtpbmQgKyAxXTtcbiAgICAgICAgeTEgPSB0aGlzLl95X3NvcnRlZFtpbmRdO1xuICAgICAgICB5MiA9IHRoaXMuX3lfc29ydGVkW2luZCArIDFdO1xuICAgICAgICByZXQgPSB5MSArICgoKHggLSB4MSkgLyAoeDIgLSB4MSkpICogKHkyIC0geTEpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIExpbmVhckludGVycG9sYXRvci5wcm90b3R5cGUudl9jb21wdXRlID0gZnVuY3Rpb24gKHhzKSB7XG4gICAgICAgIHZhciBpLCBpZHgsIGxlbiwgcmVzdWx0LCB4O1xuICAgICAgICByZXN1bHQgPSBuZXcgRmxvYXQ2NEFycmF5KHhzLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaWR4ID0gaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaWR4ID0gKytpKSB7XG4gICAgICAgICAgICB4ID0geHNbaWR4XTtcbiAgICAgICAgICAgIHJlc3VsdFtpZHhdID0gdGhpcy5jb21wdXRlKHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gTGluZWFySW50ZXJwb2xhdG9yO1xufSkoaW50ZXJwb2xhdG9yXzEuSW50ZXJwb2xhdG9yKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBpbnRlcnBvbGF0b3JfMSA9IHJlcXVpcmUoXCIuL2ludGVycG9sYXRvclwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbmV4cG9ydHMuU3RlcEludGVycG9sYXRvciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTdGVwSW50ZXJwb2xhdG9yLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTdGVwSW50ZXJwb2xhdG9yKCkge1xuICAgICAgICByZXR1cm4gU3RlcEludGVycG9sYXRvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU3RlcEludGVycG9sYXRvci5kZWZpbmUoe1xuICAgICAgICBtb2RlOiBbcC5UcmFuc2Zvcm1TdGVwTW9kZSwgXCJhZnRlclwiXVxuICAgIH0pO1xuICAgIFN0ZXBJbnRlcnBvbGF0b3IucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgZGVzY2VuZGluZywgZGlmZnMsIGluZCwgbWRpZmYsIHJldCwgdHg7XG4gICAgICAgIHRoaXMuc29ydChkZXNjZW5kaW5nID0gZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jbGlwID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoeCA8IHRoaXMuX3hfc29ydGVkWzBdIHx8IHggPiB0aGlzLl94X3NvcnRlZFt0aGlzLl94X3NvcnRlZC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHggPCB0aGlzLl94X3NvcnRlZFswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95X3NvcnRlZFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID4gdGhpcy5feF9zb3J0ZWRbdGhpcy5feF9zb3J0ZWQubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feV9zb3J0ZWRbdGhpcy5feV9zb3J0ZWQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5kID0gLTE7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwiYWZ0ZXJcIikge1xuICAgICAgICAgICAgaW5kID0gYXJyYXlfMS5maW5kTGFzdEluZGV4KHRoaXMuX3hfc29ydGVkLCBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHggPj0gbnVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJiZWZvcmVcIikge1xuICAgICAgICAgICAgaW5kID0gYXJyYXlfMS5maW5kSW5kZXgodGhpcy5feF9zb3J0ZWQsIGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geCA8PSBudW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgICBkaWZmcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlZiA9IHRoaXMuX3hfc29ydGVkO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdHggPSByZWZbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChNYXRoLmFicyh0eCAtIHgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgbWRpZmYgPSBhcnJheV8xLm1pbihkaWZmcyk7XG4gICAgICAgICAgICBpbmQgPSBhcnJheV8xLmZpbmRJbmRleChkaWZmcywgZnVuY3Rpb24gKG51bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZGlmZiA9PT0gbnVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldCA9IHRoaXMuX3lfc29ydGVkW2luZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBTdGVwSW50ZXJwb2xhdG9yLnByb3RvdHlwZS52X2NvbXB1dGUgPSBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgdmFyIGksIGlkeCwgbGVuLCByZXN1bHQsIHg7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDY0QXJyYXkoeHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpZHggPSBpID0gMCwgbGVuID0geHMubGVuZ3RoOyBpIDwgbGVuOyBpZHggPSArK2kpIHtcbiAgICAgICAgICAgIHggPSB4c1tpZHhdO1xuICAgICAgICAgICAgcmVzdWx0W2lkeF0gPSB0aGlzLmNvbXB1dGUoeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBTdGVwSW50ZXJwb2xhdG9yO1xufSkoaW50ZXJwb2xhdG9yXzEuSW50ZXJwb2xhdG9yKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVHJhbnNmb3JtLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm0uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc2Zvcm07XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXF1aXJlKFwiZXM2LXdlYWstbWFwL2ltcGxlbWVudFwiKTtcbn1cbmlmICh0eXBlb2YgU2V0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXF1aXJlKFwiZXM2LXNldC9pbXBsZW1lbnRcIik7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfYnVyc3RfaW50b19mbGFtZXM7XG5fYnVyc3RfaW50b19mbGFtZXMgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB2YXIgYm9keSwgYm94LCBidXR0b24sIG1lc3NhZ2UsIHJlZiwgdGl0bGU7XG4gICAgYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBib3guc3R5bGVbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdID0gXCIjZjJkZWRlXCI7XG4gICAgYm94LnN0eWxlW1wiYm9yZGVyXCJdID0gXCIxcHggc29saWQgI2E5NDQ0MlwiO1xuICAgIGJveC5zdHlsZVtcImJvcmRlci1yYWRpdXNcIl0gPSBcIjRweFwiO1xuICAgIGJveC5zdHlsZVtcImRpc3BsYXlcIl0gPSBcImlubGluZS1ibG9ja1wiO1xuICAgIGJveC5zdHlsZVtcImZvbnQtZmFtaWx5XCJdID0gXCJzYW5zLXNlcmlmXCI7XG4gICAgYm94LnN0eWxlW1wibWFyZ2luLXRvcFwiXSA9IFwiNXB4XCI7XG4gICAgYm94LnN0eWxlW1wibWluLXdpZHRoXCJdID0gXCIyMDBweFwiO1xuICAgIGJveC5zdHlsZVtcInBhZGRpbmdcIl0gPSBcIjVweCA1cHggNXB4IDEwcHhcIjtcbiAgICBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBidXR0b24uc3R5bGVbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdID0gXCIjYTk0NDQyXCI7XG4gICAgYnV0dG9uLnN0eWxlW1wiYm9yZGVyLXJhZGl1c1wiXSA9IFwiMHB4IDRweCAwcHggMHB4XCI7XG4gICAgYnV0dG9uLnN0eWxlW1wiY29sb3JcIl0gPSBcIndoaXRlXCI7XG4gICAgYnV0dG9uLnN0eWxlW1wiY3Vyc29yXCJdID0gXCJwb2ludGVyXCI7XG4gICAgYnV0dG9uLnN0eWxlW1wiZmxvYXRcIl0gPSBcInJpZ2h0XCI7XG4gICAgYnV0dG9uLnN0eWxlW1wiZm9udC1zaXplXCJdID0gXCIwLjhlbVwiO1xuICAgIGJ1dHRvbi5zdHlsZVtcIm1hcmdpblwiXSA9IFwiLTZweCAtNnB4IDBweCAwcHhcIjtcbiAgICBidXR0b24uc3R5bGVbXCJwYWRkaW5nXCJdID0gXCIycHggNXB4IDRweCA1cHhcIjtcbiAgICBidXR0b24udGl0bGUgPSBcImNsb3NlXCI7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJjbG9zZVwiKTtcbiAgICBidXR0b24uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpKTtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGJvZHkucmVtb3ZlQ2hpbGQoYm94KTtcbiAgICB9KTtcbiAgICB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoM1wiKTtcbiAgICB0aXRsZS5zdHlsZVtcImNvbG9yXCJdID0gXCIjYTk0NDQyXCI7XG4gICAgdGl0bGUuc3R5bGVbXCJtYXJnaW5cIl0gPSBcIjhweCAwcHggMHB4IDBweFwiO1xuICAgIHRpdGxlLnN0eWxlW1wicGFkZGluZ1wiXSA9IFwiMHB4XCI7XG4gICAgdGl0bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJCb2tlaCBFcnJvclwiKSk7XG4gICAgbWVzc2FnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIik7XG4gICAgbWVzc2FnZS5zdHlsZVtcIndoaXRlLXNwYWNlXCJdID0gXCJ1bnNldFwiO1xuICAgIG1lc3NhZ2Uuc3R5bGVbXCJvdmVyZmxvdy14XCJdID0gXCJhdXRvXCI7XG4gICAgbWVzc2FnZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgocmVmID0gZXJyb3IubWVzc2FnZSkgIT0gbnVsbCA/IHJlZiA6IGVycm9yKSk7XG4gICAgYm94LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgYm94LmFwcGVuZENoaWxkKHRpdGxlKTtcbiAgICBib3guYXBwZW5kQ2hpbGQobWVzc2FnZSk7XG4gICAgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTtcbiAgICByZXR1cm4gYm9keS5pbnNlcnRCZWZvcmUoYm94LCBib2R5LmZpcnN0Q2hpbGQpO1xufTtcbmV4cG9ydHMuc2FmZWx5ID0gZnVuY3Rpb24gKGZuLCBzaWxlbnQpIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKHNpbGVudCA9PSBudWxsKSB7XG4gICAgICAgIHNpbGVudCA9IGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICBlcnJvciA9IGVycm9yMTtcbiAgICAgICAgX2J1cnN0X2ludG9fZmxhbWVzKGVycm9yKTtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJzaW9uID0gJzAuMTIuNic7XG4iLCIvKiEhXG4gKiAgQ2FudmFzIDIgU3ZnIHYxLjAuMjFcbiAqICBBIGxvdyBsZXZlbCBjYW52YXMgdG8gU1ZHIGNvbnZlcnRlci4gVXNlcyBhIG1vY2sgY2FudmFzIGNvbnRleHQgdG8gYnVpbGQgYW4gU1ZHIGRvY3VtZW50LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqXG4gKiAgQXV0aG9yOlxuICogIEtlcnJ5IExpdVxuICpcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTQgR2xpZmZ5IEluYy5cbiAqL1xuXG47KGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBTVFlMRVMsIGN0eCwgQ2FudmFzR3JhZGllbnQsIENhbnZhc1BhdHRlcm4sIG5hbWVkRW50aXRpZXM7XG5cbiAgICAvL2hlbHBlciBmdW5jdGlvbiB0byBmb3JtYXQgYSBzdHJpbmdcbiAgICBmdW5jdGlvbiBmb3JtYXQoc3RyLCBhcmdzKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYXJncyksIGk7XG4gICAgICAgIGZvciAoaT0wOyBpPGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxce1wiICsga2V5c1tpXSArIFwiXFxcXH1cIiwgXCJnaVwiKSwgYXJnc1trZXlzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICAvL2hlbHBlciBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBhIHJhbmRvbSBzdHJpbmdcbiAgICBmdW5jdGlvbiByYW5kb21TdHJpbmcoaG9sZGVyKSB7XG4gICAgICAgIHZhciBjaGFycywgcmFuZG9tc3RyaW5nLCBpO1xuICAgICAgICBpZiAoIWhvbGRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNyZWF0ZSBhIHJhbmRvbSBhdHRyaWJ1dGUgbmFtZSBmb3IgYW4gdW5kZWZpbmVkIG9iamVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYVFphYmNkZWZnaGlrbG1ub3BxcnN0dXZ3eHl6XCI7XG4gICAgICAgIHJhbmRvbXN0cmluZyA9IFwiXCI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJhbmRvbXN0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAgIHJhbmRvbXN0cmluZyArPSBjaGFyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoaG9sZGVyW3JhbmRvbXN0cmluZ10pO1xuICAgICAgICByZXR1cm4gcmFuZG9tc3RyaW5nO1xuICAgIH1cblxuICAgIC8vaGVscGVyIGZ1bmN0aW9uIHRvIG1hcCBuYW1lZCB0byBudW1iZXJlZCBlbnRpdGllc1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU5hbWVkVG9OdW1iZXJlZExvb2t1cChpdGVtcywgcmFkaXgpIHtcbiAgICAgICAgdmFyIGksIGVudGl0eSwgbG9va3VwID0ge30sIGJhc2UxMCwgYmFzZTE2O1xuICAgICAgICBpdGVtcyA9IGl0ZW1zLnNwbGl0KCcsJyk7XG4gICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gICAgICAgIC8vIE1hcCBmcm9tIG5hbWVkIHRvIG51bWJlcmVkIGVudGl0aWVzLlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGVudGl0eSA9ICcmJyArIGl0ZW1zW2kgKyAxXSArICc7JztcbiAgICAgICAgICAgIGJhc2UxMCA9IHBhcnNlSW50KGl0ZW1zW2ldLCByYWRpeCk7XG4gICAgICAgICAgICBsb29rdXBbZW50aXR5XSA9ICcmIycrYmFzZTEwKyc7JztcbiAgICAgICAgfVxuICAgICAgICAvL0ZGIGFuZCBJRSBuZWVkIHRvIGNyZWF0ZSBhIHJlZ2V4IGZyb20gaGV4IHZhbHVlcyBpZSAmbmJzcDsgPT0gXFx4YTBcbiAgICAgICAgbG9va3VwW1wiXFxcXHhhMFwiXSA9ICcmIzE2MDsnO1xuICAgICAgICByZXR1cm4gbG9va3VwO1xuICAgIH1cblxuICAgIC8vaGVscGVyIGZ1bmN0aW9uIHRvIG1hcCBjYW52YXMtdGV4dEFsaWduIHRvIHN2Zy10ZXh0QW5jaG9yXG4gICAgZnVuY3Rpb24gZ2V0VGV4dEFuY2hvcih0ZXh0QWxpZ24pIHtcbiAgICAgICAgLy9UT0RPOiBzdXBwb3J0IHJ0bCBsYW5ndWFnZXNcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB7XCJsZWZ0XCI6XCJzdGFydFwiLCBcInJpZ2h0XCI6XCJlbmRcIiwgXCJjZW50ZXJcIjpcIm1pZGRsZVwiLCBcInN0YXJ0XCI6XCJzdGFydFwiLCBcImVuZFwiOlwiZW5kXCJ9O1xuICAgICAgICByZXR1cm4gbWFwcGluZ1t0ZXh0QWxpZ25dIHx8IG1hcHBpbmcuc3RhcnQ7XG4gICAgfVxuXG4gICAgLy9oZWxwZXIgZnVuY3Rpb24gdG8gbWFwIGNhbnZhcy10ZXh0QmFzZWxpbmUgdG8gc3ZnLWRvbWluYW50QmFzZWxpbmVcbiAgICBmdW5jdGlvbiBnZXREb21pbmFudEJhc2VsaW5lKHRleHRCYXNlbGluZSkge1xuICAgICAgICAvL0lORk86IG5vdCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzXG4gICAgICAgIHZhciBtYXBwaW5nID0ge1wiYWxwaGFiZXRpY1wiOiBcImFscGhhYmV0aWNcIiwgXCJoYW5naW5nXCI6IFwiaGFuZ2luZ1wiLCBcInRvcFwiOlwidGV4dC1iZWZvcmUtZWRnZVwiLCBcImJvdHRvbVwiOlwidGV4dC1hZnRlci1lZGdlXCIsIFwibWlkZGxlXCI6XCJjZW50cmFsXCJ9O1xuICAgICAgICByZXR1cm4gbWFwcGluZ1t0ZXh0QmFzZWxpbmVdIHx8IG1hcHBpbmcuYWxwaGFiZXRpYztcbiAgICB9XG5cbiAgICAvLyBVbnBhY2sgZW50aXRpZXMgbG9va3VwIHdoZXJlIHRoZSBudW1iZXJzIGFyZSBpbiByYWRpeCAzMiB0byByZWR1Y2UgdGhlIHNpemVcbiAgICAvLyBlbnRpdHkgbWFwcGluZyBjb3VydGVzeSBvZiB0aW55bWNlXG4gICAgbmFtZWRFbnRpdGllcyA9IGNyZWF0ZU5hbWVkVG9OdW1iZXJlZExvb2t1cChcbiAgICAgICAgJzUwLG5ic3AsNTEsaWV4Y2wsNTIsY2VudCw1Myxwb3VuZCw1NCxjdXJyZW4sNTUseWVuLDU2LGJydmJhciw1NyxzZWN0LDU4LHVtbCw1OSxjb3B5LCcgK1xuICAgICAgICAgICAgJzVhLG9yZGYsNWIsbGFxdW8sNWMsbm90LDVkLHNoeSw1ZSxyZWcsNWYsbWFjciw1ZyxkZWcsNWgscGx1c21uLDVpLHN1cDIsNWosc3VwMyw1ayxhY3V0ZSwnICtcbiAgICAgICAgICAgICc1bCxtaWNybyw1bSxwYXJhLDVuLG1pZGRvdCw1byxjZWRpbCw1cCxzdXAxLDVxLG9yZG0sNXIscmFxdW8sNXMsZnJhYzE0LDV0LGZyYWMxMiw1dSxmcmFjMzQsJyArXG4gICAgICAgICAgICAnNXYsaXF1ZXN0LDYwLEFncmF2ZSw2MSxBYWN1dGUsNjIsQWNpcmMsNjMsQXRpbGRlLDY0LEF1bWwsNjUsQXJpbmcsNjYsQUVsaWcsNjcsQ2NlZGlsLCcgK1xuICAgICAgICAgICAgJzY4LEVncmF2ZSw2OSxFYWN1dGUsNmEsRWNpcmMsNmIsRXVtbCw2YyxJZ3JhdmUsNmQsSWFjdXRlLDZlLEljaXJjLDZmLEl1bWwsNmcsRVRILDZoLE50aWxkZSwnICtcbiAgICAgICAgICAgICc2aSxPZ3JhdmUsNmosT2FjdXRlLDZrLE9jaXJjLDZsLE90aWxkZSw2bSxPdW1sLDZuLHRpbWVzLDZvLE9zbGFzaCw2cCxVZ3JhdmUsNnEsVWFjdXRlLCcgK1xuICAgICAgICAgICAgJzZyLFVjaXJjLDZzLFV1bWwsNnQsWWFjdXRlLDZ1LFRIT1JOLDZ2LHN6bGlnLDcwLGFncmF2ZSw3MSxhYWN1dGUsNzIsYWNpcmMsNzMsYXRpbGRlLDc0LGF1bWwsJyArXG4gICAgICAgICAgICAnNzUsYXJpbmcsNzYsYWVsaWcsNzcsY2NlZGlsLDc4LGVncmF2ZSw3OSxlYWN1dGUsN2EsZWNpcmMsN2IsZXVtbCw3YyxpZ3JhdmUsN2QsaWFjdXRlLDdlLGljaXJjLCcgK1xuICAgICAgICAgICAgJzdmLGl1bWwsN2csZXRoLDdoLG50aWxkZSw3aSxvZ3JhdmUsN2osb2FjdXRlLDdrLG9jaXJjLDdsLG90aWxkZSw3bSxvdW1sLDduLGRpdmlkZSw3byxvc2xhc2gsJyArXG4gICAgICAgICAgICAnN3AsdWdyYXZlLDdxLHVhY3V0ZSw3cix1Y2lyYyw3cyx1dW1sLDd0LHlhY3V0ZSw3dSx0aG9ybiw3dix5dW1sLGNpLGZub2Ysc2gsQWxwaGEsc2ksQmV0YSwnICtcbiAgICAgICAgICAgICdzaixHYW1tYSxzayxEZWx0YSxzbCxFcHNpbG9uLHNtLFpldGEsc24sRXRhLHNvLFRoZXRhLHNwLElvdGEsc3EsS2FwcGEsc3IsTGFtYmRhLHNzLE11LCcgK1xuICAgICAgICAgICAgJ3N0LE51LHN1LFhpLHN2LE9taWNyb24sdDAsUGksdDEsUmhvLHQzLFNpZ21hLHQ0LFRhdSx0NSxVcHNpbG9uLHQ2LFBoaSx0NyxDaGksdDgsUHNpLCcgK1xuICAgICAgICAgICAgJ3Q5LE9tZWdhLHRoLGFscGhhLHRpLGJldGEsdGosZ2FtbWEsdGssZGVsdGEsdGwsZXBzaWxvbix0bSx6ZXRhLHRuLGV0YSx0byx0aGV0YSx0cCxpb3RhLCcgK1xuICAgICAgICAgICAgJ3RxLGthcHBhLHRyLGxhbWJkYSx0cyxtdSx0dCxudSx0dSx4aSx0dixvbWljcm9uLHUwLHBpLHUxLHJobyx1MixzaWdtYWYsdTMsc2lnbWEsdTQsdGF1LCcgK1xuICAgICAgICAgICAgJ3U1LHVwc2lsb24sdTYscGhpLHU3LGNoaSx1OCxwc2ksdTksb21lZ2EsdWgsdGhldGFzeW0sdWksdXBzaWgsdW0scGl2LDgxMixidWxsLDgxNixoZWxsaXAsJyArXG4gICAgICAgICAgICAnODFpLHByaW1lLDgxaixQcmltZSw4MXUsb2xpbmUsODI0LGZyYXNsLDg4byx3ZWllcnAsODhoLGltYWdlLDg4cyxyZWFsLDg5Mix0cmFkZSw4OWwsYWxlZnN5bSwnICtcbiAgICAgICAgICAgICc4Y2csbGFyciw4Y2gsdWFyciw4Y2kscmFyciw4Y2osZGFyciw4Y2ssaGFyciw4ZGwsY3JhcnIsOGVnLGxBcnIsOGVoLHVBcnIsOGVpLHJBcnIsOGVqLGRBcnIsJyArXG4gICAgICAgICAgICAnOGVrLGhBcnIsOGcwLGZvcmFsbCw4ZzIscGFydCw4ZzMsZXhpc3QsOGc1LGVtcHR5LDhnNyxuYWJsYSw4ZzgsaXNpbiw4Zzksbm90aW4sOGdiLG5pLDhnZixwcm9kLCcgK1xuICAgICAgICAgICAgJzhnaCxzdW0sOGdpLG1pbnVzLDhnbixsb3dhc3QsOGdxLHJhZGljLDhndCxwcm9wLDhndSxpbmZpbiw4aDAsYW5nLDhoNyxhbmQsOGg4LG9yLDhoOSxjYXAsOGhhLGN1cCwnICtcbiAgICAgICAgICAgICc4aGIsaW50LDhoayx0aGVyZTQsOGhzLHNpbSw4aTUsY29uZyw4aTgsYXN5bXAsOGowLG5lLDhqMSxlcXVpdiw4ajQsbGUsOGo1LGdlLDhrMixzdWIsOGszLHN1cCw4azQsJyArXG4gICAgICAgICAgICAnbnN1Yiw4azYsc3ViZSw4azcsc3VwZSw4a2wsb3BsdXMsOGtuLG90aW1lcyw4bDUscGVycCw4bTUsc2RvdCw4bzgsbGNlaWwsOG85LHJjZWlsLDhvYSxsZmxvb3IsOG9iLCcgK1xuICAgICAgICAgICAgJ3JmbG9vciw4cDksbGFuZyw4cGEscmFuZyw5ZWEsbG96LDlqMCxzcGFkZXMsOWozLGNsdWJzLDlqNSxoZWFydHMsOWo2LGRpYW1zLGFpLE9FbGlnLGFqLG9lbGlnLGIwLCcgK1xuICAgICAgICAgICAgJ1NjYXJvbixiMSxzY2Fyb24sYm8sWXVtbCxtNixjaXJjLG1zLHRpbGRlLDgwMixlbnNwLDgwMyxlbXNwLDgwOSx0aGluc3AsODBjLHp3bmosODBkLHp3aiw4MGUsbHJtLCcgK1xuICAgICAgICAgICAgJzgwZixybG0sODBqLG5kYXNoLDgwayxtZGFzaCw4MG8sbHNxdW8sODBwLHJzcXVvLDgwcSxzYnF1byw4MHMsbGRxdW8sODB0LHJkcXVvLDgwdSxiZHF1byw4MTAsZGFnZ2VyLCcgK1xuICAgICAgICAgICAgJzgxMSxEYWdnZXIsODFnLHBlcm1pbCw4MXAsbHNhcXVvLDgxcSxyc2FxdW8sODVjLGV1cm8nLCAzMik7XG5cblxuICAgIC8vU29tZSBiYXNpYyBtYXBwaW5ncyBmb3IgYXR0cmlidXRlcyBhbmQgZGVmYXVsdCB2YWx1ZXMuXG4gICAgU1RZTEVTID0ge1xuICAgICAgICBcInN0cm9rZVN0eWxlXCI6e1xuICAgICAgICAgICAgc3ZnQXR0ciA6IFwic3Ryb2tlXCIsIC8vY29ycmVzcG9uZGluZyBzdmcgYXR0cmlidXRlXG4gICAgICAgICAgICBjYW52YXMgOiBcIiMwMDAwMDBcIiwgLy9jYW52YXMgZGVmYXVsdFxuICAgICAgICAgICAgc3ZnIDogXCJub25lXCIsICAgICAgIC8vc3ZnIGRlZmF1bHRcbiAgICAgICAgICAgIGFwcGx5IDogXCJzdHJva2VcIiAgICAvL2FwcGx5IG9uIHN0cm9rZSgpIG9yIGZpbGwoKVxuICAgICAgICB9LFxuICAgICAgICBcImZpbGxTdHlsZVwiOntcbiAgICAgICAgICAgIHN2Z0F0dHIgOiBcImZpbGxcIixcbiAgICAgICAgICAgIGNhbnZhcyA6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgc3ZnIDogbnVsbCwgLy9zdmcgZGVmYXVsdCBpcyBibGFjaywgYnV0IHdlIG5lZWQgdG8gc3BlY2lhbCBjYXNlIHRoaXMgdG8gaGFuZGxlIGNhbnZhcyBzdHJva2Ugd2l0aG91dCBmaWxsXG4gICAgICAgICAgICBhcHBseSA6IFwiZmlsbFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZUNhcFwiOntcbiAgICAgICAgICAgIHN2Z0F0dHIgOiBcInN0cm9rZS1saW5lY2FwXCIsXG4gICAgICAgICAgICBjYW52YXMgOiBcImJ1dHRcIixcbiAgICAgICAgICAgIHN2ZyA6IFwiYnV0dFwiLFxuICAgICAgICAgICAgYXBwbHkgOiBcInN0cm9rZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZUpvaW5cIjp7XG4gICAgICAgICAgICBzdmdBdHRyIDogXCJzdHJva2UtbGluZWpvaW5cIixcbiAgICAgICAgICAgIGNhbnZhcyA6IFwibWl0ZXJcIixcbiAgICAgICAgICAgIHN2ZyA6IFwibWl0ZXJcIixcbiAgICAgICAgICAgIGFwcGx5IDogXCJzdHJva2VcIlxuICAgICAgICB9LFxuICAgICAgICBcIm1pdGVyTGltaXRcIjp7XG4gICAgICAgICAgICBzdmdBdHRyIDogXCJzdHJva2UtbWl0ZXJsaW1pdFwiLFxuICAgICAgICAgICAgY2FudmFzIDogMTAsXG4gICAgICAgICAgICBzdmcgOiA0LFxuICAgICAgICAgICAgYXBwbHkgOiBcInN0cm9rZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZVdpZHRoXCI6e1xuICAgICAgICAgICAgc3ZnQXR0ciA6IFwic3Ryb2tlLXdpZHRoXCIsXG4gICAgICAgICAgICBjYW52YXMgOiAxLFxuICAgICAgICAgICAgc3ZnIDogMSxcbiAgICAgICAgICAgIGFwcGx5IDogXCJzdHJva2VcIlxuICAgICAgICB9LFxuICAgICAgICBcImdsb2JhbEFscGhhXCI6IHtcbiAgICAgICAgICAgIHN2Z0F0dHIgOiBcIm9wYWNpdHlcIixcbiAgICAgICAgICAgIGNhbnZhcyA6IDEsXG4gICAgICAgICAgICBzdmcgOiAxLFxuICAgICAgICAgICAgYXBwbHkgOiAgXCJmaWxsIHN0cm9rZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZm9udFwiOntcbiAgICAgICAgICAgIC8vZm9udCBjb252ZXJ0cyB0byBtdWx0aXBsZSBzdmcgYXR0cmlidXRlcywgdGhlcmUgaXMgY3VzdG9tIGxvZ2ljIGZvciB0aGlzXG4gICAgICAgICAgICBjYW52YXMgOiBcIjEwcHggc2Fucy1zZXJpZlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2hhZG93Q29sb3JcIjp7XG4gICAgICAgICAgICBjYW52YXMgOiBcIiMwMDAwMDBcIlxuICAgICAgICB9LFxuICAgICAgICBcInNoYWRvd09mZnNldFhcIjp7XG4gICAgICAgICAgICBjYW52YXMgOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwic2hhZG93T2Zmc2V0WVwiOntcbiAgICAgICAgICAgIGNhbnZhcyA6IDBcbiAgICAgICAgfSxcbiAgICAgICAgXCJzaGFkb3dCbHVyXCI6e1xuICAgICAgICAgICAgY2FudmFzIDogMFxuICAgICAgICB9LFxuICAgICAgICBcInRleHRBbGlnblwiOntcbiAgICAgICAgICAgIGNhbnZhcyA6IFwic3RhcnRcIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHRCYXNlbGluZVwiOntcbiAgICAgICAgICAgIGNhbnZhcyA6IFwiYWxwaGFiZXRpY1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZURhc2hcIiA6IHtcbiAgICAgICAgICAgIHN2Z0F0dHIgOiBcInN0cm9rZS1kYXNoYXJyYXlcIixcbiAgICAgICAgICAgIGNhbnZhcyA6IFtdLFxuICAgICAgICAgICAgc3ZnIDogbnVsbCxcbiAgICAgICAgICAgIGFwcGx5IDogXCJzdHJva2VcIlxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyYWRpZW50Tm9kZSAtIHJlZmVyZW5jZSB0byB0aGUgZ3JhZGllbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBDYW52YXNHcmFkaWVudCA9IGZ1bmN0aW9uIChncmFkaWVudE5vZGUsIGN0eCkge1xuICAgICAgICB0aGlzLl9fcm9vdCA9IGdyYWRpZW50Tm9kZTtcbiAgICAgICAgdGhpcy5fX2N0eCA9IGN0eDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvbG9yIHN0b3AgdG8gdGhlIGdyYWRpZW50IHJvb3RcbiAgICAgKi9cbiAgICBDYW52YXNHcmFkaWVudC5wcm90b3R5cGUuYWRkQ29sb3JTdG9wID0gZnVuY3Rpb24gKG9mZnNldCwgY29sb3IpIHtcbiAgICAgICAgdmFyIHN0b3AgPSB0aGlzLl9fY3R4Ll9fY3JlYXRlRWxlbWVudChcInN0b3BcIiksIHJlZ2V4LCBtYXRjaGVzO1xuICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZShcIm9mZnNldFwiLCBvZmZzZXQpO1xuICAgICAgICBpZiAoY29sb3IuaW5kZXhPZihcInJnYmFcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAvL3NlcGFyYXRlIGFscGhhIHZhbHVlLCBzaW5jZSB3ZWJraXQgY2FuJ3QgaGFuZGxlIGl0XG4gICAgICAgICAgICByZWdleCA9IC9yZ2JhXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQ/XFwuP1xcZCopXFxzKlxcKS9naTtcbiAgICAgICAgICAgIG1hdGNoZXMgPSByZWdleC5leGVjKGNvbG9yKTtcbiAgICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlKFwic3RvcC1jb2xvclwiLCBmb3JtYXQoXCJyZ2Ioe3J9LHtnfSx7Yn0pXCIsIHtyOm1hdGNoZXNbMV0sIGc6bWF0Y2hlc1syXSwgYjptYXRjaGVzWzNdfSkpO1xuICAgICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoXCJzdG9wLW9wYWNpdHlcIiwgbWF0Y2hlc1s0XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZShcInN0b3AtY29sb3JcIiwgY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19yb290LmFwcGVuZENoaWxkKHN0b3ApO1xuICAgIH07XG5cbiAgICBDYW52YXNQYXR0ZXJuID0gZnVuY3Rpb24gKHBhdHRlcm4sIGN0eCkge1xuICAgICAgICB0aGlzLl9fcm9vdCA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMuX19jdHggPSBjdHg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtb2NrIGNhbnZhcyBjb250ZXh0XG4gICAgICogQHBhcmFtIG8gLSBvcHRpb25zIGluY2x1ZGU6XG4gICAgICogY3R4IC0gZXhpc3RpbmcgQ29udGV4dDJEIHRvIHdyYXAgYXJvdW5kXG4gICAgICogd2lkdGggLSB3aWR0aCBvZiB5b3VyIGNhbnZhcyAoZGVmYXVsdHMgdG8gNTAwKVxuICAgICAqIGhlaWdodCAtIGhlaWdodCBvZiB5b3VyIGNhbnZhcyAoZGVmYXVsdHMgdG8gNTAwKVxuICAgICAqIGVuYWJsZU1pcnJvcmluZyAtIGVuYWJsZXMgY2FudmFzIG1pcnJvcmluZyAoZ2V0IGltYWdlIGRhdGEpIChkZWZhdWx0cyB0byBmYWxzZSlcbiAgICAgKiBkb2N1bWVudCAtIHRoZSBkb2N1bWVudCBvYmplY3QgKGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGRvY3VtZW50KVxuICAgICAqL1xuICAgIGN0eCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHsgd2lkdGg6NTAwLCBoZWlnaHQ6NTAwLCBlbmFibGVNaXJyb3JpbmcgOiBmYWxzZX0sIG9wdGlvbnM7XG5cbiAgICAgICAgLy9rZWVwIHN1cHBvcnQgZm9yIHRoaXMgd2F5IG9mIGNhbGxpbmcgQzJTOiBuZXcgQzJTKHdpZHRoLGhlaWdodClcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zLndpZHRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgb3B0aW9ucy5oZWlnaHQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH0gZWxzZSBpZiAoICFvICkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG87XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgY3R4KSkge1xuICAgICAgICAgICAgLy9kaWQgc29tZW9uZSBjYWxsIHRoaXMgd2l0aG91dCBuZXc/XG4gICAgICAgICAgICByZXR1cm4gbmV3IGN0eChvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc2V0dXAgb3B0aW9uc1xuICAgICAgICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aCB8fCBkZWZhdWx0T3B0aW9ucy53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCBkZWZhdWx0T3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuZW5hYmxlTWlycm9yaW5nID0gb3B0aW9ucy5lbmFibGVNaXJyb3JpbmcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZW5hYmxlTWlycm9yaW5nIDogZGVmYXVsdE9wdGlvbnMuZW5hYmxlTWlycm9yaW5nO1xuXG4gICAgICAgIHRoaXMuY2FudmFzID0gdGhpczsgICAvLy9wb2ludCBiYWNrIHRvIHRoaXMgaW5zdGFuY2UhXG4gICAgICAgIHRoaXMuX19kb2N1bWVudCA9IG9wdGlvbnMuZG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cbiAgICAgICAgLy8gYWxsb3cgcGFzc2luZyBpbiBhbiBleGlzdGluZyBjb250ZXh0IHRvIHdyYXAgYXJvdW5kXG4gICAgICAgIC8vIGlmIGEgY29udGV4dCBpcyBwYXNzZWQgaW4sIHdlIGtub3cgYSBjYW52YXMgYWxyZWFkeSBleGlzdFxuICAgICAgICBpZiAob3B0aW9ucy5jdHgpIHtcbiAgICAgICAgICAgIHRoaXMuX19jdHggPSBvcHRpb25zLmN0eDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19jYW52YXMgPSB0aGlzLl9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgIHRoaXMuX19jdHggPSB0aGlzLl9fY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zZXREZWZhdWx0U3R5bGVzKCk7XG4gICAgICAgIHRoaXMuX19zdGFjayA9IFt0aGlzLl9fZ2V0U3R5bGVTdGF0ZSgpXTtcbiAgICAgICAgdGhpcy5fX2dyb3VwU3RhY2sgPSBbXTtcblxuICAgICAgICAvL3RoZSByb290IHN2ZyBlbGVtZW50XG4gICAgICAgIHRoaXMuX19yb290ID0gdGhpcy5fX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICAgICAgICB0aGlzLl9fcm9vdC5zZXRBdHRyaWJ1dGUoXCJ2ZXJzaW9uXCIsIDEuMSk7XG4gICAgICAgIHRoaXMuX19yb290LnNldEF0dHJpYnV0ZShcInhtbG5zXCIsIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIik7XG4gICAgICAgIHRoaXMuX19yb290LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIiwgXCJ4bWxuczp4bGlua1wiLCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIik7XG4gICAgICAgIHRoaXMuX19yb290LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHRoaXMud2lkdGgpO1xuICAgICAgICB0aGlzLl9fcm9vdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgdGhpcy5oZWlnaHQpO1xuXG4gICAgICAgIC8vbWFrZSBzdXJlIHdlIGRvbid0IGdlbmVyYXRlIHRoZSBzYW1lIGlkcyBpbiBkZWZzXG4gICAgICAgIHRoaXMuX19pZHMgPSB7fTtcblxuICAgICAgICAvL2RlZnMgdGFnXG4gICAgICAgIHRoaXMuX19kZWZzID0gdGhpcy5fX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZGVmc1wiKTtcbiAgICAgICAgdGhpcy5fX3Jvb3QuYXBwZW5kQ2hpbGQodGhpcy5fX2RlZnMpO1xuXG4gICAgICAgIC8vYWxzbyBhZGQgYSBncm91cCBjaGlsZC4gdGhlIHN2ZyBlbGVtZW50IGNhbid0IHVzZSB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZVxuICAgICAgICB0aGlzLl9fY3VycmVudEVsZW1lbnQgPSB0aGlzLl9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICAgICAgICB0aGlzLl9fcm9vdC5hcHBlbmRDaGlsZCh0aGlzLl9fY3VycmVudEVsZW1lbnQpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHNwZWNpZmllZCBzdmcgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5fX2NyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIHByb3BlcnRpZXMsIHJlc2V0RmlsbCkge1xuICAgICAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5fX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIGVsZW1lbnROYW1lKSxcbiAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSwga2V5O1xuICAgICAgICBpZiAocmVzZXRGaWxsKSB7XG4gICAgICAgICAgICAvL2lmIGZpbGwgb3Igc3Ryb2tlIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBzdmcgZWxlbWVudCBzaG91bGQgbm90IGRpc3BsYXkuIEJ5IGRlZmF1bHQgU1ZHJ3MgZmlsbCBpcyBibGFjay5cbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpPTA7IGk8a2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgcHJvcGVydGllc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBkZWZhdWx0IGNhbnZhcyBzdHlsZXMgdG8gdGhlIGNvbnRleHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuX19zZXREZWZhdWx0U3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvL2RlZmF1bHQgMmQgY2FudmFzIGNvbnRleHQgcHJvcGVydGllcyBzZWU6aHR0cDovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0L1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKFNUWUxFUyksIGksIGtleTtcbiAgICAgICAgZm9yIChpPTA7IGk8a2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IFNUWUxFU1trZXldLmNhbnZhcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHN0eWxlcyBvbiByZXN0b3JlXG4gICAgICogQHBhcmFtIHN0eWxlU3RhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuX19hcHBseVN0eWxlU3RhdGUgPSBmdW5jdGlvbiAoc3R5bGVTdGF0ZSkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHN0eWxlU3RhdGUpLCBpLCBrZXk7XG4gICAgICAgIGZvciAoaT0wOyBpPGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBzdHlsZVN0YXRlW2tleV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBzdHlsZSBzdGF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuX19nZXRTdHlsZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgc3R5bGVTdGF0ZSA9IHt9LCBrZXlzID0gT2JqZWN0LmtleXMoU1RZTEVTKSwga2V5O1xuICAgICAgICBmb3IgKGk9MDsgaTxrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgc3R5bGVTdGF0ZVtrZXldID0gdGhpc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZVN0YXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsZXMgdGhlIGN1cnJlbnQgc3R5bGVzIHRvIHRoZSBjdXJyZW50IFNWRyBlbGVtZW50LiBPbiBcImN0eC5maWxsXCIgb3IgXCJjdHguc3Ryb2tlXCJcbiAgICAgKiBAcGFyYW0gdHlwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5fX2FwcGx5U3R5bGVUb0N1cnJlbnRFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBcdHZhciBjdXJyZW50RWxlbWVudCA9IHRoaXMuX19jdXJyZW50RWxlbWVudDtcbiAgICBcdHZhciBjdXJyZW50U3R5bGVHcm91cCA9IHRoaXMuX19jdXJyZW50RWxlbWVudHNUb1N0eWxlO1xuICAgIFx0aWYgKGN1cnJlbnRTdHlsZUdyb3VwKSB7XG4gICAgXHRcdGN1cnJlbnRFbGVtZW50LnNldEF0dHJpYnV0ZSh0eXBlLCBcIlwiKTtcbiAgICBcdFx0Y3VycmVudEVsZW1lbnQgPSBjdXJyZW50U3R5bGVHcm91cC5lbGVtZW50O1xuICAgIFx0XHRjdXJyZW50U3R5bGVHcm91cC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUodHlwZSwgXCJcIik7XG4gICAgXHRcdH0pXG4gICAgXHR9XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhTVFlMRVMpLCBpLCBzdHlsZSwgdmFsdWUsIGlkLCByZWdleCwgbWF0Y2hlcztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0eWxlID0gU1RZTEVTW2tleXNbaV1dO1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzW2tleXNbaV1dO1xuICAgICAgICAgICAgaWYgKHN0eWxlLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgLy9pcyB0aGlzIGEgZ3JhZGllbnQgb3IgcGF0dGVybj9cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDYW52YXNQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuX19jdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29weSBvdmVyIGRlZnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKHZhbHVlLl9fY3R4Ll9fZGVmcy5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gdmFsdWUuX19jdHguX19kZWZzLmNoaWxkTm9kZXNbMF0uZ2V0QXR0cmlidXRlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lkc1tpZF0gPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGVmcy5hcHBlbmRDaGlsZCh2YWx1ZS5fX2N0eC5fX2RlZnMuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEVsZW1lbnQuc2V0QXR0cmlidXRlKHN0eWxlLmFwcGx5LCBmb3JtYXQoXCJ1cmwoI3tpZH0pXCIsIHtpZDp2YWx1ZS5fX3Jvb3QuZ2V0QXR0cmlidXRlKFwiaWRcIil9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ2FudmFzR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9ncmFkaWVudFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoc3R5bGUuYXBwbHksIGZvcm1hdChcInVybCgje2lkfSlcIiwge2lkOnZhbHVlLl9fcm9vdC5nZXRBdHRyaWJ1dGUoXCJpZFwiKX0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLmFwcGx5LmluZGV4T2YodHlwZSkhPT0tMSAmJiBzdHlsZS5zdmcgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoc3R5bGUuc3ZnQXR0ciA9PT0gXCJzdHJva2VcIiB8fCBzdHlsZS5zdmdBdHRyID09PSBcImZpbGxcIikgJiYgdmFsdWUuaW5kZXhPZihcInJnYmFcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NlcGFyYXRlIGFscGhhIHZhbHVlLCBzaW5jZSBpbGx1c3RyYXRvciBjYW4ndCBoYW5kbGUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gL3JnYmFcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZD9cXC4/XFxkKilcXHMqXFwpL2dpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHJlZ2V4LmV4ZWModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEVsZW1lbnQuc2V0QXR0cmlidXRlKHN0eWxlLnN2Z0F0dHIsIGZvcm1hdChcInJnYih7cn0se2d9LHtifSlcIiwge3I6bWF0Y2hlc1sxXSwgZzptYXRjaGVzWzJdLCBiOm1hdGNoZXNbM119KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Nob3VsZCB0YWtlIGdsb2JhbEFscGhhIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnbG9iYWxBbHBoYSA9IHRoaXMuZ2xvYmFsQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsQWxwaGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHkgKj0gZ2xvYmFsQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoc3R5bGUuc3ZnQXR0citcIi1vcGFjaXR5XCIsIG9wYWNpdHkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBzdHlsZS5zdmdBdHRyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleXNbaV0gPT09ICdnbG9iYWxBbHBoYScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyID0gdHlwZSsnLScrc3R5bGUuc3ZnQXR0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZpbGwtb3BhY2l0eSBvciBzdHJva2Utb3BhY2l0eSBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBzdHJva2Ugb3IgZmlsbC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9vdGhlcndpc2Ugb25seSB1cGRhdGUgYXR0cmlidXRlIGlmIHJpZ2h0IHR5cGUsIGFuZCBub3Qgc3ZnIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgZ3JvdXAgb3Igc3ZnIG5vZGUuIE1heSByZXR1cm4gdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuX19jbG9zZXN0R3JvdXBPclN2ZyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGUgPSBub2RlIHx8IHRoaXMuX19jdXJyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09IFwiZ1wiIHx8IG5vZGUubm9kZU5hbWUgPT09IFwic3ZnXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19jbG9zZXN0R3JvdXBPclN2Zyhub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNlcmlhbGl6ZWQgdmFsdWUgb2YgdGhlIHN2ZyBzbyBmYXJcbiAgICAgKiBAcGFyYW0gZml4TmFtZWRFbnRpdGllcyAtIFN0YW5kYWxvbmUgU1ZHIGRvZXNuJ3Qgc3VwcG9ydCBuYW1lZCBlbnRpdGllcywgd2hpY2ggZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUgZW5jb2Rlcy5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUsIHdlIGF0dGVtcHQgdG8gZmluZCBhbGwgbmFtZWQgZW50aXRpZXMgYW5kIGVuY29kZSBpdCBhcyBhIG51bWVyaWMgZW50aXR5LlxuICAgICAqIEByZXR1cm4gc2VyaWFsaXplZCBzdmdcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLmdldFNlcmlhbGl6ZWRTdmcgPSBmdW5jdGlvbiAoZml4TmFtZWRFbnRpdGllcykge1xuICAgICAgICB2YXIgc2VyaWFsaXplZCA9IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcodGhpcy5fX3Jvb3QpLFxuICAgICAgICAgICAga2V5cywgaSwga2V5LCB2YWx1ZSwgcmVnZXhwLCB4bWxucztcblxuICAgICAgICAvL0lFIHNlYXJjaCBmb3IgYSBkdXBsaWNhdGUgeG1ubHMgYmVjYXVzZSB0aGV5IGRpZG4ndCBpbXBsZW1lbnQgc2V0QXR0cmlidXRlTlMgY29ycmVjdGx5XG4gICAgICAgIHhtbG5zID0gL3htbG5zPVwiaHR0cDpcXC9cXC93d3dcXC53M1xcLm9yZ1xcLzIwMDBcXC9zdmdcIi4reG1sbnM9XCJodHRwOlxcL1xcL3d3d1xcLnczXFwub3JnXFwvMjAwMFxcL3N2Zy9naTtcbiAgICAgICAgaWYgKHhtbG5zLnRlc3Qoc2VyaWFsaXplZCkpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQgPSBzZXJpYWxpemVkLnJlcGxhY2UoJ3htbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCd4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaXhOYW1lZEVudGl0aWVzKSB7XG4gICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMobmFtZWRFbnRpdGllcyk7XG4gICAgICAgICAgICAvL2xvb3Agb3ZlciBlYWNoIG5hbWVkIGVudGl0eSBhbmQgcmVwbGFjZSB3aXRoIHRoZSBwcm9wZXIgZXF1aXZhbGVudC5cbiAgICAgICAgICAgIGZvciAoaT0wOyBpPGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmFtZWRFbnRpdGllc1trZXldO1xuICAgICAgICAgICAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoa2V5LCBcImdpXCIpO1xuICAgICAgICAgICAgICAgIGlmIChyZWdleHAudGVzdChzZXJpYWxpemVkKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkID0gc2VyaWFsaXplZC5yZXBsYWNlKHJlZ2V4cCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJvb3Qgc3ZnXG4gICAgICogQHJldHVyblxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuZ2V0U3ZnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3Jvb3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaWxsIGdlbmVyYXRlIGEgZ3JvdXAgdGFnLlxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5fX2NyZWF0ZUVsZW1lbnQoXCJnXCIpO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fX2Nsb3Nlc3RHcm91cE9yU3ZnKCk7XG4gICAgICAgIHRoaXMuX19ncm91cFN0YWNrLnB1c2gocGFyZW50KTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGdyb3VwKTtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRFbGVtZW50ID0gZ3JvdXA7XG4gICAgICAgIHRoaXMuX19zdGFjay5wdXNoKHRoaXMuX19nZXRTdHlsZVN0YXRlKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyBjdXJyZW50IGVsZW1lbnQgdG8gcGFyZW50LCBvciBqdXN0IHJvb3QgaWYgYWxyZWFkeSByb290XG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9fY3VycmVudEVsZW1lbnQgPSB0aGlzLl9fZ3JvdXBTdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRFbGVtZW50c1RvU3R5bGUgPSBudWxsO1xuICAgICAgICAvL0NsZWFyaW5nIGNhbnZhcyB3aWxsIG1ha2UgdGhlIHBvcGVkIGdyb3VwIGludmFsaWQsIGN1cnJlbnRFbGVtZW50IGlzIHNldCB0byB0aGUgcm9vdCBncm91cCBub2RlLlxuICAgICAgICBpZiAoIXRoaXMuX19jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fX2N1cnJlbnRFbGVtZW50ID0gdGhpcy5fX3Jvb3QuY2hpbGROb2Rlc1sxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9fc3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMuX19hcHBseVN0eWxlU3RhdGUoc3RhdGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGFkZCB0cmFuc2Zvcm1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuX19hZGRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAvL2lmIHRoZSBjdXJyZW50IGVsZW1lbnQgaGFzIHNpYmxpbmdzLCBhZGQgYW5vdGhlciBncm91cFxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fX2Nsb3Nlc3RHcm91cE9yU3ZnKCk7XG4gICAgICAgIGlmIChwYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIFx0aWYgKHRoaXMuX19jdXJyZW50RWxlbWVudC5ub2RlTmFtZSA9PT0gXCJwYXRoXCIpIHtcbiAgICAgICAgXHRcdGlmICghdGhpcy5fX2N1cnJlbnRFbGVtZW50c1RvU3R5bGUpIHRoaXMuX19jdXJyZW50RWxlbWVudHNUb1N0eWxlID0ge2VsZW1lbnQ6IHBhcmVudCwgY2hpbGRyZW46IFtdfTtcbiAgICAgICAgXHRcdHRoaXMuX19jdXJyZW50RWxlbWVudHNUb1N0eWxlLmNoaWxkcmVuLnB1c2godGhpcy5fX2N1cnJlbnRFbGVtZW50KVxuICAgICAgICBcdFx0dGhpcy5fX2FwcGx5Q3VycmVudERlZmF1bHRQYXRoKCk7XG4gICAgICAgIFx0fVxuXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLl9fY3JlYXRlRWxlbWVudChcImdcIik7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuICAgICAgICAgICAgdGhpcy5fX2N1cnJlbnRFbGVtZW50ID0gZ3JvdXA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5fX2N1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtICs9IFwiIFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJhbnNmb3JtID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2Zvcm0gKz0gdDtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRFbGVtZW50LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAgc2NhbGVzIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgeSA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2FkZFRyYW5zZm9ybShmb3JtYXQoXCJzY2FsZSh7eH0se3l9KVwiLCB7eDp4LCB5Onl9KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJvdGF0ZXMgdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICAgIHZhciBkZWdyZWVzID0gKGFuZ2xlICogMTgwIC8gTWF0aC5QSSk7XG4gICAgICAgIHRoaXMuX19hZGRUcmFuc2Zvcm0oZm9ybWF0KFwicm90YXRlKHthbmdsZX0se2N4fSx7Y3l9KVwiLCB7YW5nbGU6ZGVncmVlcywgY3g6MCwgY3k6MH0pKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdHJhbnNsYXRlcyB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB0aGlzLl9fYWRkVHJhbnNmb3JtKGZvcm1hdChcInRyYW5zbGF0ZSh7eH0se3l9KVwiLCB7eDp4LHk6eX0pKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYXBwbGllcyBhIHRyYW5zZm9ybSB0byB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgICB0aGlzLl9fYWRkVHJhbnNmb3JtKGZvcm1hdChcIm1hdHJpeCh7YX0se2J9LHtjfSx7ZH0se2V9LHtmfSlcIiwge2E6YSwgYjpiLCBjOmMsIGQ6ZCwgZTplLCBmOmZ9KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBQYXRoIEVsZW1lbnRcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLmJlZ2luUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhdGgsIHBhcmVudDtcblxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgY3VycmVudCBkZWZhdWx0IHBhdGgsIGl0IGlzIG5vdCBwYXJ0IG9mIHRoZSBkcmF3aW5nIHN0YXRlLlxuICAgICAgICAvLyBTZWUgYWxzbzogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjY3VycmVudC1kZWZhdWx0LXBhdGhcbiAgICAgICAgdGhpcy5fX2N1cnJlbnREZWZhdWx0UGF0aCA9IFwiXCI7XG4gICAgICAgIHRoaXMuX19jdXJyZW50UG9zaXRpb24gPSB7fTtcblxuICAgICAgICBwYXRoID0gdGhpcy5fX2NyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHt9LCB0cnVlKTtcbiAgICAgICAgcGFyZW50ID0gdGhpcy5fX2Nsb3Nlc3RHcm91cE9yU3ZnKCk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChwYXRoKTtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRFbGVtZW50ID0gcGF0aDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGFwcGx5IGN1cnJlbnREZWZhdWx0UGF0aCB0byBjdXJyZW50IHBhdGggZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5fX2FwcGx5Q3VycmVudERlZmF1bHRQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIFx0dmFyIGN1cnJlbnRFbGVtZW50ID0gdGhpcy5fX2N1cnJlbnRFbGVtZW50O1xuICAgICAgICBpZiAoY3VycmVudEVsZW1lbnQubm9kZU5hbWUgPT09IFwicGF0aFwiKSB7XG5cdFx0XHRjdXJyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkXCIsIHRoaXMuX19jdXJyZW50RGVmYXVsdFBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkF0dGVtcHRlZCB0byBhcHBseSBwYXRoIGNvbW1hbmQgdG8gbm9kZVwiLCBjdXJyZW50RWxlbWVudC5ub2RlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGFkZCBwYXRoIGNvbW1hbmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuX19hZGRQYXRoQ29tbWFuZCA9IGZ1bmN0aW9uIChjb21tYW5kKSB7XG4gICAgICAgIHRoaXMuX19jdXJyZW50RGVmYXVsdFBhdGggKz0gXCIgXCI7XG4gICAgICAgIHRoaXMuX19jdXJyZW50RGVmYXVsdFBhdGggKz0gY29tbWFuZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgbW92ZSBjb21tYW5kIHRvIHRoZSBjdXJyZW50IHBhdGggZWxlbWVudCxcbiAgICAgKiBpZiB0aGUgY3VycmVudFBhdGhFbGVtZW50IGlzIG5vdCBlbXB0eSBjcmVhdGUgYSBuZXcgcGF0aCBlbGVtZW50XG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoeCx5KSB7XG4gICAgICAgIGlmICh0aGlzLl9fY3VycmVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwicGF0aFwiKSB7XG4gICAgICAgICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlcyBhIG5ldyBzdWJwYXRoIHdpdGggdGhlIGdpdmVuIHBvaW50XG4gICAgICAgIHRoaXMuX19jdXJyZW50UG9zaXRpb24gPSB7eDogeCwgeTogeX07XG4gICAgICAgIHRoaXMuX19hZGRQYXRoQ29tbWFuZChmb3JtYXQoXCJNIHt4fSB7eX1cIiwge3g6eCwgeTp5fSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aFxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fX2N1cnJlbnREZWZhdWx0UGF0aCkge1xuICAgICAgICAgICAgdGhpcy5fX2FkZFBhdGhDb21tYW5kKFwiWlwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGluZSB0byBjb21tYW5kXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB0aGlzLl9fY3VycmVudFBvc2l0aW9uID0ge3g6IHgsIHk6IHl9O1xuICAgICAgICBpZiAodGhpcy5fX2N1cnJlbnREZWZhdWx0UGF0aC5pbmRleE9mKCdNJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fX2FkZFBhdGhDb21tYW5kKGZvcm1hdChcIkwge3h9IHt5fVwiLCB7eDp4LCB5Onl9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fYWRkUGF0aENvbW1hbmQoZm9ybWF0KFwiTSB7eH0ge3l9XCIsIHt4OngsIHk6eX0pKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBiZXppZXIgY29tbWFuZFxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uIChjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG4gICAgICAgIHRoaXMuX19jdXJyZW50UG9zaXRpb24gPSB7eDogeCwgeTogeX07XG4gICAgICAgIHRoaXMuX19hZGRQYXRoQ29tbWFuZChmb3JtYXQoXCJDIHtjcDF4fSB7Y3AxeX0ge2NwMnh9IHtjcDJ5fSB7eH0ge3l9XCIsXG4gICAgICAgICAgICB7Y3AxeDpjcDF4LCBjcDF5OmNwMXksIGNwMng6Y3AyeCwgY3AyeTpjcDJ5LCB4OngsIHk6eX0pKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHF1YWRyYXRpYyBjdXJ2ZSB0byBjb21tYW5kXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24gKGNweCwgY3B5LCB4LCB5KSB7XG4gICAgICAgIHRoaXMuX19jdXJyZW50UG9zaXRpb24gPSB7eDogeCwgeTogeX07XG4gICAgICAgIHRoaXMuX19hZGRQYXRoQ29tbWFuZChmb3JtYXQoXCJRIHtjcHh9IHtjcHl9IHt4fSB7eX1cIiwge2NweDpjcHgsIGNweTpjcHksIHg6eCwgeTp5fSkpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBub3JtYWxpemVkIHZlY3RvciBvZiBnaXZlbiB2ZWN0b3JcbiAgICAgKi9cbiAgICB2YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gKHZlY3Rvcikge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5zcXJ0KHZlY3RvclswXSAqIHZlY3RvclswXSArIHZlY3RvclsxXSAqIHZlY3RvclsxXSk7XG4gICAgICAgIHJldHVybiBbdmVjdG9yWzBdIC8gbGVuLCB2ZWN0b3JbMV0gLyBsZW5dO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBhcmNUbyB0byB0aGUgY3VycmVudCBwYXRoXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTUvV0QtMmRjb250ZXh0LTIwMTUwNTE0LyNkb20tY29udGV4dC0yZC1hcmN0b1xuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuYXJjVG8gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICAgICAgICAvLyBMZXQgdGhlIHBvaW50ICh4MCwgeTApIGJlIHRoZSBsYXN0IHBvaW50IGluIHRoZSBzdWJwYXRoLlxuICAgICAgICB2YXIgeDAgPSB0aGlzLl9fY3VycmVudFBvc2l0aW9uICYmIHRoaXMuX19jdXJyZW50UG9zaXRpb24ueDtcbiAgICAgICAgdmFyIHkwID0gdGhpcy5fX2N1cnJlbnRQb3NpdGlvbiAmJiB0aGlzLl9fY3VycmVudFBvc2l0aW9uLnk7XG5cbiAgICAgICAgLy8gRmlyc3QgZW5zdXJlIHRoZXJlIGlzIGEgc3VicGF0aCBmb3IgKHgxLCB5MSkuXG4gICAgICAgIGlmICh0eXBlb2YgeDAgPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgeTAgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTmVnYXRpdmUgdmFsdWVzIGZvciByYWRpdXMgbXVzdCBjYXVzZSB0aGUgaW1wbGVtZW50YXRpb24gdG8gdGhyb3cgYW4gSW5kZXhTaXplRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICBpZiAocmFkaXVzIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXhTaXplRXJyb3I6IFRoZSByYWRpdXMgcHJvdmlkZWQgKFwiICsgcmFkaXVzICsgXCIpIGlzIG5lZ2F0aXZlLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBwb2ludCAoeDAsIHkwKSBpcyBlcXVhbCB0byB0aGUgcG9pbnQgKHgxLCB5MSksXG4gICAgICAgIC8vIG9yIGlmIHRoZSBwb2ludCAoeDEsIHkxKSBpcyBlcXVhbCB0byB0aGUgcG9pbnQgKHgyLCB5MiksXG4gICAgICAgIC8vIG9yIGlmIHRoZSByYWRpdXMgcmFkaXVzIGlzIHplcm8sXG4gICAgICAgIC8vIHRoZW4gdGhlIG1ldGhvZCBtdXN0IGFkZCB0aGUgcG9pbnQgKHgxLCB5MSkgdG8gdGhlIHN1YnBhdGgsXG4gICAgICAgIC8vIGFuZCBjb25uZWN0IHRoYXQgcG9pbnQgdG8gdGhlIHByZXZpb3VzIHBvaW50ICh4MCwgeTApIGJ5IGEgc3RyYWlnaHQgbGluZS5cbiAgICAgICAgaWYgKCgoeDAgPT09IHgxKSAmJiAoeTAgPT09IHkxKSlcbiAgICAgICAgICAgIHx8ICgoeDEgPT09IHgyKSAmJiAoeTEgPT09IHkyKSlcbiAgICAgICAgICAgIHx8IChyYWRpdXMgPT09IDApKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVUbyh4MSwgeTEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGUgcG9pbnRzICh4MCwgeTApLCAoeDEsIHkxKSwgYW5kICh4MiwgeTIpIGFsbCBsaWUgb24gYSBzaW5nbGUgc3RyYWlnaHQgbGluZSxcbiAgICAgICAgLy8gdGhlbiB0aGUgbWV0aG9kIG11c3QgYWRkIHRoZSBwb2ludCAoeDEsIHkxKSB0byB0aGUgc3VicGF0aCxcbiAgICAgICAgLy8gYW5kIGNvbm5lY3QgdGhhdCBwb2ludCB0byB0aGUgcHJldmlvdXMgcG9pbnQgKHgwLCB5MCkgYnkgYSBzdHJhaWdodCBsaW5lLlxuICAgICAgICB2YXIgdW5pdF92ZWNfcDFfcDAgPSBub3JtYWxpemUoW3gwIC0geDEsIHkwIC0geTFdKTtcbiAgICAgICAgdmFyIHVuaXRfdmVjX3AxX3AyID0gbm9ybWFsaXplKFt4MiAtIHgxLCB5MiAtIHkxXSk7XG4gICAgICAgIGlmICh1bml0X3ZlY19wMV9wMFswXSAqIHVuaXRfdmVjX3AxX3AyWzFdID09PSB1bml0X3ZlY19wMV9wMFsxXSAqIHVuaXRfdmVjX3AxX3AyWzBdKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVUbyh4MSwgeTEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBsZXQgVGhlIEFyYyBiZSB0aGUgc2hvcnRlc3QgYXJjIGdpdmVuIGJ5IGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNpcmNsZSB0aGF0IGhhcyByYWRpdXMgcmFkaXVzLFxuICAgICAgICAvLyBhbmQgdGhhdCBoYXMgb25lIHBvaW50IHRhbmdlbnQgdG8gdGhlIGhhbGYtaW5maW5pdGUgbGluZSB0aGF0IGNyb3NzZXMgdGhlIHBvaW50ICh4MCwgeTApIGFuZCBlbmRzIGF0IHRoZSBwb2ludCAoeDEsIHkxKSxcbiAgICAgICAgLy8gYW5kIHRoYXQgaGFzIGEgZGlmZmVyZW50IHBvaW50IHRhbmdlbnQgdG8gdGhlIGhhbGYtaW5maW5pdGUgbGluZSB0aGF0IGVuZHMgYXQgdGhlIHBvaW50ICh4MSwgeTEpLCBhbmQgY3Jvc3NlcyB0aGUgcG9pbnQgKHgyLCB5MikuXG4gICAgICAgIC8vIFRoZSBwb2ludHMgYXQgd2hpY2ggdGhpcyBjaXJjbGUgdG91Y2hlcyB0aGVzZSB0d28gbGluZXMgYXJlIGNhbGxlZCB0aGUgc3RhcnQgYW5kIGVuZCB0YW5nZW50IHBvaW50cyByZXNwZWN0aXZlbHkuXG5cbiAgICAgICAgLy8gbm90ZSB0aGF0IGJvdGggdmVjdG9ycyBhcmUgdW5pdCB2ZWN0b3JzLCBzbyB0aGUgbGVuZ3RoIGlzIDFcbiAgICAgICAgdmFyIGNvcyA9ICh1bml0X3ZlY19wMV9wMFswXSAqIHVuaXRfdmVjX3AxX3AyWzBdICsgdW5pdF92ZWNfcDFfcDBbMV0gKiB1bml0X3ZlY19wMV9wMlsxXSk7XG4gICAgICAgIHZhciB0aGV0YSA9IE1hdGguYWNvcyhNYXRoLmFicyhjb3MpKTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgb3JpZ2luXG4gICAgICAgIHZhciB1bml0X3ZlY19wMV9vcmlnaW4gPSBub3JtYWxpemUoW1xuICAgICAgICAgICAgdW5pdF92ZWNfcDFfcDBbMF0gKyB1bml0X3ZlY19wMV9wMlswXSxcbiAgICAgICAgICAgIHVuaXRfdmVjX3AxX3AwWzFdICsgdW5pdF92ZWNfcDFfcDJbMV1cbiAgICAgICAgXSk7XG4gICAgICAgIHZhciBsZW5fcDFfb3JpZ2luID0gcmFkaXVzIC8gTWF0aC5zaW4odGhldGEgLyAyKTtcbiAgICAgICAgdmFyIHggPSB4MSArIGxlbl9wMV9vcmlnaW4gKiB1bml0X3ZlY19wMV9vcmlnaW5bMF07XG4gICAgICAgIHZhciB5ID0geTEgKyBsZW5fcDFfb3JpZ2luICogdW5pdF92ZWNfcDFfb3JpZ2luWzFdO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBzdGFydCBhbmdsZSBhbmQgZW5kIGFuZ2xlXG4gICAgICAgIC8vIHJvdGF0ZSA5MGRlZyBjbG9ja3dpc2UgKG5vdGUgdGhhdCB5IGF4aXMgcG9pbnRzIHRvIGl0cyBkb3duKVxuICAgICAgICB2YXIgdW5pdF92ZWNfb3JpZ2luX3N0YXJ0X3RhbmdlbnQgPSBbXG4gICAgICAgICAgICAtdW5pdF92ZWNfcDFfcDBbMV0sXG4gICAgICAgICAgICB1bml0X3ZlY19wMV9wMFswXVxuICAgICAgICBdO1xuICAgICAgICAvLyByb3RhdGUgOTBkZWcgY291bnRlciBjbG9ja3dpc2UgKG5vdGUgdGhhdCB5IGF4aXMgcG9pbnRzIHRvIGl0cyBkb3duKVxuICAgICAgICB2YXIgdW5pdF92ZWNfb3JpZ2luX2VuZF90YW5nZW50ID0gW1xuICAgICAgICAgICAgdW5pdF92ZWNfcDFfcDJbMV0sXG4gICAgICAgICAgICAtdW5pdF92ZWNfcDFfcDJbMF1cbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGdldEFuZ2xlID0gZnVuY3Rpb24gKHZlY3Rvcikge1xuICAgICAgICAgICAgLy8gZ2V0IGFuZ2xlIChjbG9ja3dpc2UpIGJldHdlZW4gdmVjdG9yIGFuZCAoMSwgMClcbiAgICAgICAgICAgIHZhciB4ID0gdmVjdG9yWzBdO1xuICAgICAgICAgICAgdmFyIHkgPSB2ZWN0b3JbMV07XG4gICAgICAgICAgICBpZiAoeSA+PSAwKSB7IC8vIG5vdGUgdGhhdCB5IGF4aXMgcG9pbnRzIHRvIGl0cyBkb3duXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWNvcyh4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC1NYXRoLmFjb3MoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdGFydEFuZ2xlID0gZ2V0QW5nbGUodW5pdF92ZWNfb3JpZ2luX3N0YXJ0X3RhbmdlbnQpO1xuICAgICAgICB2YXIgZW5kQW5nbGUgPSBnZXRBbmdsZSh1bml0X3ZlY19vcmlnaW5fZW5kX3RhbmdlbnQpO1xuXG4gICAgICAgIC8vIENvbm5lY3QgdGhlIHBvaW50ICh4MCwgeTApIHRvIHRoZSBzdGFydCB0YW5nZW50IHBvaW50IGJ5IGEgc3RyYWlnaHQgbGluZVxuICAgICAgICB0aGlzLmxpbmVUbyh4ICsgdW5pdF92ZWNfb3JpZ2luX3N0YXJ0X3RhbmdlbnRbMF0gKiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIHkgKyB1bml0X3ZlY19vcmlnaW5fc3RhcnRfdGFuZ2VudFsxXSAqIHJhZGl1cyk7XG5cbiAgICAgICAgLy8gQ29ubmVjdCB0aGUgc3RhcnQgdGFuZ2VudCBwb2ludCB0byB0aGUgZW5kIHRhbmdlbnQgcG9pbnQgYnkgYXJjXG4gICAgICAgIC8vIGFuZCBhZGRpbmcgdGhlIGVuZCB0YW5nZW50IHBvaW50IHRvIHRoZSBzdWJwYXRoLlxuICAgICAgICB0aGlzLmFyYyh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3Ryb2tlIHByb3BlcnR5IG9uIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLnN0cm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX19jdXJyZW50RWxlbWVudC5ub2RlTmFtZSA9PT0gXCJwYXRoXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX19jdXJyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwYWludC1vcmRlclwiLCBcImZpbGwgc3Ryb2tlIG1hcmtlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2FwcGx5Q3VycmVudERlZmF1bHRQYXRoKCk7XG4gICAgICAgIHRoaXMuX19hcHBseVN0eWxlVG9DdXJyZW50RWxlbWVudChcInN0cm9rZVwiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBmaWxsIHByb3BlcnRpZXMgb24gdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX19jdXJyZW50RWxlbWVudC5ub2RlTmFtZSA9PT0gXCJwYXRoXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX19jdXJyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwYWludC1vcmRlclwiLCBcInN0cm9rZSBmaWxsIG1hcmtlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2FwcGx5Q3VycmVudERlZmF1bHRQYXRoKCk7XG4gICAgICAgIHRoaXMuX19hcHBseVN0eWxlVG9DdXJyZW50RWxlbWVudChcImZpbGxcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBBZGRzIGEgcmVjdGFuZ2xlIHRvIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUucmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLl9fY3VycmVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwicGF0aFwiKSB7XG4gICAgICAgICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLmxpbmVUbyh4K3dpZHRoLCB5KTtcbiAgICAgICAgdGhpcy5saW5lVG8oeCt3aWR0aCwgeStoZWlnaHQpO1xuICAgICAgICB0aGlzLmxpbmVUbyh4LCB5K2hlaWdodCk7XG4gICAgICAgIHRoaXMubGluZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIGFkZHMgYSByZWN0YW5nbGUgZWxlbWVudFxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuZmlsbFJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcmVjdCwgcGFyZW50O1xuICAgICAgICByZWN0ID0gdGhpcy5fX2NyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICAgICAgICAgIHggOiB4LFxuICAgICAgICAgICAgeSA6IHksXG4gICAgICAgICAgICB3aWR0aCA6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0IDogaGVpZ2h0XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBwYXJlbnQgPSB0aGlzLl9fY2xvc2VzdEdyb3VwT3JTdmcoKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHJlY3QpO1xuICAgICAgICB0aGlzLl9fY3VycmVudEVsZW1lbnQgPSByZWN0O1xuICAgICAgICB0aGlzLl9fYXBwbHlTdHlsZVRvQ3VycmVudEVsZW1lbnQoXCJmaWxsXCIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIHJlY3RhbmdsZSB3aXRoIG5vIGZpbGxcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHBhcmFtIHdpZHRoXG4gICAgICogQHBhcmFtIGhlaWdodFxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuc3Ryb2tlUmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciByZWN0LCBwYXJlbnQ7XG4gICAgICAgIHJlY3QgPSB0aGlzLl9fY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAgICAgICAgeCA6IHgsXG4gICAgICAgICAgICB5IDogeSxcbiAgICAgICAgICAgIHdpZHRoIDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgOiBoZWlnaHRcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHBhcmVudCA9IHRoaXMuX19jbG9zZXN0R3JvdXBPclN2ZygpO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocmVjdCk7XG4gICAgICAgIHRoaXMuX19jdXJyZW50RWxlbWVudCA9IHJlY3Q7XG4gICAgICAgIHRoaXMuX19hcHBseVN0eWxlVG9DdXJyZW50RWxlbWVudChcInN0cm9rZVwiKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBlbnRpcmUgY2FudmFzOlxuICAgICAqIDEuIHNhdmUgY3VycmVudCB0cmFuc2Zvcm1zXG4gICAgICogMi4gcmVtb3ZlIGFsbCB0aGUgY2hpbGROb2RlcyBvZiB0aGUgcm9vdCBnIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLl9fY2xlYXJDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fX2Nsb3Nlc3RHcm91cE9yU3ZnKCksXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBjdXJyZW50LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgICAgdmFyIHJvb3RHcm91cCA9IHRoaXMuX19yb290LmNoaWxkTm9kZXNbMV07XG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gcm9vdEdyb3VwLmNoaWxkTm9kZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSBjaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2Rlc1tpXSkge1xuICAgICAgICAgICAgICAgIHJvb3RHcm91cC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fY3VycmVudEVsZW1lbnQgPSByb290R3JvdXA7XG4gICAgICAgIC8vcmVzZXQgX19ncm91cFN0YWNrIGFzIGFsbCB0aGUgY2hpbGQgZ3JvdXAgbm9kZXMgYXJlIGFsbCByZW1vdmVkLlxuICAgICAgICB0aGlzLl9fZ3JvdXBTdGFjayA9IFtdO1xuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB0aGlzLl9fYWRkVHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogXCJDbGVhcnNcIiBhIGNhbnZhcyBieSBqdXN0IGRyYXdpbmcgYSB3aGl0ZSByZWN0YW5nbGUgaW4gdGhlIGN1cnJlbnQgZ3JvdXAuXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5jbGVhclJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAvL2NsZWFyIGVudGlyZSBjYW52YXNcbiAgICAgICAgaWYgKHggPT09IDAgJiYgeSA9PT0gMCAmJiB3aWR0aCA9PT0gdGhpcy53aWR0aCAmJiBoZWlnaHQgPT09IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLl9fY2xlYXJDYW52YXMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVjdCwgcGFyZW50ID0gdGhpcy5fX2Nsb3Nlc3RHcm91cE9yU3ZnKCk7XG4gICAgICAgIHJlY3QgPSB0aGlzLl9fY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAgICAgICAgeCA6IHgsXG4gICAgICAgICAgICB5IDogeSxcbiAgICAgICAgICAgIHdpZHRoIDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgOiBoZWlnaHQsXG4gICAgICAgICAgICBmaWxsIDogXCIjRkZGRkZGXCJcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChyZWN0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpbmVhciBncmFkaWVudCB0byBhIGRlZnMgdGFnLlxuICAgICAqIFJldHVybnMgYSBjYW52YXMgZ3JhZGllbnQgb2JqZWN0IHRoYXQgaGFzIGEgcmVmZXJlbmNlIHRvIGl0J3MgcGFyZW50IGRlZlxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuY3JlYXRlTGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgdmFyIGdyYWQgPSB0aGlzLl9fY3JlYXRlRWxlbWVudChcImxpbmVhckdyYWRpZW50XCIsIHtcbiAgICAgICAgICAgIGlkIDogcmFuZG9tU3RyaW5nKHRoaXMuX19pZHMpLFxuICAgICAgICAgICAgeDEgOiB4MStcInB4XCIsXG4gICAgICAgICAgICB4MiA6IHgyK1wicHhcIixcbiAgICAgICAgICAgIHkxIDogeTErXCJweFwiLFxuICAgICAgICAgICAgeTIgOiB5MitcInB4XCIsXG4gICAgICAgICAgICBcImdyYWRpZW50VW5pdHNcIiA6IFwidXNlclNwYWNlT25Vc2VcIlxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX19kZWZzLmFwcGVuZENoaWxkKGdyYWQpO1xuICAgICAgICByZXR1cm4gbmV3IENhbnZhc0dyYWRpZW50KGdyYWQsIHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcmFkaWFsIGdyYWRpZW50IHRvIGEgZGVmcyB0YWcuXG4gICAgICogUmV0dXJucyBhIGNhbnZhcyBncmFkaWVudCBvYmplY3QgdGhhdCBoYXMgYSByZWZlcmVuY2UgdG8gaXQncyBwYXJlbnQgZGVmXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5jcmVhdGVSYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uICh4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKSB7XG4gICAgICAgIHZhciBncmFkID0gdGhpcy5fX2NyZWF0ZUVsZW1lbnQoXCJyYWRpYWxHcmFkaWVudFwiLCB7XG4gICAgICAgICAgICBpZCA6IHJhbmRvbVN0cmluZyh0aGlzLl9faWRzKSxcbiAgICAgICAgICAgIGN4IDogeDErXCJweFwiLFxuICAgICAgICAgICAgY3kgOiB5MStcInB4XCIsXG4gICAgICAgICAgICByICA6IHIxK1wicHhcIixcbiAgICAgICAgICAgIGZ4IDogeDArXCJweFwiLFxuICAgICAgICAgICAgZnkgOiB5MCtcInB4XCIsXG4gICAgICAgICAgICBcImdyYWRpZW50VW5pdHNcIiA6IFwidXNlclNwYWNlT25Vc2VcIlxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX19kZWZzLmFwcGVuZENoaWxkKGdyYWQpO1xuICAgICAgICByZXR1cm4gbmV3IENhbnZhc0dyYWRpZW50KGdyYWQsIHRoaXMpO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZm9udCBzdHJpbmcgYW5kIHJldHVybnMgc3ZnIG1hcHBpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuX19wYXJzZUZvbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWdleCA9IC9eXFxzKig/PSg/Oig/OlstYS16XStcXHMqKXswLDJ9KGl0YWxpY3xvYmxpcXVlKSk/KSg/PSg/Oig/OlstYS16XStcXHMqKXswLDJ9KHNtYWxsLWNhcHMpKT8pKD89KD86KD86Wy1hLXpdK1xccyopezAsMn0oYm9sZCg/OmVyKT98bGlnaHRlcnxbMS05XTAwKSk/KSg/Oig/Om5vcm1hbHxcXDF8XFwyfFxcMylcXHMqKXswLDN9KCg/Onh4Py0pPyg/OnNtYWxsfGxhcmdlKXxtZWRpdW18c21hbGxlcnxsYXJnZXJ8Wy5cXGRdKyg/OlxcJXxpbnxbY2VtXW18ZXh8cFtjdHhdKSkoPzpcXHMqXFwvXFxzKihub3JtYWx8Wy5cXGRdKyg/OlxcJXxpbnxbY2VtXW18ZXh8cFtjdHhdKSkpP1xccyooWy0sXFwnXFxcIlxcc2EtejAtOV0rPylcXHMqJC9pO1xuICAgICAgICB2YXIgZm9udFBhcnQgPSByZWdleC5leGVjKCB0aGlzLmZvbnQgKTtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBzdHlsZSA6IGZvbnRQYXJ0WzFdIHx8ICdub3JtYWwnLFxuICAgICAgICAgICAgc2l6ZSA6IGZvbnRQYXJ0WzRdIHx8ICcxMHB4JyxcbiAgICAgICAgICAgIGZhbWlseSA6IGZvbnRQYXJ0WzZdIHx8ICdzYW5zLXNlcmlmJyxcbiAgICAgICAgICAgIHdlaWdodDogZm9udFBhcnRbM10gfHwgJ25vcm1hbCcsXG4gICAgICAgICAgICBkZWNvcmF0aW9uIDogZm9udFBhcnRbMl0gfHwgJ25vcm1hbCcsXG4gICAgICAgICAgICBocmVmIDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vY2FudmFzIGRvZXNuJ3Qgc3VwcG9ydCB1bmRlcmxpbmUgbmF0aXZlbHksIGJ1dCB3ZSBjYW4gcGFzcyB0aGlzIGF0dHJpYnV0ZVxuICAgICAgICBpZiAodGhpcy5fX2ZvbnRVbmRlcmxpbmUgPT09IFwidW5kZXJsaW5lXCIpIHtcbiAgICAgICAgICAgIGRhdGEuZGVjb3JhdGlvbiA9IFwidW5kZXJsaW5lXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NhbnZhcyBhbHNvIGRvZXNuJ3Qgc3VwcG9ydCBsaW5raW5nLCBidXQgd2UgY2FuIHBhc3MgdGhpcyBhcyB3ZWxsXG4gICAgICAgIGlmICh0aGlzLl9fZm9udEhyZWYpIHtcbiAgICAgICAgICAgIGRhdGEuaHJlZiA9IHRoaXMuX19mb250SHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdG8gbGluayB0ZXh0IGZyYWdtZW50c1xuICAgICAqIEBwYXJhbSBmb250XG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5fX3dyYXBUZXh0TGluayA9IGZ1bmN0aW9uIChmb250LCBlbGVtZW50KSB7XG4gICAgICAgIGlmIChmb250LmhyZWYpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5fX2NyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICAgICAgYS5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwgXCJ4bGluazpocmVmXCIsIGZvbnQuaHJlZik7XG4gICAgICAgICAgICBhLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbGxzIG9yIHN0cm9rZXMgdGV4dFxuICAgICAqIEBwYXJhbSB0ZXh0XG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBzdHJva2Ugb3IgZmlsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5fX2FwcGx5VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCB4LCB5LCBhY3Rpb24pIHtcbiAgICAgICAgdmFyIGZvbnQgPSB0aGlzLl9fcGFyc2VGb250KCksXG4gICAgICAgICAgICBwYXJlbnQgPSB0aGlzLl9fY2xvc2VzdEdyb3VwT3JTdmcoKSxcbiAgICAgICAgICAgIHRleHRFbGVtZW50ID0gdGhpcy5fX2NyZWF0ZUVsZW1lbnQoXCJ0ZXh0XCIsIHtcbiAgICAgICAgICAgICAgICBcImZvbnQtZmFtaWx5XCIgOiBmb250LmZhbWlseSxcbiAgICAgICAgICAgICAgICBcImZvbnQtc2l6ZVwiIDogZm9udC5zaXplLFxuICAgICAgICAgICAgICAgIFwiZm9udC1zdHlsZVwiIDogZm9udC5zdHlsZSxcbiAgICAgICAgICAgICAgICBcImZvbnQtd2VpZ2h0XCIgOiBmb250LndlaWdodCxcbiAgICAgICAgICAgICAgICBcInRleHQtZGVjb3JhdGlvblwiIDogZm9udC5kZWNvcmF0aW9uLFxuICAgICAgICAgICAgICAgIFwieFwiIDogeCxcbiAgICAgICAgICAgICAgICBcInlcIiA6IHksXG4gICAgICAgICAgICAgICAgXCJ0ZXh0LWFuY2hvclwiOiBnZXRUZXh0QW5jaG9yKHRoaXMudGV4dEFsaWduKSxcbiAgICAgICAgICAgICAgICBcImRvbWluYW50LWJhc2VsaW5lXCI6IGdldERvbWluYW50QmFzZWxpbmUodGhpcy50ZXh0QmFzZWxpbmUpXG4gICAgICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICB0ZXh0RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgICAgICB0aGlzLl9fY3VycmVudEVsZW1lbnQgPSB0ZXh0RWxlbWVudDtcbiAgICAgICAgdGhpcy5fX2FwcGx5U3R5bGVUb0N1cnJlbnRFbGVtZW50KGFjdGlvbik7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLl9fd3JhcFRleHRMaW5rKGZvbnQsdGV4dEVsZW1lbnQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRleHQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB0ZXh0XG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuZmlsbFRleHQgPSBmdW5jdGlvbiAodGV4dCwgeCwgeSkge1xuICAgICAgICB0aGlzLl9fYXBwbHlUZXh0KHRleHQsIHgsIHksIFwiZmlsbFwiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3Ryb2tlcyB0ZXh0XG4gICAgICogQHBhcmFtIHRleHRcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5zdHJva2VUZXh0ID0gZnVuY3Rpb24gKHRleHQsIHgsIHkpIHtcbiAgICAgICAgdGhpcy5fX2FwcGx5VGV4dCh0ZXh0LCB4LCB5LCBcInN0cm9rZVwiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm8gbmVlZCB0byBpbXBsZW1lbnQgdGhpcyBmb3Igc3ZnLlxuICAgICAqIEBwYXJhbSB0ZXh0XG4gICAgICogQHJldHVybiB7VGV4dE1ldHJpY3N9XG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5tZWFzdXJlVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHRoaXMuX19jdHguZm9udCA9IHRoaXMuZm9udDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jdHgubWVhc3VyZVRleHQodGV4dCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBBcmMgY29tbWFuZCFcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLmFyYyA9IGZ1bmN0aW9uICh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjb3VudGVyQ2xvY2t3aXNlKSB7XG4gICAgICAgIC8vIGluIGNhbnZhcyBubyBjaXJjbGUgaXMgZHJhd24gaWYgbm8gYW5nbGUgaXMgcHJvdmlkZWQuXG4gICAgICAgIGlmIChzdGFydEFuZ2xlID09PSBlbmRBbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICUgKDIqTWF0aC5QSSk7XG4gICAgICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgJSAoMipNYXRoLlBJKTtcbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPT09IGVuZEFuZ2xlKSB7XG4gICAgICAgICAgICAvL2NpcmNsZSB0aW1lISBzdWJ0cmFjdCBzb21lIG9mIHRoZSBhbmdsZSBzbyBzdmcgaXMgaGFwcHkgKHN2ZyBlbGxpcHRpY2FsIGFyYyBjYW4ndCBkcmF3IGEgZnVsbCBjaXJjbGUpXG4gICAgICAgICAgICBlbmRBbmdsZSA9ICgoZW5kQW5nbGUgKyAoMipNYXRoLlBJKSkgLSAwLjAwMSAqIChjb3VudGVyQ2xvY2t3aXNlID8gLTEgOiAxKSkgJSAoMipNYXRoLlBJKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kWCA9IHgrcmFkaXVzKk1hdGguY29zKGVuZEFuZ2xlKSxcbiAgICAgICAgICAgIGVuZFkgPSB5K3JhZGl1cypNYXRoLnNpbihlbmRBbmdsZSksXG4gICAgICAgICAgICBzdGFydFggPSB4K3JhZGl1cypNYXRoLmNvcyhzdGFydEFuZ2xlKSxcbiAgICAgICAgICAgIHN0YXJ0WSA9IHkrcmFkaXVzKk1hdGguc2luKHN0YXJ0QW5nbGUpLFxuICAgICAgICAgICAgc3dlZXBGbGFnID0gY291bnRlckNsb2Nrd2lzZSA/IDAgOiAxLFxuICAgICAgICAgICAgbGFyZ2VBcmNGbGFnID0gMCxcbiAgICAgICAgICAgIGRpZmYgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dsaWZmeS9jYW52YXMyc3ZnL2lzc3Vlcy80XG4gICAgICAgIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAgICAgZGlmZiArPSAyKk1hdGguUEk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY291bnRlckNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgbGFyZ2VBcmNGbGFnID0gZGlmZiA+IE1hdGguUEkgPyAwIDogMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhcmdlQXJjRmxhZyA9IGRpZmYgPiBNYXRoLlBJID8gMSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxpbmVUbyhzdGFydFgsIHN0YXJ0WSk7XG4gICAgICAgIHRoaXMuX19hZGRQYXRoQ29tbWFuZChmb3JtYXQoXCJBIHtyeH0ge3J5fSB7eEF4aXNSb3RhdGlvbn0ge2xhcmdlQXJjRmxhZ30ge3N3ZWVwRmxhZ30ge2VuZFh9IHtlbmRZfVwiLFxuICAgICAgICAgICAge3J4OnJhZGl1cywgcnk6cmFkaXVzLCB4QXhpc1JvdGF0aW9uOjAsIGxhcmdlQXJjRmxhZzpsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZzpzd2VlcEZsYWcsIGVuZFg6ZW5kWCwgZW5kWTplbmRZfSkpO1xuXG4gICAgICAgIHRoaXMuX19jdXJyZW50UG9zaXRpb24gPSB7eDogZW5kWCwgeTogZW5kWX07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIENsaXBQYXRoIGZyb20gdGhlIGNsaXAgY29tbWFuZC5cbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBncm91cCA9IHRoaXMuX19jbG9zZXN0R3JvdXBPclN2ZygpLFxuICAgICAgICAgICAgY2xpcFBhdGggPSB0aGlzLl9fY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIpLFxuICAgICAgICAgICAgaWQgPSAgcmFuZG9tU3RyaW5nKHRoaXMuX19pZHMpLFxuICAgICAgICAgICAgbmV3R3JvdXAgPSB0aGlzLl9fY3JlYXRlRWxlbWVudChcImdcIik7XG5cbiAgICAgICAgdGhpcy5fX2FwcGx5Q3VycmVudERlZmF1bHRQYXRoKCk7XG4gICAgICAgIGdyb3VwLnJlbW92ZUNoaWxkKHRoaXMuX19jdXJyZW50RWxlbWVudCk7XG4gICAgICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIGlkKTtcbiAgICAgICAgY2xpcFBhdGguYXBwZW5kQ2hpbGQodGhpcy5fX2N1cnJlbnRFbGVtZW50KTtcblxuICAgICAgICB0aGlzLl9fZGVmcy5hcHBlbmRDaGlsZChjbGlwUGF0aCk7XG5cbiAgICAgICAgLy9zZXQgdGhlIGNsaXAgcGF0aCB0byB0aGlzIGdyb3VwXG4gICAgICAgIGdyb3VwLnNldEF0dHJpYnV0ZShcImNsaXAtcGF0aFwiLCBmb3JtYXQoXCJ1cmwoI3tpZH0pXCIsIHtpZDppZH0pKTtcblxuICAgICAgICAvL2NsaXAgcGF0aHMgY2FuIGJlIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQsIHdlIG5lZWQgdG8gYWRkIGFub3RoZXIgd3JhcHBlciBncm91cCB0byBhdm9pZCBsYXRlciB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgLy8gdG8gdGhpcyBwYXRoXG4gICAgICAgIGdyb3VwLmFwcGVuZENoaWxkKG5ld0dyb3VwKTtcblxuICAgICAgICB0aGlzLl9fY3VycmVudEVsZW1lbnQgPSBuZXdHcm91cDtcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGNhbnZhcywgaW1hZ2Ugb3IgbW9jayBjb250ZXh0IHRvIHRoaXMgY2FudmFzLlxuICAgICAqIE5vdGUgdGhhdCBhbGwgc3ZnIGRvbSBtYW5pcHVsYXRpb24gdXNlcyBub2RlLmNoaWxkTm9kZXMgcmF0aGVyIHRoYW4gbm9kZS5jaGlsZHJlbiBmb3IgSUUgc3VwcG9ydC5cbiAgICAgKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNkb20tY29udGV4dC0yZC1kcmF3aW1hZ2VcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLmRyYXdJbWFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9jb252ZXJ0IGFyZ3VtZW50cyB0byBhIHJlYWwgYXJyYXlcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgaW1hZ2U9YXJnc1swXSxcbiAgICAgICAgICAgIGR4LCBkeSwgZHcsIGRoLCBzeD0wLCBzeT0wLCBzdywgc2gsIHBhcmVudCwgc3ZnLCBkZWZzLCBncm91cCxcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50LCBzdmdJbWFnZSwgY2FudmFzLCBjb250ZXh0LCBpZDtcblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIGR4ID0gYXJnc1sxXTtcbiAgICAgICAgICAgIGR5ID0gYXJnc1syXTtcbiAgICAgICAgICAgIHN3ID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICBzaCA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgICAgIGR3ID0gc3c7XG4gICAgICAgICAgICBkaCA9IHNoO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgICBkeCA9IGFyZ3NbMV07XG4gICAgICAgICAgICBkeSA9IGFyZ3NbMl07XG4gICAgICAgICAgICBkdyA9IGFyZ3NbM107XG4gICAgICAgICAgICBkaCA9IGFyZ3NbNF07XG4gICAgICAgICAgICBzdyA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgc2ggPSBpbWFnZS5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgICAgIHN4ID0gYXJnc1sxXTtcbiAgICAgICAgICAgIHN5ID0gYXJnc1syXTtcbiAgICAgICAgICAgIHN3ID0gYXJnc1szXTtcbiAgICAgICAgICAgIHNoID0gYXJnc1s0XTtcbiAgICAgICAgICAgIGR4ID0gYXJnc1s1XTtcbiAgICAgICAgICAgIGR5ID0gYXJnc1s2XTtcbiAgICAgICAgICAgIGR3ID0gYXJnc1s3XTtcbiAgICAgICAgICAgIGRoID0gYXJnc1s4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluYXZsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBwYXNzZWQgdG8gZHJhd0ltYWdlOiBcIiArIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gdGhpcy5fX2Nsb3Nlc3RHcm91cE9yU3ZnKCk7XG4gICAgICAgIGN1cnJlbnRFbGVtZW50ID0gdGhpcy5fX2N1cnJlbnRFbGVtZW50O1xuICAgICAgICB2YXIgdHJhbnNsYXRlRGlyZWN0aXZlID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwiLCBcIiArIGR5ICsgXCIpXCI7XG4gICAgICAgIGlmIChpbWFnZSBpbnN0YW5jZW9mIGN0eCkge1xuICAgICAgICAgICAgLy9jYW52YXMyc3ZnIG1vY2sgY2FudmFzIGNvbnRleHQuIEluIHRoZSBmdXR1cmUgd2UgbWF5IHdhbnQgdG8gY2xvbmUgbm9kZXMgaW5zdGVhZC5cbiAgICAgICAgICAgIC8vYWxzbyBJJ20gY3VycmVudGx5IGlnbm9yaW5nIGR3LCBkaCwgc3csIHNoLCBzeCwgc3kgZm9yIGEgbW9jayBjb250ZXh0LlxuICAgICAgICAgICAgc3ZnID0gaW1hZ2UuZ2V0U3ZnKCkuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgaWYgKHN2Zy5jaGlsZE5vZGVzICYmIHN2Zy5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBkZWZzID0gc3ZnLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICAgICAgd2hpbGUoZGVmcy5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IGRlZnMuY2hpbGROb2Rlc1swXS5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lkc1tpZF0gPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RlZnMuYXBwZW5kQ2hpbGQoZGVmcy5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ3JvdXAgPSBzdmcuY2hpbGROb2Rlc1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9zYXZlIG9yaWdpbmFsIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luVHJhbnNmb3JtID0gZ3JvdXAuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtRGlyZWN0aXZlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1EaXJlY3RpdmUgPSBvcmlnaW5UcmFuc2Zvcm0rXCIgXCIrdHJhbnNsYXRlRGlyZWN0aXZlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRGlyZWN0aXZlID0gdHJhbnNsYXRlRGlyZWN0aXZlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm1EaXJlY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbWFnZS5ub2RlTmFtZSA9PT0gXCJJTUdcIikge1xuICAgICAgICAgICAgc3ZnSW1hZ2UgPSB0aGlzLl9fY3JlYXRlRWxlbWVudChcImltYWdlXCIpO1xuICAgICAgICAgICAgc3ZnSW1hZ2Uuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgZHcpO1xuICAgICAgICAgICAgc3ZnSW1hZ2Uuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGRoKTtcbiAgICAgICAgICAgIHN2Z0ltYWdlLnNldEF0dHJpYnV0ZShcInByZXNlcnZlQXNwZWN0UmF0aW9cIiwgXCJub25lXCIpO1xuXG4gICAgICAgICAgICBpZiAoc3ggfHwgc3kgfHwgc3cgIT09IGltYWdlLndpZHRoIHx8IHNoICE9PSBpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvL2Nyb3AgdGhlIGltYWdlIHVzaW5nIGEgdGVtcG9yYXJ5IGNhbnZhc1xuICAgICAgICAgICAgICAgIGNhbnZhcyA9IHRoaXMuX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGR3O1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaDtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgc3gsIHN5LCBzdywgc2gsIDAsIDAsIGR3LCBkaCk7XG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBjYW52YXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdmdJbWFnZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNsYXRlRGlyZWN0aXZlKTtcbiAgICAgICAgICAgIHN2Z0ltYWdlLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBcInhsaW5rOmhyZWZcIixcbiAgICAgICAgICAgICAgICBpbWFnZS5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIiA/IGltYWdlLnRvRGF0YVVSTCgpIDogaW1hZ2UuZ2V0QXR0cmlidXRlKFwic3JjXCIpKTtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChzdmdJbWFnZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW1hZ2Uubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIpIHtcbiAgICAgICAgICAgIHN2Z0ltYWdlID0gdGhpcy5fX2NyZWF0ZUVsZW1lbnQoXCJpbWFnZVwiKTtcbiAgICAgICAgICAgIHN2Z0ltYWdlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGR3KTtcbiAgICAgICAgICAgIHN2Z0ltYWdlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBkaCk7XG4gICAgICAgICAgICBzdmdJbWFnZS5zZXRBdHRyaWJ1dGUoXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIFwibm9uZVwiKTtcblxuICAgICAgICAgICAgLy8gZHJhdyBjYW52YXMgb250byB0ZW1wb3JhcnkgY2FudmFzIHNvIHRoYXQgc21vb3RoaW5nIGNhbiBiZSBoYW5kbGVkXG4gICAgICAgICAgICBjYW52YXMgPSB0aGlzLl9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGR3O1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGRoO1xuICAgICAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29udGV4dC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRleHQub0ltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29udGV4dC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCBzeCwgc3ksIHN3LCBzaCwgMCwgMCwgZHcsIGRoKTtcbiAgICAgICAgICAgIGltYWdlID0gY2FudmFzO1xuXG4gICAgICAgICAgICBzdmdJbWFnZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNsYXRlRGlyZWN0aXZlKTtcbiAgICAgICAgICAgIHN2Z0ltYWdlLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBcInhsaW5rOmhyZWZcIiwgaW1hZ2UudG9EYXRhVVJMKCkpO1xuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHN2Z0ltYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBwYXR0ZXJuIHRhZ1xuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuY3JlYXRlUGF0dGVybiA9IGZ1bmN0aW9uIChpbWFnZSwgcmVwZXRpdGlvbikge1xuICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMuX19kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdHRlcm5cIiksIGlkID0gcmFuZG9tU3RyaW5nKHRoaXMuX19pZHMpLFxuICAgICAgICAgICAgaW1nO1xuICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZShcImlkXCIsIGlkKTtcbiAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBpbWFnZS53aWR0aCk7XG4gICAgICAgIHBhdHRlcm4uc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGltYWdlLmhlaWdodCk7XG4gICAgICAgIGlmIChpbWFnZS5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIiB8fCBpbWFnZS5ub2RlTmFtZSA9PT0gXCJJTUdcIikge1xuICAgICAgICAgICAgaW1nID0gdGhpcy5fX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiaW1hZ2VcIik7XG4gICAgICAgICAgICBpbWcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgaW1hZ2Uud2lkdGgpO1xuICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBpbWFnZS5oZWlnaHQpO1xuICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBcInhsaW5rOmhyZWZcIixcbiAgICAgICAgICAgICAgICBpbWFnZS5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIiA/IGltYWdlLnRvRGF0YVVSTCgpIDogaW1hZ2UuZ2V0QXR0cmlidXRlKFwic3JjXCIpKTtcbiAgICAgICAgICAgIHBhdHRlcm4uYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgICAgIHRoaXMuX19kZWZzLmFwcGVuZENoaWxkKHBhdHRlcm4pO1xuICAgICAgICB9IGVsc2UgaWYgKGltYWdlIGluc3RhbmNlb2YgY3R4KSB7XG4gICAgICAgICAgICBwYXR0ZXJuLmFwcGVuZENoaWxkKGltYWdlLl9fcm9vdC5jaGlsZE5vZGVzWzFdKTtcbiAgICAgICAgICAgIHRoaXMuX19kZWZzLmFwcGVuZENoaWxkKHBhdHRlcm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2FudmFzUGF0dGVybihwYXR0ZXJuLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgY3R4LnByb3RvdHlwZS5zZXRMaW5lRGFzaCA9IGZ1bmN0aW9uIChkYXNoQXJyYXkpIHtcbiAgICAgICAgaWYgKGRhc2hBcnJheSAmJiBkYXNoQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5saW5lRGFzaCA9IGRhc2hBcnJheS5qb2luKFwiLFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGluZURhc2ggPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vdCB5ZXQgaW1wbGVtZW50ZWRcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLmRyYXdGb2N1c1JpbmcgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBjdHgucHJvdG90eXBlLmNyZWF0ZUltYWdlRGF0YSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIGN0eC5wcm90b3R5cGUuZ2V0SW1hZ2VEYXRhID0gZnVuY3Rpb24gKCkge307XG4gICAgY3R4LnByb3RvdHlwZS5wdXRJbWFnZURhdGEgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBjdHgucHJvdG90eXBlLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIGN0eC5wcm90b3R5cGUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvL2FkZCBvcHRpb25zIGZvciBhbHRlcm5hdGl2ZSBuYW1lc3BhY2VcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB3aW5kb3cuQzJTID0gY3R4O1xuICAgIH1cblxuICAgIC8vIENvbW1vbkpTL0Jyb3dzZXJpZnlcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjdHg7XG4gICAgfVxuXG59KCkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29weSAgICAgICAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L2NvcHknKVxuICAsIG5vcm1hbGl6ZU9wdGlvbnMgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9ub3JtYWxpemUtb3B0aW9ucycpXG4gICwgZW5zdXJlQ2FsbGFibGUgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlJylcbiAgLCBtYXAgICAgICAgICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvbWFwJylcbiAgLCBjYWxsYWJsZSAgICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUnKVxuICAsIHZhbGlkVmFsdWUgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC12YWx1ZScpXG5cbiAgLCBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgZGVmaW5lO1xuXG5kZWZpbmUgPSBmdW5jdGlvbiAobmFtZSwgZGVzYywgb3B0aW9ucykge1xuXHR2YXIgdmFsdWUgPSB2YWxpZFZhbHVlKGRlc2MpICYmIGNhbGxhYmxlKGRlc2MudmFsdWUpLCBkZ3M7XG5cdGRncyA9IGNvcHkoZGVzYyk7XG5cdGRlbGV0ZSBkZ3Mud3JpdGFibGU7XG5cdGRlbGV0ZSBkZ3MudmFsdWU7XG5cdGRncy5nZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCFvcHRpb25zLm92ZXJ3cml0ZURlZmluaXRpb24gJiYgaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBuYW1lKSkgcmV0dXJuIHZhbHVlO1xuXHRcdGRlc2MudmFsdWUgPSBiaW5kLmNhbGwodmFsdWUsIG9wdGlvbnMucmVzb2x2ZUNvbnRleHQgPyBvcHRpb25zLnJlc29sdmVDb250ZXh0KHRoaXMpIDogdGhpcyk7XG5cdFx0ZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwgZGVzYyk7XG5cdFx0cmV0dXJuIHRoaXNbbmFtZV07XG5cdH07XG5cdHJldHVybiBkZ3M7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwcm9wcy8qLCBvcHRpb25zKi8pIHtcblx0dmFyIG9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zKGFyZ3VtZW50c1sxXSk7XG5cdGlmIChvcHRpb25zLnJlc29sdmVDb250ZXh0ICE9IG51bGwpIGVuc3VyZUNhbGxhYmxlKG9wdGlvbnMucmVzb2x2ZUNvbnRleHQpO1xuXHRyZXR1cm4gbWFwKHByb3BzLCBmdW5jdGlvbiAoZGVzYywgbmFtZSkgeyByZXR1cm4gZGVmaW5lKG5hbWUsIGRlc2MsIG9wdGlvbnMpOyB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvYXNzaWduJylcbiAgLCBub3JtYWxpemVPcHRzID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMnKVxuICAsIGlzQ2FsbGFibGUgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZScpXG4gICwgY29udGFpbnMgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMnKVxuXG4gICwgZDtcblxuZCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRzY3IsIHZhbHVlLyosIG9wdGlvbnMqLykge1xuXHR2YXIgYywgZSwgdywgb3B0aW9ucywgZGVzYztcblx0aWYgKChhcmd1bWVudHMubGVuZ3RoIDwgMikgfHwgKHR5cGVvZiBkc2NyICE9PSAnc3RyaW5nJykpIHtcblx0XHRvcHRpb25zID0gdmFsdWU7XG5cdFx0dmFsdWUgPSBkc2NyO1xuXHRcdGRzY3IgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbMl07XG5cdH1cblx0aWYgKGRzY3IgPT0gbnVsbCkge1xuXHRcdGMgPSB3ID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2MnKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCAnZScpO1xuXHRcdHcgPSBjb250YWlucy5jYWxsKGRzY3IsICd3Jyk7XG5cdH1cblxuXHRkZXNjID0geyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSwgd3JpdGFibGU6IHcgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn07XG5cbmQuZ3MgPSBmdW5jdGlvbiAoZHNjciwgZ2V0LCBzZXQvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBjLCBlLCBvcHRpb25zLCBkZXNjO1xuXHRpZiAodHlwZW9mIGRzY3IgIT09ICdzdHJpbmcnKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSBnZXQ7XG5cdFx0Z2V0ID0gZHNjcjtcblx0XHRkc2NyID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRvcHRpb25zID0gYXJndW1lbnRzWzNdO1xuXHR9XG5cdGlmIChnZXQgPT0gbnVsbCkge1xuXHRcdGdldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNDYWxsYWJsZShnZXQpKSB7XG5cdFx0b3B0aW9ucyA9IGdldDtcblx0XHRnZXQgPSBzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoc2V0ID09IG51bGwpIHtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUoc2V0KSkge1xuXHRcdG9wdGlvbnMgPSBzZXQ7XG5cdFx0c2V0ID0gdW5kZWZpbmVkO1xuXHR9XG5cdGlmIChkc2NyID09IG51bGwpIHtcblx0XHRjID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2MnKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCAnZScpO1xuXHR9XG5cblx0ZGVzYyA9IHsgZ2V0OiBnZXQsIHNldDogc2V0LCBjb25maWd1cmFibGU6IGMsIGVudW1lcmFibGU6IGUgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn07XG4iLCIvLyBJbnNwaXJlZCBieSBHb29nbGUgQ2xvc3VyZTpcbi8vIGh0dHA6Ly9jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vc3ZuL2RvY3MvXG4vLyBjbG9zdXJlX2dvb2dfYXJyYXlfYXJyYXkuanMuaHRtbCNnb29nLmFycmF5LmNsZWFyXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHZhbHVlID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0L3ZhbGlkLXZhbHVlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YWx1ZSh0aGlzKS5sZW5ndGggPSAwO1xuXHRyZXR1cm4gdGhpcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1Bvc0ludCA9IHJlcXVpcmUoJy4uLy4uL251bWJlci90by1wb3MtaW50ZWdlcicpXG4gICwgdmFsdWUgICAgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QvdmFsaWQtdmFsdWUnKVxuXG4gICwgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mXG4gICwgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgYWJzID0gTWF0aC5hYnMsIGZsb29yID0gTWF0aC5mbG9vcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudC8qLCBmcm9tSW5kZXgqLykge1xuXHR2YXIgaSwgbCwgZnJvbUluZGV4LCB2YWw7XG5cdGlmIChzZWFyY2hFbGVtZW50ID09PSBzZWFyY2hFbGVtZW50KSB7IC8vanNsaW50OiBpZ25vcmVcblx0XHRyZXR1cm4gaW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9XG5cblx0bCA9IHRvUG9zSW50KHZhbHVlKHRoaXMpLmxlbmd0aCk7XG5cdGZyb21JbmRleCA9IGFyZ3VtZW50c1sxXTtcblx0aWYgKGlzTmFOKGZyb21JbmRleCkpIGZyb21JbmRleCA9IDA7XG5cdGVsc2UgaWYgKGZyb21JbmRleCA+PSAwKSBmcm9tSW5kZXggPSBmbG9vcihmcm9tSW5kZXgpO1xuXHRlbHNlIGZyb21JbmRleCA9IHRvUG9zSW50KHRoaXMubGVuZ3RoKSAtIGZsb29yKGFicyhmcm9tSW5kZXgpKTtcblxuXHRmb3IgKGkgPSBmcm9tSW5kZXg7IGkgPCBsOyArK2kpIHtcblx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBpKSkge1xuXHRcdFx0dmFsID0gdGhpc1tpXTtcblx0XHRcdGlmICh2YWwgIT09IHZhbCkgcmV0dXJuIGk7IC8vanNsaW50OiBpZ25vcmVcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IEFycmF5LmZyb21cblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBmcm9tID0gQXJyYXkuZnJvbSwgYXJyLCByZXN1bHQ7XG5cdGlmICh0eXBlb2YgZnJvbSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRhcnIgPSBbJ3JheicsICdkd2EnXTtcblx0cmVzdWx0ID0gZnJvbShhcnIpO1xuXHRyZXR1cm4gQm9vbGVhbihyZXN1bHQgJiYgKHJlc3VsdCAhPT0gYXJyKSAmJiAocmVzdWx0WzFdID09PSAnZHdhJykpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGl0ZXJhdG9yU3ltYm9sID0gcmVxdWlyZSgnZXM2LXN5bWJvbCcpLml0ZXJhdG9yXG4gICwgaXNBcmd1bWVudHMgICAgPSByZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi9pcy1hcmd1bWVudHMnKVxuICAsIGlzRnVuY3Rpb24gICAgID0gcmVxdWlyZSgnLi4vLi4vZnVuY3Rpb24vaXMtZnVuY3Rpb24nKVxuICAsIHRvUG9zSW50ICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbnVtYmVyL3RvLXBvcy1pbnRlZ2VyJylcbiAgLCBjYWxsYWJsZSAgICAgICA9IHJlcXVpcmUoJy4uLy4uL29iamVjdC92YWxpZC1jYWxsYWJsZScpXG4gICwgdmFsaWRWYWx1ZSAgICAgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QvdmFsaWQtdmFsdWUnKVxuICAsIGlzU3RyaW5nICAgICAgID0gcmVxdWlyZSgnLi4vLi4vc3RyaW5nL2lzLXN0cmluZycpXG5cbiAgLCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgZGVzYyA9IHsgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IG51bGwgfVxuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcnJheUxpa2UvKiwgbWFwRm4sIHRoaXNBcmcqLykge1xuXHR2YXIgbWFwRm4gPSBhcmd1bWVudHNbMV0sIHRoaXNBcmcgPSBhcmd1bWVudHNbMl0sIENvbnN0cnVjdG9yLCBpLCBqLCBhcnIsIGwsIGNvZGUsIGl0ZXJhdG9yXG5cdCAgLCByZXN1bHQsIGdldEl0ZXJhdG9yLCB2YWx1ZTtcblxuXHRhcnJheUxpa2UgPSBPYmplY3QodmFsaWRWYWx1ZShhcnJheUxpa2UpKTtcblxuXHRpZiAobWFwRm4gIT0gbnVsbCkgY2FsbGFibGUobWFwRm4pO1xuXHRpZiAoIXRoaXMgfHwgKHRoaXMgPT09IEFycmF5KSB8fCAhaXNGdW5jdGlvbih0aGlzKSkge1xuXHRcdC8vIFJlc3VsdDogUGxhaW4gYXJyYXlcblx0XHRpZiAoIW1hcEZuKSB7XG5cdFx0XHRpZiAoaXNBcmd1bWVudHMoYXJyYXlMaWtlKSkge1xuXHRcdFx0XHQvLyBTb3VyY2U6IEFyZ3VtZW50c1xuXHRcdFx0XHRsID0gYXJyYXlMaWtlLmxlbmd0aDtcblx0XHRcdFx0aWYgKGwgIT09IDEpIHJldHVybiBBcnJheS5hcHBseShudWxsLCBhcnJheUxpa2UpO1xuXHRcdFx0XHRhcnIgPSBuZXcgQXJyYXkoMSk7XG5cdFx0XHRcdGFyclswXSA9IGFycmF5TGlrZVswXTtcblx0XHRcdFx0cmV0dXJuIGFycjtcblx0XHRcdH1cblx0XHRcdGlmIChpc0FycmF5KGFycmF5TGlrZSkpIHtcblx0XHRcdFx0Ly8gU291cmNlOiBBcnJheVxuXHRcdFx0XHRhcnIgPSBuZXcgQXJyYXkobCA9IGFycmF5TGlrZS5sZW5ndGgpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgKytpKSBhcnJbaV0gPSBhcnJheUxpa2VbaV07XG5cdFx0XHRcdHJldHVybiBhcnI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGFyciA9IFtdO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFJlc3VsdDogTm9uIHBsYWluIGFycmF5XG5cdFx0Q29uc3RydWN0b3IgPSB0aGlzO1xuXHR9XG5cblx0aWYgKCFpc0FycmF5KGFycmF5TGlrZSkpIHtcblx0XHRpZiAoKGdldEl0ZXJhdG9yID0gYXJyYXlMaWtlW2l0ZXJhdG9yU3ltYm9sXSkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gU291cmNlOiBJdGVyYXRvclxuXHRcdFx0aXRlcmF0b3IgPSBjYWxsYWJsZShnZXRJdGVyYXRvcikuY2FsbChhcnJheUxpa2UpO1xuXHRcdFx0aWYgKENvbnN0cnVjdG9yKSBhcnIgPSBuZXcgQ29uc3RydWN0b3IoKTtcblx0XHRcdHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcblx0XHRcdGkgPSAwO1xuXHRcdFx0d2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuXHRcdFx0XHR2YWx1ZSA9IG1hcEZuID8gY2FsbC5jYWxsKG1hcEZuLCB0aGlzQXJnLCByZXN1bHQudmFsdWUsIGkpIDogcmVzdWx0LnZhbHVlO1xuXHRcdFx0XHRpZiAoIUNvbnN0cnVjdG9yKSB7XG5cdFx0XHRcdFx0YXJyW2ldID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVzYy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KGFyciwgaSwgZGVzYyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXHRcdFx0XHQrK2k7XG5cdFx0XHR9XG5cdFx0XHRsID0gaTtcblx0XHR9IGVsc2UgaWYgKGlzU3RyaW5nKGFycmF5TGlrZSkpIHtcblx0XHRcdC8vIFNvdXJjZTogU3RyaW5nXG5cdFx0XHRsID0gYXJyYXlMaWtlLmxlbmd0aDtcblx0XHRcdGlmIChDb25zdHJ1Y3RvcikgYXJyID0gbmV3IENvbnN0cnVjdG9yKCk7XG5cdFx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7ICsraSkge1xuXHRcdFx0XHR2YWx1ZSA9IGFycmF5TGlrZVtpXTtcblx0XHRcdFx0aWYgKChpICsgMSkgPCBsKSB7XG5cdFx0XHRcdFx0Y29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHRcdFx0aWYgKChjb2RlID49IDB4RDgwMCkgJiYgKGNvZGUgPD0gMHhEQkZGKSkgdmFsdWUgKz0gYXJyYXlMaWtlWysraV07XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWUgPSBtYXBGbiA/IGNhbGwuY2FsbChtYXBGbiwgdGhpc0FyZywgdmFsdWUsIGopIDogdmFsdWU7XG5cdFx0XHRcdGlmICghQ29uc3RydWN0b3IpIHtcblx0XHRcdFx0XHRhcnJbal0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZXNjLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoYXJyLCBqLCBkZXNjKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQrK2o7XG5cdFx0XHR9XG5cdFx0XHRsID0gajtcblx0XHR9XG5cdH1cblx0aWYgKGwgPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIFNvdXJjZTogYXJyYXkgb3IgYXJyYXktbGlrZVxuXHRcdGwgPSB0b1Bvc0ludChhcnJheUxpa2UubGVuZ3RoKTtcblx0XHRpZiAoQ29uc3RydWN0b3IpIGFyciA9IG5ldyBDb25zdHJ1Y3RvcihsKTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgKytpKSB7XG5cdFx0XHR2YWx1ZSA9IG1hcEZuID8gY2FsbC5jYWxsKG1hcEZuLCB0aGlzQXJnLCBhcnJheUxpa2VbaV0sIGkpIDogYXJyYXlMaWtlW2ldO1xuXHRcdFx0aWYgKCFDb25zdHJ1Y3Rvcikge1xuXHRcdFx0XHRhcnJbaV0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlc2MudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoYXJyLCBpLCBkZXNjKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0aWYgKENvbnN0cnVjdG9yKSB7XG5cdFx0ZGVzYy52YWx1ZSA9IG51bGw7XG5cdFx0YXJyLmxlbmd0aCA9IGw7XG5cdH1cblx0cmV0dXJuIGFycjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuICAsIGlkID0gdG9TdHJpbmcuY2FsbCgoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gKHRvU3RyaW5nLmNhbGwoeCkgPT09IGlkKTsgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG4gICwgaWQgPSB0b1N0cmluZy5jYWxsKHJlcXVpcmUoJy4vbm9vcCcpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZikge1xuXHRyZXR1cm4gKHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCIpICYmICh0b1N0cmluZy5jYWxsKGYpID09PSBpZCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHt9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKClcblx0PyBNYXRoLnNpZ25cblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzaWduID0gTWF0aC5zaWduO1xuXHRpZiAodHlwZW9mIHNpZ24gIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuICgoc2lnbigxMCkgPT09IDEpICYmIChzaWduKC0yMCkgPT09IC0xKSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHR2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdGlmIChpc05hTih2YWx1ZSkgfHwgKHZhbHVlID09PSAwKSkgcmV0dXJuIHZhbHVlO1xuXHRyZXR1cm4gKHZhbHVlID4gMCkgPyAxIDogLTE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4uL21hdGgvc2lnbicpXG5cbiAgLCBhYnMgPSBNYXRoLmFicywgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoaXNOYU4odmFsdWUpKSByZXR1cm4gMDtcblx0dmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHRpZiAoKHZhbHVlID09PSAwKSB8fCAhaXNGaW5pdGUodmFsdWUpKSByZXR1cm4gdmFsdWU7XG5cdHJldHVybiBzaWduKHZhbHVlKSAqIGZsb29yKGFicyh2YWx1ZSkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG8taW50ZWdlcicpXG5cbiAgLCBtYXggPSBNYXRoLm1heDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG1heCgwLCB0b0ludGVnZXIodmFsdWUpKTsgfTtcbiIsIi8vIEludGVybmFsIG1ldGhvZCwgdXNlZCBieSBpdGVyYXRpb24gZnVuY3Rpb25zLlxuLy8gQ2FsbHMgYSBmdW5jdGlvbiBmb3IgZWFjaCBrZXktdmFsdWUgcGFpciBmb3VuZCBpbiBvYmplY3Rcbi8vIE9wdGlvbmFsbHkgdGFrZXMgY29tcGFyZUZuIHRvIGl0ZXJhdGUgb2JqZWN0IGluIHNwZWNpZmljIG9yZGVyXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGxhYmxlID0gcmVxdWlyZSgnLi92YWxpZC1jYWxsYWJsZScpXG4gICwgdmFsdWUgICAgPSByZXF1aXJlKCcuL3ZhbGlkLXZhbHVlJylcblxuICAsIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLCBrZXlzID0gT2JqZWN0LmtleXNcbiAgLCBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCwgZGVmVmFsKSB7XG5cdHJldHVybiBmdW5jdGlvbiAob2JqLCBjYi8qLCB0aGlzQXJnLCBjb21wYXJlRm4qLykge1xuXHRcdHZhciBsaXN0LCB0aGlzQXJnID0gYXJndW1lbnRzWzJdLCBjb21wYXJlRm4gPSBhcmd1bWVudHNbM107XG5cdFx0b2JqID0gT2JqZWN0KHZhbHVlKG9iaikpO1xuXHRcdGNhbGxhYmxlKGNiKTtcblxuXHRcdGxpc3QgPSBrZXlzKG9iaik7XG5cdFx0aWYgKGNvbXBhcmVGbikge1xuXHRcdFx0bGlzdC5zb3J0KCh0eXBlb2YgY29tcGFyZUZuID09PSAnZnVuY3Rpb24nKSA/IGJpbmQuY2FsbChjb21wYXJlRm4sIG9iaikgOiB1bmRlZmluZWQpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykgbWV0aG9kID0gbGlzdFttZXRob2RdO1xuXHRcdHJldHVybiBjYWxsLmNhbGwobWV0aG9kLCBsaXN0LCBmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuXHRcdFx0aWYgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwga2V5KSkgcmV0dXJuIGRlZlZhbDtcblx0XHRcdHJldHVybiBjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIG9ialtrZXldLCBrZXksIG9iaiwgaW5kZXgpO1xuXHRcdH0pO1xuXHR9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IE9iamVjdC5hc3NpZ25cblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduLCBvYmo7XG5cdGlmICh0eXBlb2YgYXNzaWduICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdG9iaiA9IHsgZm9vOiAncmF6JyB9O1xuXHRhc3NpZ24ob2JqLCB7IGJhcjogJ2R3YScgfSwgeyB0cnp5OiAndHJ6eScgfSk7XG5cdHJldHVybiAob2JqLmZvbyArIG9iai5iYXIgKyBvYmoudHJ6eSkgPT09ICdyYXpkd2F0cnp5Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzICA9IHJlcXVpcmUoJy4uL2tleXMnKVxuICAsIHZhbHVlID0gcmVxdWlyZSgnLi4vdmFsaWQtdmFsdWUnKVxuXG4gICwgbWF4ID0gTWF0aC5tYXg7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlc3QsIHNyYy8qLCDigKZzcmNuKi8pIHtcblx0dmFyIGVycm9yLCBpLCBsID0gbWF4KGFyZ3VtZW50cy5sZW5ndGgsIDIpLCBhc3NpZ247XG5cdGRlc3QgPSBPYmplY3QodmFsdWUoZGVzdCkpO1xuXHRhc3NpZ24gPSBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dHJ5IHsgZGVzdFtrZXldID0gc3JjW2tleV07IH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmICghZXJyb3IpIGVycm9yID0gZTtcblx0XHR9XG5cdH07XG5cdGZvciAoaSA9IDE7IGkgPCBsOyArK2kpIHtcblx0XHRzcmMgPSBhcmd1bWVudHNbaV07XG5cdFx0a2V5cyhzcmMpLmZvckVhY2goYXNzaWduKTtcblx0fVxuXHRpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkgdGhyb3cgZXJyb3I7XG5cdHJldHVybiBkZXN0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFGcm9tICA9IHJlcXVpcmUoJy4uL2FycmF5L2Zyb20nKVxuICAsIGFzc2lnbiA9IHJlcXVpcmUoJy4vYXNzaWduJylcbiAgLCB2YWx1ZSAgPSByZXF1aXJlKCcuL3ZhbGlkLXZhbHVlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iai8qLCBwcm9wZXJ0eU5hbWVzLCBvcHRpb25zKi8pIHtcblx0dmFyIGNvcHkgPSBPYmplY3QodmFsdWUob2JqKSksIHByb3BlcnR5TmFtZXMgPSBhcmd1bWVudHNbMV0sIG9wdGlvbnMgPSBPYmplY3QoYXJndW1lbnRzWzJdKTtcblx0aWYgKGNvcHkgIT09IG9iaiAmJiAhcHJvcGVydHlOYW1lcykgcmV0dXJuIGNvcHk7XG5cdHZhciByZXN1bHQgPSB7fTtcblx0aWYgKHByb3BlcnR5TmFtZXMpIHtcblx0XHRhRnJvbShwcm9wZXJ0eU5hbWVzLCBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5lbnN1cmUgfHwgcHJvcGVydHlOYW1lIGluIG9iaikgcmVzdWx0W3Byb3BlcnR5TmFtZV0gPSBvYmpbcHJvcGVydHlOYW1lXTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRhc3NpZ24ocmVzdWx0LCBvYmopO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gV29ya2Fyb3VuZCBmb3IgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjgwNFxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBzaGltO1xuXG5pZiAoIXJlcXVpcmUoJy4vc2V0LXByb3RvdHlwZS1vZi9pcy1pbXBsZW1lbnRlZCcpKCkpIHtcblx0c2hpbSA9IHJlcXVpcmUoJy4vc2V0LXByb3RvdHlwZS1vZi9zaGltJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIG51bGxPYmplY3QsIHByb3BzLCBkZXNjO1xuXHRpZiAoIXNoaW0pIHJldHVybiBjcmVhdGU7XG5cdGlmIChzaGltLmxldmVsICE9PSAxKSByZXR1cm4gY3JlYXRlO1xuXG5cdG51bGxPYmplY3QgPSB7fTtcblx0cHJvcHMgPSB7fTtcblx0ZGVzYyA9IHsgY29uZmlndXJhYmxlOiBmYWxzZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLFxuXHRcdHZhbHVlOiB1bmRlZmluZWQgfTtcblx0T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmIChuYW1lID09PSAnX19wcm90b19fJykge1xuXHRcdFx0cHJvcHNbbmFtZV0gPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdW5kZWZpbmVkIH07XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHByb3BzW25hbWVdID0gZGVzYztcblx0fSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG51bGxPYmplY3QsIHByb3BzKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc2hpbSwgJ251bGxQb2x5ZmlsbCcsIHsgY29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCB2YWx1ZTogbnVsbE9iamVjdCB9KTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcHMpIHtcblx0XHRyZXR1cm4gY3JlYXRlKChwcm90b3R5cGUgPT09IG51bGwpID8gbnVsbE9iamVjdCA6IHByb3RvdHlwZSwgcHJvcHMpO1xuXHR9O1xufSgpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyYXRlJykoJ2ZvckVhY2gnKTtcbiIsIi8vIERlcHJlY2F0ZWRcblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7IH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXAgPSB7ICdmdW5jdGlvbic6IHRydWUsIG9iamVjdDogdHJ1ZSB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4KSB7XG5cdHJldHVybiAoKHggIT0gbnVsbCkgJiYgbWFwW3R5cGVvZiB4XSkgfHwgZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpXG5cdD8gT2JqZWN0LmtleXNcblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmtleXMoJ3ByaW1pdGl2ZScpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXMgPSBPYmplY3Qua2V5cztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG5cdHJldHVybiBrZXlzKG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogT2JqZWN0KG9iamVjdCkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGxhYmxlID0gcmVxdWlyZSgnLi92YWxpZC1jYWxsYWJsZScpXG4gICwgZm9yRWFjaCAgPSByZXF1aXJlKCcuL2Zvci1lYWNoJylcblxuICAsIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBjYi8qLCB0aGlzQXJnKi8pIHtcblx0dmFyIG8gPSB7fSwgdGhpc0FyZyA9IGFyZ3VtZW50c1syXTtcblx0Y2FsbGFibGUoY2IpO1xuXHRmb3JFYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXksIG9iaiwgaW5kZXgpIHtcblx0XHRvW2tleV0gPSBjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIHZhbHVlLCBrZXksIG9iaiwgaW5kZXgpO1xuXHR9KTtcblx0cmV0dXJuIG87XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG52YXIgcHJvY2VzcyA9IGZ1bmN0aW9uIChzcmMsIG9iaikge1xuXHR2YXIga2V5O1xuXHRmb3IgKGtleSBpbiBzcmMpIG9ialtrZXldID0gc3JjW2tleV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLyosIOKApm9wdGlvbnMqLykge1xuXHR2YXIgcmVzdWx0ID0gY3JlYXRlKG51bGwpO1xuXHRmb3JFYWNoLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdGlmIChvcHRpb25zID09IG51bGwpIHJldHVybjtcblx0XHRwcm9jZXNzKE9iamVjdChvcHRpb25zKSwgcmVzdWx0KTtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpXG5cdD8gT2JqZWN0LnNldFByb3RvdHlwZU9mXG5cdDogcmVxdWlyZSgnLi9zaGltJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZlxuICAsIHggPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLypjdXN0b21DcmVhdGUqLykge1xuXHR2YXIgc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2Zcblx0ICAsIGN1c3RvbUNyZWF0ZSA9IGFyZ3VtZW50c1swXSB8fCBjcmVhdGU7XG5cdGlmICh0eXBlb2Ygc2V0UHJvdG90eXBlT2YgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIGdldFByb3RvdHlwZU9mKHNldFByb3RvdHlwZU9mKGN1c3RvbUNyZWF0ZShudWxsKSwgeCkpID09PSB4O1xufTtcbiIsIi8vIEJpZyB0aGFua3MgdG8gQFdlYlJlZmxlY3Rpb24gZm9yIHNvcnRpbmcgdGhpcyBvdXRcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vNTU5MzU1NFxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc09iamVjdCAgICAgID0gcmVxdWlyZSgnLi4vaXMtb2JqZWN0JylcbiAgLCB2YWx1ZSAgICAgICAgID0gcmVxdWlyZSgnLi4vdmFsaWQtdmFsdWUnKVxuXG4gICwgaXNQcm90b3R5cGVPZiA9IE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZlxuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgbnVsbERlc2MgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLFxuXHRcdHZhbHVlOiB1bmRlZmluZWQgfVxuICAsIHZhbGlkYXRlO1xuXG52YWxpZGF0ZSA9IGZ1bmN0aW9uIChvYmosIHByb3RvdHlwZSkge1xuXHR2YWx1ZShvYmopO1xuXHRpZiAoKHByb3RvdHlwZSA9PT0gbnVsbCkgfHwgaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIG9iajtcblx0dGhyb3cgbmV3IFR5cGVFcnJvcignUHJvdG90eXBlIG11c3QgYmUgbnVsbCBvciBhbiBvYmplY3QnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uIChzdGF0dXMpIHtcblx0dmFyIGZuLCBzZXQ7XG5cdGlmICghc3RhdHVzKSByZXR1cm4gbnVsbDtcblx0aWYgKHN0YXR1cy5sZXZlbCA9PT0gMikge1xuXHRcdGlmIChzdGF0dXMuc2V0KSB7XG5cdFx0XHRzZXQgPSBzdGF0dXMuc2V0O1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiAob2JqLCBwcm90b3R5cGUpIHtcblx0XHRcdFx0c2V0LmNhbGwodmFsaWRhdGUob2JqLCBwcm90b3R5cGUpLCBwcm90b3R5cGUpO1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiAob2JqLCBwcm90b3R5cGUpIHtcblx0XHRcdFx0dmFsaWRhdGUob2JqLCBwcm90b3R5cGUpLl9fcHJvdG9fXyA9IHByb3RvdHlwZTtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZuID0gZnVuY3Rpb24gc2VsZihvYmosIHByb3RvdHlwZSkge1xuXHRcdFx0dmFyIGlzTnVsbEJhc2U7XG5cdFx0XHR2YWxpZGF0ZShvYmosIHByb3RvdHlwZSk7XG5cdFx0XHRpc051bGxCYXNlID0gaXNQcm90b3R5cGVPZi5jYWxsKHNlbGYubnVsbFBvbHlmaWxsLCBvYmopO1xuXHRcdFx0aWYgKGlzTnVsbEJhc2UpIGRlbGV0ZSBzZWxmLm51bGxQb2x5ZmlsbC5fX3Byb3RvX187XG5cdFx0XHRpZiAocHJvdG90eXBlID09PSBudWxsKSBwcm90b3R5cGUgPSBzZWxmLm51bGxQb2x5ZmlsbDtcblx0XHRcdG9iai5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG5cdFx0XHRpZiAoaXNOdWxsQmFzZSkgZGVmaW5lUHJvcGVydHkoc2VsZi5udWxsUG9seWZpbGwsICdfX3Byb3RvX18nLCBudWxsRGVzYyk7XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ2xldmVsJywgeyBjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiBzdGF0dXMubGV2ZWwgfSk7XG59KChmdW5jdGlvbiAoKSB7XG5cdHZhciB4ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgeSA9IHt9LCBzZXRcblx0ICAsIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKTtcblxuXHRpZiAoZGVzYykge1xuXHRcdHRyeSB7XG5cdFx0XHRzZXQgPSBkZXNjLnNldDsgLy8gT3BlcmEgY3Jhc2hlcyBhdCB0aGlzIHBvaW50XG5cdFx0XHRzZXQuY2FsbCh4LCB5KTtcblx0XHR9IGNhdGNoIChpZ25vcmUpIHsgfVxuXHRcdGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkgPT09IHkpIHJldHVybiB7IHNldDogc2V0LCBsZXZlbDogMiB9O1xuXHR9XG5cblx0eC5fX3Byb3RvX18gPSB5O1xuXHRpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpID09PSB5KSByZXR1cm4geyBsZXZlbDogMiB9O1xuXG5cdHggPSB7fTtcblx0eC5fX3Byb3RvX18gPSB5O1xuXHRpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpID09PSB5KSByZXR1cm4geyBsZXZlbDogMSB9O1xuXG5cdHJldHVybiBmYWxzZTtcbn0oKSkpKTtcblxucmVxdWlyZSgnLi4vY3JlYXRlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcblx0cmV0dXJuIGZuO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pcy1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCFpc09iamVjdCh2YWx1ZSkpIHRocm93IG5ldyBUeXBlRXJyb3IodmFsdWUgKyBcIiBpcyBub3QgYW4gT2JqZWN0XCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAodmFsdWUgPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgbnVsbCBvciB1bmRlZmluZWRcIik7XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKClcblx0PyBTdHJpbmcucHJvdG90eXBlLmNvbnRhaW5zXG5cdDogcmVxdWlyZSgnLi9zaGltJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHIgPSAncmF6ZHdhdHJ6eSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIHN0ci5jb250YWlucyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gKChzdHIuY29udGFpbnMoJ2R3YScpID09PSB0cnVlKSAmJiAoc3RyLmNvbnRhaW5zKCdmb28nKSA9PT0gZmFsc2UpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmRleE9mID0gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcvKiwgcG9zaXRpb24qLykge1xuXHRyZXR1cm4gaW5kZXhPZi5jYWxsKHRoaXMsIHNlYXJjaFN0cmluZywgYXJndW1lbnRzWzFdKSA+IC0xO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG4gICwgaWQgPSB0b1N0cmluZy5jYWxsKCcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeCkge1xuXHRyZXR1cm4gKHR5cGVvZiB4ID09PSAnc3RyaW5nJykgfHwgKHggJiYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JykgJiZcblx0XHQoKHggaW5zdGFuY2VvZiBTdHJpbmcpIHx8ICh0b1N0cmluZy5jYWxsKHgpID09PSBpZCkpKSB8fCBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZW5lcmF0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgLCByYW5kb20gPSBNYXRoLnJhbmRvbTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzdHI7XG5cdGRvIHsgc3RyID0gcmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpOyB9IHdoaWxlIChnZW5lcmF0ZWRbc3RyXSk7XG5cdHJldHVybiBzdHI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mJylcbiAgLCBjb250YWlucyAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMnKVxuICAsIGQgICAgICAgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgSXRlcmF0b3IgICAgICAgPSByZXF1aXJlKCcuLycpXG5cbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIEFycmF5SXRlcmF0b3I7XG5cbkFycmF5SXRlcmF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcnIsIGtpbmQpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEFycmF5SXRlcmF0b3IpKSByZXR1cm4gbmV3IEFycmF5SXRlcmF0b3IoYXJyLCBraW5kKTtcblx0SXRlcmF0b3IuY2FsbCh0aGlzLCBhcnIpO1xuXHRpZiAoIWtpbmQpIGtpbmQgPSAndmFsdWUnO1xuXHRlbHNlIGlmIChjb250YWlucy5jYWxsKGtpbmQsICdrZXkrdmFsdWUnKSkga2luZCA9ICdrZXkrdmFsdWUnO1xuXHRlbHNlIGlmIChjb250YWlucy5jYWxsKGtpbmQsICdrZXknKSkga2luZCA9ICdrZXknO1xuXHRlbHNlIGtpbmQgPSAndmFsdWUnO1xuXHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19raW5kX18nLCBkKCcnLCBraW5kKSk7XG59O1xuaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihBcnJheUl0ZXJhdG9yLCBJdGVyYXRvcik7XG5cbkFycmF5SXRlcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvci5wcm90b3R5cGUsIHtcblx0Y29uc3RydWN0b3I6IGQoQXJyYXlJdGVyYXRvciksXG5cdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09ICd2YWx1ZScpIHJldHVybiB0aGlzLl9fbGlzdF9fW2ldO1xuXHRcdGlmICh0aGlzLl9fa2luZF9fID09PSAna2V5K3ZhbHVlJykgcmV0dXJuIFtpLCB0aGlzLl9fbGlzdF9fW2ldXTtcblx0XHRyZXR1cm4gaTtcblx0fSksXG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbb2JqZWN0IEFycmF5IEl0ZXJhdG9yXSc7IH0pXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHMnKVxuICAsIGNhbGxhYmxlICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUnKVxuICAsIGlzU3RyaW5nICAgID0gcmVxdWlyZSgnZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nJylcbiAgLCBnZXQgICAgICAgICA9IHJlcXVpcmUoJy4vZ2V0JylcblxuICAsIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5LCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBjYi8qLCB0aGlzQXJnKi8pIHtcblx0dmFyIG1vZGUsIHRoaXNBcmcgPSBhcmd1bWVudHNbMl0sIHJlc3VsdCwgZG9CcmVhaywgYnJva2VuLCBpLCBsLCBjaGFyLCBjb2RlO1xuXHRpZiAoaXNBcnJheShpdGVyYWJsZSkgfHwgaXNBcmd1bWVudHMoaXRlcmFibGUpKSBtb2RlID0gJ2FycmF5Jztcblx0ZWxzZSBpZiAoaXNTdHJpbmcoaXRlcmFibGUpKSBtb2RlID0gJ3N0cmluZyc7XG5cdGVsc2UgaXRlcmFibGUgPSBnZXQoaXRlcmFibGUpO1xuXG5cdGNhbGxhYmxlKGNiKTtcblx0ZG9CcmVhayA9IGZ1bmN0aW9uICgpIHsgYnJva2VuID0gdHJ1ZTsgfTtcblx0aWYgKG1vZGUgPT09ICdhcnJheScpIHtcblx0XHRzb21lLmNhbGwoaXRlcmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0Y2FsbC5jYWxsKGNiLCB0aGlzQXJnLCB2YWx1ZSwgZG9CcmVhayk7XG5cdFx0XHRpZiAoYnJva2VuKSByZXR1cm4gdHJ1ZTtcblx0XHR9KTtcblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKG1vZGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0bCA9IGl0ZXJhYmxlLmxlbmd0aDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRjaGFyID0gaXRlcmFibGVbaV07XG5cdFx0XHRpZiAoKGkgKyAxKSA8IGwpIHtcblx0XHRcdFx0Y29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcblx0XHRcdFx0aWYgKChjb2RlID49IDB4RDgwMCkgJiYgKGNvZGUgPD0gMHhEQkZGKSkgY2hhciArPSBpdGVyYWJsZVsrK2ldO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbC5jYWxsKGNiLCB0aGlzQXJnLCBjaGFyLCBkb0JyZWFrKTtcblx0XHRcdGlmIChicm9rZW4pIGJyZWFrO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblx0cmVzdWx0ID0gaXRlcmFibGUubmV4dCgpO1xuXG5cdHdoaWxlICghcmVzdWx0LmRvbmUpIHtcblx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgZG9CcmVhayk7XG5cdFx0aWYgKGJyb2tlbikgcmV0dXJuO1xuXHRcdHJlc3VsdCA9IGl0ZXJhYmxlLm5leHQoKTtcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzICAgID0gcmVxdWlyZSgnZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHMnKVxuICAsIGlzU3RyaW5nICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nJylcbiAgLCBBcnJheUl0ZXJhdG9yICA9IHJlcXVpcmUoJy4vYXJyYXknKVxuICAsIFN0cmluZ0l0ZXJhdG9yID0gcmVxdWlyZSgnLi9zdHJpbmcnKVxuICAsIGl0ZXJhYmxlICAgICAgID0gcmVxdWlyZSgnLi92YWxpZC1pdGVyYWJsZScpXG4gICwgaXRlcmF0b3JTeW1ib2wgPSByZXF1aXJlKCdlczYtc3ltYm9sJykuaXRlcmF0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuXHRpZiAodHlwZW9mIGl0ZXJhYmxlKG9iailbaXRlcmF0b3JTeW1ib2xdID09PSAnZnVuY3Rpb24nKSByZXR1cm4gb2JqW2l0ZXJhdG9yU3ltYm9sXSgpO1xuXHRpZiAoaXNBcmd1bWVudHMob2JqKSkgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKG9iaik7XG5cdGlmIChpc1N0cmluZyhvYmopKSByZXR1cm4gbmV3IFN0cmluZ0l0ZXJhdG9yKG9iaik7XG5cdHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcihvYmopO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsZWFyICAgID0gcmVxdWlyZSgnZXM1LWV4dC9hcnJheS8jL2NsZWFyJylcbiAgLCBhc3NpZ24gICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L2Fzc2lnbicpXG4gICwgY2FsbGFibGUgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG4gICwgdmFsdWUgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC12YWx1ZScpXG4gICwgZCAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBhdXRvQmluZCA9IHJlcXVpcmUoJ2QvYXV0by1iaW5kJylcbiAgLCBTeW1ib2wgICA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKVxuXG4gICwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCBJdGVyYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBJdGVyYXRvciA9IGZ1bmN0aW9uIChsaXN0LCBjb250ZXh0KSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBJdGVyYXRvcikpIHJldHVybiBuZXcgSXRlcmF0b3IobGlzdCwgY29udGV4dCk7XG5cdGRlZmluZVByb3BlcnRpZXModGhpcywge1xuXHRcdF9fbGlzdF9fOiBkKCd3JywgdmFsdWUobGlzdCkpLFxuXHRcdF9fY29udGV4dF9fOiBkKCd3JywgY29udGV4dCksXG5cdFx0X19uZXh0SW5kZXhfXzogZCgndycsIDApXG5cdH0pO1xuXHRpZiAoIWNvbnRleHQpIHJldHVybjtcblx0Y2FsbGFibGUoY29udGV4dC5vbik7XG5cdGNvbnRleHQub24oJ19hZGQnLCB0aGlzLl9vbkFkZCk7XG5cdGNvbnRleHQub24oJ19kZWxldGUnLCB0aGlzLl9vbkRlbGV0ZSk7XG5cdGNvbnRleHQub24oJ19jbGVhcicsIHRoaXMuX29uQ2xlYXIpO1xufTtcblxuZGVmaW5lUHJvcGVydGllcyhJdGVyYXRvci5wcm90b3R5cGUsIGFzc2lnbih7XG5cdGNvbnN0cnVjdG9yOiBkKEl0ZXJhdG9yKSxcblx0X25leHQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpO1xuXHRcdGlmICghdGhpcy5fX2xpc3RfXykgcmV0dXJuO1xuXHRcdGlmICh0aGlzLl9fcmVkb19fKSB7XG5cdFx0XHRpID0gdGhpcy5fX3JlZG9fXy5zaGlmdCgpO1xuXHRcdFx0aWYgKGkgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9fbmV4dEluZGV4X18gPCB0aGlzLl9fbGlzdF9fLmxlbmd0aCkgcmV0dXJuIHRoaXMuX19uZXh0SW5kZXhfXysrO1xuXHRcdHRoaXMuX3VuQmluZCgpO1xuXHR9KSxcblx0bmV4dDogZChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jcmVhdGVSZXN1bHQodGhpcy5fbmV4dCgpKTsgfSksXG5cdF9jcmVhdGVSZXN1bHQ6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHRpZiAoaSA9PT0gdW5kZWZpbmVkKSByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG5cdFx0cmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB0aGlzLl9yZXNvbHZlKGkpIH07XG5cdH0pLFxuXHRfcmVzb2x2ZTogZChmdW5jdGlvbiAoaSkgeyByZXR1cm4gdGhpcy5fX2xpc3RfX1tpXTsgfSksXG5cdF91bkJpbmQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX19saXN0X18gPSBudWxsO1xuXHRcdGRlbGV0ZSB0aGlzLl9fcmVkb19fO1xuXHRcdGlmICghdGhpcy5fX2NvbnRleHRfXykgcmV0dXJuO1xuXHRcdHRoaXMuX19jb250ZXh0X18ub2ZmKCdfYWRkJywgdGhpcy5fb25BZGQpO1xuXHRcdHRoaXMuX19jb250ZXh0X18ub2ZmKCdfZGVsZXRlJywgdGhpcy5fb25EZWxldGUpO1xuXHRcdHRoaXMuX19jb250ZXh0X18ub2ZmKCdfY2xlYXInLCB0aGlzLl9vbkNsZWFyKTtcblx0XHR0aGlzLl9fY29udGV4dF9fID0gbnVsbDtcblx0fSksXG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbb2JqZWN0IEl0ZXJhdG9yXSc7IH0pXG59LCBhdXRvQmluZCh7XG5cdF9vbkFkZDogZChmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHRpZiAoaW5kZXggPj0gdGhpcy5fX25leHRJbmRleF9fKSByZXR1cm47XG5cdFx0Kyt0aGlzLl9fbmV4dEluZGV4X187XG5cdFx0aWYgKCF0aGlzLl9fcmVkb19fKSB7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19yZWRvX18nLCBkKCdjJywgW2luZGV4XSkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9fcmVkb19fLmZvckVhY2goZnVuY3Rpb24gKHJlZG8sIGkpIHtcblx0XHRcdGlmIChyZWRvID49IGluZGV4KSB0aGlzLl9fcmVkb19fW2ldID0gKytyZWRvO1xuXHRcdH0sIHRoaXMpO1xuXHRcdHRoaXMuX19yZWRvX18ucHVzaChpbmRleCk7XG5cdH0pLFxuXHRfb25EZWxldGU6IGQoZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0dmFyIGk7XG5cdFx0aWYgKGluZGV4ID49IHRoaXMuX19uZXh0SW5kZXhfXykgcmV0dXJuO1xuXHRcdC0tdGhpcy5fX25leHRJbmRleF9fO1xuXHRcdGlmICghdGhpcy5fX3JlZG9fXykgcmV0dXJuO1xuXHRcdGkgPSB0aGlzLl9fcmVkb19fLmluZGV4T2YoaW5kZXgpO1xuXHRcdGlmIChpICE9PSAtMSkgdGhpcy5fX3JlZG9fXy5zcGxpY2UoaSwgMSk7XG5cdFx0dGhpcy5fX3JlZG9fXy5mb3JFYWNoKGZ1bmN0aW9uIChyZWRvLCBpKSB7XG5cdFx0XHRpZiAocmVkbyA+IGluZGV4KSB0aGlzLl9fcmVkb19fW2ldID0gLS1yZWRvO1xuXHRcdH0sIHRoaXMpO1xuXHR9KSxcblx0X29uQ2xlYXI6IGQoZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9fcmVkb19fKSBjbGVhci5jYWxsKHRoaXMuX19yZWRvX18pO1xuXHRcdHRoaXMuX19uZXh0SW5kZXhfXyA9IDA7XG5cdH0pXG59KSkpO1xuXG5kZWZpbmVQcm9wZXJ0eShJdGVyYXRvci5wcm90b3R5cGUsIFN5bWJvbC5pdGVyYXRvciwgZChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzO1xufSkpO1xuZGVmaW5lUHJvcGVydHkoSXRlcmF0b3IucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIGQoJycsICdJdGVyYXRvcicpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzICAgID0gcmVxdWlyZSgnZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHMnKVxuICAsIGlzU3RyaW5nICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nJylcbiAgLCBpdGVyYXRvclN5bWJvbCA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKS5pdGVyYXRvclxuXG4gICwgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdGlmIChpc0FycmF5KHZhbHVlKSkgcmV0dXJuIHRydWU7XG5cdGlmIChpc1N0cmluZyh2YWx1ZSkpIHJldHVybiB0cnVlO1xuXHRpZiAoaXNBcmd1bWVudHModmFsdWUpKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuICh0eXBlb2YgdmFsdWVbaXRlcmF0b3JTeW1ib2xdID09PSAnZnVuY3Rpb24nKTtcbn07XG4iLCIvLyBUaGFua3MgQG1hdGhpYXNieW5lbnNcbi8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSNpdGVyYXRpbmctb3Zlci1zeW1ib2xzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZicpXG4gICwgZCAgICAgICAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBJdGVyYXRvciAgICAgICA9IHJlcXVpcmUoJy4vJylcblxuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgU3RyaW5nSXRlcmF0b3I7XG5cblN0cmluZ0l0ZXJhdG9yID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHJpbmdJdGVyYXRvcikpIHJldHVybiBuZXcgU3RyaW5nSXRlcmF0b3Ioc3RyKTtcblx0c3RyID0gU3RyaW5nKHN0cik7XG5cdEl0ZXJhdG9yLmNhbGwodGhpcywgc3RyKTtcblx0ZGVmaW5lUHJvcGVydHkodGhpcywgJ19fbGVuZ3RoX18nLCBkKCcnLCBzdHIubGVuZ3RoKSk7XG5cbn07XG5pZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKFN0cmluZ0l0ZXJhdG9yLCBJdGVyYXRvcik7XG5cblN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3IucHJvdG90eXBlLCB7XG5cdGNvbnN0cnVjdG9yOiBkKFN0cmluZ0l0ZXJhdG9yKSxcblx0X25leHQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fX2xpc3RfXykgcmV0dXJuO1xuXHRcdGlmICh0aGlzLl9fbmV4dEluZGV4X18gPCB0aGlzLl9fbGVuZ3RoX18pIHJldHVybiB0aGlzLl9fbmV4dEluZGV4X18rKztcblx0XHR0aGlzLl91bkJpbmQoKTtcblx0fSksXG5cdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0dmFyIGNoYXIgPSB0aGlzLl9fbGlzdF9fW2ldLCBjb2RlO1xuXHRcdGlmICh0aGlzLl9fbmV4dEluZGV4X18gPT09IHRoaXMuX19sZW5ndGhfXykgcmV0dXJuIGNoYXI7XG5cdFx0Y29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcblx0XHRpZiAoKGNvZGUgPj0gMHhEODAwKSAmJiAoY29kZSA8PSAweERCRkYpKSByZXR1cm4gY2hhciArIHRoaXMuX19saXN0X19bdGhpcy5fX25leHRJbmRleF9fKytdO1xuXHRcdHJldHVybiBjaGFyO1xuXHR9KSxcblx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1tvYmplY3QgU3RyaW5nIEl0ZXJhdG9yXSc7IH0pXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSXRlcmFibGUgPSByZXF1aXJlKCcuL2lzLWl0ZXJhYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNJdGVyYWJsZSh2YWx1ZSkpIHRocm93IG5ldyBUeXBlRXJyb3IodmFsdWUgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vamFrZWFyY2hpYmFsZC9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuICogQHZlcnNpb24gICAzLjAuMlxuICovXG5cbihmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkdXRpbHMkJG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzTWF5YmVUaGVuYWJsZSh4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkX2lzQXJyYXk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzQXJyYXkgPSBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5O1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID0gMDtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR2ZXJ0eE5leHQ7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbjtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2xpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW5dID0gY2FsbGJhY2s7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiArIDFdID0gYXJnO1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiArPSAyO1xuICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gPT09IDIpIHtcbiAgICAgICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgICAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgICAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4obGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRBc2FwKGFzYXBGbikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAgPSBhc2FwRm47XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93ID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyB8fCB7fTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcblxuICAgIC8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc1dvcmtlciA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuICAgIC8vIG5vZGVcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTmV4dFRpY2soKSB7XG4gICAgICAvLyBub2RlIHZlcnNpb24gMC4xMC54IGRpc3BsYXlzIGEgZGVwcmVjYXRpb24gd2FybmluZyB3aGVuIG5leHRUaWNrIGlzIHVzZWQgcmVjdXJzaXZlbHlcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHZlcnR4XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVZlcnR4VGltZXIoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR2ZXJ0eE5leHQobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgbGliJGVzNiRwcm9taXNlJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIG5vZGUuZGF0YSA9IChpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHdlYiB3b3JrZXJcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2g7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlU2V0VGltZW91dCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gsIDEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbjsgaSs9Mikge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaV07XG4gICAgICAgIHZhciBhcmcgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaSsxXTtcblxuICAgICAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2krMV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhdHRlbXB0VmVydHgoKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgciA9IHJlcXVpcmU7XG4gICAgICAgIHZhciB2ZXJ0eCA9IHIoJ3ZlcnR4Jyk7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVZlcnR4VGltZXIoKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVNldFRpbWVvdXQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2g7XG4gICAgLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbiAgICBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGlzTm9kZSkge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTmV4dFRpY2soKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTXV0YXRpb25PYnNlcnZlcigpO1xuICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGlzV29ya2VyKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJXaW5kb3cgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXR0ZW1wdFZlcnR4KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVNldFRpbWVvdXQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKCkge31cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICAgPSB2b2lkIDA7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCA9IDE7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEICA9IDI7XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IgPSBuZXcgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKTtcblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRjYW5ub3RSZXR1cm5Pd24oKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGdldFRoZW4ocHJvbWlzZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbikge1xuICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3IgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlUaGVuKHRoZW4sIHRoZW5hYmxlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmIChzZWFsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICBpZiAoc2VhbGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgICAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUpIHtcbiAgICAgIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKSB7XG4gICAgICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0aGVuID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZ2V0VGhlbihtYXliZVRoZW5hYmxlKTtcblxuICAgICAgICBpZiAodGhlbiA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IuZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKHRoZW4pKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJHV0aWxzJCRvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICAgICAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICAgICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoKHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykgeyByZXR1cm47IH1cblxuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRDtcblxuICAgICAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoLCBwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHsgcmV0dXJuOyB9XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEO1xuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgIHZhciBzdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgbGVuZ3RoID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gICAgICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aCArIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEXSAgPSBvblJlamVjdGlvbjtcblxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCAmJiBwYXJlbnQuX3N0YXRlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gsIHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaChwcm9taXNlKSB7XG4gICAgICB2YXIgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycztcbiAgICAgIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgICAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCkge1xuICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUiA9IG5ldyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpO1xuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gICAgICB2YXIgaGFzQ2FsbGJhY2sgPSBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgICAgIHZhbHVlLCBlcnJvciwgc3VjY2VlZGVkLCBmYWlsZWQ7XG5cbiAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICB2YWx1ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICBlcnJvciA9IHZhbHVlLmVycm9yO1xuICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAvLyBub29wXG4gICAgICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZmFpbGVkKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpe1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICAgIGVudW1lcmF0b3IuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICAgIGVudW1lcmF0b3IucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcblxuICAgICAgaWYgKGVudW1lcmF0b3IuX3ZhbGlkYXRlSW5wdXQoaW5wdXQpKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX2lucHV0ICAgICA9IGlucHV0O1xuICAgICAgICBlbnVtZXJhdG9yLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIGVudW1lcmF0b3IuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgICBlbnVtZXJhdG9yLl9pbml0KCk7XG5cbiAgICAgICAgaWYgKGVudW1lcmF0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChlbnVtZXJhdG9yLnByb21pc2UsIGVudW1lcmF0b3IuX3Jlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW51bWVyYXRvci5sZW5ndGggPSBlbnVtZXJhdG9yLmxlbmd0aCB8fCAwO1xuICAgICAgICAgIGVudW1lcmF0b3IuX2VudW1lcmF0ZSgpO1xuICAgICAgICAgIGlmIChlbnVtZXJhdG9yLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwoZW51bWVyYXRvci5wcm9taXNlLCBlbnVtZXJhdG9yLl9yZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KGVudW1lcmF0b3IucHJvbWlzZSwgZW51bWVyYXRvci5fdmFsaWRhdGlvbkVycm9yKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVJbnB1dCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5KGlucHV0KTtcbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0aW9uRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgfTtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yO1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9lbnVtZXJhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICAgICAgdmFyIGxlbmd0aCAgPSBlbnVtZXJhdG9yLmxlbmd0aDtcbiAgICAgIHZhciBwcm9taXNlID0gZW51bWVyYXRvci5wcm9taXNlO1xuICAgICAgdmFyIGlucHV0ICAgPSBlbnVtZXJhdG9yLl9pbnB1dDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHByb21pc2UuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBlbnVtZXJhdG9yLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uKGVudHJ5LCBpKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG4gICAgICB2YXIgYyA9IGVudW1lcmF0b3IuX2luc3RhbmNlQ29uc3RydWN0b3I7XG5cbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzTWF5YmVUaGVuYWJsZShlbnRyeSkpIHtcbiAgICAgICAgaWYgKGVudHJ5LmNvbnN0cnVjdG9yID09PSBjICYmIGVudHJ5Ll9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAgIGVudHJ5Ll9vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnVtZXJhdG9yLl93aWxsU2V0dGxlQXQoYy5yZXNvbHZlKGVudHJ5KSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3JlbWFpbmluZy0tO1xuICAgICAgICBlbnVtZXJhdG9yLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbihzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcbiAgICAgIHZhciBwcm9taXNlID0gZW51bWVyYXRvci5wcm9taXNlO1xuXG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgZW51bWVyYXRvci5fcmVtYWluaW5nLS07XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW51bWVyYXRvci5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVudW1lcmF0b3IuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIGVudW1lcmF0b3IuX3Jlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24ocHJvbWlzZSwgaSkge1xuICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgZW51bWVyYXRvci5fc2V0dGxlZEF0KGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVELCBpLCByZWFzb24pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGFsbChlbnRyaWVzKSB7XG4gICAgICByZXR1cm4gbmV3IGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRkZWZhdWx0KHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGFsbDtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRyYWNlKGVudHJpZXMpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcblxuICAgICAgaWYgKCFsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzQXJyYXkoZW50cmllcykpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIGZ1bmN0aW9uIG9uRnVsZmlsbG1lbnQodmFsdWUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmVqZWN0aW9uKHJlYXNvbikge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHByb21pc2UuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUoQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKSwgdW5kZWZpbmVkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJhY2UkJHJhY2U7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkcmVzb2x2ZShvYmplY3QpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgICBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRyZXNvbHZlO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkcmVqZWN0KHJlYXNvbikge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJHJlamVjdDtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkY291bnRlciA9IDA7XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNSZXNvbHZlcigpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNOZXcoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlO1xuICAgIC8qKlxuICAgICAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICAgICAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgICAgIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICAgICAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgICAgIFRlcm1pbm9sb2d5XG4gICAgICAtLS0tLS0tLS0tLVxuXG4gICAgICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAgICAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAgICAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAgICAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gICAgICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gICAgICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICAgICAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gICAgICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICAgICAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICAgICAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgICAgIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICAgICAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICAgICAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gICAgICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gICAgICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gICAgICBCYXNpYyBVc2FnZTpcbiAgICAgIC0tLS0tLS0tLS0tLVxuXG4gICAgICBgYGBqc1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gb24gc3VjY2Vzc1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgICAgICAvLyBvbiBmYWlsdXJlXG4gICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgfSk7XG5cbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBvbiBmdWxmaWxsbWVudFxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIC8vIG9uIHJlamVjdGlvblxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQWR2YW5jZWQgVXNhZ2U6XG4gICAgICAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICAgICAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgLy8gb24gcmVqZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gICAgICBgYGBqc1xuICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICAgICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgICAgIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICAgICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgICAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBjbGFzcyBQcm9taXNlXG4gICAgICBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlclxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZShyZXNvbHZlcikge1xuICAgICAgdGhpcy5faWQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkY291bnRlcisrO1xuICAgICAgdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXG4gICAgICBpZiAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICAgICAgaWYgKCFsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24ocmVzb2x2ZXIpKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZSkpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNOZXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5hbGwgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGRlZmF1bHQ7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucmFjZSA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJhY2UkJGRlZmF1bHQ7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucmVzb2x2ZSA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJGRlZmF1bHQ7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucmVqZWN0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLl9zZXRTY2hlZHVsZXIgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0U2NoZWR1bGVyO1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLl9zZXRBc2FwID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldEFzYXA7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuX2FzYXAgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcDtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnByb3RvdHlwZSA9IHtcbiAgICAgIGNvbnN0cnVjdG9yOiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZSxcblxuICAgIC8qKlxuICAgICAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gICAgICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICAgICAgcmVhc29uIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgICAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIENoYWluaW5nXG4gICAgICAtLS0tLS0tLVxuXG4gICAgICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICAgICAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICAgICAgb3IgcmVqZWN0aW9uIGhhbmRsZXIsIG9yIHJlamVjdGVkIGlmIHRoZSBoYW5kbGVyIHRocm93cyBhbiBleGNlcHRpb24uXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuICdkZWZhdWx0IG5hbWUnO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAgICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgICAgICAvLyB3aWxsIGJlIGAnZGVmYXVsdCBuYW1lJ2BcbiAgICAgIH0pO1xuXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAgICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gICAgICB9KTtcbiAgICAgIGBgYFxuICAgICAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBlZGFnb2dpY2FsRXhjZXB0aW9uKCdVcHN0cmVhbSBlcnJvcicpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBUaGUgYFBlZGdhZ29jaWFsRXhjZXB0aW9uYCBpcyBwcm9wYWdhdGVkIGFsbCB0aGUgd2F5IGRvd24gdG8gaGVyZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQXNzaW1pbGF0aW9uXG4gICAgICAtLS0tLS0tLS0tLS1cblxuICAgICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgICAgIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgICAgIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBoYW5kbGVyLiBUaGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgdGhlbiBiZSBwZW5kaW5nXG4gICAgICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFNpbXBsZSBFeGFtcGxlXG4gICAgICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfVxuICAgICAgYGBgXG5cbiAgICAgIEVycmJhY2sgRXhhbXBsZVxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFJlc3VsdChmdW5jdGlvbihyZXN1bHQsIGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAvLyBmYWlsdXJlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBQcm9taXNlIEV4YW1wbGU7XG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIGZpbmRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgICAgIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgdmFyIGF1dGhvciwgYm9va3M7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICAgICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfVxuICAgICAgYGBgXG5cbiAgICAgIEVycmJhY2sgRXhhbXBsZVxuXG4gICAgICBgYGBqc1xuXG4gICAgICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG5cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcblxuICAgICAgfVxuXG4gICAgICBmaW5kQXV0aG9yKGZ1bmN0aW9uKGF1dGhvciwgZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICAvLyBmYWlsdXJlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbmRCb29va3NCeUF1dGhvcihhdXRob3IsIGZ1bmN0aW9uKGJvb2tzLCBlcnIpIHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBQcm9taXNlIEV4YW1wbGU7XG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIGZpbmRBdXRob3IoKS5cbiAgICAgICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgICAgIHRoZW4oZnVuY3Rpb24oYm9va3Mpe1xuICAgICAgICAgIC8vIGZvdW5kIGJvb2tzXG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQG1ldGhvZCB0aGVuXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZFxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQHJldHVybiB7UHJvbWlzZX1cbiAgICAqL1xuICAgICAgdGhlbjogZnVuY3Rpb24ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IHBhcmVudC5fc3RhdGU7XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQgJiYgIW9uRnVsZmlsbG1lbnQgfHwgc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEICYmICFvblJlamVjdGlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJlbnQuX3Jlc3VsdDtcblxuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbc3RhdGUgLSAxXTtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChmdW5jdGlvbigpe1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfSxcblxuICAgIC8qKlxuICAgICAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICAgICAgYXMgdGhlIGNhdGNoIGJsb2NrIG9mIGEgdHJ5L2NhdGNoIHN0YXRlbWVudC5cblxuICAgICAgYGBganNcbiAgICAgIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHN5bmNocm9ub3VzXG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQXV0aG9yKCk7XG4gICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfVxuXG4gICAgICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gICAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgY2F0Y2hcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0aW9uXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICovXG4gICAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkcG9seWZpbGwoKSB7XG4gICAgICB2YXIgbG9jYWw7XG5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGxvY2FsID0gZ2xvYmFsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgICAgIGlmIChQICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSkgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbG9jYWwuUHJvbWlzZSA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0O1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRwb2x5ZmlsbDtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlID0ge1xuICAgICAgJ1Byb21pc2UnOiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdCxcbiAgICAgICdwb2x5ZmlsbCc6IGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdFxuICAgIH07XG5cbiAgICAvKiBnbG9iYWwgZGVmaW5lOnRydWUgbW9kdWxlOnRydWUgd2luZG93OiB0cnVlICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTsgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGVbJ2V4cG9ydHMnXSkge1xuICAgICAgbW9kdWxlWydleHBvcnRzJ10gPSBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzWydFUzZQcm9taXNlJ10gPSBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlO1xuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdCgpO1xufSkuY2FsbCh0aGlzKTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpKSB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCdlczUtZXh0L2dsb2JhbCcpLCAnU2V0Jyxcblx0XHR7IHZhbHVlOiByZXF1aXJlKCcuL3BvbHlmaWxsJyksIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHR3cml0YWJsZTogdHJ1ZSB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZXQsIGl0ZXJhdG9yLCByZXN1bHQ7XG5cdGlmICh0eXBlb2YgU2V0ICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHNldCA9IG5ldyBTZXQoWydyYXonLCAnZHdhJywgJ3RyenknXSk7XG5cdGlmIChTdHJpbmcoc2V0KSAhPT0gJ1tvYmplY3QgU2V0XScpIHJldHVybiBmYWxzZTtcblx0aWYgKHNldC5zaXplICE9PSAzKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2Ygc2V0LmFkZCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIHNldC5jbGVhciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIHNldC5kZWxldGUgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBzZXQuZW50cmllcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIHNldC5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2Ygc2V0LmhhcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIHNldC5rZXlzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2Ygc2V0LnZhbHVlcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXG5cdGl0ZXJhdG9yID0gc2V0LnZhbHVlcygpO1xuXHRyZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG5cdGlmIChyZXN1bHQuZG9uZSAhPT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblx0aWYgKHJlc3VsdC52YWx1ZSAhPT0gJ3JheicpIHJldHVybiBmYWxzZTtcblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBFeHBvcnRzIHRydWUgaWYgZW52aXJvbm1lbnQgcHJvdmlkZXMgbmF0aXZlIGBTZXRgIGltcGxlbWVudGF0aW9uLFxuLy8gd2hhdGV2ZXIgdGhhdCBpcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChTZXQucHJvdG90eXBlKSA9PT0gJ1tvYmplY3QgU2V0XScpO1xufSgpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNldFByb3RvdHlwZU9mICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZicpXG4gICwgY29udGFpbnMgICAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zJylcbiAgLCBkICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIEl0ZXJhdG9yICAgICAgICAgID0gcmVxdWlyZSgnZXM2LWl0ZXJhdG9yJylcbiAgLCB0b1N0cmluZ1RhZ1N5bWJvbCA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKS50b1N0cmluZ1RhZ1xuXG4gICwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBTZXRJdGVyYXRvcjtcblxuU2V0SXRlcmF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXQsIGtpbmQpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFNldEl0ZXJhdG9yKSkgcmV0dXJuIG5ldyBTZXRJdGVyYXRvcihzZXQsIGtpbmQpO1xuXHRJdGVyYXRvci5jYWxsKHRoaXMsIHNldC5fX3NldERhdGFfXywgc2V0KTtcblx0aWYgKCFraW5kKSBraW5kID0gJ3ZhbHVlJztcblx0ZWxzZSBpZiAoY29udGFpbnMuY2FsbChraW5kLCAna2V5K3ZhbHVlJykpIGtpbmQgPSAna2V5K3ZhbHVlJztcblx0ZWxzZSBraW5kID0gJ3ZhbHVlJztcblx0ZGVmaW5lUHJvcGVydHkodGhpcywgJ19fa2luZF9fJywgZCgnJywga2luZCkpO1xufTtcbmlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoU2V0SXRlcmF0b3IsIEl0ZXJhdG9yKTtcblxuU2V0SXRlcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvci5wcm90b3R5cGUsIHtcblx0Y29uc3RydWN0b3I6IGQoU2V0SXRlcmF0b3IpLFxuXHRfcmVzb2x2ZTogZChmdW5jdGlvbiAoaSkge1xuXHRcdGlmICh0aGlzLl9fa2luZF9fID09PSAndmFsdWUnKSByZXR1cm4gdGhpcy5fX2xpc3RfX1tpXTtcblx0XHRyZXR1cm4gW3RoaXMuX19saXN0X19baV0sIHRoaXMuX19saXN0X19baV1dO1xuXHR9KSxcblx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc7IH0pXG59KTtcbmRlZmluZVByb3BlcnR5KFNldEl0ZXJhdG9yLnByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIGQoJ2MnLCAnU2V0IEl0ZXJhdG9yJykpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xlYXIgICAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L2FycmF5LyMvY2xlYXInKVxuICAsIGVJbmRleE9mICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9hcnJheS8jL2UtaW5kZXgtb2YnKVxuICAsIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZicpXG4gICwgY2FsbGFibGUgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG4gICwgZCAgICAgICAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBlZSAgICAgICAgICAgICA9IHJlcXVpcmUoJ2V2ZW50LWVtaXR0ZXInKVxuICAsIFN5bWJvbCAgICAgICAgID0gcmVxdWlyZSgnZXM2LXN5bWJvbCcpXG4gICwgaXRlcmF0b3IgICAgICAgPSByZXF1aXJlKCdlczYtaXRlcmF0b3IvdmFsaWQtaXRlcmFibGUnKVxuICAsIGZvck9mICAgICAgICAgID0gcmVxdWlyZSgnZXM2LWl0ZXJhdG9yL2Zvci1vZicpXG4gICwgSXRlcmF0b3IgICAgICAgPSByZXF1aXJlKCcuL2xpYi9pdGVyYXRvcicpXG4gICwgaXNOYXRpdmUgICAgICAgPSByZXF1aXJlKCcuL2lzLW5hdGl2ZS1pbXBsZW1lbnRlZCcpXG5cbiAgLCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAgLCBTZXRQb2x5LCBnZXRWYWx1ZXMsIE5hdGl2ZVNldDtcblxuaWYgKGlzTmF0aXZlKSBOYXRpdmVTZXQgPSBTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0UG9seSA9IGZ1bmN0aW9uIFNldCgvKml0ZXJhYmxlKi8pIHtcblx0dmFyIGl0ZXJhYmxlID0gYXJndW1lbnRzWzBdLCBzZWxmO1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgU2V0UG9seSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnN0cnVjdG9yIHJlcXVpcmVzIFxcJ25ld1xcJycpO1xuXHRpZiAoaXNOYXRpdmUgJiYgc2V0UHJvdG90eXBlT2YpIHNlbGYgPSBzZXRQcm90b3R5cGVPZihuZXcgTmF0aXZlU2V0KCksIGdldFByb3RvdHlwZU9mKHRoaXMpKTtcblx0ZWxzZSBzZWxmID0gdGhpcztcblx0aWYgKGl0ZXJhYmxlICE9IG51bGwpIGl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0ZGVmaW5lUHJvcGVydHkoc2VsZiwgJ19fc2V0RGF0YV9fJywgZCgnYycsIFtdKSk7XG5cdGlmICghaXRlcmFibGUpIHJldHVybiBzZWxmO1xuXHRmb3JPZihpdGVyYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKGVJbmRleE9mLmNhbGwodGhpcywgdmFsdWUpICE9PSAtMSkgcmV0dXJuO1xuXHRcdHRoaXMucHVzaCh2YWx1ZSk7XG5cdH0sIHNlbGYuX19zZXREYXRhX18pO1xuXHRyZXR1cm4gc2VsZjtcbn07XG5cbmlmIChpc05hdGl2ZSkge1xuXHRpZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKFNldFBvbHksIE5hdGl2ZVNldCk7XG5cdFNldFBvbHkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYXRpdmVTZXQucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiBkKFNldFBvbHkpIH0pO1xufVxuXG5lZShPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTZXRQb2x5LnByb3RvdHlwZSwge1xuXHRhZGQ6IGQoZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuaGFzKHZhbHVlKSkgcmV0dXJuIHRoaXM7XG5cdFx0dGhpcy5lbWl0KCdfYWRkJywgdGhpcy5fX3NldERhdGFfXy5wdXNoKHZhbHVlKSAtIDEsIHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSksXG5cdGNsZWFyOiBkKGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX19zZXREYXRhX18ubGVuZ3RoKSByZXR1cm47XG5cdFx0Y2xlYXIuY2FsbCh0aGlzLl9fc2V0RGF0YV9fKTtcblx0XHR0aGlzLmVtaXQoJ19jbGVhcicpO1xuXHR9KSxcblx0ZGVsZXRlOiBkKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHZhciBpbmRleCA9IGVJbmRleE9mLmNhbGwodGhpcy5fX3NldERhdGFfXywgdmFsdWUpO1xuXHRcdGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBmYWxzZTtcblx0XHR0aGlzLl9fc2V0RGF0YV9fLnNwbGljZShpbmRleCwgMSk7XG5cdFx0dGhpcy5lbWl0KCdfZGVsZXRlJywgaW5kZXgsIHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSksXG5cdGVudHJpZXM6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yKHRoaXMsICdrZXkrdmFsdWUnKTsgfSksXG5cdGZvckVhY2g6IGQoZnVuY3Rpb24gKGNiLyosIHRoaXNBcmcqLykge1xuXHRcdHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdLCBpdGVyYXRvciwgcmVzdWx0LCB2YWx1ZTtcblx0XHRjYWxsYWJsZShjYik7XG5cdFx0aXRlcmF0b3IgPSB0aGlzLnZhbHVlcygpO1xuXHRcdHJlc3VsdCA9IGl0ZXJhdG9yLl9uZXh0KCk7XG5cdFx0d2hpbGUgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR2YWx1ZSA9IGl0ZXJhdG9yLl9yZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIHZhbHVlLCB2YWx1ZSwgdGhpcyk7XG5cdFx0XHRyZXN1bHQgPSBpdGVyYXRvci5fbmV4dCgpO1xuXHRcdH1cblx0fSksXG5cdGhhczogZChmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRyZXR1cm4gKGVJbmRleE9mLmNhbGwodGhpcy5fX3NldERhdGFfXywgdmFsdWUpICE9PSAtMSk7XG5cdH0pLFxuXHRrZXlzOiBkKGdldFZhbHVlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudmFsdWVzKCk7IH0pLFxuXHRzaXplOiBkLmdzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX19zZXREYXRhX18ubGVuZ3RoOyB9KSxcblx0dmFsdWVzOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvcih0aGlzKTsgfSksXG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbb2JqZWN0IFNldF0nOyB9KVxufSkpO1xuZGVmaW5lUHJvcGVydHkoU2V0UG9seS5wcm90b3R5cGUsIFN5bWJvbC5pdGVyYXRvciwgZChnZXRWYWx1ZXMpKTtcbmRlZmluZVByb3BlcnR5KFNldFBvbHkucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIGQoJ2MnLCAnU2V0JykpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpID8gU3ltYm9sIDogcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmFsaWRUeXBlcyA9IHsgb2JqZWN0OiB0cnVlLCBzeW1ib2w6IHRydWUgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzeW1ib2w7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHN5bWJvbCA9IFN5bWJvbCgndGVzdCBzeW1ib2wnKTtcblx0dHJ5IHsgU3RyaW5nKHN5bWJvbCk7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gUmV0dXJuICd0cnVlJyBhbHNvIGZvciBwb2x5ZmlsbHNcblx0aWYgKCF2YWxpZFR5cGVzW3R5cGVvZiBTeW1ib2wuaXRlcmF0b3JdKSByZXR1cm4gZmFsc2U7XG5cdGlmICghdmFsaWRUeXBlc1t0eXBlb2YgU3ltYm9sLnRvUHJpbWl0aXZlXSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoIXZhbGlkVHlwZXNbdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZ10pIHJldHVybiBmYWxzZTtcblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHgpIHtcblx0aWYgKCF4KSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgeCA9PT0gJ3N5bWJvbCcpIHJldHVybiB0cnVlO1xuXHRpZiAoIXguY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblx0aWYgKHguY29uc3RydWN0b3IubmFtZSAhPT0gJ1N5bWJvbCcpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuICh4W3guY29uc3RydWN0b3IudG9TdHJpbmdUYWddID09PSAnU3ltYm9sJyk7XG59O1xuIiwiLy8gRVMyMDE1IFN5bWJvbCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IChvciBwYXJ0aWFsbHkpIHN1cHBvcnQgaXRcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCAgICAgICAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCB2YWxpZGF0ZVN5bWJvbCA9IHJlcXVpcmUoJy4vdmFsaWRhdGUtc3ltYm9sJylcblxuICAsIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBvYmpQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlXG4gICwgTmF0aXZlU3ltYm9sLCBTeW1ib2xQb2x5ZmlsbCwgSGlkZGVuU3ltYm9sLCBnbG9iYWxTeW1ib2xzID0gY3JlYXRlKG51bGwpXG4gICwgaXNOYXRpdmVTYWZlO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHROYXRpdmVTeW1ib2wgPSBTeW1ib2w7XG5cdHRyeSB7XG5cdFx0U3RyaW5nKE5hdGl2ZVN5bWJvbCgpKTtcblx0XHRpc05hdGl2ZVNhZmUgPSB0cnVlO1xuXHR9IGNhdGNoIChpZ25vcmUpIHt9XG59XG5cbnZhciBnZW5lcmF0ZU5hbWUgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgY3JlYXRlZCA9IGNyZWF0ZShudWxsKTtcblx0cmV0dXJuIGZ1bmN0aW9uIChkZXNjKSB7XG5cdFx0dmFyIHBvc3RmaXggPSAwLCBuYW1lLCBpZTExQnVnV29ya2Fyb3VuZDtcblx0XHR3aGlsZSAoY3JlYXRlZFtkZXNjICsgKHBvc3RmaXggfHwgJycpXSkgKytwb3N0Zml4O1xuXHRcdGRlc2MgKz0gKHBvc3RmaXggfHwgJycpO1xuXHRcdGNyZWF0ZWRbZGVzY10gPSB0cnVlO1xuXHRcdG5hbWUgPSAnQEAnICsgZGVzYztcblx0XHRkZWZpbmVQcm9wZXJ0eShvYmpQcm90b3R5cGUsIG5hbWUsIGQuZ3MobnVsbCwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHQvLyBGb3IgSUUxMSBpc3N1ZSBzZWU6XG5cdFx0XHQvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFja2RldGFpbC92aWV3LzE5Mjg1MDgvXG5cdFx0XHQvLyAgICBpZTExLWJyb2tlbi1nZXR0ZXJzLW9uLWRvbS1vYmplY3RzXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWtvby9lczYtc3ltYm9sL2lzc3Vlcy8xMlxuXHRcdFx0aWYgKGllMTFCdWdXb3JrYXJvdW5kKSByZXR1cm47XG5cdFx0XHRpZTExQnVnV29ya2Fyb3VuZCA9IHRydWU7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCBkKHZhbHVlKSk7XG5cdFx0XHRpZTExQnVnV29ya2Fyb3VuZCA9IGZhbHNlO1xuXHRcdH0pKTtcblx0XHRyZXR1cm4gbmFtZTtcblx0fTtcbn0oKSk7XG5cbi8vIEludGVybmFsIGNvbnN0cnVjdG9yIChub3Qgb25lIGV4cG9zZWQpIGZvciBjcmVhdGluZyBTeW1ib2wgaW5zdGFuY2VzLlxuLy8gVGhpcyBvbmUgaXMgdXNlZCB0byBlbnN1cmUgdGhhdCBgc29tZVN5bWJvbCBpbnN0YW5jZW9mIFN5bWJvbGAgYWx3YXlzIHJldHVybiBmYWxzZVxuSGlkZGVuU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKGRlc2NyaXB0aW9uKSB7XG5cdGlmICh0aGlzIGluc3RhbmNlb2YgSGlkZGVuU3ltYm9sKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcblx0cmV0dXJuIFN5bWJvbFBvbHlmaWxsKGRlc2NyaXB0aW9uKTtcbn07XG5cbi8vIEV4cG9zZWQgYFN5bWJvbGAgY29uc3RydWN0b3Jcbi8vIChyZXR1cm5zIGluc3RhbmNlcyBvZiBIaWRkZW5TeW1ib2wpXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbFBvbHlmaWxsID0gZnVuY3Rpb24gU3ltYm9sKGRlc2NyaXB0aW9uKSB7XG5cdHZhciBzeW1ib2w7XG5cdGlmICh0aGlzIGluc3RhbmNlb2YgU3ltYm9sKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcblx0aWYgKGlzTmF0aXZlU2FmZSkgcmV0dXJuIE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbik7XG5cdHN5bWJvbCA9IGNyZWF0ZShIaWRkZW5TeW1ib2wucHJvdG90eXBlKTtcblx0ZGVzY3JpcHRpb24gPSAoZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCA/ICcnIDogU3RyaW5nKGRlc2NyaXB0aW9uKSk7XG5cdHJldHVybiBkZWZpbmVQcm9wZXJ0aWVzKHN5bWJvbCwge1xuXHRcdF9fZGVzY3JpcHRpb25fXzogZCgnJywgZGVzY3JpcHRpb24pLFxuXHRcdF9fbmFtZV9fOiBkKCcnLCBnZW5lcmF0ZU5hbWUoZGVzY3JpcHRpb24pKVxuXHR9KTtcbn07XG5kZWZpbmVQcm9wZXJ0aWVzKFN5bWJvbFBvbHlmaWxsLCB7XG5cdGZvcjogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0aWYgKGdsb2JhbFN5bWJvbHNba2V5XSkgcmV0dXJuIGdsb2JhbFN5bWJvbHNba2V5XTtcblx0XHRyZXR1cm4gKGdsb2JhbFN5bWJvbHNba2V5XSA9IFN5bWJvbFBvbHlmaWxsKFN0cmluZyhrZXkpKSk7XG5cdH0pLFxuXHRrZXlGb3I6IGQoZnVuY3Rpb24gKHMpIHtcblx0XHR2YXIga2V5O1xuXHRcdHZhbGlkYXRlU3ltYm9sKHMpO1xuXHRcdGZvciAoa2V5IGluIGdsb2JhbFN5bWJvbHMpIGlmIChnbG9iYWxTeW1ib2xzW2tleV0gPT09IHMpIHJldHVybiBrZXk7XG5cdH0pLFxuXG5cdC8vIFRvIGVuc3VyZSBwcm9wZXIgaW50ZXJvcGVyYWJpbGl0eSB3aXRoIG90aGVyIG5hdGl2ZSBmdW5jdGlvbnMgKGUuZy4gQXJyYXkuZnJvbSlcblx0Ly8gZmFsbGJhY2sgdG8gZXZlbnR1YWwgbmF0aXZlIGltcGxlbWVudGF0aW9uIG9mIGdpdmVuIHN5bWJvbFxuXHRoYXNJbnN0YW5jZTogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuaGFzSW5zdGFuY2UpIHx8IFN5bWJvbFBvbHlmaWxsKCdoYXNJbnN0YW5jZScpKSxcblx0aXNDb25jYXRTcHJlYWRhYmxlOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUpIHx8XG5cdFx0U3ltYm9sUG9seWZpbGwoJ2lzQ29uY2F0U3ByZWFkYWJsZScpKSxcblx0aXRlcmF0b3I6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLml0ZXJhdG9yKSB8fCBTeW1ib2xQb2x5ZmlsbCgnaXRlcmF0b3InKSksXG5cdG1hdGNoOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5tYXRjaCkgfHwgU3ltYm9sUG9seWZpbGwoJ21hdGNoJykpLFxuXHRyZXBsYWNlOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5yZXBsYWNlKSB8fCBTeW1ib2xQb2x5ZmlsbCgncmVwbGFjZScpKSxcblx0c2VhcmNoOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5zZWFyY2gpIHx8IFN5bWJvbFBvbHlmaWxsKCdzZWFyY2gnKSksXG5cdHNwZWNpZXM6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnNwZWNpZXMpIHx8IFN5bWJvbFBvbHlmaWxsKCdzcGVjaWVzJykpLFxuXHRzcGxpdDogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuc3BsaXQpIHx8IFN5bWJvbFBvbHlmaWxsKCdzcGxpdCcpKSxcblx0dG9QcmltaXRpdmU6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnRvUHJpbWl0aXZlKSB8fCBTeW1ib2xQb2x5ZmlsbCgndG9QcmltaXRpdmUnKSksXG5cdHRvU3RyaW5nVGFnOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC50b1N0cmluZ1RhZykgfHwgU3ltYm9sUG9seWZpbGwoJ3RvU3RyaW5nVGFnJykpLFxuXHR1bnNjb3BhYmxlczogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wudW5zY29wYWJsZXMpIHx8IFN5bWJvbFBvbHlmaWxsKCd1bnNjb3BhYmxlcycpKVxufSk7XG5cbi8vIEludGVybmFsIHR3ZWFrcyBmb3IgcmVhbCBzeW1ib2wgcHJvZHVjZXJcbmRlZmluZVByb3BlcnRpZXMoSGlkZGVuU3ltYm9sLnByb3RvdHlwZSwge1xuXHRjb25zdHJ1Y3RvcjogZChTeW1ib2xQb2x5ZmlsbCksXG5cdHRvU3RyaW5nOiBkKCcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9fbmFtZV9fOyB9KVxufSk7XG5cbi8vIFByb3BlciBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGV4cG9zZWQgb24gU3ltYm9sLnByb3RvdHlwZVxuLy8gVGhleSB3b24ndCBiZSBhY2Nlc3NpYmxlIG9uIHByb2R1Y2VkIHN5bWJvbCBpbnN0YW5jZXMgYXMgdGhleSBkZXJpdmUgZnJvbSBIaWRkZW5TeW1ib2wucHJvdG90eXBlXG5kZWZpbmVQcm9wZXJ0aWVzKFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZSwge1xuXHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7IHJldHVybiAnU3ltYm9sICgnICsgdmFsaWRhdGVTeW1ib2wodGhpcykuX19kZXNjcmlwdGlvbl9fICsgJyknOyB9KSxcblx0dmFsdWVPZjogZChmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0ZVN5bWJvbCh0aGlzKTsgfSlcbn0pO1xuZGVmaW5lUHJvcGVydHkoU3ltYm9sUG9seWZpbGwucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1ByaW1pdGl2ZSwgZCgnJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgc3ltYm9sID0gdmFsaWRhdGVTeW1ib2wodGhpcyk7XG5cdGlmICh0eXBlb2Ygc3ltYm9sID09PSAnc3ltYm9sJykgcmV0dXJuIHN5bWJvbDtcblx0cmV0dXJuIHN5bWJvbC50b1N0cmluZygpO1xufSkpO1xuZGVmaW5lUHJvcGVydHkoU3ltYm9sUG9seWZpbGwucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywgZCgnYycsICdTeW1ib2wnKSk7XG5cbi8vIFByb3BlciBpbXBsZW1lbnRhdG9uIG9mIHRvUHJpbWl0aXZlIGFuZCB0b1N0cmluZ1RhZyBmb3IgcmV0dXJuZWQgc3ltYm9sIGluc3RhbmNlc1xuZGVmaW5lUHJvcGVydHkoSGlkZGVuU3ltYm9sLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsXG5cdGQoJ2MnLCBTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGVbU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWddKSk7XG5cbi8vIE5vdGU6IEl0J3MgaW1wb3J0YW50IHRvIGRlZmluZSBgdG9QcmltaXRpdmVgIGFzIGxhc3Qgb25lLCBhcyBzb21lIGltcGxlbWVudGF0aW9uc1xuLy8gaW1wbGVtZW50IGB0b1ByaW1pdGl2ZWAgbmF0aXZlbHkgd2l0aG91dCBpbXBsZW1lbnRpbmcgYHRvU3RyaW5nVGFnYCAob3Igb3RoZXIgc3BlY2lmaWVkIHN5bWJvbHMpXG4vLyBBbmQgdGhhdCBtYXkgaW52b2tlIGVycm9yIGluIGRlZmluaXRpb24gZmxvdzpcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21lZGlrb28vZXM2LXN5bWJvbC9pc3N1ZXMvMTMjaXNzdWVjb21tZW50LTE2NDE0NjE0OVxuZGVmaW5lUHJvcGVydHkoSGlkZGVuU3ltYm9sLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9QcmltaXRpdmUsXG5cdGQoJ2MnLCBTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGVbU3ltYm9sUG9seWZpbGwudG9QcmltaXRpdmVdKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXMtc3ltYm9sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNTeW1ib2wodmFsdWUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKHZhbHVlICsgXCIgaXMgbm90IGEgc3ltYm9sXCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpKSB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCdlczUtZXh0L2dsb2JhbCcpLCAnV2Vha01hcCcsXG5cdFx0eyB2YWx1ZTogcmVxdWlyZSgnLi9wb2x5ZmlsbCcpLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0d3JpdGFibGU6IHRydWUgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgd2Vha01hcCwgeDtcblx0aWYgKHR5cGVvZiBXZWFrTWFwICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHRyeSB7XG5cdFx0Ly8gV2ViS2l0IGRvZXNuJ3Qgc3VwcG9ydCBhcmd1bWVudHMgYW5kIGNyYXNoZXNcblx0XHR3ZWFrTWFwID0gbmV3IFdlYWtNYXAoW1t4ID0ge30sICdvbmUnXSwgW3t9LCAndHdvJ10sIFt7fSwgJ3RocmVlJ11dKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAoU3RyaW5nKHdlYWtNYXApICE9PSAnW29iamVjdCBXZWFrTWFwXScpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiB3ZWFrTWFwLnNldCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAod2Vha01hcC5zZXQoe30sIDEpICE9PSB3ZWFrTWFwKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2Ygd2Vha01hcC5kZWxldGUgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiB3ZWFrTWFwLmhhcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAod2Vha01hcC5nZXQoeCkgIT09ICdvbmUnKSByZXR1cm4gZmFsc2U7XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiLy8gRXhwb3J0cyB0cnVlIGlmIGVudmlyb25tZW50IHByb3ZpZGVzIG5hdGl2ZSBgV2Vha01hcGAgaW1wbGVtZW50YXRpb24sIHdoYXRldmVyIHRoYXQgaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIFdlYWtNYXAgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IFdlYWtNYXAoKSkgPT09ICdbb2JqZWN0IFdlYWtNYXBdJyk7XG59KCkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mJylcbiAgLCBvYmplY3QgICAgICAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLW9iamVjdCcpXG4gICwgdmFsdWUgICAgICAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC12YWx1ZScpXG4gICwgcmFuZG9tVW5pcSAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L3N0cmluZy9yYW5kb20tdW5pcScpXG4gICwgZCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBnZXRJdGVyYXRvciAgICAgICA9IHJlcXVpcmUoJ2VzNi1pdGVyYXRvci9nZXQnKVxuICAsIGZvck9mICAgICAgICAgICAgID0gcmVxdWlyZSgnZXM2LWl0ZXJhdG9yL2Zvci1vZicpXG4gICwgdG9TdHJpbmdUYWdTeW1ib2wgPSByZXF1aXJlKCdlczYtc3ltYm9sJykudG9TdHJpbmdUYWdcbiAgLCBpc05hdGl2ZSAgICAgICAgICA9IHJlcXVpcmUoJy4vaXMtbmF0aXZlLWltcGxlbWVudGVkJylcblxuICAsIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5LCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAgLCBXZWFrTWFwUG9seTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwUG9seSA9IGZ1bmN0aW9uICgvKml0ZXJhYmxlKi8pIHtcblx0dmFyIGl0ZXJhYmxlID0gYXJndW1lbnRzWzBdLCBzZWxmO1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgV2Vha01hcFBvbHkpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb25zdHJ1Y3RvciByZXF1aXJlcyBcXCduZXdcXCcnKTtcblx0aWYgKGlzTmF0aXZlICYmIHNldFByb3RvdHlwZU9mICYmIChXZWFrTWFwICE9PSBXZWFrTWFwUG9seSkpIHtcblx0XHRzZWxmID0gc2V0UHJvdG90eXBlT2YobmV3IFdlYWtNYXAoKSwgZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuXHR9IGVsc2Uge1xuXHRcdHNlbGYgPSB0aGlzO1xuXHR9XG5cdGlmIChpdGVyYWJsZSAhPSBudWxsKSB7XG5cdFx0aWYgKCFpc0FycmF5KGl0ZXJhYmxlKSkgaXRlcmFibGUgPSBnZXRJdGVyYXRvcihpdGVyYWJsZSk7XG5cdH1cblx0ZGVmaW5lUHJvcGVydHkoc2VsZiwgJ19fd2Vha01hcERhdGFfXycsIGQoJ2MnLCAnJHdlYWtNYXAkJyArIHJhbmRvbVVuaXEoKSkpO1xuXHRpZiAoIWl0ZXJhYmxlKSByZXR1cm4gc2VsZjtcblx0Zm9yT2YoaXRlcmFibGUsIGZ1bmN0aW9uICh2YWwpIHtcblx0XHR2YWx1ZSh2YWwpO1xuXHRcdHNlbGYuc2V0KHZhbFswXSwgdmFsWzFdKTtcblx0fSk7XG5cdHJldHVybiBzZWxmO1xufTtcblxuaWYgKGlzTmF0aXZlKSB7XG5cdGlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoV2Vha01hcFBvbHksIFdlYWtNYXApO1xuXHRXZWFrTWFwUG9seS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdlYWtNYXAucHJvdG90eXBlLCB7XG5cdFx0Y29uc3RydWN0b3I6IGQoV2Vha01hcFBvbHkpXG5cdH0pO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXZWFrTWFwUG9seS5wcm90b3R5cGUsIHtcblx0ZGVsZXRlOiBkKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3Qoa2V5KSwgdGhpcy5fX3dlYWtNYXBEYXRhX18pKSB7XG5cdFx0XHRkZWxldGUga2V5W3RoaXMuX193ZWFrTWFwRGF0YV9fXTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0pLFxuXHRnZXQ6IGQoZnVuY3Rpb24gKGtleSkge1xuXHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdChrZXkpLCB0aGlzLl9fd2Vha01hcERhdGFfXykpIHtcblx0XHRcdHJldHVybiBrZXlbdGhpcy5fX3dlYWtNYXBEYXRhX19dO1xuXHRcdH1cblx0fSksXG5cdGhhczogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0cmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0KGtleSksIHRoaXMuX193ZWFrTWFwRGF0YV9fKTtcblx0fSksXG5cdHNldDogZChmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdGRlZmluZVByb3BlcnR5KG9iamVjdChrZXkpLCB0aGlzLl9fd2Vha01hcERhdGFfXywgZCgnYycsIHZhbHVlKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0pLFxuXHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7IHJldHVybiAnW29iamVjdCBXZWFrTWFwXSc7IH0pXG59KTtcbmRlZmluZVByb3BlcnR5KFdlYWtNYXBQb2x5LnByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIGQoJ2MnLCAnV2Vha01hcCcpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGQgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgY2FsbGFibGUgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG5cbiAgLCBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBkZXNjcmlwdG9yID0geyBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9XG5cbiAgLCBvbiwgb25jZSwgb2ZmLCBlbWl0LCBtZXRob2RzLCBkZXNjcmlwdG9ycywgYmFzZTtcblxub24gPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIGRhdGE7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHtcblx0XHRkYXRhID0gZGVzY3JpcHRvci52YWx1ZSA9IGNyZWF0ZShudWxsKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19lZV9fJywgZGVzY3JpcHRvcik7XG5cdFx0ZGVzY3JpcHRvci52YWx1ZSA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0ZGF0YSA9IHRoaXMuX19lZV9fO1xuXHR9XG5cdGlmICghZGF0YVt0eXBlXSkgZGF0YVt0eXBlXSA9IGxpc3RlbmVyO1xuXHRlbHNlIGlmICh0eXBlb2YgZGF0YVt0eXBlXSA9PT0gJ29iamVjdCcpIGRhdGFbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG5cdGVsc2UgZGF0YVt0eXBlXSA9IFtkYXRhW3R5cGVdLCBsaXN0ZW5lcl07XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5vbmNlID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBvbmNlLCBzZWxmO1xuXG5cdGNhbGxhYmxlKGxpc3RlbmVyKTtcblx0c2VsZiA9IHRoaXM7XG5cdG9uLmNhbGwodGhpcywgdHlwZSwgb25jZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRvZmYuY2FsbChzZWxmLCB0eXBlLCBvbmNlKTtcblx0XHRhcHBseS5jYWxsKGxpc3RlbmVyLCB0aGlzLCBhcmd1bWVudHMpO1xuXHR9KTtcblxuXHRvbmNlLl9fZWVPbmNlTGlzdGVuZXJfXyA9IGxpc3RlbmVyO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbm9mZiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgZGF0YSwgbGlzdGVuZXJzLCBjYW5kaWRhdGUsIGk7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHJldHVybiB0aGlzO1xuXHRkYXRhID0gdGhpcy5fX2VlX187XG5cdGlmICghZGF0YVt0eXBlXSkgcmV0dXJuIHRoaXM7XG5cdGxpc3RlbmVycyA9IGRhdGFbdHlwZV07XG5cblx0aWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdvYmplY3QnKSB7XG5cdFx0Zm9yIChpID0gMDsgKGNhbmRpZGF0ZSA9IGxpc3RlbmVyc1tpXSk7ICsraSkge1xuXHRcdFx0aWYgKChjYW5kaWRhdGUgPT09IGxpc3RlbmVyKSB8fFxuXHRcdFx0XHRcdChjYW5kaWRhdGUuX19lZU9uY2VMaXN0ZW5lcl9fID09PSBsaXN0ZW5lcikpIHtcblx0XHRcdFx0aWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDIpIGRhdGFbdHlwZV0gPSBsaXN0ZW5lcnNbaSA/IDAgOiAxXTtcblx0XHRcdFx0ZWxzZSBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAoKGxpc3RlbmVycyA9PT0gbGlzdGVuZXIpIHx8XG5cdFx0XHRcdChsaXN0ZW5lcnMuX19lZU9uY2VMaXN0ZW5lcl9fID09PSBsaXN0ZW5lcikpIHtcblx0XHRcdGRlbGV0ZSBkYXRhW3R5cGVdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuZW1pdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdHZhciBpLCBsLCBsaXN0ZW5lciwgbGlzdGVuZXJzLCBhcmdzO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHJldHVybjtcblx0bGlzdGVuZXJzID0gdGhpcy5fX2VlX19bdHlwZV07XG5cdGlmICghbGlzdGVuZXJzKSByZXR1cm47XG5cblx0aWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdvYmplY3QnKSB7XG5cdFx0bCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0YXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG5cdFx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cblx0XHRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcblx0XHRmb3IgKGkgPSAwOyAobGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV0pOyArK2kpIHtcblx0XHRcdGFwcGx5LmNhbGwobGlzdGVuZXIsIHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRjYXNlIDE6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0bCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcblx0XHRcdGZvciAoaSA9IDE7IGkgPCBsOyArK2kpIHtcblx0XHRcdFx0YXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHR9XG5cdFx0XHRhcHBseS5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJncyk7XG5cdFx0fVxuXHR9XG59O1xuXG5tZXRob2RzID0ge1xuXHRvbjogb24sXG5cdG9uY2U6IG9uY2UsXG5cdG9mZjogb2ZmLFxuXHRlbWl0OiBlbWl0XG59O1xuXG5kZXNjcmlwdG9ycyA9IHtcblx0b246IGQob24pLFxuXHRvbmNlOiBkKG9uY2UpLFxuXHRvZmY6IGQob2ZmKSxcblx0ZW1pdDogZChlbWl0KVxufTtcblxuYmFzZSA9IGRlZmluZVByb3BlcnRpZXMoe30sIGRlc2NyaXB0b3JzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24gKG8pIHtcblx0cmV0dXJuIChvID09IG51bGwpID8gY3JlYXRlKGJhc2UpIDogZGVmaW5lUHJvcGVydGllcyhPYmplY3QobyksIGRlc2NyaXB0b3JzKTtcbn07XG5leHBvcnRzLm1ldGhvZHMgPSBtZXRob2RzO1xuIiwiLyohIEhhbW1lci5KUyAtIHYyLjAuNyAtIDIwMTYtMDQtMjJcbiAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEpvcmlrIFRhbmdlbGRlcjtcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIGV4cG9ydE5hbWUsIHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbnZhciBWRU5ET1JfUFJFRklYRVMgPSBbJycsICd3ZWJraXQnLCAnTW96JywgJ01TJywgJ21zJywgJ28nXTtcbnZhciBURVNUX0VMRU1FTlQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxudmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIG5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIHNldCBhIHRpbWVvdXQgd2l0aCBhIGdpdmVuIHNjb3BlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBzZXRUaW1lb3V0Q29udGV4dChmbiwgdGltZW91dCwgY29udGV4dCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmRGbihmbiwgY29udGV4dCksIHRpbWVvdXQpO1xufVxuXG4vKipcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XG4gKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfEFycmF5fSBhcmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIGVhY2goYXJnLCBjb250ZXh0W2ZuXSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyB0aGUgc3VwcGxpZWQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gICAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9ICdERVBSRUNBVEVEIE1FVEhPRDogJyArIG5hbWUgKyAnXFxuJyArIG1lc3NhZ2UgKyAnIEFUIFxcbic7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcignZ2V0LXN0YWNrLXRyYWNlJyk7XG4gICAgICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxzK2F0XFxzKy9nbSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXk9iamVjdC48YW5vbnltb3VzPlxccypcXCgvZ20sICd7YW5vbnltb3VzfSgpQCcpIDogJ1Vua25vd24gU3RhY2sgVHJhY2UnO1xuXG4gICAgICAgIHZhciBsb2cgPSB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUud2FybiB8fCB3aW5kb3cuY29uc29sZS5sb2cpO1xuICAgICAgICBpZiAobG9nKSB7XG4gICAgICAgICAgICBsb2cuY2FsbCh3aW5kb3cuY29uc29sZSwgZGVwcmVjYXRpb25NZXNzYWdlLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHNfdG9fYXNzaWduXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAqL1xudmFyIGFzc2lnbjtcbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xufVxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV1cbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xudmFyIGV4dGVuZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICBpZiAoIW1lcmdlIHx8IChtZXJnZSAmJiBkZXN0W2tleXNbaV1dID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbnZhciBtZXJnZSA9IGRlcHJlY2F0ZShmdW5jdGlvbiBtZXJnZShkZXN0LCBzcmMpIHtcbiAgICByZXR1cm4gZXh0ZW5kKGRlc3QsIHNyYywgdHJ1ZSk7XG59LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4vKipcbiAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAqL1xuZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xuICAgIHZhciBiYXNlUCA9IGJhc2UucHJvdG90eXBlLFxuICAgICAgICBjaGlsZFA7XG5cbiAgICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XG5cbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICBhc3NpZ24oY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG59XG5cbi8qKlxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBiaW5kRm4oZm4sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRGbigpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT0gVFlQRV9GVU5DVElPTikge1xuICAgICAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogdXNlIHRoZSB2YWwyIHdoZW4gdmFsMSBpcyB1bmRlZmluZWRcbiAqIEBwYXJhbSB7Kn0gdmFsMVxuICogQHBhcmFtIHsqfSB2YWwyXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gaWZVbmRlZmluZWQodmFsMSwgdmFsMikge1xuICAgIHJldHVybiAodmFsMSA9PT0gdW5kZWZpbmVkKSA/IHZhbDIgOiB2YWwxO1xufVxuXG4vKipcbiAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICogQG1ldGhvZCBoYXNQYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YoZmluZCkgPiAtMTtcbn1cblxuLyoqXG4gKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICovXG5mdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cblxuLyoqXG4gKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXG4gKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cbiAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcbiAgICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xuICAgICAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICgoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQpIHx8ICghZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufVxuXG4vKipcbiAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG59XG5cbi8qKlxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxuICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAqL1xuZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuICAgICAgICBpZiAoaW5BcnJheSh2YWx1ZXMsIHZhbCkgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaV0gPSB2YWw7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoc29ydCkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiBzb3J0VW5pcXVlQXJyYXkoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gKi9cbmZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgICB2YXIgcHJlZml4LCBwcm9wO1xuICAgIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XG4gICAgICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICAgICAgcHJvcCA9IChwcmVmaXgpID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogZ2V0IGEgdW5pcXVlIGlkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICovXG52YXIgX3VuaXF1ZUlkID0gMTtcbmZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBfdW5pcXVlSWQrKztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcbiAgICByZXR1cm4gKGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93IHx8IHdpbmRvdyk7XG59XG5cbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XG5cbnZhciBTVVBQT1JUX1RPVUNIID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbmRvdywgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XG52YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxudmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xudmFyIElOUFVUX1RZUEVfUEVOID0gJ3Blbic7XG52YXIgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XG52YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcblxudmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcblxudmFyIElOUFVUX1NUQVJUID0gMTtcbnZhciBJTlBVVF9NT1ZFID0gMjtcbnZhciBJTlBVVF9FTkQgPSA0O1xudmFyIElOUFVUX0NBTkNFTCA9IDg7XG5cbnZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG52YXIgRElSRUNUSU9OX0xFRlQgPSAyO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XG52YXIgRElSRUNUSU9OX1VQID0gODtcbnZhciBESVJFQ1RJT05fRE9XTiA9IDE2O1xuXG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcbnZhciBESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVVAgfCBESVJFQ1RJT05fRE9XTjtcbnZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG5cbnZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG52YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0lucHV0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICB0aGlzLnRhcmdldCA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dFRhcmdldDtcblxuICAgIC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxuICAgIC8vIHNvIHdoZW4gZGlzYWJsZWQgdGhlIGlucHV0IGV2ZW50cyBhcmUgY29tcGxldGVseSBieXBhc3NlZC5cbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVyKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmluaXQoKTtcblxufVxuXG5JbnB1dC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2hvdWxkIGhhbmRsZSB0aGUgaW5wdXRFdmVudCBkYXRhIGFuZCB0cmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBjYWxsZWQgYnkgdGhlIE1hbmFnZXIgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICAgIHZhciBUeXBlO1xuICAgIHZhciBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgICBpZiAoaW5wdXRDbGFzcykge1xuICAgICAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICAgICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaElucHV0O1xuICAgIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcbiAgICAgICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoVHlwZSkobWFuYWdlciwgaW5wdXRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBoYW5kbGUgaW5wdXQgZXZlbnRzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xuICAgIHZhciBwb2ludGVyc0xlbiA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgY2hhbmdlZFBvaW50ZXJzTGVuID0gaW5wdXQuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgaXNGaXJzdCA9IChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcbiAgICB2YXIgaXNGaW5hbCA9IChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcblxuICAgIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICAgIH1cblxuICAgIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gICAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG4gICAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuXG4gICAgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG4gICAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7XG5cbiAgICAvLyBlbWl0IHNlY3JldCBldmVudFxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuXG4gICAgbWFuYWdlci5yZWNvZ25pemUoaW5wdXQpO1xuICAgIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcbn1cblxuLyoqXG4gKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXG4gKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG4gICAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH1cblxuICAgIC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XG4gICAgdmFyIGZpcnN0TXVsdGlwbGUgPSBzZXNzaW9uLmZpcnN0TXVsdGlwbGU7XG4gICAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xuXG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlciA9IGdldENlbnRlcihwb2ludGVycyk7XG4gICAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XG5cbiAgICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcblxuICAgIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcbiAgICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuXG4gICAgdmFyIG92ZXJhbGxWZWxvY2l0eSA9IGdldFZlbG9jaXR5KGlucHV0LmRlbHRhVGltZSwgaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVggPSBvdmVyYWxsVmVsb2NpdHkueDtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZID0gb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5ID0gKGFicyhvdmVyYWxsVmVsb2NpdHkueCkgPiBhYnMob3ZlcmFsbFZlbG9jaXR5LnkpKSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG5cbiAgICBpbnB1dC5zY2FsZSA9IGZpcnN0TXVsdGlwbGUgPyBnZXRTY2FsZShmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAxO1xuICAgIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG5cbiAgICBpbnB1dC5tYXhQb2ludGVycyA9ICFzZXNzaW9uLnByZXZJbnB1dCA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6ICgoaW5wdXQucG9pbnRlcnMubGVuZ3RoID5cbiAgICAgICAgc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpO1xuXG4gICAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTtcblxuICAgIC8vIGZpbmQgdGhlIGNvcnJlY3QgdGFyZ2V0XG4gICAgdmFyIHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBpZiAoaGFzUGFyZW50KGlucHV0LnNyY0V2ZW50LnRhcmdldCwgdGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQgPSBpbnB1dC5zcmNFdmVudC50YXJnZXQ7XG4gICAgfVxuICAgIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyO1xuICAgIHZhciBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldklucHV0ID0gc2Vzc2lvbi5wcmV2SW5wdXQgfHwge307XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcbiAgICAgICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICAgICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcbiAgICAgICAgfTtcblxuICAgICAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgICAgICB5OiBjZW50ZXIueVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICAgIGlucHV0LmRlbHRhWSA9IHByZXZEZWx0YS55ICsgKGNlbnRlci55IC0gb2Zmc2V0LnkpO1xufVxuXG4vKipcbiAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgbGFzdCA9IHNlc3Npb24ubGFzdEludGVydmFsIHx8IGlucHV0LFxuICAgICAgICBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcCxcbiAgICAgICAgdmVsb2NpdHksIHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBkaXJlY3Rpb247XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHZhciBkZWx0YVggPSBpbnB1dC5kZWx0YVggLSBsYXN0LmRlbHRhWDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuXG4gICAgICAgIHZhciB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICAgICAgdmVsb2NpdHlZID0gdi55O1xuICAgICAgICB2ZWxvY2l0eSA9IChhYnModi54KSA+IGFicyh2LnkpKSA/IHYueCA6IHYueTtcbiAgICAgICAgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGRlbHRhWCwgZGVsdGFZKTtcblxuICAgICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcbiAgICAgICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xuICAgICAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICAgICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICAgIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG59XG5cbi8qKlxuICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcbiAqL1xuZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcbiAgICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBpbnB1dC5wb2ludGVycy5sZW5ndGgpIHtcbiAgICAgICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICAgICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcbiAgICAgICAgICAgIGNsaWVudFk6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFkpXG4gICAgICAgIH07XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0aW1lU3RhbXA6IG5vdygpLFxuICAgICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICAgICAgZGVsdGFYOiBpbnB1dC5kZWx0YVgsXG4gICAgICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXG4gICAgICAgICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciB4ID0gMCwgeSA9IDAsIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgICAgICB5ICs9IHBvaW50ZXJzW2ldLmNsaWVudFk7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxuICAgICAgICB5OiByb3VuZCh5IC8gcG9pbnRlcnNMZW5ndGgpXG4gICAgfTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge09iamVjdH0gdmVsb2NpdHkgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxuICAgICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgICB9O1xufVxuXG4vKipcbiAqIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpcmVjdGlvblxuICovXG5mdW5jdGlvbiBnZXREaXJlY3Rpb24oeCwgeSkge1xuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xuICAgICAgICByZXR1cm4geCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG4gICAgcmV0dXJuIHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gcDFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMlxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICovXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cbiAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXSxcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0sIFBST1BTX0NMSUVOVF9YWSkgKyBnZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICovXG5mdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG52YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICAgIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gICAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIG1vdXNldXA6IElOUFVUX0VORFxufTtcblxudmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XG52YXIgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG5cbi8qKlxuICogTW91c2UgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG5cbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1FaGFuZGxlcihldikge1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9IElOUFVUX0VORDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX01PVVNFLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gICAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxuICAgIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICAgIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcbiAgICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbn07XG5cbi8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG52YXIgSUUxMF9QT0lOVEVSX1RZUEVfRU5VTSA9IHtcbiAgICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgIDM6IElOUFVUX1RZUEVfUEVOLFxuICAgIDQ6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG59O1xuXG52YXIgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcblxuLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5pZiAod2luZG93Lk1TUG9pbnRlckV2ZW50ICYmICF3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdNU1BvaW50ZXJEb3duJztcbiAgICBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAnTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xufVxuXG4vKipcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLnN0b3JlID0gKHRoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXSk7XG59XG5cbmluaGVyaXQoUG9pbnRlckV2ZW50SW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFBFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBldmVudFR5cGVOb3JtYWxpemVkID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ21zJywgJycpO1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XG4gICAgICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuXG4gICAgICAgIHZhciBpc1RvdWNoID0gKHBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpO1xuXG4gICAgICAgIC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7XG5cbiAgICAgICAgLy8gc3RhcnQgYW5kIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICAgICAgICAgICAgc3RvcmVJbmRleCA9IHN0b3JlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG4gICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogc3RvcmUsXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlbW92ZVBvaW50ZXIpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgICAgICAgc3RvcmUuc3BsaWNlKHN0b3JlSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0JztcbnZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogVG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU2luZ2xlVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBURWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cbiAgICAgICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcblxuICAgICAgICAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xufVxuXG52YXIgVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBUT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBNdWx0aS11c2VyIHRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBUb3VjaElucHV0KCkge1xuICAgIHRoaXMuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMudGFyZ2V0SWRzID0ge307XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTVRFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgdHlwZSA9IFRPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuICAgICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBnZXRUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbFRvdWNoZXMgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciB0YXJnZXRJZHMgPSB0aGlzLnRhcmdldElkcztcblxuICAgIC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfU1RBUlQgfCBJTlBVVF9NT1ZFKSAmJiBhbGxUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XG4gICAgfVxuXG4gICAgdmFyIGksXG4gICAgICAgIHRhcmdldFRvdWNoZXMsXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzID0gW10sXG4gICAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuXG4gICAgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xuICAgIHRhcmdldFRvdWNoZXMgPSBhbGxUb3VjaGVzLmZpbHRlcihmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICByZXR1cm4gaGFzUGFyZW50KHRvdWNoLnRhcmdldCwgdGFyZ2V0KTtcbiAgICB9KTtcblxuICAgIC8vIGNvbGxlY3QgdG91Y2hlc1xuICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzLnB1c2goY2hhbmdlZFRvdWNoZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKCFjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICAgIC8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xuICAgICAgICB1bmlxdWVBcnJheSh0YXJnZXRUb3VjaGVzLmNvbmNhdChjaGFuZ2VkVGFyZ2V0VG91Y2hlcyksICdpZGVudGlmaWVyJywgdHJ1ZSksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzXG4gICAgXTtcbn1cblxuLyoqXG4gKiBDb21iaW5lZCB0b3VjaCBhbmQgbW91c2UgaW5wdXRcbiAqXG4gKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cbiAqIFRoaXMgYmVjYXVzZSB0b3VjaCBkZXZpY2VzIGFsc28gZW1pdCBtb3VzZSBldmVudHMgd2hpbGUgZG9pbmcgYSB0b3VjaC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIERFRFVQX1RJTUVPVVQgPSAyNTAwO1xudmFyIERFRFVQX0RJU1RBTkNFID0gMjU7XG5cbmZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dCgpIHtcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBiaW5kRm4odGhpcy5oYW5kbGVyLCB0aGlzKTtcbiAgICB0aGlzLnRvdWNoID0gbmV3IFRvdWNoSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcbiAgICB0aGlzLm1vdXNlID0gbmV3IE1vdXNlSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcblxuICAgIHRoaXMucHJpbWFyeVRvdWNoID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb3VjaGVzID0gW107XG59XG5cbmluaGVyaXQoVG91Y2hNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBUTUVoYW5kbGVyKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgaXNUb3VjaCA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCksXG4gICAgICAgICAgICBpc01vdXNlID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX01PVVNFKTtcblxuICAgICAgICBpZiAoaXNNb3VzZSAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCByZWNvcmQgdG91Y2hlcyB0byAgZGUtZHVwZSBzeW50aGV0aWMgbW91c2UgZXZlbnRcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgIHJlY29yZFRvdWNoZXMuY2FsbCh0aGlzLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91c2UgJiYgaXNTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGlucHV0RGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdLmlkZW50aWZpZXI7XG4gICAgICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0TGFzdFRvdWNoKGV2ZW50RGF0YSkge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF07XG5cbiAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcbiAgICAgICAgdmFyIGxhc3RUb3VjaCA9IHt4OiB0b3VjaC5jbGllbnRYLCB5OiB0b3VjaC5jbGllbnRZfTtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hlcy5wdXNoKGxhc3RUb3VjaCk7XG4gICAgICAgIHZhciBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgICAgICB2YXIgcmVtb3ZlTGFzdFRvdWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGx0cy5pbmRleE9mKGxhc3RUb3VjaCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dChyZW1vdmVMYXN0VG91Y2gsIERFRFVQX1RJTUVPVVQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcbiAgICB2YXIgeCA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRYLCB5ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5sYXN0VG91Y2hlc1tpXTtcbiAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoeCAtIHQueCksIGR5ID0gTWF0aC5hYnMoeSAtIHQueSk7XG4gICAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUQU5DRSAmJiBkeSA8PSBERURVUF9ESVNUQU5DRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbnZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XG5cbi8vIG1hZ2ljYWwgdG91Y2hBY3Rpb24gdmFsdWVcbnZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbnZhciBUT1VDSF9BQ1RJT05fQVVUTyA9ICdhdXRvJztcbnZhciBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OID0gJ21hbmlwdWxhdGlvbic7IC8vIG5vdCBpbXBsZW1lbnRlZFxudmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWCA9ICdwYW4teCc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcbnZhciBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xuXG4vKipcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVG91Y2hBY3Rpb24obWFuYWdlciwgdmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbn1cblxuVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaWYgKHZhbHVlID09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04gJiYgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUgJiYgVE9VQ0hfQUNUSU9OX01BUFt2YWx1ZV0pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IGJhc2VkIG9uIHRoZSByZWNvZ25pemVyJ3Mgc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGNvbXB1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XG5cbiAgICAgICAgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgdmFyIGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWF07XG5cbiAgICAgICAgaWYgKGhhc05vbmUpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IHByZXZlbnQgZGVmYXVsdHMgaWYgdGhpcyBpcyBhIHRhcCBnZXN0dXJlXG5cbiAgICAgICAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgICAgICAgIHZhciBpc1RhcFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IDI1MDtcblxuICAgICAgICAgICAgaWYgKGlzVGFwUG9pbnRlciAmJiBpc1RhcE1vdmVtZW50ICYmIGlzVGFwVG91Y2hUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICAgICAgLy8gYHBhbi14IHBhbi15YCBtZWFucyBicm93c2VyIGhhbmRsZXMgYWxsIHNjcm9sbGluZy9wYW5uaW5nLCBkbyBub3QgcHJldmVudFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc05vbmUgfHxcbiAgICAgICAgICAgIChoYXNQYW5ZICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB8fFxuICAgICAgICAgICAgKGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XG4gICAgICovXG4gICAgcHJldmVudFNyYzogZnVuY3Rpb24oc3JjRXZlbnQpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zKSB7XG4gICAgLy8gbm9uZVxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG5cbiAgICAvLyBpZiBib3RoIHBhbi14IGFuZCBwYW4teSBhcmUgc2V0IChkaWZmZXJlbnQgcmVjb2duaXplcnNcbiAgICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgICAvLyB3ZSBuZWVkIG5vbmUgKGFzIG90aGVyd2lzZSB3aXRoIHBhbi14IHBhbi15IGNvbWJpbmVkIG5vbmUgb2YgdGhlc2VcbiAgICAvLyByZWNvZ25pemVycyB3aWxsIHdvcmssIHNpbmNlIHRoZSBicm93c2VyIHdvdWxkIGhhbmRsZSBhbGwgcGFubmluZ1xuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIC8vIHBhbi14IE9SIHBhbi15XG4gICAgaWYgKGhhc1BhblggfHwgaGFzUGFuWSkge1xuICAgICAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcbiAgICB9XG5cbiAgICAvLyBtYW5pcHVsYXRpb25cbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gICAgfVxuXG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9BVVRPO1xufVxuXG5mdW5jdGlvbiBnZXRUb3VjaEFjdGlvblByb3BzKCkge1xuICAgIGlmICghTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0b3VjaE1hcCA9IHt9O1xuICAgIHZhciBjc3NTdXBwb3J0cyA9IHdpbmRvdy5DU1MgJiYgd2luZG93LkNTUy5zdXBwb3J0cztcbiAgICBbJ2F1dG8nLCAnbWFuaXB1bGF0aW9uJywgJ3Bhbi15JywgJ3Bhbi14JywgJ3Bhbi14IHBhbi15JywgJ25vbmUnXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgICAgIC8vIElmIGNzcy5zdXBwb3J0cyBpcyBub3Qgc3VwcG9ydGVkIGJ1dCB0aGVyZSBpcyBuYXRpdmUgdG91Y2gtYWN0aW9uIGFzc3VtZSBpdCBzdXBwb3J0c1xuICAgICAgICAvLyBhbGwgdmFsdWVzLiBUaGlzIGlzIHRoZSBjYXNlIGZvciBJRSAxMCBhbmQgMTEuXG4gICAgICAgIHRvdWNoTWFwW3ZhbF0gPSBjc3NTdXBwb3J0cyA/IHdpbmRvdy5DU1Muc3VwcG9ydHMoJ3RvdWNoLWFjdGlvbicsIHZhbCkgOiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3VjaE1hcDtcbn1cblxuLyoqXG4gKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXG4gKiBBbGwgcmVjb2duaXplcnMgaGF2ZSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBQT1NTSUJMRSB3aGVuIGEgaW5wdXQgc2Vzc2lvbiBzdGFydHMuXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxuICpcbiAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXG4gKlxuICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cbiAqXG4gKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gKiAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgKy0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcbiAqICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxcbiAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGFuZ2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxuICovXG52YXIgU1RBVEVfUE9TU0lCTEUgPSAxO1xudmFyIFNUQVRFX0JFR0FOID0gMjtcbnZhciBTVEFURV9DSEFOR0VEID0gNDtcbnZhciBTVEFURV9FTkRFRCA9IDg7XG52YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xudmFyIFNUQVRFX0NBTkNFTExFRCA9IDE2O1xudmFyIFNUQVRFX0ZBSUxFRCA9IDMyO1xuXG4vKipcbiAqIFJlY29nbml6ZXJcbiAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcblxuICAgIC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcbiAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG5cbiAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcbn1cblxuUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuICAgICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgcmVxdWlyZUZhaWx1cmUgbGluay4gaXQgZG9lcyBub3QgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSZXF1aXJlRmFpbHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNhblJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG4gICAgICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgICAgICBpZiAoaW5wdXQuYWRkaXRpb25hbEV2ZW50KSB7IC8vIGFkZGl0aW9uYWwgZXZlbnQocGFubGVmdCwgcGFucmlnaHQsIHBpbmNoaW4sIHBpbmNob3V0Li4uKVxuICAgICAgICAgICAgZW1pdChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcbiAgICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmUgZmFpbHVyZSByZWNvZ25pemVycyBoYXMgZmFpbGVkLFxuICAgICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcbiAgICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgdHJ5RW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbiB3ZSBlbWl0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNhbkVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIC8vIG1ha2UgYSBuZXcgY29weSBvZiB0aGUgaW5wdXREYXRhXG4gICAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGFzc2lnbih7fSwgaW5wdXREYXRhKTtcblxuICAgICAgICAvLyBpcyBpcyBlbmFibGVkIGFuZCBhbGxvdyByZWNvZ25pemluZz9cbiAgICAgICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTtcblxuICAgICAgICAvLyB0aGUgcmVjb2duaXplciBoYXMgcmVjb2duaXplZCBhIGdlc3R1cmVcbiAgICAgICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5RW1pdChpbnB1dERhdGFDbG9uZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqIEByZXR1cm5zIHtDb25zdH0gU1RBVEVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dERhdGEpIHsgfSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHsgfVxufTtcblxuLyoqXG4gKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcbiAqIEBwYXJhbSB7Q29uc3R9IHN0YXRlXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxuICovXG5mdW5jdGlvbiBzdGF0ZVN0cihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xuICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgICAgIHJldHVybiAnZW5kJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgICAgICByZXR1cm4gJ21vdmUnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xuICAgICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICogQHBhcmFtIHtDb25zdH0gZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTikge1xuICAgICAgICByZXR1cm4gJ2Rvd24nO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCkge1xuICAgICAgICByZXR1cm4gJ3VwJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fTEVGVCkge1xuICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9SSUdIVCkge1xuICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcbiAgICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcbiAgICBpZiAobWFuYWdlcikge1xuICAgICAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG90aGVyUmVjb2duaXplcjtcbn1cblxuLyoqXG4gKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gQXR0clJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KEF0dHJSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICAgKi9cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMgeyp9IFN0YXRlXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcblxuICAgICAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTtcblxuICAgICAgICAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXG4gICAgICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBhblxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGFuUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5wWCA9IG51bGw7XG4gICAgdGhpcy5wWSA9IG51bGw7XG59XG5cbmluaGVyaXQoUGFuUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3BhbicsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICB9LFxuXG4gICAgZGlyZWN0aW9uVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgLy8gbG9jayB0byBheGlzP1xuICAgICAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHggPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeSA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh5IDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHkgIT0gdGhpcy5wWTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgICh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgKCEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKSk7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG5cbiAgICAgICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdGhpcy5wWSA9IGlucHV0LmRlbHRhWTtcblxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUGluY2hcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUGluY2hSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwaW5jaCcsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgaW5PdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQcmVzc1xuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUHJlc3NSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG59XG5cbmluaGVyaXQoUHJlc3NSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQcmVzc1JlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3ByZXNzJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRpbWU6IDI1MSwgLy8gbWluaW1hbCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIHByZXNzZWRcbiAgICAgICAgdGhyZXNob2xkOiA5IC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAoIXZhbGlkTW92ZW1lbnQgfHwgIXZhbGlkUG9pbnRlcnMgfHwgKGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWUsIHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0ICYmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyAndXAnLCBpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogUm90YXRlXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUm90YXRlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFJvdGF0ZVJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTd2lwZVxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gU3dpcGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU3dpcGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgU3dpcGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHZlbG9jaXR5OiAwLjMsXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHZlbG9jaXR5O1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYO1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICBkaXJlY3Rpb24gJiBpbnB1dC5vZmZzZXREaXJlY3Rpb24gJiZcbiAgICAgICAgICAgIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJlxuICAgICAgICAgICAgaW5wdXQubWF4UG9pbnRlcnMgPT0gdGhpcy5vcHRpb25zLnBvaW50ZXJzICYmXG4gICAgICAgICAgICBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5vZmZzZXREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEEgdGFwIGlzIGVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICogYSBzaW5nbGUgdGFwLlxuICpcbiAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFRhcFJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gcHJldmlvdXMgdGltZSBhbmQgY2VudGVyLFxuICAgIC8vIHVzZWQgZm9yIHRhcCBjb3VudGluZ1xuICAgIHRoaXMucFRpbWUgPSBmYWxzZTtcbiAgICB0aGlzLnBDZW50ZXIgPSBmYWxzZTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgdGhpcy5jb3VudCA9IDA7XG59XG5cbmluaGVyaXQoVGFwUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICd0YXAnLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgdGFwczogMSxcbiAgICAgICAgaW50ZXJ2YWw6IDMwMCwgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgICAgICAgdGltZTogMjUwLCAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxuICAgICAgICB0aHJlc2hvbGQ6IDksIC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgICAgIHBvc1RocmVzaG9sZDogMTAgLy8gYSBtdWx0aS10YXAgY2FuIGJlIGEgYml0IG9mZiB0aGUgaW5pdGlhbCBwb3NpdGlvblxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgaWYgKChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkgJiYgKHRoaXMuY291bnQgPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IChpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCkgOiB0cnVlO1xuICAgICAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuXG4gICAgICAgICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xuICAgICAgICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgICAgICAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAgICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuICAgICAgICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcbiAgICAgICAgICAgIGlmICh0YXBDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIGZhaWxUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucmVjb2duaXplcnMgPSBpZlVuZGVmaW5lZChvcHRpb25zLnJlY29nbml6ZXJzLCBIYW1tZXIuZGVmYXVsdHMucHJlc2V0KTtcbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cbkhhbW1lci5WRVJTSU9OID0gJzIuMC43JztcblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzXG4gKiBAbmFtZXNwYWNlXG4gKi9cbkhhbW1lci5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuICAgICAqIEJ1dCB0aGlzIGlzIHNsb3dlciBhbmQgdW51c2VkIGJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbnMsIHNvIGRpc2FibGVkIGJ5IGRlZmF1bHQuXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkb21FdmVudHM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXG4gICAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBjb21wdXRlXG4gICAgICovXG4gICAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGVuYWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEVYUEVSSU1FTlRBTCBGRUFUVVJFIC0tIGNhbiBiZSByZW1vdmVkL2NoYW5nZWRcbiAgICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cbiAgICAgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtOdWxsfEV2ZW50VGFyZ2V0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dFRhcmdldDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0Q2xhc3M6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcbiAgICAgKiBXaGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIgdGhlc2Ugd2lsbCBiZSBza2lwcGVkLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBwcmVzZXQ6IFtcbiAgICAgICAgLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXG4gICAgICAgIFtSb3RhdGVSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX1dLFxuICAgICAgICBbUGluY2hSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX0sIFsncm90YXRlJ11dLFxuICAgICAgICBbU3dpcGVSZWNvZ25pemVyLCB7ZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTH1dLFxuICAgICAgICBbUGFuUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9LCBbJ3N3aXBlJ11dLFxuICAgICAgICBbVGFwUmVjb2duaXplcl0sXG4gICAgICAgIFtUYXBSZWNvZ25pemVyLCB7ZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyfSwgWyd0YXAnXV0sXG4gICAgICAgIFtQcmVzc1JlY29nbml6ZXJdXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIFNvbWUgQ1NTIHByb3BlcnRpZXMgY2FuIGJlIHVzZWQgdG8gaW1wcm92ZSB0aGUgd29ya2luZyBvZiBIYW1tZXIuXG4gICAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBjc3NQcm9wczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGF0IGFuIGVudGlyZSBlbGVtZW50IHNob3VsZCBiZSBkcmFnZ2FibGUgaW5zdGVhZCBvZiBpdHMgY29udGVudHMuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyRHJhZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxuICAgICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICAgIH1cbn07XG5cbnZhciBTVE9QID0gMTtcbnZhciBGT1JDRURfU1RPUCA9IDI7XG5cbi8qKlxuICogTWFuYWdlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgSGFtbWVyLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCA9IHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCB8fCBlbGVtZW50O1xuXG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXQgPSBjcmVhdGVJbnB1dEluc3RhbmNlKHRoaXMpO1xuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcblxuICAgIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIHRydWUpO1xuXG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSB0aGlzLmFkZChuZXcgKGl0ZW1bMF0pKGl0ZW1bMV0pKTtcbiAgICAgICAgaXRlbVsyXSAmJiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbVsyXSk7XG4gICAgICAgIGl0ZW1bM10gJiYgcmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShpdGVtWzNdKTtcbiAgICB9LCB0aGlzKTtcbn1cblxuTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG4gICAgICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYW5kIHJlaW5pdGlhbGl6ZVxuICAgICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAgICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG4gICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuXG4gICAgICAgIHZhciByZWNvZ25pemVyO1xuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuXG4gICAgICAgIC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgICAgIC8vIGlmIG5vIHJlY29nbml6ZXIgaXMgZGV0ZWN0aW5nIGEgdGhpbmcsIGl0IGlzIHNldCB0byBgbnVsbGBcbiAgICAgICAgdmFyIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXI7XG5cbiAgICAgICAgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXG4gICAgICAgIGlmICghY3VyUmVjb2duaXplciB8fCAoY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkpIHtcbiAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldO1xuXG4gICAgICAgICAgICAvLyBmaW5kIG91dCBpZiB3ZSBhcmUgYWxsb3dlZCB0cnkgdG8gcmVjb2duaXplIHRoZSBpbnB1dCBmb3IgdGhpcyBvbmUuXG4gICAgICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcbiAgICAgICAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgICAgICAgLy8gICAgICB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cbiAgICAgICAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXG4gICAgICAgICAgICAgICAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT0gY3VyUmVjb2duaXplciB8fCAvLyAyXG4gICAgICAgICAgICAgICAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHsgLy8gM1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIHJlY29nbml6ZXIgaGFzIGJlZW4gcmVjb2duaXppbmcgdGhlIGlucHV0IGFzIGEgdmFsaWQgZ2VzdHVyZSwgd2Ugd2FudCB0byBzdG9yZSB0aGlzIG9uZSBhcyB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuICAgICAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TnVsbH1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09IHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICAgKiBleGlzdGluZyByZWNvZ25pemVycyB3aXRoIHRoZSBzYW1lIGV2ZW50IG5hbWUgd2lsbCBiZSByZW1vdmVkXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQocmVjb2duaXplci5vcHRpb25zLmV2ZW50KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShleGlzdGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZWNvZ25pemVyID0gdGhpcy5nZXQocmVjb2duaXplcik7XG5cbiAgICAgICAgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcbiAgICAgICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCByZWNvZ25pemVyKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIGV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgZXZlbnQsIGxlYXZlIGVtaXQgYmxhbmsgdG8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gJiYgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGVtaXQgZXZlbnQgdG8gdGhlIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuICAgICAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEudHlwZSA9IGV2ZW50O1xuICAgICAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkYXRhLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXG4gICAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICAgIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcm9wO1xuICAgIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBwcm9wID0gcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSk7XG4gICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gPSBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gfHwgJyc7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWFkZCkge1xuICAgICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gICAgfVxufVxuXG4vKipcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gICAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xufVxuXG5hc3NpZ24oSGFtbWVyLCB7XG4gICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxuICAgIElOUFVUX01PVkU6IElOUFVUX01PVkUsXG4gICAgSU5QVVRfRU5EOiBJTlBVVF9FTkQsXG4gICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXG5cbiAgICBTVEFURV9QT1NTSUJMRTogU1RBVEVfUE9TU0lCTEUsXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRUQ6IFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfRU5ERUQ6IFNUQVRFX0VOREVELFxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVEOiBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRkFJTEVEOiBTVEFURV9GQUlMRUQsXG5cbiAgICBESVJFQ1RJT05fTk9ORTogRElSRUNUSU9OX05PTkUsXG4gICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxuICAgIERJUkVDVElPTl9VUDogRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMOiBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcblxuICAgIE1hbmFnZXI6IE1hbmFnZXIsXG4gICAgSW5wdXQ6IElucHV0LFxuICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcblxuICAgIFRvdWNoSW5wdXQ6IFRvdWNoSW5wdXQsXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcbiAgICBQb2ludGVyRXZlbnRJbnB1dDogUG9pbnRlckV2ZW50SW5wdXQsXG4gICAgVG91Y2hNb3VzZUlucHV0OiBUb3VjaE1vdXNlSW5wdXQsXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcblxuICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxuICAgIFRhcDogVGFwUmVjb2duaXplcixcbiAgICBQYW46IFBhblJlY29nbml6ZXIsXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcbiAgICBQaW5jaDogUGluY2hSZWNvZ25pemVyLFxuICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxuXG4gICAgb246IGFkZEV2ZW50TGlzdGVuZXJzLFxuICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXG4gICAgZWFjaDogZWFjaCxcbiAgICBtZXJnZTogbWVyZ2UsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgYXNzaWduOiBhc3NpZ24sXG4gICAgaW5oZXJpdDogaW5oZXJpdCxcbiAgICBiaW5kRm46IGJpbmRGbixcbiAgICBwcmVmaXhlZDogcHJlZml4ZWRcbn0pO1xuXG4vLyB0aGlzIHByZXZlbnRzIGVycm9ycyB3aGVuIEhhbW1lciBpcyBsb2FkZWQgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRFxuLy8gIHN0eWxlIGxvYWRlciBidXQgYnkgc2NyaXB0IHRhZywgbm90IGJ5IHRoZSBsb2FkZXIuXG52YXIgZnJlZUdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5mcmVlR2xvYmFsLkhhbW1lciA9IEhhbW1lcjtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEhhbW1lcjtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSGFtbWVyO1xufSBlbHNlIHtcbiAgICB3aW5kb3dbZXhwb3J0TmFtZV0gPSBIYW1tZXI7XG59XG5cbn0pKHdpbmRvdywgZG9jdW1lbnQsICdIYW1tZXInKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIDIwMTQsIE51Y2xlaWMgRGV2ZWxvcG1lbnQgVGVhbS5cbnxcbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbnxcbnwgVGhlIGZ1bGwgbGljZW5zZSBpcyBpbiB0aGUgZmlsZSBDT1BZSU5HLnR4dCwgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvZnR3YXJlLlxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHN0cmVuZ3RoXzEgPSByZXF1aXJlKFwiLi9zdHJlbmd0aFwiKTtcbi8qKlxuICogQW4gZW51bSBkZWZpbmluZyB0aGUgbGluZWFyIGNvbnN0cmFpbnQgb3BlcmF0b3JzLlxuICovXG52YXIgT3BlcmF0b3I7XG4oZnVuY3Rpb24gKE9wZXJhdG9yKSB7XG4gICAgT3BlcmF0b3JbT3BlcmF0b3JbXCJMZVwiXSA9IDBdID0gXCJMZVwiO1xuICAgIE9wZXJhdG9yW09wZXJhdG9yW1wiR2VcIl0gPSAxXSA9IFwiR2VcIjtcbiAgICBPcGVyYXRvcltPcGVyYXRvcltcIkVxXCJdID0gMl0gPSBcIkVxXCI7IC8vID09XG59KShPcGVyYXRvciA9IGV4cG9ydHMuT3BlcmF0b3IgfHwgKGV4cG9ydHMuT3BlcmF0b3IgPSB7fSkpO1xuLyoqXG4gKiBBIGxpbmVhciBjb25zdHJhaW50IGVxdWF0aW9uLlxuICpcbiAqIEEgY29uc3RyYWludCBlcXVhdGlvbiBpcyBjb21wb3NlZCBvZiBhbiBleHByZXNzaW9uLCBhbiBvcGVyYXRvcixcbiAqIGFuZCBhIHN0cmVuZ3RoLiBUaGUgUkhTIG9mIHRoZSBlcXVhdGlvbiBpcyBpbXBsaWNpdGx5IHplcm8uXG4gKlxuICogQGNsYXNzXG4gKi9cbnZhciBDb25zdHJhaW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgQ29uc3RyYWludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBleHByZXNzaW9uIFRoZSBjb25zdHJhaW50IGV4cHJlc3Npb24uXG4gICAgICogQHBhcmFtIG9wZXJhdG9yIFRoZSBlcXVhdGlvbiBvcGVyYXRvci5cbiAgICAgKiBAcGFyYW0gc3RyZW5ndGggVGhlIHN0cmVuZ3RoIG9mIHRoZSBjb25zdHJhaW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbnN0cmFpbnQoZXhwcmVzc2lvbiwgb3BlcmF0b3IsIHN0cmVuZ3RoKSB7XG4gICAgICAgIGlmIChzdHJlbmd0aCA9PT0gdm9pZCAwKSB7IHN0cmVuZ3RoID0gc3RyZW5ndGhfMS5TdHJlbmd0aC5yZXF1aXJlZDsgfVxuICAgICAgICB0aGlzLl9pZCA9IENuSWQrKztcbiAgICAgICAgdGhpcy5fb3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgdGhpcy5fZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMuX3N0cmVuZ3RoID0gc3RyZW5ndGhfMS5TdHJlbmd0aC5jbGlwKHN0cmVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdGF0aWMgY29uc3RyYWludCBjb21wYXJpc29uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIENvbnN0cmFpbnQuQ29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmlkIC0gYi5pZDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJhaW50LnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bmlxdWUgaWQgbnVtYmVyIG9mIHRoZSBjb25zdHJhaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJhaW50LnByb3RvdHlwZSwgXCJleHByZXNzaW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGV4cHJlc3Npb24gb2YgdGhlIGNvbnN0cmFpbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByZXNzaW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RyYWludC5wcm90b3R5cGUsIFwib3BcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcmVsYXRpb25hbCBvcGVyYXRvciBvZiB0aGUgY29uc3RyYWludC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wZXJhdG9yO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RyYWludC5wcm90b3R5cGUsIFwic3RyZW5ndGhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgc3RyZW5ndGggb2YgdGhlIGNvbnN0cmFpbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIENvbnN0cmFpbnQ7XG59KCkpO1xuZXhwb3J0cy5Db25zdHJhaW50ID0gQ29uc3RyYWludDtcbi8qKlxuICogVGhlIGludGVybmFsIGNvbnN0cmFpbnQgaWQgY291bnRlci5cbiAqL1xudmFyIENuSWQgPSAwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNCwgTnVjbGVpYyBEZXZlbG9wbWVudCBUZWFtLlxufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIENPUFlJTkcudHh0LCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHN1XzEgPSByZXF1aXJlKFwiLi90c3VcIik7XG52YXIgdmFyaWFibGVfMSA9IHJlcXVpcmUoXCIuL3ZhcmlhYmxlXCIpO1xudmFyIG1hcHR5cGVfMSA9IHJlcXVpcmUoXCIuL21hcHR5cGVcIik7XG4vKipcbiAqIEFuIGV4cHJlc3Npb24gb2YgdmFyaWFibGUgdGVybXMgYW5kIGEgY29uc3RhbnQuXG4gKlxuICogQGNsYXNzXG4gKi9cbnZhciBFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VBcmdzKGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3Rlcm1zID0gcGFyc2VkLnRlcm1zO1xuICAgICAgICB0aGlzLl9jb25zdGFudCA9IHBhcnNlZC5jb25zdGFudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV4cHJlc3Npb24ucHJvdG90eXBlLCBcInRlcm1zXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIG1hcHBpbmcgb2YgdGVybXMgaW4gdGhlIGV4cHJlc3Npb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgKm11c3QqIGJlIHRyZWF0ZWQgYXMgY29uc3QuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXJtcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV4cHJlc3Npb24ucHJvdG90eXBlLCBcImNvbnN0YW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNvbnN0YW50IG9mIHRoZSBleHByZXNzaW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29uc3RhbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeHByZXNzaW9uLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb21wdXRlZCB2YWx1ZSBvZiB0aGUgZXhwcmVzc2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2NvbnN0YW50O1xuICAgICAgICAgICAgdHN1XzEuZm9yRWFjaCh0aGlzLl90ZXJtcywgZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gcGFpci5maXJzdC52YWx1ZSAqIHBhaXIuc2Vjb25kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRXhwcmVzc2lvbjtcbn0oKSk7XG5leHBvcnRzLkV4cHJlc3Npb24gPSBFeHByZXNzaW9uO1xuLyoqXG4gKiBBbiBpbnRlcm5hbCBhcmd1bWVudCBwYXJzaW5nIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBwYXJzZUFyZ3MoYXJncykge1xuICAgIHZhciBjb25zdGFudCA9IDAuMDtcbiAgICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAuMDsgfTtcbiAgICB2YXIgdGVybXMgPSBtYXB0eXBlXzEuY3JlYXRlTWFwKHZhcmlhYmxlXzEuVmFyaWFibGUuQ29tcGFyZSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBhcmdzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICB2YXIgaXRlbSA9IGFyZ3NbaV07XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgY29uc3RhbnQgKz0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgdmFyaWFibGVfMS5WYXJpYWJsZSkge1xuICAgICAgICAgICAgdGVybXMuc2V0RGVmYXVsdChpdGVtLCBmYWN0b3J5KS5zZWNvbmQgKz0gMS4wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0ubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgbXVzdCBoYXZlIGxlbmd0aCAyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gaXRlbVswXTtcbiAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IGl0ZW1bMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXRlbSAwIG11c3QgYmUgYSBudW1iZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISh2YXJpYWJsZSBpbnN0YW5jZW9mIHZhcmlhYmxlXzEuVmFyaWFibGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXRlbSAxIG11c3QgYmUgYSB2YXJpYWJsZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlcm1zLnNldERlZmF1bHQodmFyaWFibGUsIGZhY3RvcnkpLnNlY29uZCArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgRXhwcmVzc2lvbiBhcmd1bWVudDogXCIgKyBKU09OLnN0cmluZ2lmeShpdGVtKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdGVybXM6IHRlcm1zLCBjb25zdGFudDogY29uc3RhbnQgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIDIwMTQsIE51Y2xlaWMgRGV2ZWxvcG1lbnQgVGVhbS5cbnxcbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbnxcbnwgVGhlIGZ1bGwgbGljZW5zZSBpcyBpbiB0aGUgZmlsZSBDT1BZSU5HLnR4dCwgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvZnR3YXJlLlxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3ZhcmlhYmxlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2V4cHJlc3Npb25cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29uc3RyYWludFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdHJlbmd0aFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zb2x2ZXJcIikpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNCwgTnVjbGVpYyBEZXZlbG9wbWVudCBUZWFtLlxufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIENPUFlJTkcudHh0LCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHN1XzEgPSByZXF1aXJlKFwiLi90c3VcIik7XG5mdW5jdGlvbiBjcmVhdGVNYXAoY29tcGFyZSkge1xuICAgIHJldHVybiBuZXcgdHN1XzEuQXNzb2NpYXRpdmVBcnJheShjb21wYXJlKTtcbn1cbmV4cG9ydHMuY3JlYXRlTWFwID0gY3JlYXRlTWFwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNCwgTnVjbGVpYyBEZXZlbG9wbWVudCBUZWFtLlxufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIENPUFlJTkcudHh0LCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmFyaWFibGVfMSA9IHJlcXVpcmUoXCIuL3ZhcmlhYmxlXCIpO1xudmFyIGV4cHJlc3Npb25fMSA9IHJlcXVpcmUoXCIuL2V4cHJlc3Npb25cIik7XG52YXIgY29uc3RyYWludF8xID0gcmVxdWlyZShcIi4vY29uc3RyYWludFwiKTtcbnZhciBzdHJlbmd0aF8xID0gcmVxdWlyZShcIi4vc3RyZW5ndGhcIik7XG52YXIgbWFwdHlwZV8xID0gcmVxdWlyZShcIi4vbWFwdHlwZVwiKTtcbi8qKlxuICogVGhlIGNvbnN0cmFpbnQgc29sdmVyIGNsYXNzLlxuICpcbiAqIEBjbGFzc1xuICovXG52YXIgU29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgU29sdmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNvbHZlcigpIHtcbiAgICAgICAgdGhpcy5fY25NYXAgPSBjcmVhdGVDbk1hcCgpO1xuICAgICAgICB0aGlzLl9yb3dNYXAgPSBjcmVhdGVSb3dNYXAoKTtcbiAgICAgICAgdGhpcy5fdmFyTWFwID0gY3JlYXRlVmFyTWFwKCk7XG4gICAgICAgIHRoaXMuX2VkaXRNYXAgPSBjcmVhdGVFZGl0TWFwKCk7XG4gICAgICAgIHRoaXMuX2luZmVhc2libGVSb3dzID0gW107XG4gICAgICAgIHRoaXMuX29iamVjdGl2ZSA9IG5ldyBSb3coKTtcbiAgICAgICAgdGhpcy5fYXJ0aWZpY2lhbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lkVGljayA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gdGhlIHNvbHZlci5cbiAgICAgKi9cbiAgICBTb2x2ZXIucHJvdG90eXBlLmFkZENvbnN0cmFpbnQgPSBmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICB2YXIgY25QYWlyID0gdGhpcy5fY25NYXAuZmluZChjb25zdHJhaW50KTtcbiAgICAgICAgaWYgKGNuUGFpciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkdXBsaWNhdGUgY29uc3RyYWludFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGluZyBhIHJvdyBjYXVzZXMgc3ltYm9scyB0byBiZSByZXNlcnZlZCBmb3IgdGhlIHZhcmlhYmxlc1xuICAgICAgICAvLyBpbiB0aGUgY29uc3RyYWludC4gSWYgdGhpcyBtZXRob2QgZXhpdHMgd2l0aCBhbiBleGNlcHRpb24sXG4gICAgICAgIC8vIHRoZW4gaXRzIHBvc3NpYmxlIHRob3NlIHZhcmlhYmxlcyB3aWxsIGxpbmdlciBpbiB0aGUgdmFyIG1hcC5cbiAgICAgICAgLy8gU2luY2UgaXRzIGxpa2VseSB0aGF0IHRob3NlIHZhcmlhYmxlcyB3aWxsIGJlIHVzZWQgaW4gb3RoZXJcbiAgICAgICAgLy8gY29uc3RyYWludHMgYW5kIHNpbmNlIGV4Y2VwdGlvbmFsIGNvbmRpdGlvbnMgYXJlIHVuY29tbW9uLFxuICAgICAgICAvLyBpJ20gbm90IHRvbyB3b3JyaWVkIGFib3V0IGFnZ3Jlc3NpdmUgY2xlYW51cCBvZiB0aGUgdmFyIG1hcC5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9jcmVhdGVSb3coY29uc3RyYWludCk7XG4gICAgICAgIHZhciByb3cgPSBkYXRhLnJvdztcbiAgICAgICAgdmFyIHRhZyA9IGRhdGEudGFnO1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuX2Nob29zZVN1YmplY3Qocm93LCB0YWcpO1xuICAgICAgICAvLyBJZiBjaG9vc2VTdWJqZWN0IGNvdWxkbnQgZmluZCBhIHZhbGlkIGVudGVyaW5nIHN5bWJvbCwgb25lXG4gICAgICAgIC8vIGxhc3Qgb3B0aW9uIGlzIGF2YWlsYWJsZSBpZiB0aGUgZW50aXJlIHJvdyBpcyBjb21wb3NlZCBvZlxuICAgICAgICAvLyBkdW1teSB2YXJpYWJsZXMuIElmIHRoZSBjb25zdGFudCBvZiB0aGUgcm93IGlzIHplcm8sIHRoZW5cbiAgICAgICAgLy8gdGhpcyByZXByZXNlbnRzIHJlZHVuZGFudCBjb25zdHJhaW50cyBhbmQgdGhlIG5ldyBkdW1teVxuICAgICAgICAvLyBtYXJrZXIgY2FuIGVudGVyIHRoZSBiYXNpcy4gSWYgdGhlIGNvbnN0YW50IGlzIG5vbi16ZXJvLFxuICAgICAgICAvLyB0aGVuIGl0IHJlcHJlc2VudHMgYW4gdW5zYXRpc2ZpYWJsZSBjb25zdHJhaW50LlxuICAgICAgICBpZiAoc3ViamVjdC50eXBlKCkgPT09IFN5bWJvbFR5cGUuSW52YWxpZCAmJiByb3cuYWxsRHVtbWllcygpKSB7XG4gICAgICAgICAgICBpZiAoIW5lYXJaZXJvKHJvdy5jb25zdGFudCgpKSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb25zdHJhaW50LmV4cHJlc3Npb24udGVybXMuX2FycmF5OyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZXMucHVzaChpdGVtLmZpcnN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgb3AgPSBbJ0xFJywgJ0dFJywgJ0VRJ11bY29uc3RyYWludC5vcF07XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zYXRpc2ZpYWJsZSBjb25zdHJhaW50IFtcIiArIG5hbWVzLmpvaW4oXCIsXCIpICsgXCJdIG9wZXJhdG9yOiBcIiArIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1YmplY3QgPSB0YWcubWFya2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFuIGVudGVyaW5nIHN5bWJvbCBzdGlsbCBpc24ndCBmb3VuZCwgdGhlbiB0aGUgcm93IG11c3RcbiAgICAgICAgLy8gYmUgYWRkZWQgdXNpbmcgYW4gYXJ0aWZpY2lhbCB2YXJpYWJsZS4gSWYgdGhhdCBmYWlscywgdGhlblxuICAgICAgICAvLyB0aGUgcm93IHJlcHJlc2VudHMgYW4gdW5zYXRpc2ZpYWJsZSBjb25zdHJhaW50LlxuICAgICAgICBpZiAoc3ViamVjdC50eXBlKCkgPT09IFN5bWJvbFR5cGUuSW52YWxpZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hZGRXaXRoQXJ0aWZpY2lhbFZhcmlhYmxlKHJvdykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnNhdGlzZmlhYmxlIGNvbnN0cmFpbnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3cuc29sdmVGb3Ioc3ViamVjdCk7XG4gICAgICAgICAgICB0aGlzLl9zdWJzdGl0dXRlKHN1YmplY3QsIHJvdyk7XG4gICAgICAgICAgICB0aGlzLl9yb3dNYXAuaW5zZXJ0KHN1YmplY3QsIHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY25NYXAuaW5zZXJ0KGNvbnN0cmFpbnQsIHRhZyk7XG4gICAgICAgIC8vIE9wdGltaXppbmcgYWZ0ZXIgZWFjaCBjb25zdHJhaW50IGlzIGFkZGVkIHBlcmZvcm1zIGxlc3NcbiAgICAgICAgLy8gYWdncmVnYXRlIHdvcmsgZHVlIHRvIGEgc21hbGxlciBhdmVyYWdlIHN5c3RlbSBzaXplLiBJdFxuICAgICAgICAvLyBhbHNvIGVuc3VyZXMgdGhlIHNvbHZlciByZW1haW5zIGluIGEgY29uc2lzdGVudCBzdGF0ZS5cbiAgICAgICAgdGhpcy5fb3B0aW1pemUodGhpcy5fb2JqZWN0aXZlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGNvbnN0cmFpbnQgZnJvbSB0aGUgc29sdmVyLlxuICAgICAqL1xuICAgIFNvbHZlci5wcm90b3R5cGUucmVtb3ZlQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50LCBzaWxlbnQpIHtcbiAgICAgICAgaWYgKHNpbGVudCA9PT0gdm9pZCAwKSB7IHNpbGVudCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBjblBhaXIgPSB0aGlzLl9jbk1hcC5lcmFzZShjb25zdHJhaW50KTtcbiAgICAgICAgaWYgKGNuUGFpciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoc2lsZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGNvbnN0cmFpbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBlcnJvciBlZmZlY3RzIGZyb20gdGhlIG9iamVjdGl2ZSBmdW5jdGlvblxuICAgICAgICAvLyAqYmVmb3JlKiBwaXZvdGluZywgb3Igc3Vic3RpdHV0aW9ucyBpbnRvIHRoZSBvYmplY3RpdmVcbiAgICAgICAgLy8gd2lsbCBsZWFkIHRvIGluY29ycmVjdCBzb2x2ZXIgcmVzdWx0cy5cbiAgICAgICAgdGhpcy5fcmVtb3ZlQ29uc3RyYWludEVmZmVjdHMoY29uc3RyYWludCwgY25QYWlyLnNlY29uZCk7XG4gICAgICAgIC8vIElmIHRoZSBtYXJrZXIgaXMgYmFzaWMsIHNpbXBseSBkcm9wIHRoZSByb3cuIE90aGVyd2lzZSxcbiAgICAgICAgLy8gcGl2b3QgdGhlIG1hcmtlciBpbnRvIHRoZSBiYXNpcyBhbmQgdGhlbiBkcm9wIHRoZSByb3cuXG4gICAgICAgIHZhciBtYXJrZXIgPSBjblBhaXIuc2Vjb25kLm1hcmtlcjtcbiAgICAgICAgdmFyIHJvd1BhaXIgPSB0aGlzLl9yb3dNYXAuZXJhc2UobWFya2VyKTtcbiAgICAgICAgaWYgKHJvd1BhaXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGxlYXZpbmcgPSB0aGlzLl9nZXRNYXJrZXJMZWF2aW5nU3ltYm9sKG1hcmtlcik7XG4gICAgICAgICAgICBpZiAobGVhdmluZy50eXBlKCkgPT09IFN5bWJvbFR5cGUuSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBmaW5kIGxlYXZpbmcgcm93XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93UGFpciA9IHRoaXMuX3Jvd01hcC5lcmFzZShsZWF2aW5nKTtcbiAgICAgICAgICAgIHJvd1BhaXIuc2Vjb25kLnNvbHZlRm9yRXgobGVhdmluZywgbWFya2VyKTtcbiAgICAgICAgICAgIHRoaXMuX3N1YnN0aXR1dGUobWFya2VyLCByb3dQYWlyLnNlY29uZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3B0aW1pemluZyBhZnRlciBlYWNoIGNvbnN0cmFpbnQgaXMgcmVtb3ZlZCBlbnN1cmVzIHRoYXQgdGhlXG4gICAgICAgIC8vIHNvbHZlciByZW1haW5zIGNvbnNpc3RlbnQuIEl0IG1ha2VzIHRoZSBzb2x2ZXIgYXBpIGVhc2llciB0b1xuICAgICAgICAvLyB1c2UgYXQgYSBzbWFsbCB0cmFkZW9mZiBmb3Igc3BlZWQuXG4gICAgICAgIHRoaXMuX29wdGltaXplKHRoaXMuX29iamVjdGl2ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgdGhlIHNvbHZlciBjb250YWlucyB0aGUgY29uc3RyYWludC5cbiAgICAgKi9cbiAgICBTb2x2ZXIucHJvdG90eXBlLmhhc0NvbnN0cmFpbnQgPSBmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY25NYXAuY29udGFpbnMoY29uc3RyYWludCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZWRpdCB2YXJpYWJsZSB0byB0aGUgc29sdmVyLlxuICAgICAqL1xuICAgIFNvbHZlci5wcm90b3R5cGUuYWRkRWRpdFZhcmlhYmxlID0gZnVuY3Rpb24gKHZhcmlhYmxlLCBzdHJlbmd0aCkge1xuICAgICAgICB2YXIgZWRpdFBhaXIgPSB0aGlzLl9lZGl0TWFwLmZpbmQodmFyaWFibGUpO1xuICAgICAgICBpZiAoZWRpdFBhaXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZHVwbGljYXRlIGVkaXQgdmFyaWFibGU6IFwiICsgdmFyaWFibGUubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZW5ndGggPSBzdHJlbmd0aF8xLlN0cmVuZ3RoLmNsaXAoc3RyZW5ndGgpO1xuICAgICAgICBpZiAoc3RyZW5ndGggPT09IHN0cmVuZ3RoXzEuU3RyZW5ndGgucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCByZXF1aXJlZCBzdHJlbmd0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhwciA9IG5ldyBleHByZXNzaW9uXzEuRXhwcmVzc2lvbih2YXJpYWJsZSk7XG4gICAgICAgIHZhciBjbiA9IG5ldyBjb25zdHJhaW50XzEuQ29uc3RyYWludChleHByLCBjb25zdHJhaW50XzEuT3BlcmF0b3IuRXEsIHN0cmVuZ3RoKTtcbiAgICAgICAgdGhpcy5hZGRDb25zdHJhaW50KGNuKTtcbiAgICAgICAgdmFyIHRhZyA9IHRoaXMuX2NuTWFwLmZpbmQoY24pLnNlY29uZDtcbiAgICAgICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBjb25zdHJhaW50OiBjbiwgY29uc3RhbnQ6IDAuMCB9O1xuICAgICAgICB0aGlzLl9lZGl0TWFwLmluc2VydCh2YXJpYWJsZSwgaW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZWRpdCB2YXJpYWJsZSBmcm9tIHRoZSBzb2x2ZXIuXG4gICAgICovXG4gICAgU29sdmVyLnByb3RvdHlwZS5yZW1vdmVFZGl0VmFyaWFibGUgPSBmdW5jdGlvbiAodmFyaWFibGUsIHNpbGVudCkge1xuICAgICAgICBpZiAoc2lsZW50ID09PSB2b2lkIDApIHsgc2lsZW50ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGVkaXRQYWlyID0gdGhpcy5fZWRpdE1hcC5lcmFzZSh2YXJpYWJsZSk7XG4gICAgICAgIGlmIChlZGl0UGFpciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoc2lsZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGVkaXQgdmFyaWFibGU6IFwiICsgdmFyaWFibGUubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVDb25zdHJhaW50KGVkaXRQYWlyLnNlY29uZC5jb25zdHJhaW50LCBzaWxlbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIHRoZSBzb2x2ZXIgY29udGFpbnMgdGhlIGVkaXQgdmFyaWFibGUuXG4gICAgICovXG4gICAgU29sdmVyLnByb3RvdHlwZS5oYXNFZGl0VmFyaWFibGUgPSBmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VkaXRNYXAuY29udGFpbnModmFyaWFibGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3VnZ2VzdCB0aGUgdmFsdWUgb2YgYW4gZWRpdCB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBTb2x2ZXIucHJvdG90eXBlLnN1Z2dlc3RWYWx1ZSA9IGZ1bmN0aW9uICh2YXJpYWJsZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGVkaXRQYWlyID0gdGhpcy5fZWRpdE1hcC5maW5kKHZhcmlhYmxlKTtcbiAgICAgICAgaWYgKGVkaXRQYWlyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gZWRpdCB2YXJpYWJsZTogXCIgKyB2YXJpYWJsZS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm93cyA9IHRoaXMuX3Jvd01hcDtcbiAgICAgICAgdmFyIGluZm8gPSBlZGl0UGFpci5zZWNvbmQ7XG4gICAgICAgIHZhciBkZWx0YSA9IHZhbHVlIC0gaW5mby5jb25zdGFudDtcbiAgICAgICAgaW5mby5jb25zdGFudCA9IHZhbHVlO1xuICAgICAgICAvLyBDaGVjayBmaXJzdCBpZiB0aGUgcG9zaXRpdmUgZXJyb3IgdmFyaWFibGUgaXMgYmFzaWMuXG4gICAgICAgIHZhciBtYXJrZXIgPSBpbmZvLnRhZy5tYXJrZXI7XG4gICAgICAgIHZhciByb3dQYWlyID0gcm93cy5maW5kKG1hcmtlcik7XG4gICAgICAgIGlmIChyb3dQYWlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChyb3dQYWlyLnNlY29uZC5hZGQoLWRlbHRhKSA8IDAuMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZmVhc2libGVSb3dzLnB1c2gobWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2R1YWxPcHRpbWl6ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIG5leHQgaWYgdGhlIG5lZ2F0aXZlIGVycm9yIHZhcmlhYmxlIGlzIGJhc2ljLlxuICAgICAgICB2YXIgb3RoZXIgPSBpbmZvLnRhZy5vdGhlcjtcbiAgICAgICAgcm93UGFpciA9IHJvd3MuZmluZChvdGhlcik7XG4gICAgICAgIGlmIChyb3dQYWlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChyb3dQYWlyLnNlY29uZC5hZGQoZGVsdGEpIDwgMC4wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5mZWFzaWJsZVJvd3MucHVzaChvdGhlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kdWFsT3B0aW1pemUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgdXBkYXRlIGVhY2ggcm93IHdoZXJlIHRoZSBlcnJvciB2YXJpYWJsZXMgZXhpc3QuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcm93cy5zaXplKCk7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciByb3dQYWlyXzEgPSByb3dzLml0ZW1BdChpKTtcbiAgICAgICAgICAgIHZhciByb3cgPSByb3dQYWlyXzEuc2Vjb25kO1xuICAgICAgICAgICAgdmFyIGNvZWZmID0gcm93LmNvZWZmaWNpZW50Rm9yKG1hcmtlcik7XG4gICAgICAgICAgICBpZiAoY29lZmYgIT09IDAuMCAmJiByb3cuYWRkKGRlbHRhICogY29lZmYpIDwgMC4wICYmXG4gICAgICAgICAgICAgICAgcm93UGFpcl8xLmZpcnN0LnR5cGUoKSAhPT0gU3ltYm9sVHlwZS5FeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZmVhc2libGVSb3dzLnB1c2gocm93UGFpcl8xLmZpcnN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kdWFsT3B0aW1pemUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdmFsdWVzIG9mIHRoZSB2YXJpYWJsZXMuXG4gICAgICovXG4gICAgU29sdmVyLnByb3RvdHlwZS51cGRhdGVWYXJpYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YXJzID0gdGhpcy5fdmFyTWFwO1xuICAgICAgICB2YXIgcm93cyA9IHRoaXMuX3Jvd01hcDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB2YXJzLnNpemUoKTsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSB2YXJzLml0ZW1BdChpKTtcbiAgICAgICAgICAgIHZhciByb3dQYWlyID0gcm93cy5maW5kKHBhaXIuc2Vjb25kKTtcbiAgICAgICAgICAgIGlmIChyb3dQYWlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWlyLmZpcnN0LnNldFZhbHVlKHJvd1BhaXIuc2Vjb25kLmNvbnN0YW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFpci5maXJzdC5zZXRWYWx1ZSgwLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU29sdmVyLnByb3RvdHlwZSwgXCJudW1Db25zdHJhaW50c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NuTWFwLnNpemUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvbHZlci5wcm90b3R5cGUsIFwibnVtRWRpdFZhcmlhYmxlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VkaXRNYXAuc2l6ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN5bWJvbCBmb3IgdGhlIGdpdmVuIHZhcmlhYmxlLlxuICAgICAqXG4gICAgICogSWYgYSBzeW1ib2wgZG9lcyBub3QgZXhpc3QgZm9yIHRoZSB2YXJpYWJsZSwgb25lIHdpbGwgYmUgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBTb2x2ZXIucHJvdG90eXBlLl9nZXRWYXJTeW1ib2wgPSBmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbWFrZVN5bWJvbChTeW1ib2xUeXBlLkV4dGVybmFsKTsgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zhck1hcC5zZXREZWZhdWx0KHZhcmlhYmxlLCBmYWN0b3J5KS5zZWNvbmQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgUm93IG9iamVjdCBmb3IgdGhlIGdpdmVuIGNvbnN0cmFpbnQuXG4gICAgICpcbiAgICAgKiBUaGUgdGVybXMgaW4gdGhlIGNvbnN0cmFpbnQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2VsbHMgaW4gdGhlIHJvdy5cbiAgICAgKiBBbnkgdGVybSBpbiB0aGUgY29uc3RyYWludCB3aXRoIGEgY29lZmZpY2llbnQgb2YgemVybyBpcyBpZ25vcmVkLlxuICAgICAqIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGBfZ2V0VmFyU3ltYm9sYCBtZXRob2QgdG8gZ2V0IHRoZSBzeW1ib2wgZm9yXG4gICAgICogdGhlIHZhcmlhYmxlcyBhZGRlZCB0byB0aGUgcm93LiBJZiB0aGUgc3ltYm9sIGZvciBhIGdpdmVuIGNlbGxcbiAgICAgKiB2YXJpYWJsZSBpcyBiYXNpYywgdGhlIGNlbGwgdmFyaWFibGUgd2lsbCBiZSBzdWJzdGl0dXRlZCB3aXRoIHRoZVxuICAgICAqIGJhc2ljIHJvdy5cbiAgICAgKlxuICAgICAqIFRoZSBuZWNlc3Nhcnkgc2xhY2sgYW5kIGVycm9yIHZhcmlhYmxlcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSByb3cuXG4gICAgICogSWYgdGhlIGNvbnN0YW50IGZvciB0aGUgcm93IGlzIG5lZ2F0aXZlLCB0aGUgc2lnbiBmb3IgdGhlIHJvd1xuICAgICAqIHdpbGwgYmUgaW52ZXJ0ZWQgc28gdGhlIGNvbnN0YW50IGJlY29tZXMgcG9zaXRpdmUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBjcmVhdGVkIFJvdyBhbmQgdGhlIHRhZyBmb3IgdHJhY2tpbmcgdGhlIGNvbnN0cmFpbnQuXG4gICAgICovXG4gICAgU29sdmVyLnByb3RvdHlwZS5fY3JlYXRlUm93ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBjb25zdHJhaW50LmV4cHJlc3Npb247XG4gICAgICAgIHZhciByb3cgPSBuZXcgUm93KGV4cHIuY29uc3RhbnQpO1xuICAgICAgICAvLyBTdWJzdGl0dXRlIHRoZSBjdXJyZW50IGJhc2ljIHZhcmlhYmxlcyBpbnRvIHRoZSByb3cuXG4gICAgICAgIHZhciB0ZXJtcyA9IGV4cHIudGVybXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGVybXMuc2l6ZSgpOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdGVybVBhaXIgPSB0ZXJtcy5pdGVtQXQoaSk7XG4gICAgICAgICAgICBpZiAoIW5lYXJaZXJvKHRlcm1QYWlyLnNlY29uZCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gdGhpcy5fZ2V0VmFyU3ltYm9sKHRlcm1QYWlyLmZpcnN0KTtcbiAgICAgICAgICAgICAgICB2YXIgYmFzaWNQYWlyID0gdGhpcy5fcm93TWFwLmZpbmQoc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBpZiAoYmFzaWNQYWlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93Lmluc2VydFJvdyhiYXNpY1BhaXIuc2Vjb25kLCB0ZXJtUGFpci5zZWNvbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm93Lmluc2VydFN5bWJvbChzeW1ib2wsIHRlcm1QYWlyLnNlY29uZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgbmVjZXNzYXJ5IHNsYWNrLCBlcnJvciwgYW5kIGR1bW15IHZhcmlhYmxlcy5cbiAgICAgICAgdmFyIG9iamVjdGl2ZSA9IHRoaXMuX29iamVjdGl2ZTtcbiAgICAgICAgdmFyIHN0cmVuZ3RoID0gY29uc3RyYWludC5zdHJlbmd0aDtcbiAgICAgICAgdmFyIHRhZyA9IHsgbWFya2VyOiBJTlZBTElEX1NZTUJPTCwgb3RoZXI6IElOVkFMSURfU1lNQk9MIH07XG4gICAgICAgIHN3aXRjaCAoY29uc3RyYWludC5vcCkge1xuICAgICAgICAgICAgY2FzZSBjb25zdHJhaW50XzEuT3BlcmF0b3IuTGU6XG4gICAgICAgICAgICBjYXNlIGNvbnN0cmFpbnRfMS5PcGVyYXRvci5HZTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2VmZiA9IGNvbnN0cmFpbnQub3AgPT09IGNvbnN0cmFpbnRfMS5PcGVyYXRvci5MZSA/IDEuMCA6IC0xLjA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbGFjayA9IHRoaXMuX21ha2VTeW1ib2woU3ltYm9sVHlwZS5TbGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHRhZy5tYXJrZXIgPSBzbGFjaztcbiAgICAgICAgICAgICAgICAgICAgcm93Lmluc2VydFN5bWJvbChzbGFjaywgY29lZmYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZW5ndGggPCBzdHJlbmd0aF8xLlN0cmVuZ3RoLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLl9tYWtlU3ltYm9sKFN5bWJvbFR5cGUuRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnLm90aGVyID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cuaW5zZXJ0U3ltYm9sKGVycm9yLCAtY29lZmYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0aXZlLmluc2VydFN5bWJvbChlcnJvciwgc3RyZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgY29uc3RyYWludF8xLk9wZXJhdG9yLkVxOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmVuZ3RoIDwgc3RyZW5ndGhfMS5TdHJlbmd0aC5yZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycnBsdXMgPSB0aGlzLl9tYWtlU3ltYm9sKFN5bWJvbFR5cGUuRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm1pbnVzID0gdGhpcy5fbWFrZVN5bWJvbChTeW1ib2xUeXBlLkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZy5tYXJrZXIgPSBlcnJwbHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnLm90aGVyID0gZXJybWludXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cuaW5zZXJ0U3ltYm9sKGVycnBsdXMsIC0xLjApOyAvLyB2ID0gZXBsdXMgLSBlbWludXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5pbnNlcnRTeW1ib2woZXJybWludXMsIDEuMCk7IC8vIHYgLSBlcGx1cyArIGVtaW51cyA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdGl2ZS5pbnNlcnRTeW1ib2woZXJycGx1cywgc3RyZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0aXZlLmluc2VydFN5bWJvbChlcnJtaW51cywgc3RyZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR1bW15ID0gdGhpcy5fbWFrZVN5bWJvbChTeW1ib2xUeXBlLkR1bW15KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZy5tYXJrZXIgPSBkdW1teTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5pbnNlcnRTeW1ib2woZHVtbXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHJvdyBoYXMgYSBwb3NpdGl2ZSBjb25zdGFudC5cbiAgICAgICAgaWYgKHJvdy5jb25zdGFudCgpIDwgMC4wKSB7XG4gICAgICAgICAgICByb3cucmV2ZXJzZVNpZ24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByb3c6IHJvdywgdGFnOiB0YWcgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENob29zZSB0aGUgc3ViamVjdCBmb3Igc29sdmluZyBmb3IgdGhlIHJvdy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2hvb3NlIHRoZSBiZXN0IHN1YmplY3QgZm9yIHVzaW5nIGFzIHRoZSBzb2x2ZVxuICAgICAqIHRhcmdldCBmb3IgdGhlIHJvdy4gQW4gaW52YWxpZCBzeW1ib2wgd2lsbCBiZSByZXR1cm5lZCBpZiB0aGVyZVxuICAgICAqIGlzIG5vIHZhbGlkIHRhcmdldC5cbiAgICAgKlxuICAgICAqIFRoZSBzeW1ib2xzIGFyZSBjaG9zZW4gYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmcgcHJlY2VkZW5jZTpcbiAgICAgKlxuICAgICAqIDEpIFRoZSBmaXJzdCBzeW1ib2wgcmVwcmVzZW50aW5nIGFuIGV4dGVybmFsIHZhcmlhYmxlLlxuICAgICAqIDIpIEEgbmVnYXRpdmUgc2xhY2sgb3IgZXJyb3IgdGFnIHZhcmlhYmxlLlxuICAgICAqXG4gICAgICogSWYgYSBzdWJqZWN0IGNhbm5vdCBiZSBmb3VuZCwgYW4gaW52YWxpZCBzeW1ib2wgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBTb2x2ZXIucHJvdG90eXBlLl9jaG9vc2VTdWJqZWN0ID0gZnVuY3Rpb24gKHJvdywgdGFnKSB7XG4gICAgICAgIHZhciBjZWxscyA9IHJvdy5jZWxscygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNlbGxzLnNpemUoKTsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBjZWxscy5pdGVtQXQoaSk7XG4gICAgICAgICAgICBpZiAocGFpci5maXJzdC50eXBlKCkgPT09IFN5bWJvbFR5cGUuRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFpci5maXJzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZSA9IHRhZy5tYXJrZXIudHlwZSgpO1xuICAgICAgICBpZiAodHlwZSA9PT0gU3ltYm9sVHlwZS5TbGFjayB8fCB0eXBlID09PSBTeW1ib2xUeXBlLkVycm9yKSB7XG4gICAgICAgICAgICBpZiAocm93LmNvZWZmaWNpZW50Rm9yKHRhZy5tYXJrZXIpIDwgMC4wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZy5tYXJrZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHlwZSA9IHRhZy5vdGhlci50eXBlKCk7XG4gICAgICAgIGlmICh0eXBlID09PSBTeW1ib2xUeXBlLlNsYWNrIHx8IHR5cGUgPT09IFN5bWJvbFR5cGUuRXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChyb3cuY29lZmZpY2llbnRGb3IodGFnLm90aGVyKSA8IDAuMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YWcub3RoZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIElOVkFMSURfU1lNQk9MO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSByb3cgdG8gdGhlIHRhYmxlYXUgdXNpbmcgYW4gYXJ0aWZpY2lhbCB2YXJpYWJsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCByZXR1cm4gZmFsc2UgaWYgdGhlIGNvbnN0cmFpbnQgY2Fubm90IGJlIHNhdGlzZmllZC5cbiAgICAgKi9cbiAgICBTb2x2ZXIucHJvdG90eXBlLl9hZGRXaXRoQXJ0aWZpY2lhbFZhcmlhYmxlID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCB0aGUgYXJ0aWZpY2lhbCB2YXJpYWJsZSB0byB0aGUgdGFibGVhdS5cbiAgICAgICAgdmFyIGFydCA9IHRoaXMuX21ha2VTeW1ib2woU3ltYm9sVHlwZS5TbGFjayk7XG4gICAgICAgIHRoaXMuX3Jvd01hcC5pbnNlcnQoYXJ0LCByb3cuY29weSgpKTtcbiAgICAgICAgdGhpcy5fYXJ0aWZpY2lhbCA9IHJvdy5jb3B5KCk7XG4gICAgICAgIC8vIE9wdGltaXplIHRoZSBhcnRpZmljaWFsIG9iamVjdGl2ZS4gVGhpcyBpcyBzdWNjZXNzZnVsXG4gICAgICAgIC8vIG9ubHkgaWYgdGhlIGFydGlmaWNpYWwgb2JqZWN0aXZlIGlzIG9wdGltaXplZCB0byB6ZXJvLlxuICAgICAgICB0aGlzLl9vcHRpbWl6ZSh0aGlzLl9hcnRpZmljaWFsKTtcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBuZWFyWmVybyh0aGlzLl9hcnRpZmljaWFsLmNvbnN0YW50KCkpO1xuICAgICAgICB0aGlzLl9hcnRpZmljaWFsID0gbnVsbDtcbiAgICAgICAgLy8gSWYgdGhlIGFydGlmaWNpYWwgdmFyaWFibGUgaXMgYmFzaWMsIHBpdm90IHRoZSByb3cgc28gdGhhdFxuICAgICAgICAvLyBpdCBiZWNvbWVzIG5vbi1iYXNpYy4gSWYgdGhlIHJvdyBpcyBjb25zdGFudCwgZXhpdCBlYXJseS5cbiAgICAgICAgdmFyIHBhaXIgPSB0aGlzLl9yb3dNYXAuZXJhc2UoYXJ0KTtcbiAgICAgICAgaWYgKHBhaXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGJhc2ljUm93ID0gcGFpci5zZWNvbmQ7XG4gICAgICAgICAgICBpZiAoYmFzaWNSb3cuaXNDb25zdGFudCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZW50ZXJpbmcgPSB0aGlzLl9hbnlQaXZvdGFibGVTeW1ib2woYmFzaWNSb3cpO1xuICAgICAgICAgICAgaWYgKGVudGVyaW5nLnR5cGUoKSA9PT0gU3ltYm9sVHlwZS5JbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB1bnNhdGlzZmlhYmxlICh3aWxsIHRoaXMgZXZlciBoYXBwZW4/KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFzaWNSb3cuc29sdmVGb3JFeChhcnQsIGVudGVyaW5nKTtcbiAgICAgICAgICAgIHRoaXMuX3N1YnN0aXR1dGUoZW50ZXJpbmcsIGJhc2ljUm93KTtcbiAgICAgICAgICAgIHRoaXMuX3Jvd01hcC5pbnNlcnQoZW50ZXJpbmcsIGJhc2ljUm93KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGFydGlmaWNpYWwgdmFyaWFibGUgZnJvbSB0aGUgdGFibGVhdS5cbiAgICAgICAgdmFyIHJvd3MgPSB0aGlzLl9yb3dNYXA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcm93cy5zaXplKCk7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHJvd3MuaXRlbUF0KGkpLnNlY29uZC5yZW1vdmVTeW1ib2woYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vYmplY3RpdmUucmVtb3ZlU3ltYm9sKGFydCk7XG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3Vic3RpdHV0ZSB0aGUgcGFyYW1ldHJpYyBzeW1ib2wgd2l0aCB0aGUgZ2l2ZW4gcm93LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBzdWJzdGl0dXRlIGFsbCBpbnN0YW5jZXMgb2YgdGhlIHBhcmFtZXRyaWMgc3ltYm9sXG4gICAgICogaW4gdGhlIHRhYmxlYXUgYW5kIHRoZSBvYmplY3RpdmUgZnVuY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gcm93LlxuICAgICAqL1xuICAgIFNvbHZlci5wcm90b3R5cGUuX3N1YnN0aXR1dGUgPSBmdW5jdGlvbiAoc3ltYm9sLCByb3cpIHtcbiAgICAgICAgdmFyIHJvd3MgPSB0aGlzLl9yb3dNYXA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcm93cy5zaXplKCk7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gcm93cy5pdGVtQXQoaSk7XG4gICAgICAgICAgICBwYWlyLnNlY29uZC5zdWJzdGl0dXRlKHN5bWJvbCwgcm93KTtcbiAgICAgICAgICAgIGlmIChwYWlyLnNlY29uZC5jb25zdGFudCgpIDwgMC4wICYmXG4gICAgICAgICAgICAgICAgcGFpci5maXJzdC50eXBlKCkgIT09IFN5bWJvbFR5cGUuRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmZlYXNpYmxlUm93cy5wdXNoKHBhaXIuZmlyc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29iamVjdGl2ZS5zdWJzdGl0dXRlKHN5bWJvbCwgcm93KTtcbiAgICAgICAgaWYgKHRoaXMuX2FydGlmaWNpYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2FydGlmaWNpYWwuc3Vic3RpdHV0ZShzeW1ib2wsIHJvdyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9wdGltaXplIHRoZSBzeXN0ZW0gZm9yIHRoZSBnaXZlbiBvYmplY3RpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyBpdGVyYXRpb25zIG9mIFBoYXNlIDIgb2YgdGhlIHNpbXBsZXggbWV0aG9kXG4gICAgICogdW50aWwgdGhlIG9iamVjdGl2ZSBmdW5jdGlvbiByZWFjaGVzIGEgbWluaW11bS5cbiAgICAgKi9cbiAgICBTb2x2ZXIucHJvdG90eXBlLl9vcHRpbWl6ZSA9IGZ1bmN0aW9uIChvYmplY3RpdmUpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBlbnRlcmluZyA9IHRoaXMuX2dldEVudGVyaW5nU3ltYm9sKG9iamVjdGl2ZSk7XG4gICAgICAgICAgICBpZiAoZW50ZXJpbmcudHlwZSgpID09PSBTeW1ib2xUeXBlLkludmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVhdmluZyA9IHRoaXMuX2dldExlYXZpbmdTeW1ib2woZW50ZXJpbmcpO1xuICAgICAgICAgICAgaWYgKGxlYXZpbmcudHlwZSgpID09PSBTeW1ib2xUeXBlLkludmFsaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgb2JqZWN0aXZlIGlzIHVuYm91bmRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHBpdm90IHRoZSBlbnRlcmluZyBzeW1ib2wgaW50byB0aGUgYmFzaXNcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLl9yb3dNYXAuZXJhc2UobGVhdmluZykuc2Vjb25kO1xuICAgICAgICAgICAgcm93LnNvbHZlRm9yRXgobGVhdmluZywgZW50ZXJpbmcpO1xuICAgICAgICAgICAgdGhpcy5fc3Vic3RpdHV0ZShlbnRlcmluZywgcm93KTtcbiAgICAgICAgICAgIHRoaXMuX3Jvd01hcC5pbnNlcnQoZW50ZXJpbmcsIHJvdyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9wdGltaXplIHRoZSBzeXN0ZW0gdXNpbmcgdGhlIGR1YWwgb2YgdGhlIHNpbXBsZXggbWV0aG9kLlxuICAgICAqXG4gICAgICogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHN5c3RlbSBzaG91bGQgYmUgc3VjaCB0aGF0IHRoZSBvYmplY3RpdmVcbiAgICAgKiBmdW5jdGlvbiBpcyBvcHRpbWFsLCBidXQgbm90IGZlYXNpYmxlLiBUaGlzIG1ldGhvZCB3aWxsIHBlcmZvcm1cbiAgICAgKiBhbiBpdGVyYXRpb24gb2YgdGhlIGR1YWwgc2ltcGxleCBtZXRob2QgdG8gbWFrZSB0aGUgc29sdXRpb24gYm90aFxuICAgICAqIG9wdGltYWwgYW5kIGZlYXNpYmxlLlxuICAgICAqL1xuICAgIFNvbHZlci5wcm90b3R5cGUuX2R1YWxPcHRpbWl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvd3MgPSB0aGlzLl9yb3dNYXA7XG4gICAgICAgIHZhciBpbmZlYXNpYmxlID0gdGhpcy5faW5mZWFzaWJsZVJvd3M7XG4gICAgICAgIHdoaWxlIChpbmZlYXNpYmxlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIGxlYXZpbmcgPSBpbmZlYXNpYmxlLnBvcCgpO1xuICAgICAgICAgICAgdmFyIHBhaXIgPSByb3dzLmZpbmQobGVhdmluZyk7XG4gICAgICAgICAgICBpZiAocGFpciAhPT0gdW5kZWZpbmVkICYmIHBhaXIuc2Vjb25kLmNvbnN0YW50KCkgPCAwLjApIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50ZXJpbmcgPSB0aGlzLl9nZXREdWFsRW50ZXJpbmdTeW1ib2wocGFpci5zZWNvbmQpO1xuICAgICAgICAgICAgICAgIGlmIChlbnRlcmluZy50eXBlKCkgPT09IFN5bWJvbFR5cGUuSW52YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkdWFsIG9wdGltaXplIGZhaWxlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcGl2b3QgdGhlIGVudGVyaW5nIHN5bWJvbCBpbnRvIHRoZSBiYXNpc1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBwYWlyLnNlY29uZDtcbiAgICAgICAgICAgICAgICByb3dzLmVyYXNlKGxlYXZpbmcpO1xuICAgICAgICAgICAgICAgIHJvdy5zb2x2ZUZvckV4KGxlYXZpbmcsIGVudGVyaW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzdGl0dXRlKGVudGVyaW5nLCByb3cpO1xuICAgICAgICAgICAgICAgIHJvd3MuaW5zZXJ0KGVudGVyaW5nLCByb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBlbnRlcmluZyB2YXJpYWJsZSBmb3IgYSBwaXZvdCBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBmaXJzdCBzeW1ib2wgaW4gdGhlIG9iamVjdGl2ZSBmdW5jdGlvbiB3aGljaFxuICAgICAqIGlzIG5vbi1kdW1teSBhbmQgaGFzIGEgY29lZmZpY2llbnQgbGVzcyB0aGFuIHplcm8uIElmIG5vIHN5bWJvbCBtZWV0c1xuICAgICAqIHRoZSBjcml0ZXJpYSwgaXQgbWVhbnMgdGhlIG9iamVjdGl2ZSBmdW5jdGlvbiBpcyBhdCBhIG1pbmltdW0sIGFuZCBhblxuICAgICAqIGludmFsaWQgc3ltYm9sIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIFNvbHZlci5wcm90b3R5cGUuX2dldEVudGVyaW5nU3ltYm9sID0gZnVuY3Rpb24gKG9iamVjdGl2ZSkge1xuICAgICAgICB2YXIgY2VsbHMgPSBvYmplY3RpdmUuY2VsbHMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjZWxscy5zaXplKCk7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gY2VsbHMuaXRlbUF0KGkpO1xuICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHBhaXIuZmlyc3Q7XG4gICAgICAgICAgICBpZiAocGFpci5zZWNvbmQgPCAwLjAgJiYgc3ltYm9sLnR5cGUoKSAhPT0gU3ltYm9sVHlwZS5EdW1teSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIElOVkFMSURfU1lNQk9MO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgZW50ZXJpbmcgc3ltYm9sIGZvciB0aGUgZHVhbCBvcHRpbWl6ZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc3ltYm9sIGluIHRoZSByb3cgd2hpY2ggaGFzIGEgcG9zaXRpdmVcbiAgICAgKiBjb2VmZmljaWVudCBhbmQgeWllbGRzIHRoZSBtaW5pbXVtIHJhdGlvIGZvciBpdHMgcmVzcGVjdGl2ZSBzeW1ib2xcbiAgICAgKiBpbiB0aGUgb2JqZWN0aXZlIGZ1bmN0aW9uLiBUaGUgcHJvdmlkZWQgcm93ICptdXN0KiBiZSBpbmZlYXNpYmxlLlxuICAgICAqIElmIG5vIHN5bWJvbCBpcyBmb3VuZCB3aGljaCBtZWF0cyB0aGUgY3JpdGVyaWEsIGFuIGludmFsaWQgc3ltYm9sXG4gICAgICogaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgU29sdmVyLnByb3RvdHlwZS5fZ2V0RHVhbEVudGVyaW5nU3ltYm9sID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgcmF0aW8gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBJTlZBTElEX1NZTUJPTDtcbiAgICAgICAgdmFyIGNlbGxzID0gcm93LmNlbGxzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY2VsbHMuc2l6ZSgpOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IGNlbGxzLml0ZW1BdChpKTtcbiAgICAgICAgICAgIHZhciBzeW1ib2wgPSBwYWlyLmZpcnN0O1xuICAgICAgICAgICAgdmFyIGMgPSBwYWlyLnNlY29uZDtcbiAgICAgICAgICAgIGlmIChjID4gMC4wICYmIHN5bWJvbC50eXBlKCkgIT09IFN5bWJvbFR5cGUuRHVtbXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29lZmYgPSB0aGlzLl9vYmplY3RpdmUuY29lZmZpY2llbnRGb3Ioc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGNvZWZmIC8gYztcbiAgICAgICAgICAgICAgICBpZiAociA8IHJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhdGlvID0gcjtcbiAgICAgICAgICAgICAgICAgICAgZW50ZXJpbmcgPSBzeW1ib2w7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRlcmluZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIHN5bWJvbCBmb3IgcGl2b3QgZXhpdCByb3cuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc3ltYm9sIGZvciB0aGUgZXhpdCByb3cgaW4gdGhlIHJvd1xuICAgICAqIG1hcC4gSWYgbm8gYXBwcm9wcmlhdGUgZXhpdCBzeW1ib2wgaXMgZm91bmQsIGFuIGludmFsaWQgc3ltYm9sXG4gICAgICogd2lsbCBiZSByZXR1cm5lZC4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB0aGUgb2JqZWN0aXZlIGZ1bmN0aW9uIGlzXG4gICAgICogdW5ib3VuZGVkLlxuICAgICAqL1xuICAgIFNvbHZlci5wcm90b3R5cGUuX2dldExlYXZpbmdTeW1ib2wgPSBmdW5jdGlvbiAoZW50ZXJpbmcpIHtcbiAgICAgICAgdmFyIHJhdGlvID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIGZvdW5kID0gSU5WQUxJRF9TWU1CT0w7XG4gICAgICAgIHZhciByb3dzID0gdGhpcy5fcm93TWFwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHJvd3Muc2l6ZSgpOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IHJvd3MuaXRlbUF0KGkpO1xuICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHBhaXIuZmlyc3Q7XG4gICAgICAgICAgICBpZiAoc3ltYm9sLnR5cGUoKSAhPT0gU3ltYm9sVHlwZS5FeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBwYWlyLnNlY29uZDtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHJvdy5jb2VmZmljaWVudEZvcihlbnRlcmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXAgPCAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBfcmF0aW8gPSAtcm93LmNvbnN0YW50KCkgLyB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVtcF9yYXRpbyA8IHJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXRpbyA9IHRlbXBfcmF0aW87XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBsZWF2aW5nIHN5bWJvbCBmb3IgYSBtYXJrZXIgdmFyaWFibGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBhIHN5bWJvbCBjb3JyZXNwb25kaW5nIHRvIGEgYmFzaWMgcm93XG4gICAgICogd2hpY2ggaG9sZHMgdGhlIGdpdmVuIG1hcmtlciB2YXJpYWJsZS4gVGhlIHJvdyB3aWxsIGJlIGNob3NlblxuICAgICAqIGFjY29yZGluZyB0byB0aGUgZm9sbG93aW5nIHByZWNlZGVuY2U6XG4gICAgICpcbiAgICAgKiAxKSBUaGUgcm93IHdpdGggYSByZXN0cmljdGVkIGJhc2ljIHZhcmlibGUgYW5kIGEgbmVnYXRpdmUgY29lZmZpY2llbnRcbiAgICAgKiAgICBmb3IgdGhlIG1hcmtlciB3aXRoIHRoZSBzbWFsbGVzdCByYXRpbyBvZiAtY29uc3RhbnQgLyBjb2VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIDIpIFRoZSByb3cgd2l0aCBhIHJlc3RyaWN0ZWQgYmFzaWMgdmFyaWFibGUgYW5kIHRoZSBzbWFsbGVzdCByYXRpb1xuICAgICAqICAgIG9mIGNvbnN0YW50IC8gY29lZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiAzKSBUaGUgbGFzdCB1bnJlc3RyaWN0ZWQgcm93IHdoaWNoIGNvbnRhaW5zIHRoZSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgbWFya2VyIGRvZXMgbm90IGV4aXN0IGluIGFueSByb3csIGFuIGludmFsaWQgc3ltYm9sIHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC4gVGhpcyBpbmRpY2F0ZXMgYW4gaW50ZXJuYWwgc29sdmVyIGVycm9yIHNpbmNlIHRoZSBtYXJrZXJcbiAgICAgKiAqc2hvdWxkKiBleGlzdCBzb21ld2hlcmUgaW4gdGhlIHRhYmxlYXUuXG4gICAgICovXG4gICAgU29sdmVyLnByb3RvdHlwZS5fZ2V0TWFya2VyTGVhdmluZ1N5bWJvbCA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgdmFyIGRtYXggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB2YXIgcjEgPSBkbWF4O1xuICAgICAgICB2YXIgcjIgPSBkbWF4O1xuICAgICAgICB2YXIgaW52YWxpZCA9IElOVkFMSURfU1lNQk9MO1xuICAgICAgICB2YXIgZmlyc3QgPSBpbnZhbGlkO1xuICAgICAgICB2YXIgc2Vjb25kID0gaW52YWxpZDtcbiAgICAgICAgdmFyIHRoaXJkID0gaW52YWxpZDtcbiAgICAgICAgdmFyIHJvd3MgPSB0aGlzLl9yb3dNYXA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcm93cy5zaXplKCk7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gcm93cy5pdGVtQXQoaSk7XG4gICAgICAgICAgICB2YXIgcm93ID0gcGFpci5zZWNvbmQ7XG4gICAgICAgICAgICB2YXIgYyA9IHJvdy5jb2VmZmljaWVudEZvcihtYXJrZXIpO1xuICAgICAgICAgICAgaWYgKGMgPT09IDAuMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHBhaXIuZmlyc3Q7XG4gICAgICAgICAgICBpZiAoc3ltYm9sLnR5cGUoKSA9PT0gU3ltYm9sVHlwZS5FeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXJkID0gc3ltYm9sO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA8IDAuMCkge1xuICAgICAgICAgICAgICAgIHZhciByID0gLXJvdy5jb25zdGFudCgpIC8gYztcbiAgICAgICAgICAgICAgICBpZiAociA8IHIxKSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gcjtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBzeW1ib2w7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSByb3cuY29uc3RhbnQoKSAvIGM7XG4gICAgICAgICAgICAgICAgaWYgKHIgPCByMikge1xuICAgICAgICAgICAgICAgICAgICByMiA9IHI7XG4gICAgICAgICAgICAgICAgICAgIHNlY29uZCA9IHN5bWJvbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0ICE9PSBpbnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY29uZCAhPT0gaW52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlY29uZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcmQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGVmZmVjdHMgb2YgYSBjb25zdHJhaW50IG9uIHRoZSBvYmplY3RpdmUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgU29sdmVyLnByb3RvdHlwZS5fcmVtb3ZlQ29uc3RyYWludEVmZmVjdHMgPSBmdW5jdGlvbiAoY24sIHRhZykge1xuICAgICAgICBpZiAodGFnLm1hcmtlci50eXBlKCkgPT09IFN5bWJvbFR5cGUuRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZU1hcmtlckVmZmVjdHModGFnLm1hcmtlciwgY24uc3RyZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcub3RoZXIudHlwZSgpID09PSBTeW1ib2xUeXBlLkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVNYXJrZXJFZmZlY3RzKHRhZy5vdGhlciwgY24uc3RyZW5ndGgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGVmZmVjdHMgb2YgYW4gZXJyb3IgbWFya2VyIG9uIHRoZSBvYmplY3RpdmUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgU29sdmVyLnByb3RvdHlwZS5fcmVtb3ZlTWFya2VyRWZmZWN0cyA9IGZ1bmN0aW9uIChtYXJrZXIsIHN0cmVuZ3RoKSB7XG4gICAgICAgIHZhciBwYWlyID0gdGhpcy5fcm93TWFwLmZpbmQobWFya2VyKTtcbiAgICAgICAgaWYgKHBhaXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fb2JqZWN0aXZlLmluc2VydFJvdyhwYWlyLnNlY29uZCwgLXN0cmVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdGl2ZS5pbnNlcnRTeW1ib2wobWFya2VyLCAtc3RyZW5ndGgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZpcnN0IFNsYWNrIG9yIEVycm9yIHN5bWJvbCBpbiB0aGUgcm93LlxuICAgICAqXG4gICAgICogSWYgbm8gc3VjaCBzeW1ib2wgaXMgcHJlc2VudCwgYW4gaW52YWxpZCBzeW1ib2wgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBTb2x2ZXIucHJvdG90eXBlLl9hbnlQaXZvdGFibGVTeW1ib2wgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBjZWxscyA9IHJvdy5jZWxscygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNlbGxzLnNpemUoKTsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBjZWxscy5pdGVtQXQoaSk7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHBhaXIuZmlyc3QudHlwZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFN5bWJvbFR5cGUuU2xhY2sgfHwgdHlwZSA9PT0gU3ltYm9sVHlwZS5FcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWlyLmZpcnN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJTlZBTElEX1NZTUJPTDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgU3ltYm9sIG9mIHRoZSBnaXZlbiB0eXBlLlxuICAgICAqL1xuICAgIFNvbHZlci5wcm90b3R5cGUuX21ha2VTeW1ib2wgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCh0eXBlLCB0aGlzLl9pZFRpY2srKyk7XG4gICAgfTtcbiAgICByZXR1cm4gU29sdmVyO1xufSgpKTtcbmV4cG9ydHMuU29sdmVyID0gU29sdmVyO1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYSB2YWx1ZSBpcyBhcHByb3hpbWF0ZWx5IHplcm8uXG4gKi9cbmZ1bmN0aW9uIG5lYXJaZXJvKHZhbHVlKSB7XG4gICAgdmFyIGVwcyA9IDEuMGUtODtcbiAgICByZXR1cm4gdmFsdWUgPCAwLjAgPyAtdmFsdWUgPCBlcHMgOiB2YWx1ZSA8IGVwcztcbn1cbi8qKlxuICogQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgY29uc3RyYWludCBtYXAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNuTWFwKCkge1xuICAgIHJldHVybiBtYXB0eXBlXzEuY3JlYXRlTWFwKGNvbnN0cmFpbnRfMS5Db25zdHJhaW50LkNvbXBhcmUpO1xufVxuLyoqXG4gKiBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSByb3cgbWFwLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3dNYXAoKSB7XG4gICAgcmV0dXJuIG1hcHR5cGVfMS5jcmVhdGVNYXAoU3ltYm9sLkNvbXBhcmUpO1xufVxuLyoqXG4gKiBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSB2YXJpYWJsZSBtYXAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVZhck1hcCgpIHtcbiAgICByZXR1cm4gbWFwdHlwZV8xLmNyZWF0ZU1hcCh2YXJpYWJsZV8xLlZhcmlhYmxlLkNvbXBhcmUpO1xufVxuLyoqXG4gKiBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYW4gZWRpdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVkaXRNYXAoKSB7XG4gICAgcmV0dXJuIG1hcHR5cGVfMS5jcmVhdGVNYXAodmFyaWFibGVfMS5WYXJpYWJsZS5Db21wYXJlKTtcbn1cbi8qKlxuICogQW4gZW51bSBkZWZpbmluZyB0aGUgYXZhaWxhYmxlIHN5bWJvbCB0eXBlcy5cbiAqL1xudmFyIFN5bWJvbFR5cGU7XG4oZnVuY3Rpb24gKFN5bWJvbFR5cGUpIHtcbiAgICBTeW1ib2xUeXBlW1N5bWJvbFR5cGVbXCJJbnZhbGlkXCJdID0gMF0gPSBcIkludmFsaWRcIjtcbiAgICBTeW1ib2xUeXBlW1N5bWJvbFR5cGVbXCJFeHRlcm5hbFwiXSA9IDFdID0gXCJFeHRlcm5hbFwiO1xuICAgIFN5bWJvbFR5cGVbU3ltYm9sVHlwZVtcIlNsYWNrXCJdID0gMl0gPSBcIlNsYWNrXCI7XG4gICAgU3ltYm9sVHlwZVtTeW1ib2xUeXBlW1wiRXJyb3JcIl0gPSAzXSA9IFwiRXJyb3JcIjtcbiAgICBTeW1ib2xUeXBlW1N5bWJvbFR5cGVbXCJEdW1teVwiXSA9IDRdID0gXCJEdW1teVwiO1xufSkoU3ltYm9sVHlwZSB8fCAoU3ltYm9sVHlwZSA9IHt9KSk7XG4vKipcbiAqIEFuIGludGVybmFsIGNsYXNzIHJlcHJlc2VudGluZyBhIHN5bWJvbCBpbiB0aGUgc29sdmVyLlxuICovXG52YXIgU3ltYm9sID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgU3ltYm9sXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW3R5cGVdIFRoZSB0eXBlIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIFtpZF0gVGhlIHVuaXF1ZSBpZCBudW1iZXIgb2YgdGhlIHN5bWJvbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTeW1ib2wodHlwZSwgaWQpIHtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzdGF0aWMgU3ltYm9sIGNvbXBhcmlzb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgU3ltYm9sLkNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5pZCgpIC0gYi5pZCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5pcXVlIGlkIG51bWJlciBvZiB0aGUgc3ltYm9sLlxuICAgICAqL1xuICAgIFN5bWJvbC5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHR5cGUgb2YgdGhlIHN5bWJvbC5cbiAgICAgKi9cbiAgICBTeW1ib2wucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH07XG4gICAgcmV0dXJuIFN5bWJvbDtcbn0oKSk7XG4vKipcbiAqIEEgc3RhdGljIGludmFsaWQgc3ltYm9sXG4gKi9cbnZhciBJTlZBTElEX1NZTUJPTCA9IG5ldyBTeW1ib2woU3ltYm9sVHlwZS5JbnZhbGlkLCAtMSk7XG4vKipcbiAqIEFuIGludGVybmFsIHJvdyBjbGFzcyB1c2VkIGJ5IHRoZSBzb2x2ZXIuXG4gKi9cbnZhciBSb3cgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBSb3cuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUm93KGNvbnN0YW50KSB7XG4gICAgICAgIGlmIChjb25zdGFudCA9PT0gdm9pZCAwKSB7IGNvbnN0YW50ID0gMC4wOyB9XG4gICAgICAgIHRoaXMuX2NlbGxNYXAgPSBtYXB0eXBlXzEuY3JlYXRlTWFwKFN5bWJvbC5Db21wYXJlKTtcbiAgICAgICAgdGhpcy5fY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWFwcGluZyBvZiBzeW1ib2xzIHRvIGNvZWZmaWNpZW50cy5cbiAgICAgKi9cbiAgICBSb3cucHJvdG90eXBlLmNlbGxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2VsbE1hcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnN0YW50IGZvciB0aGUgcm93LlxuICAgICAqL1xuICAgIFJvdy5wcm90b3R5cGUuY29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25zdGFudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcm93IGlzIGEgY29uc3RhbnQgdmFsdWUuXG4gICAgICovXG4gICAgUm93LnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2VsbE1hcC5lbXB0eSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBSb3cgaGFzIGFsbCBkdW1teSBzeW1ib2xzLlxuICAgICAqL1xuICAgIFJvdy5wcm90b3R5cGUuYWxsRHVtbWllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNlbGxzID0gdGhpcy5fY2VsbE1hcDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjZWxscy5zaXplKCk7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gY2VsbHMuaXRlbUF0KGkpO1xuICAgICAgICAgICAgaWYgKHBhaXIuZmlyc3QudHlwZSgpICE9PSBTeW1ib2xUeXBlLkR1bW15KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY29weSBvZiB0aGUgcm93LlxuICAgICAqL1xuICAgIFJvdy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRoZUNvcHkgPSBuZXcgUm93KHRoaXMuX2NvbnN0YW50KTtcbiAgICAgICAgdGhlQ29weS5fY2VsbE1hcCA9IHRoaXMuX2NlbGxNYXAuY29weSgpO1xuICAgICAgICByZXR1cm4gdGhlQ29weTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIGNvbnN0YW50IHZhbHVlIHRvIHRoZSByb3cgY29uc3RhbnQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXcgdmFsdWUgb2YgdGhlIGNvbnN0YW50LlxuICAgICAqL1xuICAgIFJvdy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25zdGFudCArPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluc2VydCB0aGUgc3ltYm9sIGludG8gdGhlIHJvdyB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBzeW1ib2wgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHJvdywgdGhlIGNvZWZmaWNpZW50XG4gICAgICogd2lsbCBiZSBhZGRlZCB0byB0aGUgZXhpc3RpbmcgY29lZmZpY2llbnQuIElmIHRoZSByZXN1bHRpbmdcbiAgICAgKiBjb2VmZmljaWVudCBpcyB6ZXJvLCB0aGUgc3ltYm9sIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSByb3cuXG4gICAgICovXG4gICAgUm93LnByb3RvdHlwZS5pbnNlcnRTeW1ib2wgPSBmdW5jdGlvbiAoc3ltYm9sLCBjb2VmZmljaWVudCkge1xuICAgICAgICBpZiAoY29lZmZpY2llbnQgPT09IHZvaWQgMCkgeyBjb2VmZmljaWVudCA9IDEuMDsgfVxuICAgICAgICB2YXIgcGFpciA9IHRoaXMuX2NlbGxNYXAuc2V0RGVmYXVsdChzeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAuMDsgfSk7XG4gICAgICAgIGlmIChuZWFyWmVybyhwYWlyLnNlY29uZCArPSBjb2VmZmljaWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NlbGxNYXAuZXJhc2Uoc3ltYm9sKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgcm93IGludG8gdGhpcyByb3cgd2l0aCBhIGdpdmVuIGNvZWZmaWNpZW50LlxuICAgICAqXG4gICAgICogVGhlIGNvbnN0YW50IGFuZCB0aGUgY2VsbHMgb2YgdGhlIG90aGVyIHJvdyB3aWxsIGJlXG4gICAgICogbXVsdGlwbGllZCBieSB0aGUgY29lZmZpY2llbnQgYW5kIGFkZGVkIHRvIHRoaXMgcm93LiBBbnlcbiAgICAgKiBjZWxsIHdpdGggYSByZXN1bHRpbmcgY29lZmZpY2llbnQgb2YgemVybyB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKiBmcm9tIHRoZSByb3cuXG4gICAgICovXG4gICAgUm93LnByb3RvdHlwZS5pbnNlcnRSb3cgPSBmdW5jdGlvbiAob3RoZXIsIGNvZWZmaWNpZW50KSB7XG4gICAgICAgIGlmIChjb2VmZmljaWVudCA9PT0gdm9pZCAwKSB7IGNvZWZmaWNpZW50ID0gMS4wOyB9XG4gICAgICAgIHRoaXMuX2NvbnN0YW50ICs9IG90aGVyLl9jb25zdGFudCAqIGNvZWZmaWNpZW50O1xuICAgICAgICB2YXIgY2VsbHMgPSBvdGhlci5fY2VsbE1hcDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjZWxscy5zaXplKCk7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gY2VsbHMuaXRlbUF0KGkpO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRTeW1ib2wocGFpci5maXJzdCwgcGFpci5zZWNvbmQgKiBjb2VmZmljaWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHN5bWJvbCBmcm9tIHRoZSByb3cuXG4gICAgICovXG4gICAgUm93LnByb3RvdHlwZS5yZW1vdmVTeW1ib2wgPSBmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgICAgIHRoaXMuX2NlbGxNYXAuZXJhc2Uoc3ltYm9sKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldmVyc2UgdGhlIHNpZ24gb2YgdGhlIGNvbnN0YW50IGFuZCBjZWxscyBpbiB0aGUgcm93LlxuICAgICAqL1xuICAgIFJvdy5wcm90b3R5cGUucmV2ZXJzZVNpZ24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NvbnN0YW50ID0gLXRoaXMuX2NvbnN0YW50O1xuICAgICAgICB2YXIgY2VsbHMgPSB0aGlzLl9jZWxsTWFwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNlbGxzLnNpemUoKTsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBjZWxscy5pdGVtQXQoaSk7XG4gICAgICAgICAgICBwYWlyLnNlY29uZCA9IC1wYWlyLnNlY29uZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU29sdmUgdGhlIHJvdyBmb3IgdGhlIGdpdmVuIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFzc3VtZXMgdGhlIHJvdyBpcyBvZiB0aGUgZm9ybVxuICAgICAqIGEgKiB4ICsgYiAqIHkgKyBjID0gMCBhbmQgKGFzc3VtaW5nIHNvbHZlIGZvciB4KSB3aWxsIG1vZGlmeVxuICAgICAqIHRoZSByb3cgdG8gcmVwcmVzZW50IHRoZSByaWdodCBoYW5kIHNpZGUgb2ZcbiAgICAgKiB4ID0gLWIvYSAqIHkgLSBjIC8gYS4gVGhlIHRhcmdldCBzeW1ib2wgd2lsbCBiZSByZW1vdmVkIGZyb21cbiAgICAgKiB0aGUgcm93LCBhbmQgdGhlIGNvbnN0YW50IGFuZCBvdGhlciBjZWxscyB3aWxsIGJlIG11bHRpcGxpZWRcbiAgICAgKiBieSB0aGUgbmVnYXRpdmUgaW52ZXJzZSBvZiB0aGUgdGFyZ2V0IGNvZWZmaWNpZW50LlxuICAgICAqXG4gICAgICogVGhlIGdpdmVuIHN5bWJvbCAqbXVzdCogZXhpc3QgaW4gdGhlIHJvdy5cbiAgICAgKi9cbiAgICBSb3cucHJvdG90eXBlLnNvbHZlRm9yID0gZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICB2YXIgY2VsbHMgPSB0aGlzLl9jZWxsTWFwO1xuICAgICAgICB2YXIgcGFpciA9IGNlbGxzLmVyYXNlKHN5bWJvbCk7XG4gICAgICAgIHZhciBjb2VmZiA9IC0xLjAgLyBwYWlyLnNlY29uZDtcbiAgICAgICAgdGhpcy5fY29uc3RhbnQgKj0gY29lZmY7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY2VsbHMuc2l6ZSgpOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBjZWxscy5pdGVtQXQoaSkuc2Vjb25kICo9IGNvZWZmO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTb2x2ZSB0aGUgcm93IGZvciB0aGUgZ2l2ZW4gc3ltYm9scy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFzc3VtZXMgdGhlIHJvdyBpcyBvZiB0aGUgZm9ybVxuICAgICAqIHggPSBiICogeSArIGMgYW5kIHdpbGwgc29sdmUgdGhlIHJvdyBzdWNoIHRoYXRcbiAgICAgKiB5ID0geCAvIGIgLSBjIC8gYi4gVGhlIHJocyBzeW1ib2wgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlXG4gICAgICogcm93LCB0aGUgbGhzIGFkZGVkLCBhbmQgdGhlIHJlc3VsdCBkaXZpZGVkIGJ5IHRoZSBuZWdhdGl2ZVxuICAgICAqIGludmVyc2Ugb2YgdGhlIHJocyBjb2VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIFRoZSBsaHMgc3ltYm9sICptdXN0IG5vdCogZXhpc3QgaW4gdGhlIHJvdywgYW5kIHRoZSByaHNcbiAgICAgKiBzeW1ib2wgbXVzdCogZXhpc3QgaW4gdGhlIHJvdy5cbiAgICAgKi9cbiAgICBSb3cucHJvdG90eXBlLnNvbHZlRm9yRXggPSBmdW5jdGlvbiAobGhzLCByaHMpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRTeW1ib2wobGhzLCAtMS4wKTtcbiAgICAgICAgdGhpcy5zb2x2ZUZvcihyaHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29lZmZpY2llbnQgZm9yIHRoZSBnaXZlbiBzeW1ib2wuXG4gICAgICovXG4gICAgUm93LnByb3RvdHlwZS5jb2VmZmljaWVudEZvciA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgdmFyIHBhaXIgPSB0aGlzLl9jZWxsTWFwLmZpbmQoc3ltYm9sKTtcbiAgICAgICAgcmV0dXJuIHBhaXIgIT09IHVuZGVmaW5lZCA/IHBhaXIuc2Vjb25kIDogMC4wO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3Vic3RpdHV0ZSBhIHN5bWJvbCB3aXRoIHRoZSBkYXRhIGZyb20gYW5vdGhlciByb3cuXG4gICAgICpcbiAgICAgKiBHaXZlbiBhIHJvdyBvZiB0aGUgZm9ybSBhICogeCArIGIgYW5kIGEgc3Vic3RpdHV0aW9uIG9mIHRoZVxuICAgICAqIGZvcm0geCA9IDMgKiB5ICsgYyB0aGUgcm93IHdpbGwgYmUgdXBkYXRlZCB0byByZWZsZWN0IHRoZVxuICAgICAqIGV4cHJlc3Npb24gMyAqIGEgKiB5ICsgYSAqIGMgKyBiLlxuICAgICAqXG4gICAgICogSWYgdGhlIHN5bWJvbCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcm93LCB0aGlzIGlzIGEgbm8tb3AuXG4gICAgICovXG4gICAgUm93LnByb3RvdHlwZS5zdWJzdGl0dXRlID0gZnVuY3Rpb24gKHN5bWJvbCwgcm93KSB7XG4gICAgICAgIHZhciBwYWlyID0gdGhpcy5fY2VsbE1hcC5lcmFzZShzeW1ib2wpO1xuICAgICAgICBpZiAocGFpciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydFJvdyhyb3csIHBhaXIuc2Vjb25kKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJvdztcbn0oKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSAyMDE0LCBOdWNsZWljIERldmVsb3BtZW50IFRlYW0uXG58XG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG58XG58IFRoZSBmdWxsIGxpY2Vuc2UgaXMgaW4gdGhlIGZpbGUgQ09QWUlORy50eHQsIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb2Z0d2FyZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTdHJlbmd0aDtcbihmdW5jdGlvbiAoU3RyZW5ndGgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgc3ltYm9saWMgc3RyZW5ndGguXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGEsIGIsIGMsIHcpIHtcbiAgICAgICAgaWYgKHcgPT09IHZvaWQgMCkgeyB3ID0gMS4wOyB9XG4gICAgICAgIHZhciByZXN1bHQgPSAwLjA7XG4gICAgICAgIHJlc3VsdCArPSBNYXRoLm1heCgwLjAsIE1hdGgubWluKDEwMDAuMCwgYSAqIHcpKSAqIDEwMDAwMDAuMDtcbiAgICAgICAgcmVzdWx0ICs9IE1hdGgubWF4KDAuMCwgTWF0aC5taW4oMTAwMC4wLCBiICogdykpICogMTAwMC4wO1xuICAgICAgICByZXN1bHQgKz0gTWF0aC5tYXgoMC4wLCBNYXRoLm1pbigxMDAwLjAsIGMgKiB3KSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFN0cmVuZ3RoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBUaGUgJ3JlcXVpcmVkJyBzeW1ib2xpYyBzdHJlbmd0aC5cbiAgICAgKi9cbiAgICBTdHJlbmd0aC5yZXF1aXJlZCA9IGNyZWF0ZSgxMDAwLjAsIDEwMDAuMCwgMTAwMC4wKTtcbiAgICAvKipcbiAgICAgKiBUaGUgJ3N0cm9uZycgc3ltYm9saWMgc3RyZW5ndGguXG4gICAgICovXG4gICAgU3RyZW5ndGguc3Ryb25nID0gY3JlYXRlKDEuMCwgMC4wLCAwLjApO1xuICAgIC8qKlxuICAgICAqIFRoZSAnbWVkaXVtJyBzeW1ib2xpYyBzdHJlbmd0aC5cbiAgICAgKi9cbiAgICBTdHJlbmd0aC5tZWRpdW0gPSBjcmVhdGUoMC4wLCAxLjAsIDAuMCk7XG4gICAgLyoqXG4gICAgICogVGhlICd3ZWFrJyBzeW1ib2xpYyBzdHJlbmd0aC5cbiAgICAgKi9cbiAgICBTdHJlbmd0aC53ZWFrID0gY3JlYXRlKDAuMCwgMC4wLCAxLjApO1xuICAgIC8qKlxuICAgICAqIENsaXAgYSBzeW1ib2xpYyBzdHJlbmd0aCB0byB0aGUgYWxsb3dlZCBtaW4gYW5kIG1heC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGlwKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLjAsIE1hdGgubWluKFN0cmVuZ3RoLnJlcXVpcmVkLCB2YWx1ZSkpO1xuICAgIH1cbiAgICBTdHJlbmd0aC5jbGlwID0gY2xpcDtcbn0pKFN0cmVuZ3RoID0gZXhwb3J0cy5TdHJlbmd0aCB8fCAoZXhwb3J0cy5TdHJlbmd0aCA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSAyMDE0LCBOdWNsZWljIERldmVsb3BtZW50IFRlYW0uXG58XG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG58XG58IFRoZSBmdWxsIGxpY2Vuc2UgaXMgaW4gdGhlIGZpbGUgQ09QWUlORy50eHQsIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb2Z0d2FyZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpdGVyYXRvcl8xID0gcmVxdWlyZShcIi4vaXRlcmF0b3JcIik7XG4vKipcbiogUGVyZm9ybSBhIGxvd2VyIGJvdW5kIHNlYXJjaCBvbiBhIHNvcnRlZCBhcnJheS5cbipcbiogQHBhcmFtIGFycmF5IFRoZSBhcnJheSBvZiBzb3J0ZWQgaXRlbXMgdG8gc2VhcmNoLlxuKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGxvY2F0ZWQgaW4gdGhlIGFycmF5LlxuKiBAcGFyYW0gY29tcGFyZSBUaGUgdmFsdWUgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheSB3aGljaFxuKiAgICAgICAgICBjb21wYXJlcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHZhbHVlLlxuKi9cbmZ1bmN0aW9uIGxvd2VyQm91bmQoYXJyYXksIHZhbHVlLCBjb21wYXJlKSB7XG4gICAgdmFyIGJlZ2luID0gMDtcbiAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgaGFsZjtcbiAgICB2YXIgbWlkZGxlO1xuICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICBoYWxmID0gbiA+PiAxO1xuICAgICAgICBtaWRkbGUgPSBiZWdpbiArIGhhbGY7XG4gICAgICAgIGlmIChjb21wYXJlKGFycmF5W21pZGRsZV0sIHZhbHVlKSA8IDApIHtcbiAgICAgICAgICAgIGJlZ2luID0gbWlkZGxlICsgMTtcbiAgICAgICAgICAgIG4gLT0gaGFsZiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuID0gaGFsZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmVnaW47XG59XG5leHBvcnRzLmxvd2VyQm91bmQgPSBsb3dlckJvdW5kO1xuLyoqXG4qIFBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5LlxuKlxuKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5IG9mIHNvcnRlZCBpdGVtcyB0byBzZWFyY2guXG4qIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gbG9jYXRlZCBpbiB0aGUgYXJyYXkuXG4qIEBwYXJhbSBjb21wYXJlIFRoZSB2YWx1ZSBjb21wYXJpc29uIGZ1bmN0aW9uLlxuKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGZvdW5kIGl0ZW0sIG9yIC0xLlxuKi9cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhcnJheSwgdmFsdWUsIGNvbXBhcmUpIHtcbiAgICB2YXIgaW5kZXggPSBsb3dlckJvdW5kKGFycmF5LCB2YWx1ZSwgY29tcGFyZSk7XG4gICAgaWYgKGluZGV4ID09PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB2YXIgaXRlbSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoY29tcGFyZShpdGVtLCB2YWx1ZSkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG59XG5leHBvcnRzLmJpbmFyeVNlYXJjaCA9IGJpbmFyeVNlYXJjaDtcbi8qKlxuKiBQZXJmb3JtIGEgYmluYXJ5IGZpbmQgb24gYSBzb3J0ZWQgYXJyYXkuXG4qXG4qIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgb2Ygc29ydGVkIGl0ZW1zIHRvIHNlYXJjaC5cbiogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBsb2NhdGVkIGluIHRoZSBhcnJheS5cbiogQHBhcmFtIGNvbXBhcmUgVGhlIHZhbHVlIGNvbXBhcmlzb24gZnVuY3Rpb24uXG4qIEByZXR1cm5zIFRoZSBmb3VuZCBpdGVtIGluIHRoZSBhcnJheSwgb3IgdW5kZWZpbmVkLlxuKi9cbmZ1bmN0aW9uIGJpbmFyeUZpbmQoYXJyYXksIHZhbHVlLCBjb21wYXJlKSB7XG4gICAgdmFyIGluZGV4ID0gbG93ZXJCb3VuZChhcnJheSwgdmFsdWUsIGNvbXBhcmUpO1xuICAgIGlmIChpbmRleCA9PT0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciBpdGVtID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChjb21wYXJlKGl0ZW0sIHZhbHVlKSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbn1cbmV4cG9ydHMuYmluYXJ5RmluZCA9IGJpbmFyeUZpbmQ7XG5mdW5jdGlvbiBhc1NldChpdGVtcywgY29tcGFyZSkge1xuICAgIHZhciBhcnJheSA9IGl0ZXJhdG9yXzEuYXNBcnJheShpdGVtcyk7XG4gICAgdmFyIG4gPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKG4gPD0gMSkge1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIGFycmF5LnNvcnQoY29tcGFyZSk7XG4gICAgdmFyIHJlc3VsdCA9IFthcnJheVswXV07XG4gICAgZm9yICh2YXIgaSA9IDEsIGogPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICAgIGlmIChjb21wYXJlKHJlc3VsdFtqXSwgaXRlbSkgIT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgKytqO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmFzU2V0ID0gYXNTZXQ7XG4vKipcbiogVGVzdCB3aGV0aGVyIGEgdHdvIHNvcnRlZCBhcnJheXMgc2V0cyBhcmUgZGlzam9pbnQuXG4qXG4qIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3Qgc29ydGVkIGFycmF5IHNldC5cbiogQHBhcmFtIHNlY29uZCBUaGUgc2Vjb25kIHNvcnRlZCBhcnJheSBzZXQuXG4qIEBwYXJhbSBjb21wYXJlIFRoZSB2YWx1ZSBjb21wYXJpc29uIGZ1bmN0aW9uLlxuKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzZXRzIGFyZSBkaXNqb2ludCwgZmFsc2Ugb3RoZXJ3aXNlLlxuKi9cbmZ1bmN0aW9uIHNldElzRGlzam9pbnQoZmlyc3QsIHNlY29uZCwgY29tcGFyZSkge1xuICAgIHZhciBpID0gMCwgaiA9IDA7XG4gICAgdmFyIGxlbjEgPSBmaXJzdC5sZW5ndGg7XG4gICAgdmFyIGxlbjIgPSBzZWNvbmQubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgbGVuMSAmJiBqIDwgbGVuMikge1xuICAgICAgICB2YXIgdiA9IGNvbXBhcmUoZmlyc3RbaV0sIHNlY29uZFtqXSk7XG4gICAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgPiAwKSB7XG4gICAgICAgICAgICArK2o7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLnNldElzRGlzam9pbnQgPSBzZXRJc0Rpc2pvaW50O1xuLyoqXG4qIFRlc3Qgd2hldGhlciBvbmUgc29ydGVkIGFycmF5IHNldCBpcyB0aGUgc3Vic2V0IG9mIGFub3RoZXIuXG4qXG4qIEBwYXJhbSBmaXJzdCBUaGUgcG90ZW50aWFsIHN1YnNldC5cbiogQHBhcmFtIHNlY29uZCBUaGUgcG90ZW50aWFsIHN1cGVyc2V0LlxuKiBAcGFyYW0gY29tcGFyZSBUaGUgdmFsdWUgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZmlyc3Qgc2V0IGlzIGEgc3Vic2V0IG9mIHRoZSBzZWNvbmQuXG4qL1xuZnVuY3Rpb24gc2V0SXNTdWJzZXQoZmlyc3QsIHNlY29uZCwgY29tcGFyZSkge1xuICAgIHZhciBsZW4xID0gZmlyc3QubGVuZ3RoO1xuICAgIHZhciBsZW4yID0gc2Vjb25kLmxlbmd0aDtcbiAgICBpZiAobGVuMSA+IGxlbjIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaSA9IDAsIGogPSAwO1xuICAgIHdoaWxlIChpIDwgbGVuMSAmJiBqIDwgbGVuMikge1xuICAgICAgICB2YXIgdiA9IGNvbXBhcmUoZmlyc3RbaV0sIHNlY29uZFtqXSk7XG4gICAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgPiAwKSB7XG4gICAgICAgICAgICArK2o7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICArK2o7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPCBsZW4xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLnNldElzU3Vic2V0ID0gc2V0SXNTdWJzZXQ7XG4vKipcbiogQ3JlYXRlIHRoZSBzZXQgdW5pb24gb2YgdHdvIHNvcnRlZCBzZXQgYXJyYXlzLlxudmFyIGogPSAwO1xuKlxuKiBAcGFyYW0gZmlyc3QgVGhlIGZpcnN0IHNvcnRlZCBhcnJheSBzZXQuXG4qIEBwYXJhbSBzZWNvbmQgVGhlIHNlY29uZCBzb3J0ZWQgYXJyYXkgc2V0LlxuKiBAcGFyYW0gY29tcGFyZSBUaGUgdmFsdWUgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiogQHJldHVybnMgVGhlIHNldCB1bmlvbiBvZiB0aGUgdHdvIGFycmF5cy5cbiovXG5mdW5jdGlvbiBzZXRVbmlvbihmaXJzdCwgc2Vjb25kLCBjb21wYXJlKSB7XG4gICAgdmFyIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgbGVuMSA9IGZpcnN0Lmxlbmd0aDtcbiAgICB2YXIgbGVuMiA9IHNlY29uZC5sZW5ndGg7XG4gICAgdmFyIG1lcmdlZCA9IFtdO1xuICAgIHdoaWxlIChpIDwgbGVuMSAmJiBqIDwgbGVuMikge1xuICAgICAgICB2YXIgYSA9IGZpcnN0W2ldO1xuICAgICAgICB2YXIgYiA9IHNlY29uZFtqXTtcbiAgICAgICAgdmFyIHYgPSBjb21wYXJlKGEsIGIpO1xuICAgICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgICAgIG1lcmdlZC5wdXNoKGEpO1xuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgPiAwKSB7XG4gICAgICAgICAgICBtZXJnZWQucHVzaChiKTtcbiAgICAgICAgICAgICsrajtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lcmdlZC5wdXNoKGEpO1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgKytqO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChpIDwgbGVuMSkge1xuICAgICAgICBtZXJnZWQucHVzaChmaXJzdFtpXSk7XG4gICAgICAgICsraTtcbiAgICB9XG4gICAgd2hpbGUgKGogPCBsZW4yKSB7XG4gICAgICAgIG1lcmdlZC5wdXNoKHNlY29uZFtqXSk7XG4gICAgICAgICsrajtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydHMuc2V0VW5pb24gPSBzZXRVbmlvbjtcbi8qKlxuKiBDcmVhdGUgYSBzZXQgaW50ZXJzZWN0aW9uIG9mIHR3byBzb3J0ZWQgc2V0IGFycmF5cy5cbipcbiogQHBhcmFtIGZpcnN0IFRoZSBmaXJzdCBzb3J0ZWQgYXJyYXkgc2V0LlxuKiBAcGFyYW0gc2Vjb25kIFRoZSBzZWNvbmQgc29ydGVkIGFycmF5IHNldC5cbiogQHBhcmFtIGNvbXBhcmUgVGhlIHZhbHVlIGNvbXBhcmlzb24gZnVuY3Rpb24uXG4qIEByZXR1cm5zIFRoZSBzZXQgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gYXJyYXlzLlxuKi9cbmZ1bmN0aW9uIHNldEludGVyc2VjdGlvbihmaXJzdCwgc2Vjb25kLCBjb21wYXJlKSB7XG4gICAgdmFyIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgbGVuMSA9IGZpcnN0Lmxlbmd0aDtcbiAgICB2YXIgbGVuMiA9IHNlY29uZC5sZW5ndGg7XG4gICAgdmFyIG1lcmdlZCA9IFtdO1xuICAgIHdoaWxlIChpIDwgbGVuMSAmJiBqIDwgbGVuMikge1xuICAgICAgICB2YXIgYSA9IGZpcnN0W2ldO1xuICAgICAgICB2YXIgYiA9IHNlY29uZFtqXTtcbiAgICAgICAgdmFyIHYgPSBjb21wYXJlKGEsIGIpO1xuICAgICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID4gMCkge1xuICAgICAgICAgICAgKytqO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2goYSk7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICArK2o7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydHMuc2V0SW50ZXJzZWN0aW9uID0gc2V0SW50ZXJzZWN0aW9uO1xuLyoqXG4qIENyZWF0ZSBhIHNldCBkaWZmZXJlbmNlIG9mIHR3byBzb3J0ZWQgc2V0IGFycmF5cy5cbipcbiogQHBhcmFtIGZpcnN0IFRoZSBmaXJzdCBzb3J0ZWQgYXJyYXkgc2V0LlxuKiBAcGFyYW0gc2Vjb25kIFRoZSBzZWNvbmQgc29ydGVkIGFycmF5IHNldC5cbiogQHBhcmFtIGNvbXBhcmUgVGhlIHZhbHVlIGNvbXBhcmlzb24gZnVuY3Rpb24uXG4qIEByZXR1cm5zIFRoZSBzZXQgZGlmZmVyZW5jZSBvZiB0aGUgdHdvIGFycmF5cy5cbiovXG5mdW5jdGlvbiBzZXREaWZmZXJlbmNlKGZpcnN0LCBzZWNvbmQsIGNvbXBhcmUpIHtcbiAgICB2YXIgaSA9IDAsIGogPSAwO1xuICAgIHZhciBsZW4xID0gZmlyc3QubGVuZ3RoO1xuICAgIHZhciBsZW4yID0gc2Vjb25kLmxlbmd0aDtcbiAgICB2YXIgbWVyZ2VkID0gW107XG4gICAgd2hpbGUgKGkgPCBsZW4xICYmIGogPCBsZW4yKSB7XG4gICAgICAgIHZhciBhID0gZmlyc3RbaV07XG4gICAgICAgIHZhciBiID0gc2Vjb25kW2pdO1xuICAgICAgICB2YXIgdiA9IGNvbXBhcmUoYSwgYik7XG4gICAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2goYSk7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA+IDApIHtcbiAgICAgICAgICAgICsrajtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICsrajtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoaSA8IGxlbjEpIHtcbiAgICAgICAgbWVyZ2VkLnB1c2goZmlyc3RbaV0pO1xuICAgICAgICArK2k7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnRzLnNldERpZmZlcmVuY2UgPSBzZXREaWZmZXJlbmNlO1xuLyoqXG4qIENyZWF0ZSBhIHNldCBzeW1tZXRyaWMgZGlmZmVyZW5jZSBvZiB0d28gc29ydGVkIHNldCBhcnJheXMuXG4qXG4qIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3Qgc29ydGVkIGFycmF5IHNldC5cbiogQHBhcmFtIHNlY29uZCBUaGUgc2Vjb25kIHNvcnRlZCBhcnJheSBzZXQuXG4qIEBwYXJhbSBjb21wYXJlIFRoZSB2YWx1ZSBjb21wYXJpc29uIGZ1bmN0aW9uLlxuKiBAcmV0dXJucyBUaGUgc2V0IHN5bW1ldHJpYyBkaWZmZXJlbmNlIG9mIHRoZSB0d28gYXJyYXlzLlxuKi9cbmZ1bmN0aW9uIHNldFN5bW1ldHJpY0RpZmZlcmVuY2UoZmlyc3QsIHNlY29uZCwgY29tcGFyZSkge1xuICAgIHZhciBpID0gMCwgaiA9IDA7XG4gICAgdmFyIGxlbjEgPSBmaXJzdC5sZW5ndGg7XG4gICAgdmFyIGxlbjIgPSBzZWNvbmQubGVuZ3RoO1xuICAgIHZhciBtZXJnZWQgPSBbXTtcbiAgICB3aGlsZSAoaSA8IGxlbjEgJiYgaiA8IGxlbjIpIHtcbiAgICAgICAgdmFyIGEgPSBmaXJzdFtpXTtcbiAgICAgICAgdmFyIGIgPSBzZWNvbmRbal07XG4gICAgICAgIHZhciB2ID0gY29tcGFyZShhLCBiKTtcbiAgICAgICAgaWYgKHYgPCAwKSB7XG4gICAgICAgICAgICBtZXJnZWQucHVzaChhKTtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID4gMCkge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2goYik7XG4gICAgICAgICAgICArK2o7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICArK2o7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGkgPCBsZW4xKSB7XG4gICAgICAgIG1lcmdlZC5wdXNoKGZpcnN0W2ldKTtcbiAgICAgICAgKytpO1xuICAgIH1cbiAgICB3aGlsZSAoaiA8IGxlbjIpIHtcbiAgICAgICAgbWVyZ2VkLnB1c2goc2Vjb25kW2pdKTtcbiAgICAgICAgKytqO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0cy5zZXRTeW1tZXRyaWNEaWZmZXJlbmNlID0gc2V0U3ltbWV0cmljRGlmZmVyZW5jZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIDIwMTQsIE51Y2xlaWMgRGV2ZWxvcG1lbnQgVGVhbS5cbnxcbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbnxcbnwgVGhlIGZ1bGwgbGljZW5zZSBpcyBpbiB0aGUgZmlsZSBDT1BZSU5HLnR4dCwgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvZnR3YXJlLlxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGl0ZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9pdGVyYXRvclwiKTtcbi8qKlxuKiBBIGJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGluZyBhcnJheS1iYXNlZCBkYXRhIHN0cnVjdHVyZXMuXG4qXG4qIEBjbGFzc1xuKi9cbnZhciBBcnJheUJhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFycmF5QmFzZSgpIHtcbiAgICAgICAgLypcbiAgICAgICAgKiBUaGUgaW50ZXJuYWwgZGF0YSBhcnJheS5cbiAgICAgICAgKlxuICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGFycmF5LlxuICAgICovXG4gICAgQXJyYXlCYXNlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFycmF5IGlzIGVtcHR5LlxuICAgICovXG4gICAgQXJyYXlCYXNlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FycmF5Lmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgaXRlbSBhdCB0aGUgZ2l2ZW4gYXJyYXkgaW5kZXguXG4gICAgKlxuICAgICogQHBhcmFtIGluZGV4IFRoZSBpbnRlZ2VyIGluZGV4IG9mIHRoZSBkZXNpcmVkIGl0ZW0uXG4gICAgKi9cbiAgICBBcnJheUJhc2UucHJvdG90eXBlLml0ZW1BdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXlbaW5kZXhdO1xuICAgIH07XG4gICAgLyoqXG4gICAgKiBSZW1vdmVzIGFuZCByZXR1cm5zIHRoZSBpdGVtIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAqXG4gICAgKiBAcGFyYW0gaW5kZXggVGhlIGludGVnZXIgaW5kZXggb2YgdGhlIGRlc2lyZWQgaXRlbS5cbiAgICAqL1xuICAgIEFycmF5QmFzZS5wcm90b3R5cGUudGFrZUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcnJheS5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgIH07XG4gICAgLyoqXG4gICAgKiBDbGVhciB0aGUgaW50ZXJuYWwgY29udGVudHMgb2YgYXJyYXkuXG4gICAgKi9cbiAgICBBcnJheUJhc2UucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9hcnJheSA9IFtdO1xuICAgIH07XG4gICAgLyoqXG4gICAgKiBTd2FwIHRoaXMgYXJyYXkncyBjb250ZW50cyB3aXRoIGFub3RoZXIgYXJyYXkuXG4gICAgKlxuICAgICogQHBhcmFtIG90aGVyIFRoZSBhcnJheSBiYXNlIHRvIHVzZSBmb3IgdGhlIHN3YXAuXG4gICAgKi9cbiAgICBBcnJheUJhc2UucHJvdG90eXBlLnN3YXAgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5fYXJyYXk7XG4gICAgICAgIHRoaXMuX2FycmF5ID0gb3RoZXIuX2FycmF5O1xuICAgICAgICBvdGhlci5fYXJyYXkgPSBhcnJheTtcbiAgICB9O1xuICAgIC8qKlxuICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBhcnJheSBvZiBpdGVtcy5cbiAgICAqL1xuICAgIEFycmF5QmFzZS5wcm90b3R5cGUuX19pdGVyX18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvcl8xLml0ZXIodGhpcy5fYXJyYXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGEgcmV2ZXJzZSBpdGVyYXRvciBvdmVyIHRoZSBhcnJheSBvZiBpdGVtcy5cbiAgICAqL1xuICAgIEFycmF5QmFzZS5wcm90b3R5cGUuX19yZXZlcnNlZF9fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JfMS5yZXZlcnNlZCh0aGlzLl9hcnJheSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlCYXNlO1xufSgpKTtcbmV4cG9ydHMuQXJyYXlCYXNlID0gQXJyYXlCYXNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNCwgTnVjbGVpYyBEZXZlbG9wbWVudCBUZWFtLlxufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIENPUFlJTkcudHh0LCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwYWlyXzEgPSByZXF1aXJlKFwiLi9wYWlyXCIpO1xudmFyIGFycmF5X2Jhc2VfMSA9IHJlcXVpcmUoXCIuL2FycmF5X2Jhc2VcIik7XG52YXIgYWxnb3JpdGhtXzEgPSByZXF1aXJlKFwiLi9hbGdvcml0aG1cIik7XG52YXIgaXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL2l0ZXJhdG9yXCIpO1xuLyoqXG4qIEEgbWFwcGluZyBjb250YWluZXIgYnVpbGQgb24gYSBzb3J0ZWQgYXJyYXkuXG4qXG4qIEBjbGFzc1xuKi9cbnZhciBBc3NvY2lhdGl2ZUFycmF5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXNzb2NpYXRpdmVBcnJheSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAqIENvbnN0cnVjdCBhIG5ldyBBc3NvY2lhdGl2ZUFycmF5LlxuICAgICpcbiAgICAqIEBwYXJhbSBjb21wYXJlIFRoZSBrZXkgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIEFzc29jaWF0aXZlQXJyYXkoY29tcGFyZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgIF90aGlzLl93cmFwcGVkID0gd3JhcENvbXBhcmUoY29tcGFyZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBrZXkgY29tcGFyaXNvbiBmdW5jdGlvbiB1c2VkIGJ5IHRoaXMgYXJyYXkuXG4gICAgKi9cbiAgICBBc3NvY2lhdGl2ZUFycmF5LnByb3RvdHlwZS5jb21wYXJpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcGFyZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICogUmV0dXJuIHRoZSBhcnJheSBpbmRleCBvZiB0aGUgZ2l2ZW4ga2V5LCBvciAtMS5cbiAgICAqXG4gICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gbG9jYXRlIGluIHRoZSBhcnJheS5cbiAgICAqL1xuICAgIEFzc29jaWF0aXZlQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBhbGdvcml0aG1fMS5iaW5hcnlTZWFyY2godGhpcy5fYXJyYXksIGtleSwgdGhpcy5fd3JhcHBlZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUga2V5IGlzIGluIHRoZSBhcnJheSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICpcbiAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBsb2NhdGUgaW4gdGhlIGFycmF5LlxuICAgICovXG4gICAgQXNzb2NpYXRpdmVBcnJheS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBhbGdvcml0aG1fMS5iaW5hcnlTZWFyY2godGhpcy5fYXJyYXksIGtleSwgdGhpcy5fd3JhcHBlZCkgPj0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgcGFpciBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleSwgb3IgdW5kZWZpbmVkLlxuICAgICpcbiAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBsb2NhdGUgaW4gdGhlIGFycmF5LlxuICAgICovXG4gICAgQXNzb2NpYXRpdmVBcnJheS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGFsZ29yaXRobV8xLmJpbmFyeUZpbmQodGhpcy5fYXJyYXksIGtleSwgdGhpcy5fd3JhcHBlZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhlIHBhaXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkgaWYgaXQgZXhpc3RzLlxuICAgICpcbiAgICAqIElmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3QsIGEgbmV3IHBhaXIgd2lsbCBiZSBjcmVhdGVkIGFuZFxuICAgICogaW5zZXJ0ZWQgdXNpbmcgdGhlIHZhbHVlIGNyZWF0ZWQgYnkgdGhlIGdpdmVuIGZhY3RvcnkuXG4gICAgKlxuICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXG4gICAgKiBAcGFyYW0gZmFjdG9yeSBUaGUgZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAqL1xuICAgIEFzc29jaWF0aXZlQXJyYXkucHJvdG90eXBlLnNldERlZmF1bHQgPSBmdW5jdGlvbiAoa2V5LCBmYWN0b3J5KSB7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgICAgICB2YXIgaW5kZXggPSBhbGdvcml0aG1fMS5sb3dlckJvdW5kKGFycmF5LCBrZXksIHRoaXMuX3dyYXBwZWQpO1xuICAgICAgICBpZiAoaW5kZXggPT09IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBuZXcgcGFpcl8xLlBhaXIoa2V5LCBmYWN0b3J5KCkpO1xuICAgICAgICAgICAgYXJyYXkucHVzaChwYWlyKTtcbiAgICAgICAgICAgIHJldHVybiBwYWlyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyUGFpciA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBhcmUoY3VyclBhaXIuZmlyc3QsIGtleSkgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gbmV3IHBhaXJfMS5QYWlyKGtleSwgZmFjdG9yeSgpKTtcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpbmRleCwgMCwgcGFpcik7XG4gICAgICAgICAgICByZXR1cm4gcGFpcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VyclBhaXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAqIEluc2VydCB0aGUgcGFpciBpbnRvIHRoZSBhcnJheSBhbmQgcmV0dXJuIHRoZSBwYWlyLlxuICAgICpcbiAgICAqIFRoaXMgd2lsbCBvdmVyd3JpdGUgYW55IGV4aXN0aW5nIGVudHJ5IGluIHRoZSBhcnJheS5cbiAgICAqXG4gICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgcG9ydGlvbiBvZiB0aGUgcGFpci5cbiAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgcG9ydGlvbiBvZiB0aGUgcGFpci5cbiAgICAqL1xuICAgIEFzc29jaWF0aXZlQXJyYXkucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgICAgICB2YXIgaW5kZXggPSBhbGdvcml0aG1fMS5sb3dlckJvdW5kKGFycmF5LCBrZXksIHRoaXMuX3dyYXBwZWQpO1xuICAgICAgICBpZiAoaW5kZXggPT09IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBuZXcgcGFpcl8xLlBhaXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBhcnJheS5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgcmV0dXJuIHBhaXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJQYWlyID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodGhpcy5fY29tcGFyZShjdXJyUGFpci5maXJzdCwga2V5KSAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBuZXcgcGFpcl8xLlBhaXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDAsIHBhaXIpO1xuICAgICAgICAgICAgcmV0dXJuIHBhaXI7XG4gICAgICAgIH1cbiAgICAgICAgY3VyclBhaXIuc2Vjb25kID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjdXJyUGFpcjtcbiAgICB9O1xuICAgIEFzc29jaWF0aXZlQXJyYXkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFzc29jaWF0aXZlQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FycmF5ID0gbWVyZ2UodGhpcy5fYXJyYXksIG9iamVjdC5fYXJyYXksIHRoaXMuX2NvbXBhcmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3JfMS5mb3JFYWNoKG9iamVjdCwgZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbnNlcnQocGFpci5maXJzdCwgcGFpci5zZWNvbmQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICogUmVtb3ZlcyBhbmQgcmV0dXJucyB0aGUgcGFpciBmb3IgdGhlIGdpdmVuIGtleSwgb3IgdW5kZWZpbmVkLlxuICAgICpcbiAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byByZW1vdmUgZnJvbSB0aGUgbWFwLlxuICAgICovXG4gICAgQXNzb2NpYXRpdmVBcnJheS5wcm90b3R5cGUuZXJhc2UgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgICAgICB2YXIgaW5kZXggPSBhbGdvcml0aG1fMS5iaW5hcnlTZWFyY2goYXJyYXksIGtleSwgdGhpcy5fd3JhcHBlZCk7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5LnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgfTtcbiAgICAvKipcbiAgICAqIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBhc3NvY2lhdGl2ZSBhcnJheS5cbiAgICAqL1xuICAgIEFzc29jaWF0aXZlQXJyYXkucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGVDb3B5ID0gbmV3IEFzc29jaWF0aXZlQXJyYXkodGhpcy5fY29tcGFyZSk7XG4gICAgICAgIHZhciBjb3B5QXJyYXkgPSB0aGVDb3B5Ll9hcnJheTtcbiAgICAgICAgdmFyIHRoaXNBcnJheSA9IHRoaXMuX2FycmF5O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXNBcnJheS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGNvcHlBcnJheS5wdXNoKHRoaXNBcnJheVtpXS5jb3B5KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGVDb3B5O1xuICAgIH07XG4gICAgcmV0dXJuIEFzc29jaWF0aXZlQXJyYXk7XG59KGFycmF5X2Jhc2VfMS5BcnJheUJhc2UpKTtcbmV4cG9ydHMuQXNzb2NpYXRpdmVBcnJheSA9IEFzc29jaWF0aXZlQXJyYXk7XG4vKipcbiogQW4gaW50ZXJuYWwgd2hpY2ggd3JhcHMgYSBjb21wYXJpc29uIGtleSBmdW5jdGlvbi5cbiovXG5mdW5jdGlvbiB3cmFwQ29tcGFyZShjbXApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhaXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjbXAocGFpci5maXJzdCwgdmFsdWUpO1xuICAgIH07XG59XG4vKipcbiogQW4gaW50ZXJuYWwgZnVuY3Rpb24gd2hpY2ggbWVyZ2VzIHR3byBvcmRlcmVkIHBhaXIgYXJyYXlzLlxuKi9cbmZ1bmN0aW9uIG1lcmdlKGZpcnN0LCBzZWNvbmQsIGNvbXBhcmUpIHtcbiAgICB2YXIgaSA9IDAsIGogPSAwO1xuICAgIHZhciBsZW4xID0gZmlyc3QubGVuZ3RoO1xuICAgIHZhciBsZW4yID0gc2Vjb25kLmxlbmd0aDtcbiAgICB2YXIgbWVyZ2VkID0gW107XG4gICAgd2hpbGUgKGkgPCBsZW4xICYmIGogPCBsZW4yKSB7XG4gICAgICAgIHZhciBhID0gZmlyc3RbaV07XG4gICAgICAgIHZhciBiID0gc2Vjb25kW2pdO1xuICAgICAgICB2YXIgdiA9IGNvbXBhcmUoYS5maXJzdCwgYi5maXJzdCk7XG4gICAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2goYS5jb3B5KCkpO1xuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgPiAwKSB7XG4gICAgICAgICAgICBtZXJnZWQucHVzaChiLmNvcHkoKSk7XG4gICAgICAgICAgICArK2o7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXJnZWQucHVzaChiLmNvcHkoKSk7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICArK2o7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGkgPCBsZW4xKSB7XG4gICAgICAgIG1lcmdlZC5wdXNoKGZpcnN0W2ldLmNvcHkoKSk7XG4gICAgICAgICsraTtcbiAgICB9XG4gICAgd2hpbGUgKGogPCBsZW4yKSB7XG4gICAgICAgIG1lcmdlZC5wdXNoKHNlY29uZFtqXS5jb3B5KCkpO1xuICAgICAgICArK2o7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9hbGdvcml0aG1cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vYXJyYXlfYmFzZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9hc3NvY2lhdGl2ZV9hcnJheVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9pdGVyYXRvclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wYWlyXCIpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIDIwMTQsIE51Y2xlaWMgRGV2ZWxvcG1lbnQgVGVhbS5cbnxcbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbnxcbnwgVGhlIGZ1bGwgbGljZW5zZSBpcyBpbiB0aGUgZmlsZSBDT1BZSU5HLnR4dCwgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvZnR3YXJlLlxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4qIEFuIGl0ZXJhdG9yIGZvciBhbiBhcnJheSBvZiBpdGVtcy5cbiovXG52YXIgQXJyYXlJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLypcbiAgICAqIENvbnN0cnVjdCBhIG5ldyBBcnJheUl0ZXJhdG9yLlxuICAgICpcbiAgICAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgb2YgaXRlbXMgdG8gaXRlcmF0ZS5cbiAgICAqIEBwYXJhbSBbaW5kZXhdIFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBpdGVyYXRpb24uXG4gICAgKi9cbiAgICBmdW5jdGlvbiBBcnJheUl0ZXJhdG9yKGFycmF5LCBpbmRleCkge1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXJyYXkgPSBhcnJheTtcbiAgICAgICAgdGhpcy5faW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgbmV4dCBpdGVtIGZyb20gdGhlIGl0ZXJhdG9yIG9yIHVuZGVmaW5lZC5cbiAgICAqL1xuICAgIEFycmF5SXRlcmF0b3IucHJvdG90eXBlLl9fbmV4dF9fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXlbdGhpcy5faW5kZXgrK107XG4gICAgfTtcbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhpcyBzYW1lIGl0ZXJhdG9yLlxuICAgICovXG4gICAgQXJyYXlJdGVyYXRvci5wcm90b3R5cGUuX19pdGVyX18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5SXRlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5BcnJheUl0ZXJhdG9yID0gQXJyYXlJdGVyYXRvcjtcbi8qKlxuKiBBIHJldmVyc2UgaXRlcmF0b3IgZm9yIGFuIGFycmF5IG9mIGl0ZW1zLlxuKi9cbnZhciBSZXZlcnNlQXJyYXlJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgKiBDb25zdHJ1Y3QgYSBuZXcgUmV2ZXJzZUFycmF5SXRlcmF0b3IuXG4gICAgKlxuICAgICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSBvZiBpdGVtcyB0byBpdGVyYXRlLlxuICAgICogQHBhcmFtIFtpbmRleF0gVGhlIGluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IGl0ZXJhdGlvbi5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIFJldmVyc2VBcnJheUl0ZXJhdG9yKGFycmF5LCBpbmRleCkge1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpbmRleCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hcnJheSA9IGFycmF5O1xuICAgICAgICB0aGlzLl9pbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBuZXh0IGl0ZW0gZnJvbSB0aGUgaXRlcmF0b3Igb3IgdW5kZWZpbmVkLlxuICAgICovXG4gICAgUmV2ZXJzZUFycmF5SXRlcmF0b3IucHJvdG90eXBlLl9fbmV4dF9fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXlbLS10aGlzLl9pbmRleF07XG4gICAgfTtcbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhpcyBzYW1lIGl0ZXJhdG9yLlxuICAgICovXG4gICAgUmV2ZXJzZUFycmF5SXRlcmF0b3IucHJvdG90eXBlLl9faXRlcl9fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBSZXZlcnNlQXJyYXlJdGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLlJldmVyc2VBcnJheUl0ZXJhdG9yID0gUmV2ZXJzZUFycmF5SXRlcmF0b3I7XG5mdW5jdGlvbiBpdGVyKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5SXRlcmF0b3Iob2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdC5fX2l0ZXJfXygpO1xufVxuZXhwb3J0cy5pdGVyID0gaXRlcjtcbmZ1bmN0aW9uIHJldmVyc2VkKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFJldmVyc2VBcnJheUl0ZXJhdG9yKG9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3QuX19yZXZlcnNlZF9fKCk7XG59XG5leHBvcnRzLnJldmVyc2VkID0gcmV2ZXJzZWQ7XG4vKipcbiogUmV0dXJucyB0aGUgbmV4dCB2YWx1ZSBmcm9tIGFuIGl0ZXJhdG9yLCBvciB1bmRlZmluZWQuXG4qL1xuZnVuY3Rpb24gbmV4dChpdGVyYXRvcikge1xuICAgIHJldHVybiBpdGVyYXRvci5fX25leHRfXygpO1xufVxuZXhwb3J0cy5uZXh0ID0gbmV4dDtcbmZ1bmN0aW9uIGFzQXJyYXkob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHJldHVybiBvYmplY3Quc2xpY2UoKTtcbiAgICB9XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciBpdCA9IG9iamVjdC5fX2l0ZXJfXygpO1xuICAgIHdoaWxlICgodmFsdWUgPSBpdC5fX25leHRfXygpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLmFzQXJyYXkgPSBhc0FycmF5O1xuZnVuY3Rpb24gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gb2JqZWN0Lmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKG9iamVjdFtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHZhciBpdCA9IG9iamVjdC5fX2l0ZXJfXygpO1xuICAgICAgICB3aGlsZSAoKHZhbHVlID0gaXQuX19uZXh0X18oKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmZvckVhY2ggPSBmb3JFYWNoO1xuZnVuY3Rpb24gbWFwKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gb2JqZWN0Lmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2sob2JqZWN0W2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdmFyIGl0ID0gb2JqZWN0Ll9faXRlcl9fKCk7XG4gICAgICAgIHdoaWxlICgodmFsdWUgPSBpdC5fX25leHRfXygpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjYWxsYmFjayh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLm1hcCA9IG1hcDtcbmZ1bmN0aW9uIGZpbHRlcihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBvYmplY3QubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBpdCA9IG9iamVjdC5fX2l0ZXJfXygpO1xuICAgICAgICB3aGlsZSAoKHZhbHVlID0gaXQuX19uZXh0X18oKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSAyMDE0LCBOdWNsZWljIERldmVsb3BtZW50IFRlYW0uXG58XG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG58XG58IFRoZSBmdWxsIGxpY2Vuc2UgaXMgaW4gdGhlIGZpbGUgQ09QWUlORy50eHQsIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb2Z0d2FyZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuKiBBIGNsYXNzIHdoaWNoIGRlZmluZXMgYSBnZW5lcmljIHBhaXIgb2JqZWN0LlxuKi9cbnZhciBQYWlyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAqIENvbnN0cnVjdCBhIG5ldyBQYWlyIG9iamVjdC5cbiAgICAqXG4gICAgKiBAcGFyYW0gZmlyc3QgVGhlIGZpcnN0IGl0ZW0gb2YgdGhlIHBhaXIuXG4gICAgKiBAcGFyYW0gc2Vjb25kIFRoZSBzZWNvbmQgaXRlbSBvZiB0aGUgcGFpci5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIFBhaXIoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICB0aGlzLmZpcnN0ID0gZmlyc3Q7XG4gICAgICAgIHRoaXMuc2Vjb25kID0gc2Vjb25kO1xuICAgIH1cbiAgICAvKipcbiAgICAqIENyZWF0ZSBhIGNvcHkgb2YgdGhlIHBhaXIuXG4gICAgKi9cbiAgICBQYWlyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhaXIodGhpcy5maXJzdCwgdGhpcy5zZWNvbmQpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhaXI7XG59KCkpO1xuZXhwb3J0cy5QYWlyID0gUGFpcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIDIwMTQsIE51Y2xlaWMgRGV2ZWxvcG1lbnQgVGVhbS5cbnxcbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbnxcbnwgVGhlIGZ1bGwgbGljZW5zZSBpcyBpbiB0aGUgZmlsZSBDT1BZSU5HLnR4dCwgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvZnR3YXJlLlxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBUaGUgcHJpbWFyeSB1c2VyIGNvbnN0cmFpbnQgdmFyaWFibGUuXG4gKlxuICogQGNsYXNzXG4gKi9cbnZhciBWYXJpYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IFZhcmlhYmxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW25hbWVdIFRoZSBuYW1lIHRvIGFzc29jaWF0ZWQgd2l0aCB0aGUgdmFyaWFibGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmFyaWFibGUobmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBcIlwiOyB9XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gMC4wO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faWQgPSBWYXJJZCsrO1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdGF0aWMgdmFyaWFibGUgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBWYXJpYWJsZS5Db21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZhcmlhYmxlLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bmlxdWUgaWQgbnVtYmVyIG9mIHRoZSB2YXJpYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmFyaWFibGUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIFZhcmlhYmxlLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmFyaWFibGUucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgdXNlciBjb250ZXh0IG9iamVjdCBvZiB0aGUgdmFyaWFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHVzZXIgY29udGV4dCBvYmplY3Qgb2YgdGhlIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIFZhcmlhYmxlLnByb3RvdHlwZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmFyaWFibGUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBWYXJpYWJsZS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBWYXJpYWJsZTtcbn0oKSk7XG5leHBvcnRzLlZhcmlhYmxlID0gVmFyaWFibGU7XG4vKipcbiAqIFRoZSBpbnRlcm5hbCB2YXJpYWJsZSBpZCBjb3VudGVyLlxuICovXG52YXIgVmFySWQgPSAwO1xuIiwiLyohXG4gKiBudW1icm8uanNcbiAqIHZlcnNpb24gOiAxLjYuMlxuICogYXV0aG9yIDogRsO2cmV0YWdzcGxhdHNlbiBBQlxuICogbGljZW5zZSA6IE1JVFxuICogaHR0cDovL3d3dy5mb3JldGFnc3BsYXRzZW4uc2VcbiAqL1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBDb25zdGFudHNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICB2YXIgbnVtYnJvLFxuICAgICAgICBWRVJTSU9OID0gJzEuNi4yJyxcbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBjdWx0dXJlIGNvbmZpZyBmaWxlc1xuICAgICAgICBjdWx0dXJlcyA9IHt9LFxuICAgIC8vIFRvZG86IFJlbW92ZSBpbiAyLjAuMFxuICAgICAgICBsYW5ndWFnZXMgPSBjdWx0dXJlcyxcbiAgICAgICAgY3VycmVudEN1bHR1cmUgPSAnZW4tVVMnLFxuICAgICAgICB6ZXJvRm9ybWF0ID0gbnVsbCxcbiAgICAgICAgZGVmYXVsdEZvcm1hdCA9ICcwLDAnLFxuICAgICAgICBkZWZhdWx0Q3VycmVuY3lGb3JtYXQgPSAnMCQnLFxuICAgICAgICAvLyBjaGVjayBmb3Igbm9kZUpTXG4gICAgICAgIGhhc01vZHVsZSA9ICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyksXG4gICAgLy8gZGVmYXVsdCBjdWx0dXJlXG4gICAgICAgIGVuVVMgPSB7XG4gICAgICAgICAgICBkZWxpbWl0ZXJzOiB7XG4gICAgICAgICAgICAgICAgdGhvdXNhbmRzOiAnLCcsXG4gICAgICAgICAgICAgICAgZGVjaW1hbDogJy4nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWJicmV2aWF0aW9uczoge1xuICAgICAgICAgICAgICAgIHRob3VzYW5kOiAnaycsXG4gICAgICAgICAgICAgICAgbWlsbGlvbjogJ20nLFxuICAgICAgICAgICAgICAgIGJpbGxpb246ICdiJyxcbiAgICAgICAgICAgICAgICB0cmlsbGlvbjogJ3QnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKH5+KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdXJyZW5jeToge1xuICAgICAgICAgICAgICAgIHN5bWJvbDogJyQnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncHJlZml4J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgICAgICAgY3VycmVuY3lGb3JtYXQ6ICcsMDAwMCBhJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm1hdHM6IHtcbiAgICAgICAgICAgICAgICBmb3VyRGlnaXRzOiAnMDAwMCBhJyxcbiAgICAgICAgICAgICAgICBmdWxsV2l0aFR3b0RlY2ltYWxzOiAnJCAsMC4wMCcsXG4gICAgICAgICAgICAgICAgZnVsbFdpdGhUd29EZWNpbWFsc05vQ3VycmVuY3k6ICcsMC4wMCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgQ29uc3RydWN0b3JzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICAvLyBOdW1icm8gcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE51bWJybyhudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudW1iZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb2VzKGNvdW50KSB7XG4gICAgICAgIHZhciBpLCByZXQgPSAnJztcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgcmV0ICs9ICcwJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGF0aW9uIG9mIHRvRml4ZWQoKSBmb3IgbnVtYmVycyB3aXRoIGV4cG9uZW50ID4gMjFcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9GaXhlZExhcmdlKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgICAgICAgdmFyIG1hbnRpc3NhLFxuICAgICAgICAgICAgYmVmb3JlRGVjLFxuICAgICAgICAgICAgYWZ0ZXJEZWMsXG4gICAgICAgICAgICBleHBvbmVudCxcbiAgICAgICAgICAgIHN0cjtcblxuICAgICAgICBzdHIgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIG1hbnRpc3NhID0gc3RyLnNwbGl0KCdlJylbMF07XG4gICAgICAgIGV4cG9uZW50ICA9IHN0ci5zcGxpdCgnZScpWzFdO1xuXG4gICAgICAgIGJlZm9yZURlYyA9IG1hbnRpc3NhLnNwbGl0KCcuJylbMF07XG4gICAgICAgIGFmdGVyRGVjID0gbWFudGlzc2Euc3BsaXQoJy4nKVsxXSB8fCAnJztcblxuICAgICAgICBzdHIgPSBiZWZvcmVEZWMgKyBhZnRlckRlYyArIHplcm9lcyhleHBvbmVudCAtIGFmdGVyRGVjLmxlbmd0aCk7XG4gICAgICAgIGlmIChwcmVjaXNpb24gPiAwKSB7XG4gICAgICAgICAgICBzdHIgKz0gJy4nICsgemVyb2VzKHByZWNpc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGF0aW9uIG9mIHRvRml4ZWQoKSB0aGF0IHRyZWF0cyBmbG9hdHMgbW9yZSBsaWtlIGRlY2ltYWxzXG4gICAgICpcbiAgICAgKiBGaXhlcyBiaW5hcnkgcm91bmRpbmcgaXNzdWVzIChlZy4gKDAuNjE1KS50b0ZpeGVkKDIpID09PSAnMC42MScpIHRoYXQgcHJlc2VudFxuICAgICAqIHByb2JsZW1zIGZvciBhY2NvdW50aW5nLSBhbmQgZmluYW5jZS1yZWxhdGVkIHNvZnR3YXJlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRml4ZWQodmFsdWUsIHByZWNpc2lvbiwgcm91bmRpbmdGdW5jdGlvbiwgb3B0aW9uYWxzKSB7XG4gICAgICAgIHZhciBwb3dlciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pLFxuICAgICAgICAgICAgb3B0aW9uYWxzUmVnRXhwLFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIGlmICh2YWx1ZS50b0ZpeGVkKDApLnNlYXJjaCgnZScpID4gLTEpIHtcbiAgICAgICAgICAgIC8vIEFib3ZlIDFlMjEsIHRvRml4ZWQgcmV0dXJucyBzY2llbnRpZmljIG5vdGF0aW9uLCB3aGljaFxuICAgICAgICAgICAgLy8gaXMgdXNlbGVzcyBhbmQgdW5leHBlY3RlZFxuICAgICAgICAgICAgb3V0cHV0ID0gdG9GaXhlZExhcmdlKHZhbHVlLCBwcmVjaXNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy9yb3VuZGluZ0Z1bmN0aW9uID0gKHJvdW5kaW5nRnVuY3Rpb24gIT09IHVuZGVmaW5lZCA/IHJvdW5kaW5nRnVuY3Rpb24gOiBNYXRoLnJvdW5kKTtcbiAgICAgICAgICAgIC8vIE11bHRpcGx5IHVwIGJ5IHByZWNpc2lvbiwgcm91bmQgYWNjdXJhdGVseSwgdGhlbiBkaXZpZGUgYW5kIHVzZSBuYXRpdmUgdG9GaXhlZCgpOlxuICAgICAgICAgICAgb3V0cHV0ID0gKHJvdW5kaW5nRnVuY3Rpb24odmFsdWUgKiBwb3dlcikgLyBwb3dlcikudG9GaXhlZChwcmVjaXNpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbmFscykge1xuICAgICAgICAgICAgb3B0aW9uYWxzUmVnRXhwID0gbmV3IFJlZ0V4cCgnMHsxLCcgKyBvcHRpb25hbHMgKyAnfSQnKTtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKG9wdGlvbmFsc1JlZ0V4cCwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEZvcm1hdHRpbmdcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvLyBkZXRlcm1pbmUgd2hhdCB0eXBlIG9mIGZvcm1hdHRpbmcgd2UgbmVlZCB0byBkb1xuICAgIGZ1bmN0aW9uIGZvcm1hdE51bWJybyh2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHZhciBvdXRwdXQ7XG4gICAgICAgIC8vIFRPRE86IGRvIHNvbWV0aGluZyB3aXRoIGBsYW5ndWFnZWBcblxuICAgICAgICAvLyBmaWd1cmUgb3V0IHdoYXQga2luZCBvZiBmb3JtYXQgd2UgYXJlIGRlYWxpbmcgd2l0aFxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyQnKSA+IC0xKSB7IC8vIGN1cnJlbmN5ISEhISFcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdEN1cnJlbmN5KHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCclJykgPiAtMSkgeyAvLyBwZXJjZW50YWdlXG4gICAgICAgICAgICBvdXRwdXQgPSBmb3JtYXRQZXJjZW50YWdlKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCc6JykgPiAtMSkgeyAvLyB0aW1lXG4gICAgICAgICAgICBvdXRwdXQgPSBmb3JtYXRUaW1lKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gcGxhaW4gb2wnIG51bWJlcnMgb3IgYnl0ZXNcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdE51bWJlcih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiBzdHJpbmdcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRDdXJyZW5jeSh2YWx1ZSwgb3JpZ2luYWxGb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IG9yaWdpbmFsRm9ybWF0LFxuICAgICAgICAgICAgc3ltYm9sSW5kZXggPSBmb3JtYXQuaW5kZXhPZignJCcpLFxuICAgICAgICAgICAgb3BlblBhcmVuSW5kZXggPSBmb3JtYXQuaW5kZXhPZignKCcpLFxuICAgICAgICAgICAgcGx1c1NpZ25JbmRleCA9IGZvcm1hdC5pbmRleE9mKCcrJyksXG4gICAgICAgICAgICBtaW51c1NpZ25JbmRleCA9IGZvcm1hdC5pbmRleE9mKCctJyksXG4gICAgICAgICAgICBzcGFjZSA9ICcnLFxuICAgICAgICAgICAgZGVjaW1hbFNlcGFyYXRvciA9ICcnLFxuICAgICAgICAgICAgc3BsaWNlSW5kZXgsXG4gICAgICAgICAgICBvdXRwdXQ7XG5cbiAgICAgICAgaWYoZm9ybWF0LmluZGV4T2YoJyQnKSA9PT0gLTEpe1xuICAgICAgICAgICAgLy8gVXNlIGRlZmF1bHRzIGluc3RlYWQgb2YgdGhlIGZvcm1hdCBwcm92aWRlZFxuICAgICAgICAgICAgaWYgKGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5jdXJyZW5jeS5wb3NpdGlvbiA9PT0gJ2luZml4Jykge1xuICAgICAgICAgICAgICAgIGRlY2ltYWxTZXBhcmF0b3IgPSBjdWx0dXJlc1tjdXJyZW50Q3VsdHVyZV0uY3VycmVuY3kuc3ltYm9sO1xuICAgICAgICAgICAgICAgIGlmIChjdWx0dXJlc1tjdXJyZW50Q3VsdHVyZV0uY3VycmVuY3kuc3BhY2VTZXBhcmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbFNlcGFyYXRvciA9ICcgJyArIGRlY2ltYWxTZXBhcmF0b3IgKyAnICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdWx0dXJlc1tjdXJyZW50Q3VsdHVyZV0uY3VycmVuY3kuc3BhY2VTZXBhcmF0ZWQpIHtcbiAgICAgICAgICAgICAgICBzcGFjZSA9ICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgb3IgYWZ0ZXIgY3VycmVuY3lcbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignICQnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc3BhY2UgPSAnICc7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyAkJywgJycpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignJCAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc3BhY2UgPSAnICc7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyQgJywgJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnJCcsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvcm1hdCBUaGUgTnVtYmVyXG4gICAgICAgIG91dHB1dCA9IGZvcm1hdE51bWJlcih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uLCBkZWNpbWFsU2VwYXJhdG9yKTtcblxuICAgICAgICBpZiAob3JpZ2luYWxGb3JtYXQuaW5kZXhPZignJCcpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gVXNlIGRlZmF1bHRzIGluc3RlYWQgb2YgdGhlIGZvcm1hdCBwcm92aWRlZFxuICAgICAgICAgICAgc3dpdGNoIChjdWx0dXJlc1tjdXJyZW50Q3VsdHVyZV0uY3VycmVuY3kucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdwb3N0Zml4JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5pbmRleE9mKCcpJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoLTEsIDAsIHNwYWNlICsgY3VsdHVyZXNbY3VycmVudEN1bHR1cmVdLmN1cnJlbmN5LnN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBzcGFjZSArIGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5jdXJyZW5jeS5zeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW5maXgnOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwcmVmaXgnOlxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0LmluZGV4T2YoJygnKSA+IC0xIHx8IG91dHB1dC5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZUluZGV4ID0gTWF0aC5tYXgob3BlblBhcmVuSW5kZXgsIG1pbnVzU2lnbkluZGV4KSArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2Uoc3BsaWNlSW5kZXgsIDAsIGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5jdXJyZW5jeS5zeW1ib2wgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBjdWx0dXJlc1tjdXJyZW50Q3VsdHVyZV0uY3VycmVuY3kuc3ltYm9sICsgc3BhY2UgKyBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0N1cnJlbmN5IHBvc2l0aW9uIHNob3VsZCBiZSBhbW9uZyBbXCJwcmVmaXhcIiwgXCJpbmZpeFwiLCBcInBvc3RmaXhcIl0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIHRoZSBzeW1ib2xcbiAgICAgICAgICAgIGlmIChzeW1ib2xJbmRleCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dC5pbmRleE9mKCcoJykgPiAtMSB8fCBvdXRwdXQuaW5kZXhPZignKycpID4gLTEgfHwgb3V0cHV0LmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZUluZGV4ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN5bWJvbEluZGV4IDwgb3BlblBhcmVuSW5kZXggfHwgc3ltYm9sSW5kZXggPCBwbHVzU2lnbkluZGV4IHx8IHN5bWJvbEluZGV4IDwgbWludXNTaWduSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzeW1ib2wgYXBwZWFycyBiZWZvcmUgdGhlIFwiKFwiLCBcIitcIiBvciBcIi1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaWNlSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2Uoc3BsaWNlSW5kZXgsIDAsIGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5jdXJyZW5jeS5zeW1ib2wgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBjdWx0dXJlc1tjdXJyZW50Q3VsdHVyZV0uY3VycmVuY3kuc3ltYm9sICsgc3BhY2UgKyBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0LmluZGV4T2YoJyknKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoLTEsIDAsIHNwYWNlICsgY3VsdHVyZXNbY3VycmVudEN1bHR1cmVdLmN1cnJlbmN5LnN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBzcGFjZSArIGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5jdXJyZW5jeS5zeW1ib2w7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRQZXJjZW50YWdlKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHNwYWNlID0gJycsXG4gICAgICAgICAgICBvdXRwdXQ7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgKiAxMDA7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSAlXG4gICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignICUnKSA+IC0xKSB7XG4gICAgICAgICAgICBzcGFjZSA9ICcgJztcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgJScsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCclJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ID0gZm9ybWF0TnVtYmVyKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuXG4gICAgICAgIGlmIChvdXRwdXQuaW5kZXhPZignKScpID4gLTEpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5zcGxpdCgnJyk7XG4gICAgICAgICAgICBvdXRwdXQuc3BsaWNlKC0xLCAwLCBzcGFjZSArICclJyk7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBzcGFjZSArICclJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VGltZSh2YWx1ZSkge1xuICAgICAgICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKHZhbHVlIC8gNjAgLyA2MCksXG4gICAgICAgICAgICBtaW51dGVzID0gTWF0aC5mbG9vcigodmFsdWUgLSAoaG91cnMgKiA2MCAqIDYwKSkgLyA2MCksXG4gICAgICAgICAgICBzZWNvbmRzID0gTWF0aC5yb3VuZCh2YWx1ZSAtIChob3VycyAqIDYwICogNjApIC0gKG1pbnV0ZXMgKiA2MCkpO1xuICAgICAgICByZXR1cm4gaG91cnMgKyAnOicgK1xuICAgICAgICAgICAgKChtaW51dGVzIDwgMTApID8gJzAnICsgbWludXRlcyA6IG1pbnV0ZXMpICsgJzonICtcbiAgICAgICAgICAgICgoc2Vjb25kcyA8IDEwKSA/ICcwJyArIHNlY29uZHMgOiBzZWNvbmRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXROdW1iZXIgKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24sIHNlcCkge1xuICAgICAgICB2YXIgbmVnUCA9IGZhbHNlLFxuICAgICAgICAgICAgc2lnbmVkID0gZmFsc2UsXG4gICAgICAgICAgICBvcHREZWMgPSBmYWxzZSxcbiAgICAgICAgICAgIGFiYnIgPSAnJyxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBhYmJySyA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gdGhvdXNhbmRzXG4gICAgICAgICAgICBhYmJyTSA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gbWlsbGlvbnNcbiAgICAgICAgICAgIGFiYnJCID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvbiB0byBiaWxsaW9uc1xuICAgICAgICAgICAgYWJiclQgPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uIHRvIHRyaWxsaW9uc1xuICAgICAgICAgICAgYWJickZvcmNlID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvblxuICAgICAgICAgICAgYnl0ZXMgPSAnJyxcbiAgICAgICAgICAgIG9yZCA9ICcnLFxuICAgICAgICAgICAgYWJzID0gTWF0aC5hYnModmFsdWUpLFxuICAgICAgICAgICAgYmluYXJ5U3VmZml4ZXMgPSBbJ0InLCAnS2lCJywgJ01pQicsICdHaUInLCAnVGlCJywgJ1BpQicsICdFaUInLCAnWmlCJywgJ1lpQiddLFxuICAgICAgICAgICAgZGVjaW1hbFN1ZmZpeGVzID0gWydCJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJywgJ0VCJywgJ1pCJywgJ1lCJ10sXG4gICAgICAgICAgICBtaW4sXG4gICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICBwb3dlcixcbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoLFxuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgbWluaW11bVByZWNpc2lvbixcbiAgICAgICAgICAgIHBvdyxcbiAgICAgICAgICAgIHcsXG4gICAgICAgICAgICBpbnRQcmVjaXNpb24sXG4gICAgICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICBwb3N0Zml4LFxuICAgICAgICAgICAgdGhvdXNhbmRzLFxuICAgICAgICAgICAgZCA9ICcnLFxuICAgICAgICAgICAgZm9yY2VkTmVnID0gZmFsc2UsXG4gICAgICAgICAgICBuZWcgPSBmYWxzZSxcbiAgICAgICAgICAgIGluZGV4T3BlblAsXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgaW5kZXhNaW51cyxcbiAgICAgICAgICAgIHBhcmVuID0gJycsXG4gICAgICAgICAgICBtaW5sZW47XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgbnVtYmVyIGlzIHplcm8gYW5kIGEgY3VzdG9tIHplcm8gZm9ybWF0IGhhcyBiZWVuIHNldFxuICAgICAgICBpZiAodmFsdWUgPT09IDAgJiYgemVyb0Zvcm1hdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHplcm9Gb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ3snKSA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGVuZCA9IGZvcm1hdC5pbmRleE9mKCd9Jyk7XG4gICAgICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdGb3JtYXQgc2hvdWxkIGFsc28gY29udGFpbiBhIFwifVwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVmaXggPSBmb3JtYXQuc2xpY2UoMSwgZW5kKTtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5zbGljZShlbmQgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZWZpeCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCd9JykgPT09IGZvcm1hdC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBmb3JtYXQuaW5kZXhPZigneycpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdGb3JtYXQgc2hvdWxkIGFsc28gY29udGFpbiBhIFwie1wiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3N0Zml4ID0gZm9ybWF0LnNsaWNlKHN0YXJ0ICsgMSwgLTEpO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnNsaWNlKDAsIHN0YXJ0ICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3N0Zml4ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgbWluIGxlbmd0aFxuICAgICAgICB2YXIgaW5mbztcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICAgICAgICBpbmZvID0gZm9ybWF0Lm1hdGNoKC8oWzAtOV0rKS4qLyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmZvID0gZm9ybWF0Lm1hdGNoKC8oWzAtOV0rKVxcLi4qLyk7XG4gICAgICAgIH1cbiAgICAgICAgbWlubGVuID0gaW5mbyA9PT0gbnVsbCA/IC0xIDogaW5mb1sxXS5sZW5ndGg7XG5cbiAgICAgICAgLy8gc2VlIGlmIHdlIHNob3VsZCB1c2UgcGFyZW50aGVzZXMgZm9yIG5lZ2F0aXZlIG51bWJlciBvciBpZiB3ZSBzaG91bGQgcHJlZml4IHdpdGggYSBzaWduXG4gICAgICAgIC8vIGlmIGJvdGggYXJlIHByZXNlbnQgd2UgZGVmYXVsdCB0byBwYXJlbnRoZXNlc1xuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJy0nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGZvcmNlZE5lZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcoJykgPiAtMSkge1xuICAgICAgICAgICAgbmVnUCA9IHRydWU7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCcrJykgPiAtMSkge1xuICAgICAgICAgICAgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9cXCsvZywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VlIGlmIGFiYnJldmlhdGlvbiBpcyB3YW50ZWRcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdhJykgPiAtMSkge1xuICAgICAgICAgICAgaW50UHJlY2lzaW9uID0gZm9ybWF0LnNwbGl0KCcuJylbMF0ubWF0Y2goL1swLTldKy9nKSB8fCBbJzAnXTtcbiAgICAgICAgICAgIGludFByZWNpc2lvbiA9IHBhcnNlSW50KGludFByZWNpc2lvblswXSwgMTApO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBhYmJyZXZpYXRpb24gaXMgc3BlY2lmaWVkXG4gICAgICAgICAgICBhYmJySyA9IGZvcm1hdC5pbmRleE9mKCdhSycpID49IDA7XG4gICAgICAgICAgICBhYmJyTSA9IGZvcm1hdC5pbmRleE9mKCdhTScpID49IDA7XG4gICAgICAgICAgICBhYmJyQiA9IGZvcm1hdC5pbmRleE9mKCdhQicpID49IDA7XG4gICAgICAgICAgICBhYmJyVCA9IGZvcm1hdC5pbmRleE9mKCdhVCcpID49IDA7XG4gICAgICAgICAgICBhYmJyRm9yY2UgPSBhYmJySyB8fCBhYmJyTSB8fCBhYmJyQiB8fCBhYmJyVDtcblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSBhYmJyZXZpYXRpb25cbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignIGEnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgYWJiciA9ICcgJztcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnIGEnLCAnJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdhJywgJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b3RhbExlbmd0aCA9IE1hdGguZmxvb3IoTWF0aC5sb2coYWJzKSAvIE1hdGguTE4xMCkgKyAxO1xuXG4gICAgICAgICAgICBtaW5pbXVtUHJlY2lzaW9uID0gdG90YWxMZW5ndGggJSAzO1xuICAgICAgICAgICAgbWluaW11bVByZWNpc2lvbiA9IG1pbmltdW1QcmVjaXNpb24gPT09IDAgPyAzIDogbWluaW11bVByZWNpc2lvbjtcblxuICAgICAgICAgICAgaWYgKGludFByZWNpc2lvbiAmJiBhYnMgIT09IDApIHtcblxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IE1hdGguZmxvb3IoTWF0aC5sb2coYWJzKSAvIE1hdGguTE4xMCkgKyAxIC0gaW50UHJlY2lzaW9uO1xuXG4gICAgICAgICAgICAgICAgcG93ID0gMyAqIH5+KChNYXRoLm1pbihpbnRQcmVjaXNpb24sIHRvdGFsTGVuZ3RoKSAtIG1pbmltdW1QcmVjaXNpb24pIC8gMyk7XG5cbiAgICAgICAgICAgICAgICBhYnMgPSBhYnMgLyBNYXRoLnBvdygxMCwgcG93KTtcblxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignLicpID09PSAtMSAmJiBpbnRQcmVjaXNpb24gPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCArPSAnWy5dJztcblxuICAgICAgICAgICAgICAgICAgICBzaXplID0gbGVuZ3RoID09PSAwID8gMCA6IDMgKiB+fihsZW5ndGggLyAzKSAtIGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IHNpemUgPCAwID8gc2l6ZSArIDMgOiBzaXplO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCArPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKHZhbHVlKSkgLyBNYXRoLkxOMTApICsgMSAhPT0gaW50UHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFicyA+PSBNYXRoLnBvdygxMCwgMTIpICYmICFhYmJyRm9yY2UgfHwgYWJiclQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJpbGxpb25cbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBjdWx0dXJlc1tjdXJyZW50Q3VsdHVyZV0uYWJicmV2aWF0aW9ucy50cmlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCAxMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYnMgPCBNYXRoLnBvdygxMCwgMTIpICYmIGFicyA+PSBNYXRoLnBvdygxMCwgOSkgJiYgIWFiYnJGb3JjZSB8fCBhYmJyQikge1xuICAgICAgICAgICAgICAgICAgICAvLyBiaWxsaW9uXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSBhYmJyICsgY3VsdHVyZXNbY3VycmVudEN1bHR1cmVdLmFiYnJldmlhdGlvbnMuYmlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCA5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IE1hdGgucG93KDEwLCA5KSAmJiBhYnMgPj0gTWF0aC5wb3coMTAsIDYpICYmICFhYmJyRm9yY2UgfHwgYWJick0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5hYmJyZXZpYXRpb25zLm1pbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBNYXRoLnBvdygxMCwgNik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYnMgPCBNYXRoLnBvdygxMCwgNikgJiYgYWJzID49IE1hdGgucG93KDEwLCAzKSAmJiAhYWJickZvcmNlIHx8IGFiYnJLKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRob3VzYW5kXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSBhYmJyICsgY3VsdHVyZXNbY3VycmVudEN1bHR1cmVdLmFiYnJldmlhdGlvbnMudGhvdXNhbmQ7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBNYXRoLnBvdygxMCwgMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VlIGlmIHdlIGFyZSBmb3JtYXR0aW5nIGJpbmFyeSBieXRlc1xuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ2InKSA+IC0xKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyBiJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gJyAnO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgYicsICcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ2InLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAocG93ZXIgPSAwOyBwb3dlciA8PSBiaW5hcnlTdWZmaXhlcy5sZW5ndGg7IHBvd2VyKyspIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLnBvdygxMDI0LCBwb3dlcik7XG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5wb3coMTAyNCwgcG93ZXIgKyAxKTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPCBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSBieXRlcyArIGJpbmFyeVN1ZmZpeGVzW3Bvd2VyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBtaW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VlIGlmIHdlIGFyZSBmb3JtYXR0aW5nIGRlY2ltYWwgYnl0ZXNcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdkJykgPiAtMSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZVxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgZCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBieXRlcyA9ICcgJztcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnIGQnLCAnJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdkJywgJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHBvd2VyID0gMDsgcG93ZXIgPD0gZGVjaW1hbFN1ZmZpeGVzLmxlbmd0aDsgcG93ZXIrKykge1xuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgucG93KDEwMDAsIHBvd2VyKTtcbiAgICAgICAgICAgICAgICBtYXggPSBNYXRoLnBvdygxMDAwLCBwb3dlciArIDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcyA9IGJ5dGVzICsgZGVjaW1hbFN1ZmZpeGVzW3Bvd2VyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBtaW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VlIGlmIG9yZGluYWwgaXMgd2FudGVkXG4gICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignbycpID4gLTEpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmVcbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignIG8nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgb3JkID0gJyAnO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgbycsICcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ28nLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdWx0dXJlc1tjdXJyZW50Q3VsdHVyZV0ub3JkaW5hbCkge1xuICAgICAgICAgICAgICAgIG9yZCA9IG9yZCArIGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5vcmRpbmFsKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignWy5dJykgPiAtMSkge1xuICAgICAgICAgICAgb3B0RGVjID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdbLl0nLCAnLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdyA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcbiAgICAgICAgcHJlY2lzaW9uID0gZm9ybWF0LnNwbGl0KCcuJylbMV07XG4gICAgICAgIHRob3VzYW5kcyA9IGZvcm1hdC5pbmRleE9mKCcsJyk7XG5cbiAgICAgICAgaWYgKHByZWNpc2lvbikge1xuICAgICAgICAgICAgaWYgKHByZWNpc2lvbi5pbmRleE9mKCcqJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZCA9IHRvRml4ZWQodmFsdWUsIHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVsxXS5sZW5ndGgsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uLmluZGV4T2YoJ1snKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbi5yZXBsYWNlKCddJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24uc3BsaXQoJ1snKTtcbiAgICAgICAgICAgICAgICAgICAgZCA9IHRvRml4ZWQodmFsdWUsIChwcmVjaXNpb25bMF0ubGVuZ3RoICsgcHJlY2lzaW9uWzFdLmxlbmd0aCksIHJvdW5kaW5nRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb25bMV0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkID0gdG9GaXhlZCh2YWx1ZSwgcHJlY2lzaW9uLmxlbmd0aCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3ID0gZC5zcGxpdCgnLicpWzBdO1xuXG4gICAgICAgICAgICBpZiAoZC5zcGxpdCgnLicpWzFdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gc2VwID8gYWJiciArIHNlcCA6IGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5kZWxpbWl0ZXJzLmRlY2ltYWw7XG4gICAgICAgICAgICAgICAgZCA9IHAgKyBkLnNwbGl0KCcuJylbMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGQgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdERlYyAmJiBOdW1iZXIoZC5zbGljZSgxKSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3ID0gdG9GaXhlZCh2YWx1ZSwgbnVsbCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3JtYXQgbnVtYmVyXG4gICAgICAgIGlmICh3LmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICB3ID0gdy5zbGljZSgxKTtcbiAgICAgICAgICAgIG5lZyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5sZW5ndGggPCBtaW5sZW4pIHtcbiAgICAgICAgICAgIHcgPSBuZXcgQXJyYXkobWlubGVuIC0gdy5sZW5ndGggKyAxKS5qb2luKCcwJykgKyB3O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRob3VzYW5kcyA+IC0xKSB7XG4gICAgICAgICAgICB3ID0gdy50b1N0cmluZygpLnJlcGxhY2UoLyhcXGQpKD89KFxcZHszfSkrKD8hXFxkKSkvZywgJyQxJyArXG4gICAgICAgICAgICAgICAgY3VsdHVyZXNbY3VycmVudEN1bHR1cmVdLmRlbGltaXRlcnMudGhvdXNhbmRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignLicpID09PSAwKSB7XG4gICAgICAgICAgICB3ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleE9wZW5QID0gZm9ybWF0LmluZGV4T2YoJygnKTtcbiAgICAgICAgaW5kZXhNaW51cyA9IGZvcm1hdC5pbmRleE9mKCctJyk7XG5cbiAgICAgICAgaWYgKGluZGV4T3BlblAgPCBpbmRleE1pbnVzKSB7XG4gICAgICAgICAgICBwYXJlbiA9ICgobmVnUCAmJiBuZWcpID8gJygnIDogJycpICsgKCgoZm9yY2VkTmVnICYmIG5lZykgfHwgKCFuZWdQICYmIG5lZykpID8gJy0nIDogJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW4gPSAoKChmb3JjZWROZWcgJiYgbmVnKSB8fCAoIW5lZ1AgJiYgbmVnKSkgPyAnLScgOiAnJykgKyAoKG5lZ1AgJiYgbmVnKSA/ICcoJyA6ICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcmVmaXggK1xuICAgICAgICAgICAgcGFyZW4gKyAoKCFuZWcgJiYgc2lnbmVkICYmIHZhbHVlICE9PSAwKSA/ICcrJyA6ICcnKSArXG4gICAgICAgICAgICB3ICsgZCArXG4gICAgICAgICAgICAoKG9yZCkgPyBvcmQgOiAnJykgK1xuICAgICAgICAgICAgKChhYmJyICYmICFzZXApID8gYWJiciA6ICcnKSArXG4gICAgICAgICAgICAoKGJ5dGVzKSA/IGJ5dGVzIDogJycpICtcbiAgICAgICAgICAgICgobmVnUCAmJiBuZWcpID8gJyknIDogJycpICtcbiAgICAgICAgICAgIHBvc3RmaXg7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBUb3AgTGV2ZWwgRnVuY3Rpb25zXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgbnVtYnJvID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKG51bWJyby5pc051bWJybyhpbnB1dCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQudmFsdWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gMCB8fCB0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoIU51bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gbnVtYnJvLmZuLnVuZm9ybWF0KGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTnVtYnJvKE51bWJlcihpbnB1dCkpO1xuICAgIH07XG5cbiAgICAvLyB2ZXJzaW9uIG51bWJlclxuICAgIG51bWJyby52ZXJzaW9uID0gVkVSU0lPTjtcblxuICAgIC8vIGNvbXBhcmUgbnVtYnJvIG9iamVjdFxuICAgIG51bWJyby5pc051bWJybyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTnVtYnJvO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFsbG93IHRoZSB1c2VyIHRvIHNldCBhIG5ldyBsYW5ndWFnZSB3aXRoIGEgZmFsbGJhY2sgaWZcbiAgICAgKiB0aGUgbGFuZ3VhZ2UgZG9lcyBub3QgZXhpc3QuIElmIG5vIGZhbGxiYWNrIGxhbmd1YWdlIGlzIHByb3ZpZGVkLFxuICAgICAqIGl0IGZhbGxiYWNrcyB0byBlbmdsaXNoLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgU2luY2UgaW4gdmVyc2lvbiAxLjYuMC4gSXQgd2lsbCBiZSBkZWxldGVkIGluIHZlcnNpb24gMi4wXG4gICAgICogYHNldEN1bHR1cmVgIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgICovXG4gICAgbnVtYnJvLnNldExhbmd1YWdlID0gZnVuY3Rpb24obmV3TGFuZ3VhZ2UsIGZhbGxiYWNrTGFuZ3VhZ2UpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdgc2V0TGFuZ3VhZ2VgIGlzIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjYuMC4gVXNlIGBzZXRDdWx0dXJlYCBpbnN0ZWFkJyk7XG4gICAgICAgIHZhciBrZXkgPSBuZXdMYW5ndWFnZSxcbiAgICAgICAgICAgIHByZWZpeCA9IG5ld0xhbmd1YWdlLnNwbGl0KCctJylbMF0sXG4gICAgICAgICAgICBtYXRjaGluZ0xhbmd1YWdlID0gbnVsbDtcbiAgICAgICAgaWYgKCFsYW5ndWFnZXNba2V5XSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobGFuZ3VhZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGluZ0xhbmd1YWdlICYmIGxhbmd1YWdlLnNwbGl0KCctJylbMF0gPT09IHByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZ0xhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBrZXkgPSBtYXRjaGluZ0xhbmd1YWdlIHx8IGZhbGxiYWNrTGFuZ3VhZ2UgfHwgJ2VuLVVTJztcbiAgICAgICAgfVxuICAgICAgICBjaG9vc2VDdWx0dXJlKGtleSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWxsb3cgdGhlIHVzZXIgdG8gc2V0IGEgbmV3IGN1bHR1cmUgd2l0aCBhIGZhbGxiYWNrIGlmXG4gICAgICogdGhlIGN1bHR1cmUgZG9lcyBub3QgZXhpc3QuIElmIG5vIGZhbGxiYWNrIGN1bHR1cmUgaXMgcHJvdmlkZWQsXG4gICAgICogaXQgZmFsbGJhY2tzIHRvIFwiZW4tVVNcIi5cbiAgICAgKi9cbiAgICBudW1icm8uc2V0Q3VsdHVyZSA9IGZ1bmN0aW9uKG5ld0N1bHR1cmUsIGZhbGxiYWNrQ3VsdHVyZSkge1xuICAgICAgICB2YXIga2V5ID0gbmV3Q3VsdHVyZSxcbiAgICAgICAgICAgIHN1ZmZpeCA9IG5ld0N1bHR1cmUuc3BsaXQoJy0nKVsxXSxcbiAgICAgICAgICAgIG1hdGNoaW5nQ3VsdHVyZSA9IG51bGw7XG4gICAgICAgIGlmICghY3VsdHVyZXNba2V5XSkge1xuICAgICAgICAgICAgaWYgKHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGN1bHR1cmVzKS5mb3JFYWNoKGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hpbmdDdWx0dXJlICYmIGxhbmd1YWdlLnNwbGl0KCctJylbMV0gPT09IHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdDdWx0dXJlID0gbGFuZ3VhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAga2V5ID0gbWF0Y2hpbmdDdWx0dXJlIHx8IGZhbGxiYWNrQ3VsdHVyZSB8fCAnZW4tVVMnO1xuICAgICAgICB9XG4gICAgICAgIGNob29zZUN1bHR1cmUoa2V5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbGFuZ3VhZ2VzIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxhbmd1YWdlLiAgSWZcbiAgICAgKiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgICAqIGxhbmd1YWdlIGtleS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFNpbmNlIGluIHZlcnNpb24gMS42LjAuIEl0IHdpbGwgYmUgZGVsZXRlZCBpbiB2ZXJzaW9uIDIuMFxuICAgICAqIGBjdWx0dXJlYCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIG51bWJyby5sYW5ndWFnZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYGxhbmd1YWdlYCBpcyBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS42LjAuIFVzZSBgY3VsdHVyZWAgaW5zdGVhZCcpO1xuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEN1bHR1cmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ICYmICF2YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICghbGFuZ3VhZ2VzW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2UgOiAnICsga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNob29zZUN1bHR1cmUoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZXMgfHwgIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICBzZXRDdWx0dXJlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW1icm87XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGN1bHR1cmVzIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGN1bHR1cmUuICBJZlxuICAgICAqIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgICogY3VsdHVyZSBjb2RlLlxuICAgICAqL1xuICAgIG51bWJyby5jdWx0dXJlID0gZnVuY3Rpb24oY29kZSwgdmFsdWVzKSB7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDdWx0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgJiYgIXZhbHVlcykge1xuICAgICAgICAgICAgaWYgKCFjdWx0dXJlc1tjb2RlXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjdWx0dXJlIDogJyArIGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hvb3NlQ3VsdHVyZShjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZXMgfHwgIWN1bHR1cmVzW2NvZGVdKSB7XG4gICAgICAgICAgICBzZXRDdWx0dXJlKGNvZGUsIHZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVtYnJvO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgbG9hZGVkIGxhbmd1YWdlIGRhdGEuICBJZlxuICAgICAqIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnRcbiAgICAgKiBnbG9iYWwgbGFuZ3VhZ2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgU2luY2UgaW4gdmVyc2lvbiAxLjYuMC4gSXQgd2lsbCBiZSBkZWxldGVkIGluIHZlcnNpb24gMi4wXG4gICAgICogYGN1bHR1cmVgIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgICovXG4gICAgbnVtYnJvLmxhbmd1YWdlRGF0YSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2BsYW5ndWFnZURhdGFgIGlzIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjYuMC4gVXNlIGBjdWx0dXJlRGF0YWAgaW5zdGVhZCcpO1xuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzW2N1cnJlbnRDdWx0dXJlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbGFuZ3VhZ2VzW2tleV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsYW5ndWFnZSA6ICcgKyBrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlc1trZXldO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgbG9hZGVkIGN1bHR1cmUgZGF0YS4gIElmXG4gICAgICogbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudFxuICAgICAqIGdsb2JhbCBjdWx0dXJlIG9iamVjdC5cbiAgICAgKi9cbiAgICBudW1icm8uY3VsdHVyZURhdGEgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY3VsdHVyZXNbY29kZV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjdWx0dXJlIDogJyArIGNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1bHR1cmVzW2NvZGVdO1xuICAgIH07XG5cbiAgICBudW1icm8uY3VsdHVyZSgnZW4tVVMnLCBlblVTKTtcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFNpbmNlIGluIHZlcnNpb24gMS42LjAuIEl0IHdpbGwgYmUgZGVsZXRlZCBpbiB2ZXJzaW9uIDIuMFxuICAgICAqIGBjdWx0dXJlc2Agc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBudW1icm8ubGFuZ3VhZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYGxhbmd1YWdlc2AgaXMgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuNi4wLiBVc2UgYGN1bHR1cmVzYCBpbnN0ZWFkJyk7XG5cbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlcztcbiAgICB9O1xuXG4gICAgbnVtYnJvLmN1bHR1cmVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjdWx0dXJlcztcbiAgICB9O1xuXG4gICAgbnVtYnJvLnplcm9Gb3JtYXQgPSBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgemVyb0Zvcm1hdCA9IHR5cGVvZihmb3JtYXQpID09PSAnc3RyaW5nJyA/IGZvcm1hdCA6IG51bGw7XG4gICAgfTtcblxuICAgIG51bWJyby5kZWZhdWx0Rm9ybWF0ID0gZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIGRlZmF1bHRGb3JtYXQgPSB0eXBlb2YoZm9ybWF0KSA9PT0gJ3N0cmluZycgPyBmb3JtYXQgOiAnMC4wJztcbiAgICB9O1xuXG4gICAgbnVtYnJvLmRlZmF1bHRDdXJyZW5jeUZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgZGVmYXVsdEN1cnJlbmN5Rm9ybWF0ID0gdHlwZW9mKGZvcm1hdCkgPT09ICdzdHJpbmcnID8gZm9ybWF0IDogJzAkJztcbiAgICB9O1xuXG4gICAgbnVtYnJvLnZhbGlkYXRlID0gZnVuY3Rpb24odmFsLCBjdWx0dXJlKSB7XG5cbiAgICAgICAgdmFyIF9kZWNpbWFsU2VwLFxuICAgICAgICAgICAgX3Rob3VzYW5kU2VwLFxuICAgICAgICAgICAgX2N1cnJTeW1ib2wsXG4gICAgICAgICAgICBfdmFsQXJyYXksXG4gICAgICAgICAgICBfYWJick9iaixcbiAgICAgICAgICAgIF90aG91c2FuZFJlZ0V4LFxuICAgICAgICAgICAgY3VsdHVyZURhdGEsXG4gICAgICAgICAgICB0ZW1wO1xuXG4gICAgICAgIC8vY29lcmNlIHZhbCB0byBzdHJpbmdcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWwgKz0gJyc7XG4gICAgICAgICAgICBpZiAoY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdOdW1icm8uanM6IFZhbHVlIGlzIG5vdCBzdHJpbmcuIEl0IGhhcyBiZWVuIGNvLWVyY2VkIHRvOiAnLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy90cmltIHdoaXRlc3BhY2VzIGZyb20gZWl0aGVyIHNpZGVzXG4gICAgICAgIHZhbCA9IHZhbC50cmltKCk7XG5cbiAgICAgICAgLy9pZiB2YWwgaXMganVzdCBkaWdpdHMgcmV0dXJuIHRydWVcbiAgICAgICAgaWYgKCAhISB2YWwubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdmFsIGlzIGVtcHR5IHJldHVybiBmYWxzZVxuICAgICAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9nZXQgdGhlIGRlY2ltYWwgYW5kIHRob3VzYW5kcyBzZXBhcmF0b3IgZnJvbSBudW1icm8uY3VsdHVyZURhdGFcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhlIGN1bHR1cmUgaXMgdW5kZXJzdG9vZCBieSBudW1icm8uIGlmIG5vdCwgZGVmYXVsdCBpdCB0byBjdXJyZW50IGN1bHR1cmVcbiAgICAgICAgICAgIGN1bHR1cmVEYXRhID0gbnVtYnJvLmN1bHR1cmVEYXRhKGN1bHR1cmUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjdWx0dXJlRGF0YSA9IG51bWJyby5jdWx0dXJlRGF0YShudW1icm8uY3VsdHVyZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc2V0dXAgdGhlIGRlbGltaXRlcnMgYW5kIGN1cnJlbmN5IHN5bWJvbCBiYXNlZCBvbiBjdWx0dXJlXG4gICAgICAgIF9jdXJyU3ltYm9sID0gY3VsdHVyZURhdGEuY3VycmVuY3kuc3ltYm9sO1xuICAgICAgICBfYWJick9iaiA9IGN1bHR1cmVEYXRhLmFiYnJldmlhdGlvbnM7XG4gICAgICAgIF9kZWNpbWFsU2VwID0gY3VsdHVyZURhdGEuZGVsaW1pdGVycy5kZWNpbWFsO1xuICAgICAgICBpZiAoY3VsdHVyZURhdGEuZGVsaW1pdGVycy50aG91c2FuZHMgPT09ICcuJykge1xuICAgICAgICAgICAgX3Rob3VzYW5kU2VwID0gJ1xcXFwuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aG91c2FuZFNlcCA9IGN1bHR1cmVEYXRhLmRlbGltaXRlcnMudGhvdXNhbmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWRhdGluZyBjdXJyZW5jeSBzeW1ib2xcbiAgICAgICAgdGVtcCA9IHZhbC5tYXRjaCgvXlteXFxkXSsvKTtcbiAgICAgICAgaWYgKHRlbXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5zdWJzdHIoMSk7XG4gICAgICAgICAgICBpZiAodGVtcFswXSAhPT0gX2N1cnJTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3ZhbGlkYXRpbmcgYWJicmV2aWF0aW9uIHN5bWJvbFxuICAgICAgICB0ZW1wID0gdmFsLm1hdGNoKC9bXlxcZF0rJC8pO1xuICAgICAgICBpZiAodGVtcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsID0gdmFsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGlmICh0ZW1wWzBdICE9PSBfYWJick9iai50aG91c2FuZCAmJiB0ZW1wWzBdICE9PSBfYWJick9iai5taWxsaW9uICYmXG4gICAgICAgICAgICAgICAgICAgIHRlbXBbMF0gIT09IF9hYmJyT2JqLmJpbGxpb24gJiYgdGVtcFswXSAhPT0gX2FiYnJPYmoudHJpbGxpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhvdXNhbmRSZWdFeCA9IG5ldyBSZWdFeHAoX3Rob3VzYW5kU2VwICsgJ3syfScpO1xuXG4gICAgICAgIGlmICghdmFsLm1hdGNoKC9bXlxcZC4sXS9nKSkge1xuICAgICAgICAgICAgX3ZhbEFycmF5ID0gdmFsLnNwbGl0KF9kZWNpbWFsU2VwKTtcbiAgICAgICAgICAgIGlmIChfdmFsQXJyYXkubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKF92YWxBcnJheS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoICEhIF92YWxBcnJheVswXS5tYXRjaCgvXlxcZCsuKlxcZCQvKSAmJiAhX3ZhbEFycmF5WzBdLm1hdGNoKF90aG91c2FuZFJlZ0V4KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF92YWxBcnJheVswXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoICEhIF92YWxBcnJheVswXS5tYXRjaCgvXlxcZCskLykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhX3ZhbEFycmF5WzBdLm1hdGNoKF90aG91c2FuZFJlZ0V4KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEhIF92YWxBcnJheVsxXS5tYXRjaCgvXlxcZCskLykpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggISEgX3ZhbEFycmF5WzBdLm1hdGNoKC9eXFxkKy4qXFxkJC8pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIV92YWxBcnJheVswXS5tYXRjaChfdGhvdXNhbmRSZWdFeCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhISBfdmFsQXJyYXlbMV0ubWF0Y2goL15cXGQrJC8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBIZWxwZXJzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gc2V0Q3VsdHVyZShjb2RlLCB2YWx1ZXMpIHtcbiAgICAgICAgY3VsdHVyZXNbY29kZV0gPSB2YWx1ZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hvb3NlQ3VsdHVyZShjb2RlKSB7XG4gICAgICAgIGN1cnJlbnRDdWx0dXJlID0gY29kZTtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0gY3VsdHVyZXNbY29kZV0uZGVmYXVsdHM7XG4gICAgICAgIGlmIChkZWZhdWx0cyAmJiBkZWZhdWx0cy5mb3JtYXQpIHtcbiAgICAgICAgICAgIG51bWJyby5kZWZhdWx0Rm9ybWF0KGRlZmF1bHRzLmZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRzICYmIGRlZmF1bHRzLmN1cnJlbmN5Rm9ybWF0KSB7XG4gICAgICAgICAgICBudW1icm8uZGVmYXVsdEN1cnJlbmN5Rm9ybWF0KGRlZmF1bHRzLmN1cnJlbmN5Rm9ybWF0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdChpbnB1dCwgZm9ybWF0U3RyaW5nLCBsYW5ndWFnZSwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICBpZiAobGFuZ3VhZ2UgIT0gbnVsbCAmJiBsYW5ndWFnZSAhPT0gbnVtYnJvLmN1bHR1cmUoKSkge1xuICAgICAgICAgICAgbnVtYnJvLnNldEN1bHR1cmUobGFuZ3VhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXROdW1icm8oXG4gICAgICAgICAgICBOdW1iZXIoaW5wdXQpLFxuICAgICAgICAgICAgZm9ybWF0U3RyaW5nICE9IG51bGwgICAgID8gZm9ybWF0U3RyaW5nIDogZGVmYXVsdEZvcm1hdCxcbiAgICAgICAgICAgIHJvdW5kaW5nRnVuY3Rpb24gPT0gbnVsbCA/IE1hdGgucm91bmQgICA6IHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1wiZm9ybWF0XCI6IGZvcm1hdH07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIHBhcnNlQ29kZSA9IHJlcXVpcmUoJy4vcGFyc2VDb2RlJyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi9leHRlbmQnKTtcbnZhciBwcm9qZWN0aW9ucyA9IHJlcXVpcmUoJy4vcHJvamVjdGlvbnMnKTtcbnZhciBkZXJpdmVDb25zdGFudHMgPSByZXF1aXJlKCcuL2Rlcml2ZUNvbnN0YW50cycpO1xudmFyIERhdHVtID0gcmVxdWlyZSgnLi9jb25zdGFudHMvRGF0dW0nKTtcbnZhciBkYXR1bSA9IHJlcXVpcmUoJy4vZGF0dW0nKTtcblxuXG5mdW5jdGlvbiBQcm9qZWN0aW9uKHNyc0NvZGUsY2FsbGJhY2spIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb2plY3Rpb24pKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9qZWN0aW9uKHNyc0NvZGUpO1xuICB9XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oZXJyb3Ipe1xuICAgIGlmKGVycm9yKXtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgdmFyIGpzb24gPSBwYXJzZUNvZGUoc3JzQ29kZSk7XG4gIGlmKHR5cGVvZiBqc29uICE9PSAnb2JqZWN0Jyl7XG4gICAgY2FsbGJhY2soc3JzQ29kZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvdXJQcm9qID0gUHJvamVjdGlvbi5wcm9qZWN0aW9ucy5nZXQoanNvbi5wcm9qTmFtZSk7XG4gIGlmKCFvdXJQcm9qKXtcbiAgICBjYWxsYmFjayhzcnNDb2RlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGpzb24uZGF0dW1Db2RlICYmIGpzb24uZGF0dW1Db2RlICE9PSAnbm9uZScpIHtcbiAgICB2YXIgZGF0dW1EZWYgPSBEYXR1bVtqc29uLmRhdHVtQ29kZV07XG4gICAgaWYgKGRhdHVtRGVmKSB7XG4gICAgICBqc29uLmRhdHVtX3BhcmFtcyA9IGRhdHVtRGVmLnRvd2dzODQgPyBkYXR1bURlZi50b3dnczg0LnNwbGl0KCcsJykgOiBudWxsO1xuICAgICAganNvbi5lbGxwcyA9IGRhdHVtRGVmLmVsbGlwc2U7XG4gICAgICBqc29uLmRhdHVtTmFtZSA9IGRhdHVtRGVmLmRhdHVtTmFtZSA/IGRhdHVtRGVmLmRhdHVtTmFtZSA6IGpzb24uZGF0dW1Db2RlO1xuICAgIH1cbiAgfVxuICBqc29uLmswID0ganNvbi5rMCB8fCAxLjA7XG4gIGpzb24uYXhpcyA9IGpzb24uYXhpcyB8fCAnZW51JztcblxuICB2YXIgc3BoZXJlID0gZGVyaXZlQ29uc3RhbnRzLnNwaGVyZShqc29uLmEsIGpzb24uYiwganNvbi5yZiwganNvbi5lbGxwcywganNvbi5zcGhlcmUpO1xuICB2YXIgZWNjID0gZGVyaXZlQ29uc3RhbnRzLmVjY2VudHJpY2l0eShzcGhlcmUuYSwgc3BoZXJlLmIsIHNwaGVyZS5yZiwganNvbi5SX0EpO1xuICB2YXIgZGF0dW1PYmogPSBqc29uLmRhdHVtIHx8IGRhdHVtKGpzb24uZGF0dW1Db2RlLCBqc29uLmRhdHVtX3BhcmFtcywgc3BoZXJlLmEsIHNwaGVyZS5iLCBlY2MuZXMsIGVjYy5lcDIpO1xuXG4gIGV4dGVuZCh0aGlzLCBqc29uKTsgLy8gdHJhbnNmZXIgZXZlcnl0aGluZyBvdmVyIGZyb20gdGhlIHByb2plY3Rpb24gYmVjYXVzZSB3ZSBkb24ndCBrbm93IHdoYXQgd2UnbGwgbmVlZFxuICBleHRlbmQodGhpcywgb3VyUHJvaik7IC8vIHRyYW5zZmVyIGFsbCB0aGUgbWV0aG9kcyBmcm9tIHRoZSBwcm9qZWN0aW9uXG5cbiAgLy8gY29weSB0aGUgNCB0aGluZ3Mgb3ZlciB3ZSBjYWx1bGF0ZWQgaW4gZGVyaXZlQ29uc3RhbnRzLnNwaGVyZVxuICB0aGlzLmEgPSBzcGhlcmUuYTtcbiAgdGhpcy5iID0gc3BoZXJlLmI7XG4gIHRoaXMucmYgPSBzcGhlcmUucmY7XG4gIHRoaXMuc3BoZXJlID0gc3BoZXJlLnNwaGVyZTtcblxuICAvLyBjb3B5IHRoZSAzIHRoaW5ncyB3ZSBjYWxjdWxhdGVkIGluIGRlcml2ZUNvbnN0YW50cy5lY2NlbnRyaWNpdHlcbiAgdGhpcy5lcyA9IGVjYy5lcztcbiAgdGhpcy5lID0gZWNjLmU7XG4gIHRoaXMuZXAyID0gZWNjLmVwMjtcblxuICAvLyBhZGQgaW4gdGhlIGRhdHVtIG9iamVjdFxuICB0aGlzLmRhdHVtID0gZGF0dW1PYmo7XG5cbiAgLy8gaW5pdCB0aGUgcHJvamVjdGlvblxuICB0aGlzLmluaXQoKTtcblxuICAvLyBsZWdlY3kgY2FsbGJhY2sgZnJvbSBiYWNrIGluIHRoZSBkYXkgd2hlbiBpdCB3ZW50IHRvIHNwYXRpYWxyZWZlcmVuY2Uub3JnXG4gIGNhbGxiYWNrKG51bGwsIHRoaXMpO1xuXG59XG5Qcm9qZWN0aW9uLnByb2plY3Rpb25zID0gcHJvamVjdGlvbnM7XG5Qcm9qZWN0aW9uLnByb2plY3Rpb25zLnN0YXJ0KCk7XG5tb2R1bGUuZXhwb3J0cyA9IFByb2plY3Rpb247XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNycywgZGVub3JtLCBwb2ludCkge1xuICB2YXIgeGluID0gcG9pbnQueCxcbiAgICB5aW4gPSBwb2ludC55LFxuICAgIHppbiA9IHBvaW50LnogfHwgMC4wO1xuICB2YXIgdiwgdCwgaTtcbiAgdmFyIG91dCA9IHt9O1xuICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgaWYgKGRlbm9ybSAmJiBpID09PSAyICYmIHBvaW50LnogPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICB2ID0geGluO1xuICAgICAgdCA9ICd4JztcbiAgICB9XG4gICAgZWxzZSBpZiAoaSA9PT0gMSkge1xuICAgICAgdiA9IHlpbjtcbiAgICAgIHQgPSAneSc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdiA9IHppbjtcbiAgICAgIHQgPSAneic7XG4gICAgfVxuICAgIHN3aXRjaCAoY3JzLmF4aXNbaV0pIHtcbiAgICBjYXNlICdlJzpcbiAgICAgIG91dFt0XSA9IHY7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3JzpcbiAgICAgIG91dFt0XSA9IC12O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbic6XG4gICAgICBvdXRbdF0gPSB2O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncyc6XG4gICAgICBvdXRbdF0gPSAtdjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3UnOlxuICAgICAgaWYgKHBvaW50W3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0LnogPSB2O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZCc6XG4gICAgICBpZiAocG9pbnRbdF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXQueiA9IC12O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vY29uc29sZS5sb2coXCJFUlJPUjogdW5rbm93IGF4aXMgKFwiK2Nycy5heGlzW2ldK1wiKSAtIGNoZWNrIGRlZmluaXRpb24gb2YgXCIrY3JzLnByb2pOYW1lKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufTtcbiIsInZhciBUV09fUEkgPSBNYXRoLlBJICogMjtcbi8vIFNQSSBpcyBzbGlnaHRseSBncmVhdGVyIHRoYW4gTWF0aC5QSSwgc28gdmFsdWVzIHRoYXQgZXhjZWVkIHRoZSAtMTgwLi4xODBcbi8vIGRlZ3JlZSByYW5nZSBieSBhIHRpbnkgYW1vdW50IGRvbid0IGdldCB3cmFwcGVkLiBUaGlzIHByZXZlbnRzIHBvaW50cyB0aGF0XG4vLyBoYXZlIGRyaWZ0ZWQgZnJvbSB0aGVpciBvcmlnaW5hbCBsb2NhdGlvbiBhbG9uZyB0aGUgMTgwdGggbWVyaWRpYW4gKGR1ZSB0b1xuLy8gZmxvYXRpbmcgcG9pbnQgZXJyb3IpIGZyb20gY2hhbmdpbmcgdGhlaXIgc2lnbi5cbnZhciBTUEkgPSAzLjE0MTU5MjY1MzU5O1xudmFyIHNpZ24gPSByZXF1aXJlKCcuL3NpZ24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoTWF0aC5hYnMoeCkgPD0gU1BJKSA/IHggOiAoeCAtIChzaWduKHgpICogVFdPX1BJKSk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWNjZW50LCBzaW5waGksIGNvc3BoaSkge1xuICB2YXIgY29uID0gZWNjZW50ICogc2lucGhpO1xuICByZXR1cm4gY29zcGhpIC8gKE1hdGguc3FydCgxIC0gY29uICogY29uKSk7XG59OyIsInZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlY2NlbnQsIHRzKSB7XG4gIHZhciBlY2NudGggPSAwLjUgKiBlY2NlbnQ7XG4gIHZhciBjb24sIGRwaGk7XG4gIHZhciBwaGkgPSBIQUxGX1BJIC0gMiAqIE1hdGguYXRhbih0cyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IDE1OyBpKyspIHtcbiAgICBjb24gPSBlY2NlbnQgKiBNYXRoLnNpbihwaGkpO1xuICAgIGRwaGkgPSBIQUxGX1BJIC0gMiAqIE1hdGguYXRhbih0cyAqIChNYXRoLnBvdygoKDEgLSBjb24pIC8gKDEgKyBjb24pKSwgZWNjbnRoKSkpIC0gcGhpO1xuICAgIHBoaSArPSBkcGhpO1xuICAgIGlmIChNYXRoLmFicyhkcGhpKSA8PSAwLjAwMDAwMDAwMDEpIHtcbiAgICAgIHJldHVybiBwaGk7XG4gICAgfVxuICB9XG4gIC8vY29uc29sZS5sb2coXCJwaGkyeiBoYXMgTm9Db252ZXJnZW5jZVwiKTtcbiAgcmV0dXJuIC05OTk5O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg8MCA/IC0xIDogMTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyYXkpe1xuICB2YXIgb3V0ID0ge1xuICAgIHg6IGFycmF5WzBdLFxuICAgIHk6IGFycmF5WzFdXG4gIH07XG4gIGlmIChhcnJheS5sZW5ndGg+Mikge1xuICAgIG91dC56ID0gYXJyYXlbMl07XG4gIH1cbiAgaWYgKGFycmF5Lmxlbmd0aD4zKSB7XG4gICAgb3V0Lm0gPSBhcnJheVszXTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTsiLCJ2YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlY2NlbnQsIHBoaSwgc2lucGhpKSB7XG4gIHZhciBjb24gPSBlY2NlbnQgKiBzaW5waGk7XG4gIHZhciBjb20gPSAwLjUgKiBlY2NlbnQ7XG4gIGNvbiA9IE1hdGgucG93KCgoMSAtIGNvbikgLyAoMSArIGNvbikpLCBjb20pO1xuICByZXR1cm4gKE1hdGgudGFuKDAuNSAqIChIQUxGX1BJIC0gcGhpKSkgLyBjb24pO1xufTsiLCJleHBvcnRzLndnczg0ID0ge1xuICB0b3dnczg0OiBcIjAsMCwwXCIsXG4gIGVsbGlwc2U6IFwiV0dTODRcIixcbiAgZGF0dW1OYW1lOiBcIldHUzg0XCJcbn07XG5leHBvcnRzLmNoMTkwMyA9IHtcbiAgdG93Z3M4NDogXCI2NzQuMzc0LDE1LjA1Niw0MDUuMzQ2XCIsXG4gIGVsbGlwc2U6IFwiYmVzc2VsXCIsXG4gIGRhdHVtTmFtZTogXCJzd2lzc1wiXG59O1xuZXhwb3J0cy5nZ3JzODcgPSB7XG4gIHRvd2dzODQ6IFwiLTE5OS44Nyw3NC43OSwyNDYuNjJcIixcbiAgZWxsaXBzZTogXCJHUlM4MFwiLFxuICBkYXR1bU5hbWU6IFwiR3JlZWtfR2VvZGV0aWNfUmVmZXJlbmNlX1N5c3RlbV8xOTg3XCJcbn07XG5leHBvcnRzLm5hZDgzID0ge1xuICB0b3dnczg0OiBcIjAsMCwwXCIsXG4gIGVsbGlwc2U6IFwiR1JTODBcIixcbiAgZGF0dW1OYW1lOiBcIk5vcnRoX0FtZXJpY2FuX0RhdHVtXzE5ODNcIlxufTtcbmV4cG9ydHMubmFkMjcgPSB7XG4gIG5hZGdyaWRzOiBcIkBjb251cyxAYWxhc2thLEBudHYyXzAuZ3NiLEBudHYxX2Nhbi5kYXRcIixcbiAgZWxsaXBzZTogXCJjbHJrNjZcIixcbiAgZGF0dW1OYW1lOiBcIk5vcnRoX0FtZXJpY2FuX0RhdHVtXzE5MjdcIlxufTtcbmV4cG9ydHMucG90c2RhbSA9IHtcbiAgdG93Z3M4NDogXCI2MDYuMCwyMy4wLDQxMy4wXCIsXG4gIGVsbGlwc2U6IFwiYmVzc2VsXCIsXG4gIGRhdHVtTmFtZTogXCJQb3RzZGFtIFJhdWVuYmVyZyAxOTUwIERIRE5cIlxufTtcbmV4cG9ydHMuY2FydGhhZ2UgPSB7XG4gIHRvd2dzODQ6IFwiLTI2My4wLDYuMCw0MzEuMFwiLFxuICBlbGxpcHNlOiBcImNsYXJrODBcIixcbiAgZGF0dW1OYW1lOiBcIkNhcnRoYWdlIDE5MzQgVHVuaXNpYVwiXG59O1xuZXhwb3J0cy5oZXJtYW5uc2tvZ2VsID0ge1xuICB0b3dnczg0OiBcIjY1My4wLC0yMTIuMCw0NDkuMFwiLFxuICBlbGxpcHNlOiBcImJlc3NlbFwiLFxuICBkYXR1bU5hbWU6IFwiSGVybWFubnNrb2dlbFwiXG59O1xuZXhwb3J0cy5pcmU2NSA9IHtcbiAgdG93Z3M4NDogXCI0ODIuNTMwLC0xMzAuNTk2LDU2NC41NTcsLTEuMDQyLC0wLjIxNCwtMC42MzEsOC4xNVwiLFxuICBlbGxpcHNlOiBcIm1vZF9haXJ5XCIsXG4gIGRhdHVtTmFtZTogXCJJcmVsYW5kIDE5NjVcIlxufTtcbmV4cG9ydHMucmFzc2FkaXJhbiA9IHtcbiAgdG93Z3M4NDogXCItMTMzLjYzLC0xNTcuNSwtMTU4LjYyXCIsXG4gIGVsbGlwc2U6IFwiaW50bFwiLFxuICBkYXR1bU5hbWU6IFwiUmFzc2FkaXJhblwiXG59O1xuZXhwb3J0cy5uemdkNDkgPSB7XG4gIHRvd2dzODQ6IFwiNTkuNDcsLTUuMDQsMTg3LjQ0LDAuNDcsLTAuMSwxLjAyNCwtNC41OTkzXCIsXG4gIGVsbGlwc2U6IFwiaW50bFwiLFxuICBkYXR1bU5hbWU6IFwiTmV3IFplYWxhbmQgR2VvZGV0aWMgRGF0dW0gMTk0OVwiXG59O1xuZXhwb3J0cy5vc2diMzYgPSB7XG4gIHRvd2dzODQ6IFwiNDQ2LjQ0OCwtMTI1LjE1Nyw1NDIuMDYwLDAuMTUwMiwwLjI0NzAsMC44NDIxLC0yMC40ODk0XCIsXG4gIGVsbGlwc2U6IFwiYWlyeVwiLFxuICBkYXR1bU5hbWU6IFwiQWlyeSAxODMwXCJcbn07XG5leHBvcnRzLnNfanRzayA9IHtcbiAgdG93Z3M4NDogXCI1ODksNzYsNDgwXCIsXG4gIGVsbGlwc2U6ICdiZXNzZWwnLFxuICBkYXR1bU5hbWU6ICdTLUpUU0sgKEZlcnJvKSdcbn07XG5leHBvcnRzLmJlZHVhcmFtID0ge1xuICB0b3dnczg0OiAnLTEwNiwtODcsMTg4JyxcbiAgZWxsaXBzZTogJ2Nscms4MCcsXG4gIGRhdHVtTmFtZTogJ0JlZHVhcmFtJ1xufTtcbmV4cG9ydHMuZ3VudW5nX3NlZ2FyYSA9IHtcbiAgdG93Z3M4NDogJy00MDMsNjg0LDQxJyxcbiAgZWxsaXBzZTogJ2Jlc3NlbCcsXG4gIGRhdHVtTmFtZTogJ0d1bnVuZyBTZWdhcmEgSmFrYXJ0YSdcbn07XG5leHBvcnRzLnJuYjcyID0ge1xuICB0b3dnczg0OiBcIjEwNi44NjksLTUyLjI5NzgsMTAzLjcyNCwtMC4zMzY1NywwLjQ1Njk1NSwtMS44NDIxOCwxXCIsXG4gIGVsbGlwc2U6IFwiaW50bFwiLFxuICBkYXR1bU5hbWU6IFwiUmVzZWF1IE5hdGlvbmFsIEJlbGdlIDE5NzJcIlxufTsiLCJleHBvcnRzLk1FUklUID0ge1xuICBhOiA2Mzc4MTM3LjAsXG4gIHJmOiAyOTguMjU3LFxuICBlbGxpcHNlTmFtZTogXCJNRVJJVCAxOTgzXCJcbn07XG5leHBvcnRzLlNHUzg1ID0ge1xuICBhOiA2Mzc4MTM2LjAsXG4gIHJmOiAyOTguMjU3LFxuICBlbGxpcHNlTmFtZTogXCJTb3ZpZXQgR2VvZGV0aWMgU3lzdGVtIDg1XCJcbn07XG5leHBvcnRzLkdSUzgwID0ge1xuICBhOiA2Mzc4MTM3LjAsXG4gIHJmOiAyOTguMjU3MjIyMTAxLFxuICBlbGxpcHNlTmFtZTogXCJHUlMgMTk4MChJVUdHLCAxOTgwKVwiXG59O1xuZXhwb3J0cy5JQVU3NiA9IHtcbiAgYTogNjM3ODE0MC4wLFxuICByZjogMjk4LjI1NyxcbiAgZWxsaXBzZU5hbWU6IFwiSUFVIDE5NzZcIlxufTtcbmV4cG9ydHMuYWlyeSA9IHtcbiAgYTogNjM3NzU2My4zOTYsXG4gIGI6IDYzNTYyNTYuOTEwLFxuICBlbGxpcHNlTmFtZTogXCJBaXJ5IDE4MzBcIlxufTtcbmV4cG9ydHMuQVBMNCA9IHtcbiAgYTogNjM3ODEzNyxcbiAgcmY6IDI5OC4yNSxcbiAgZWxsaXBzZU5hbWU6IFwiQXBwbC4gUGh5c2ljcy4gMTk2NVwiXG59O1xuZXhwb3J0cy5OV0w5RCA9IHtcbiAgYTogNjM3ODE0NS4wLFxuICByZjogMjk4LjI1LFxuICBlbGxpcHNlTmFtZTogXCJOYXZhbCBXZWFwb25zIExhYi4sIDE5NjVcIlxufTtcbmV4cG9ydHMubW9kX2FpcnkgPSB7XG4gIGE6IDYzNzczNDAuMTg5LFxuICBiOiA2MzU2MDM0LjQ0NixcbiAgZWxsaXBzZU5hbWU6IFwiTW9kaWZpZWQgQWlyeVwiXG59O1xuZXhwb3J0cy5hbmRyYWUgPSB7XG4gIGE6IDYzNzcxMDQuNDMsXG4gIHJmOiAzMDAuMCxcbiAgZWxsaXBzZU5hbWU6IFwiQW5kcmFlIDE4NzYgKERlbi4sIEljbG5kLilcIlxufTtcbmV4cG9ydHMuYXVzdF9TQSA9IHtcbiAgYTogNjM3ODE2MC4wLFxuICByZjogMjk4LjI1LFxuICBlbGxpcHNlTmFtZTogXCJBdXN0cmFsaWFuIE5hdGwgJiBTLiBBbWVyLiAxOTY5XCJcbn07XG5leHBvcnRzLkdSUzY3ID0ge1xuICBhOiA2Mzc4MTYwLjAsXG4gIHJmOiAyOTguMjQ3MTY3NDI3MCxcbiAgZWxsaXBzZU5hbWU6IFwiR1JTIDY3KElVR0cgMTk2NylcIlxufTtcbmV4cG9ydHMuYmVzc2VsID0ge1xuICBhOiA2Mzc3Mzk3LjE1NSxcbiAgcmY6IDI5OS4xNTI4MTI4LFxuICBlbGxpcHNlTmFtZTogXCJCZXNzZWwgMTg0MVwiXG59O1xuZXhwb3J0cy5iZXNzX25hbSA9IHtcbiAgYTogNjM3NzQ4My44NjUsXG4gIHJmOiAyOTkuMTUyODEyOCxcbiAgZWxsaXBzZU5hbWU6IFwiQmVzc2VsIDE4NDEgKE5hbWliaWEpXCJcbn07XG5leHBvcnRzLmNscms2NiA9IHtcbiAgYTogNjM3ODIwNi40LFxuICBiOiA2MzU2NTgzLjgsXG4gIGVsbGlwc2VOYW1lOiBcIkNsYXJrZSAxODY2XCJcbn07XG5leHBvcnRzLmNscms4MCA9IHtcbiAgYTogNjM3ODI0OS4xNDUsXG4gIHJmOiAyOTMuNDY2MyxcbiAgZWxsaXBzZU5hbWU6IFwiQ2xhcmtlIDE4ODAgbW9kLlwiXG59O1xuZXhwb3J0cy5jbHJrNTggPSB7XG4gIGE6IDYzNzgyOTMuNjQ1MjA4NzU5LFxuICByZjogMjk0LjI2MDY3NjM2OTI2NTQsXG4gIGVsbGlwc2VOYW1lOiBcIkNsYXJrZSAxODU4XCJcbn07XG5leHBvcnRzLkNQTSA9IHtcbiAgYTogNjM3NTczOC43LFxuICByZjogMzM0LjI5LFxuICBlbGxpcHNlTmFtZTogXCJDb21tLiBkZXMgUG9pZHMgZXQgTWVzdXJlcyAxNzk5XCJcbn07XG5leHBvcnRzLmRlbG1iciA9IHtcbiAgYTogNjM3NjQyOC4wLFxuICByZjogMzExLjUsXG4gIGVsbGlwc2VOYW1lOiBcIkRlbGFtYnJlIDE4MTAgKEJlbGdpdW0pXCJcbn07XG5leHBvcnRzLmVuZ2VsaXMgPSB7XG4gIGE6IDYzNzgxMzYuMDUsXG4gIHJmOiAyOTguMjU2NixcbiAgZWxsaXBzZU5hbWU6IFwiRW5nZWxpcyAxOTg1XCJcbn07XG5leHBvcnRzLmV2cnN0MzAgPSB7XG4gIGE6IDYzNzcyNzYuMzQ1LFxuICByZjogMzAwLjgwMTcsXG4gIGVsbGlwc2VOYW1lOiBcIkV2ZXJlc3QgMTgzMFwiXG59O1xuZXhwb3J0cy5ldnJzdDQ4ID0ge1xuICBhOiA2Mzc3MzA0LjA2MyxcbiAgcmY6IDMwMC44MDE3LFxuICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IDE5NDhcIlxufTtcbmV4cG9ydHMuZXZyc3Q1NiA9IHtcbiAgYTogNjM3NzMwMS4yNDMsXG4gIHJmOiAzMDAuODAxNyxcbiAgZWxsaXBzZU5hbWU6IFwiRXZlcmVzdCAxOTU2XCJcbn07XG5leHBvcnRzLmV2cnN0NjkgPSB7XG4gIGE6IDYzNzcyOTUuNjY0LFxuICByZjogMzAwLjgwMTcsXG4gIGVsbGlwc2VOYW1lOiBcIkV2ZXJlc3QgMTk2OVwiXG59O1xuZXhwb3J0cy5ldnJzdFNTID0ge1xuICBhOiA2Mzc3Mjk4LjU1NixcbiAgcmY6IDMwMC44MDE3LFxuICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IChTYWJhaCAmIFNhcmF3YWspXCJcbn07XG5leHBvcnRzLmZzY2hyNjAgPSB7XG4gIGE6IDYzNzgxNjYuMCxcbiAgcmY6IDI5OC4zLFxuICBlbGxpcHNlTmFtZTogXCJGaXNjaGVyIChNZXJjdXJ5IERhdHVtKSAxOTYwXCJcbn07XG5leHBvcnRzLmZzY2hyNjBtID0ge1xuICBhOiA2Mzc4MTU1LjAsXG4gIHJmOiAyOTguMyxcbiAgZWxsaXBzZU5hbWU6IFwiRmlzY2hlciAxOTYwXCJcbn07XG5leHBvcnRzLmZzY2hyNjggPSB7XG4gIGE6IDYzNzgxNTAuMCxcbiAgcmY6IDI5OC4zLFxuICBlbGxpcHNlTmFtZTogXCJGaXNjaGVyIDE5NjhcIlxufTtcbmV4cG9ydHMuaGVsbWVydCA9IHtcbiAgYTogNjM3ODIwMC4wLFxuICByZjogMjk4LjMsXG4gIGVsbGlwc2VOYW1lOiBcIkhlbG1lcnQgMTkwNlwiXG59O1xuZXhwb3J0cy5ob3VnaCA9IHtcbiAgYTogNjM3ODI3MC4wLFxuICByZjogMjk3LjAsXG4gIGVsbGlwc2VOYW1lOiBcIkhvdWdoXCJcbn07XG5leHBvcnRzLmludGwgPSB7XG4gIGE6IDYzNzgzODguMCxcbiAgcmY6IDI5Ny4wLFxuICBlbGxpcHNlTmFtZTogXCJJbnRlcm5hdGlvbmFsIDE5MDkgKEhheWZvcmQpXCJcbn07XG5leHBvcnRzLmthdWxhID0ge1xuICBhOiA2Mzc4MTYzLjAsXG4gIHJmOiAyOTguMjQsXG4gIGVsbGlwc2VOYW1lOiBcIkthdWxhIDE5NjFcIlxufTtcbmV4cG9ydHMubGVyY2ggPSB7XG4gIGE6IDYzNzgxMzkuMCxcbiAgcmY6IDI5OC4yNTcsXG4gIGVsbGlwc2VOYW1lOiBcIkxlcmNoIDE5NzlcIlxufTtcbmV4cG9ydHMubXBydHMgPSB7XG4gIGE6IDYzOTczMDAuMCxcbiAgcmY6IDE5MS4wLFxuICBlbGxpcHNlTmFtZTogXCJNYXVwZXJ0aXVzIDE3MzhcIlxufTtcbmV4cG9ydHMubmV3X2ludGwgPSB7XG4gIGE6IDYzNzgxNTcuNSxcbiAgYjogNjM1Njc3Mi4yLFxuICBlbGxpcHNlTmFtZTogXCJOZXcgSW50ZXJuYXRpb25hbCAxOTY3XCJcbn07XG5leHBvcnRzLnBsZXNzaXMgPSB7XG4gIGE6IDYzNzY1MjMuMCxcbiAgcmY6IDYzNTU4NjMuMCxcbiAgZWxsaXBzZU5hbWU6IFwiUGxlc3NpcyAxODE3IChGcmFuY2UpXCJcbn07XG5leHBvcnRzLmtyYXNzID0ge1xuICBhOiA2Mzc4MjQ1LjAsXG4gIHJmOiAyOTguMyxcbiAgZWxsaXBzZU5hbWU6IFwiS3Jhc3NvdnNreSwgMTk0MlwiXG59O1xuZXhwb3J0cy5TRWFzaWEgPSB7XG4gIGE6IDYzNzgxNTUuMCxcbiAgYjogNjM1Njc3My4zMjA1LFxuICBlbGxpcHNlTmFtZTogXCJTb3V0aGVhc3QgQXNpYVwiXG59O1xuZXhwb3J0cy53YWxiZWNrID0ge1xuICBhOiA2Mzc2ODk2LjAsXG4gIGI6IDYzNTU4MzQuODQ2NyxcbiAgZWxsaXBzZU5hbWU6IFwiV2FsYmVja1wiXG59O1xuZXhwb3J0cy5XR1M2MCA9IHtcbiAgYTogNjM3ODE2NS4wLFxuICByZjogMjk4LjMsXG4gIGVsbGlwc2VOYW1lOiBcIldHUyA2MFwiXG59O1xuZXhwb3J0cy5XR1M2NiA9IHtcbiAgYTogNjM3ODE0NS4wLFxuICByZjogMjk4LjI1LFxuICBlbGxpcHNlTmFtZTogXCJXR1MgNjZcIlxufTtcbmV4cG9ydHMuV0dTNyA9IHtcbiAgYTogNjM3ODEzNS4wLFxuICByZjogMjk4LjI2LFxuICBlbGxpcHNlTmFtZTogXCJXR1MgNzJcIlxufTtcbmV4cG9ydHMuV0dTODQgPSB7XG4gIGE6IDYzNzgxMzcuMCxcbiAgcmY6IDI5OC4yNTcyMjM1NjMsXG4gIGVsbGlwc2VOYW1lOiBcIldHUyA4NFwiXG59O1xuZXhwb3J0cy5zcGhlcmUgPSB7XG4gIGE6IDYzNzA5OTcuMCxcbiAgYjogNjM3MDk5Ny4wLFxuICBlbGxpcHNlTmFtZTogXCJOb3JtYWwgU3BoZXJlIChyPTYzNzA5OTcpXCJcbn07IiwiZXhwb3J0cy5ncmVlbndpY2ggPSAwLjA7IC8vXCIwZEVcIixcbmV4cG9ydHMubGlzYm9uID0gLTkuMTMxOTA2MTExMTExOyAvL1wiOWQwNyc1NC44NjJcXFwiV1wiLFxuZXhwb3J0cy5wYXJpcyA9IDIuMzM3MjI5MTY2NjY3OyAvL1wiMmQyMCcxNC4wMjVcXFwiRVwiLFxuZXhwb3J0cy5ib2dvdGEgPSAtNzQuMDgwOTE2NjY2NjY3OyAvL1wiNzRkMDQnNTEuM1xcXCJXXCIsXG5leHBvcnRzLm1hZHJpZCA9IC0zLjY4NzkzODg4ODg4OTsgLy9cIjNkNDEnMTYuNThcXFwiV1wiLFxuZXhwb3J0cy5yb21lID0gMTIuNDUyMzMzMzMzMzMzOyAvL1wiMTJkMjcnOC40XFxcIkVcIixcbmV4cG9ydHMuYmVybiA9IDcuNDM5NTgzMzMzMzMzOyAvL1wiN2QyNicyMi41XFxcIkVcIixcbmV4cG9ydHMuamFrYXJ0YSA9IDEwNi44MDc3MTk0NDQ0NDQ7IC8vXCIxMDZkNDgnMjcuNzlcXFwiRVwiLFxuZXhwb3J0cy5mZXJybyA9IC0xNy42NjY2NjY2NjY2Njc7IC8vXCIxN2Q0MCdXXCIsXG5leHBvcnRzLmJydXNzZWxzID0gNC4zNjc5NzU7IC8vXCI0ZDIyJzQuNzFcXFwiRVwiLFxuZXhwb3J0cy5zdG9ja2hvbG0gPSAxOC4wNTgyNzc3Nzc3Nzg7IC8vXCIxOGQzJzI5LjhcXFwiRVwiLFxuZXhwb3J0cy5hdGhlbnMgPSAyMy43MTYzMzc1OyAvL1wiMjNkNDInNTguODE1XFxcIkVcIixcbmV4cG9ydHMub3NsbyA9IDEwLjcyMjkxNjY2NjY2NzsgLy9cIjEwZDQzJzIyLjVcXFwiRVwiIiwiZXhwb3J0cy5mdCA9IHt0b19tZXRlcjogMC4zMDQ4fTtcbmV4cG9ydHNbJ3VzLWZ0J10gPSB7dG9fbWV0ZXI6IDEyMDAgLyAzOTM3fTtcbiIsInZhciBwcm9qID0gcmVxdWlyZSgnLi9Qcm9qJyk7XG52YXIgdHJhbnNmb3JtID0gcmVxdWlyZSgnLi90cmFuc2Zvcm0nKTtcbnZhciB3Z3M4NCA9IHByb2ooJ1dHUzg0Jyk7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyKGZyb20sIHRvLCBjb29yZHMpIHtcbiAgdmFyIHRyYW5zZm9ybWVkQXJyYXk7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvb3JkcykpIHtcbiAgICB0cmFuc2Zvcm1lZEFycmF5ID0gdHJhbnNmb3JtKGZyb20sIHRvLCBjb29yZHMpO1xuICAgIGlmIChjb29yZHMubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gW3RyYW5zZm9ybWVkQXJyYXkueCwgdHJhbnNmb3JtZWRBcnJheS55LCB0cmFuc2Zvcm1lZEFycmF5LnpdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBbdHJhbnNmb3JtZWRBcnJheS54LCB0cmFuc2Zvcm1lZEFycmF5LnldO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtKGZyb20sIHRvLCBjb29yZHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvaihpdGVtKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgcHJvaikge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG4gIGlmIChpdGVtLm9Qcm9qKSB7XG4gICAgcmV0dXJuIGl0ZW0ub1Byb2o7XG4gIH1cbiAgcmV0dXJuIHByb2ooaXRlbSk7XG59XG5mdW5jdGlvbiBwcm9qNChmcm9tUHJvaiwgdG9Qcm9qLCBjb29yZCkge1xuICBmcm9tUHJvaiA9IGNoZWNrUHJvaihmcm9tUHJvaik7XG4gIHZhciBzaW5nbGUgPSBmYWxzZTtcbiAgdmFyIG9iajtcbiAgaWYgKHR5cGVvZiB0b1Byb2ogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdG9Qcm9qID0gZnJvbVByb2o7XG4gICAgZnJvbVByb2ogPSB3Z3M4NDtcbiAgICBzaW5nbGUgPSB0cnVlO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiB0b1Byb2oueCAhPT0gJ3VuZGVmaW5lZCcgfHwgQXJyYXkuaXNBcnJheSh0b1Byb2opKSB7XG4gICAgY29vcmQgPSB0b1Byb2o7XG4gICAgdG9Qcm9qID0gZnJvbVByb2o7XG4gICAgZnJvbVByb2ogPSB3Z3M4NDtcbiAgICBzaW5nbGUgPSB0cnVlO1xuICB9XG4gIHRvUHJvaiA9IGNoZWNrUHJvaih0b1Byb2opO1xuICBpZiAoY29vcmQpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtZXIoZnJvbVByb2osIHRvUHJvaiwgY29vcmQpO1xuICB9XG4gIGVsc2Uge1xuICAgIG9iaiA9IHtcbiAgICAgIGZvcndhcmQ6IGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIoZnJvbVByb2osIHRvUHJvaiwgY29vcmRzKTtcbiAgICAgIH0sXG4gICAgICBpbnZlcnNlOiBmdW5jdGlvbihjb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyKHRvUHJvaiwgZnJvbVByb2osIGNvb3Jkcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoc2luZ2xlKSB7XG4gICAgICBvYmoub1Byb2ogPSB0b1Byb2o7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gcHJvajQ7IiwidmFyIFBKRF8zUEFSQU0gPSAxO1xudmFyIFBKRF83UEFSQU0gPSAyO1xudmFyIFBKRF9XR1M4NCA9IDQ7IC8vIFdHUzg0IG9yIGVxdWl2YWxlbnRcbnZhciBQSkRfTk9EQVRVTSA9IDU7IC8vIFdHUzg0IG9yIGVxdWl2YWxlbnRcbnZhciBTRUNfVE9fUkFEID0gNC44NDgxMzY4MTEwOTUzNTk5MzU4OTkxNDEwMjM1N2UtNjtcblxuZnVuY3Rpb24gZGF0dW0oZGF0dW1Db2RlLCBkYXR1bV9wYXJhbXMsIGEsIGIsIGVzLCBlcDIpIHtcbiAgdmFyIG91dCA9IHt9O1xuICBvdXQuZGF0dW1fdHlwZSA9IFBKRF9XR1M4NDsgLy9kZWZhdWx0IHNldHRpbmdcbiAgaWYgKGRhdHVtQ29kZSAmJiBkYXR1bUNvZGUgPT09ICdub25lJykge1xuICAgIG91dC5kYXR1bV90eXBlID0gUEpEX05PREFUVU07XG4gIH1cblxuICBpZiAoZGF0dW1fcGFyYW1zKSB7XG4gICAgb3V0LmRhdHVtX3BhcmFtcyA9IGRhdHVtX3BhcmFtcy5tYXAocGFyc2VGbG9hdCk7XG4gICAgaWYgKG91dC5kYXR1bV9wYXJhbXNbMF0gIT09IDAgfHwgb3V0LmRhdHVtX3BhcmFtc1sxXSAhPT0gMCB8fCBvdXQuZGF0dW1fcGFyYW1zWzJdICE9PSAwKSB7XG4gICAgICBvdXQuZGF0dW1fdHlwZSA9IFBKRF8zUEFSQU07XG4gICAgfVxuICAgIGlmIChvdXQuZGF0dW1fcGFyYW1zLmxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChvdXQuZGF0dW1fcGFyYW1zWzNdICE9PSAwIHx8IG91dC5kYXR1bV9wYXJhbXNbNF0gIT09IDAgfHwgb3V0LmRhdHVtX3BhcmFtc1s1XSAhPT0gMCB8fCBvdXQuZGF0dW1fcGFyYW1zWzZdICE9PSAwKSB7XG4gICAgICAgIG91dC5kYXR1bV90eXBlID0gUEpEXzdQQVJBTTtcbiAgICAgICAgb3V0LmRhdHVtX3BhcmFtc1szXSAqPSBTRUNfVE9fUkFEO1xuICAgICAgICBvdXQuZGF0dW1fcGFyYW1zWzRdICo9IFNFQ19UT19SQUQ7XG4gICAgICAgIG91dC5kYXR1bV9wYXJhbXNbNV0gKj0gU0VDX1RPX1JBRDtcbiAgICAgICAgb3V0LmRhdHVtX3BhcmFtc1s2XSA9IChvdXQuZGF0dW1fcGFyYW1zWzZdIC8gMTAwMDAwMC4wKSArIDEuMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIG91dC5hID0gYTsgLy9kYXR1bSBvYmplY3QgYWxzbyB1c2VzIHRoZXNlIHZhbHVlc1xuICBvdXQuYiA9IGI7XG4gIG91dC5lcyA9IGVzO1xuICBvdXQuZXAyID0gZXAyO1xuICByZXR1cm4gb3V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhdHVtO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFBKRF8zUEFSQU0gPSAxO1xudmFyIFBKRF83UEFSQU0gPSAyO1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG5cbmV4cG9ydHMuY29tcGFyZURhdHVtcyA9IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdCkge1xuICBpZiAoc291cmNlLmRhdHVtX3R5cGUgIT09IGRlc3QuZGF0dW1fdHlwZSkge1xuICAgIHJldHVybiBmYWxzZTsgLy8gZmFsc2UsIGRhdHVtcyBhcmUgbm90IGVxdWFsXG4gIH0gZWxzZSBpZiAoc291cmNlLmEgIT09IGRlc3QuYSB8fCBNYXRoLmFicyh0aGlzLmVzIC0gZGVzdC5lcykgPiAwLjAwMDAwMDAwMDA1MCkge1xuICAgIC8vIHRoZSB0b2xlcmVuY2UgZm9yIGVzIGlzIHRvIGVuc3VyZSB0aGF0IEdSUzgwIGFuZCBXR1M4NFxuICAgIC8vIGFyZSBjb25zaWRlcmVkIGlkZW50aWNhbFxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChzb3VyY2UuZGF0dW1fdHlwZSA9PT0gUEpEXzNQQVJBTSkge1xuICAgIHJldHVybiAodGhpcy5kYXR1bV9wYXJhbXNbMF0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzBdICYmIHNvdXJjZS5kYXR1bV9wYXJhbXNbMV0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzFdICYmIHNvdXJjZS5kYXR1bV9wYXJhbXNbMl0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzJdKTtcbiAgfSBlbHNlIGlmIChzb3VyY2UuZGF0dW1fdHlwZSA9PT0gUEpEXzdQQVJBTSkge1xuICAgIHJldHVybiAoc291cmNlLmRhdHVtX3BhcmFtc1swXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbMF0gJiYgc291cmNlLmRhdHVtX3BhcmFtc1sxXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbMV0gJiYgc291cmNlLmRhdHVtX3BhcmFtc1syXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbMl0gJiYgc291cmNlLmRhdHVtX3BhcmFtc1szXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbM10gJiYgc291cmNlLmRhdHVtX3BhcmFtc1s0XSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbNF0gJiYgc291cmNlLmRhdHVtX3BhcmFtc1s1XSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbNV0gJiYgc291cmNlLmRhdHVtX3BhcmFtc1s2XSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbNl0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlOyAvLyBkYXR1bXMgYXJlIGVxdWFsXG4gIH1cbn07IC8vIGNzX2NvbXBhcmVfZGF0dW1zKClcblxuLypcbiAqIFRoZSBmdW5jdGlvbiBDb252ZXJ0X0dlb2RldGljX1RvX0dlb2NlbnRyaWMgY29udmVydHMgZ2VvZGV0aWMgY29vcmRpbmF0ZXNcbiAqIChsYXRpdHVkZSwgbG9uZ2l0dWRlLCBhbmQgaGVpZ2h0KSB0byBnZW9jZW50cmljIGNvb3JkaW5hdGVzIChYLCBZLCBaKSxcbiAqIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBlbGxpcHNvaWQgcGFyYW1ldGVycy5cbiAqXG4gKiAgICBMYXRpdHVkZSAgOiBHZW9kZXRpYyBsYXRpdHVkZSBpbiByYWRpYW5zICAgICAgICAgICAgICAgICAgICAgKGlucHV0KVxuICogICAgTG9uZ2l0dWRlIDogR2VvZGV0aWMgbG9uZ2l0dWRlIGluIHJhZGlhbnMgICAgICAgICAgICAgICAgICAgIChpbnB1dClcbiAqICAgIEhlaWdodCAgICA6IEdlb2RldGljIGhlaWdodCwgaW4gbWV0ZXJzICAgICAgICAgICAgICAgICAgICAgICAoaW5wdXQpXG4gKiAgICBYICAgICAgICAgOiBDYWxjdWxhdGVkIEdlb2NlbnRyaWMgWCBjb29yZGluYXRlLCBpbiBtZXRlcnMgICAgKG91dHB1dClcbiAqICAgIFkgICAgICAgICA6IENhbGN1bGF0ZWQgR2VvY2VudHJpYyBZIGNvb3JkaW5hdGUsIGluIG1ldGVycyAgICAob3V0cHV0KVxuICogICAgWiAgICAgICAgIDogQ2FsY3VsYXRlZCBHZW9jZW50cmljIFogY29vcmRpbmF0ZSwgaW4gbWV0ZXJzICAgIChvdXRwdXQpXG4gKlxuICovXG5leHBvcnRzLmdlb2RldGljVG9HZW9jZW50cmljID0gZnVuY3Rpb24ocCwgZXMsIGEpIHtcbiAgdmFyIExvbmdpdHVkZSA9IHAueDtcbiAgdmFyIExhdGl0dWRlID0gcC55O1xuICB2YXIgSGVpZ2h0ID0gcC56ID8gcC56IDogMDsgLy9aIHZhbHVlIG5vdCBhbHdheXMgc3VwcGxpZWRcblxuICB2YXIgUm47IC8qICBFYXJ0aCByYWRpdXMgYXQgbG9jYXRpb24gICovXG4gIHZhciBTaW5fTGF0OyAvKiAgTWF0aC5zaW4oTGF0aXR1ZGUpICAqL1xuICB2YXIgU2luMl9MYXQ7IC8qICBTcXVhcmUgb2YgTWF0aC5zaW4oTGF0aXR1ZGUpICAqL1xuICB2YXIgQ29zX0xhdDsgLyogIE1hdGguY29zKExhdGl0dWRlKSAgKi9cblxuICAvKlxuICAgKiogRG9uJ3QgYmxvdyB1cCBpZiBMYXRpdHVkZSBpcyBqdXN0IGEgbGl0dGxlIG91dCBvZiB0aGUgdmFsdWVcbiAgICoqIHJhbmdlIGFzIGl0IG1heSBqdXN0IGJlIGEgcm91bmRpbmcgaXNzdWUuICBBbHNvIHJlbW92ZWQgbG9uZ2l0dWRlXG4gICAqKiB0ZXN0LCBpdCBzaG91bGQgYmUgd3JhcHBlZCBieSBNYXRoLmNvcygpIGFuZCBNYXRoLnNpbigpLiAgTkZXIGZvciBQUk9KLjQsIFNlcC8yMDAxLlxuICAgKi9cbiAgaWYgKExhdGl0dWRlIDwgLUhBTEZfUEkgJiYgTGF0aXR1ZGUgPiAtMS4wMDEgKiBIQUxGX1BJKSB7XG4gICAgTGF0aXR1ZGUgPSAtSEFMRl9QSTtcbiAgfSBlbHNlIGlmIChMYXRpdHVkZSA+IEhBTEZfUEkgJiYgTGF0aXR1ZGUgPCAxLjAwMSAqIEhBTEZfUEkpIHtcbiAgICBMYXRpdHVkZSA9IEhBTEZfUEk7XG4gIH0gZWxzZSBpZiAoKExhdGl0dWRlIDwgLUhBTEZfUEkpIHx8IChMYXRpdHVkZSA+IEhBTEZfUEkpKSB7XG4gICAgLyogTGF0aXR1ZGUgb3V0IG9mIHJhbmdlICovXG4gICAgLy8uLnJlcG9ydEVycm9yKCdnZW9jZW50OmxhdCBvdXQgb2YgcmFuZ2U6JyArIExhdGl0dWRlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChMb25naXR1ZGUgPiBNYXRoLlBJKSB7XG4gICAgTG9uZ2l0dWRlIC09ICgyICogTWF0aC5QSSk7XG4gIH1cbiAgU2luX0xhdCA9IE1hdGguc2luKExhdGl0dWRlKTtcbiAgQ29zX0xhdCA9IE1hdGguY29zKExhdGl0dWRlKTtcbiAgU2luMl9MYXQgPSBTaW5fTGF0ICogU2luX0xhdDtcbiAgUm4gPSBhIC8gKE1hdGguc3FydCgxLjBlMCAtIGVzICogU2luMl9MYXQpKTtcbiAgcmV0dXJuIHtcbiAgICB4OiAoUm4gKyBIZWlnaHQpICogQ29zX0xhdCAqIE1hdGguY29zKExvbmdpdHVkZSksXG4gICAgeTogKFJuICsgSGVpZ2h0KSAqIENvc19MYXQgKiBNYXRoLnNpbihMb25naXR1ZGUpLFxuICAgIHo6ICgoUm4gKiAoMSAtIGVzKSkgKyBIZWlnaHQpICogU2luX0xhdFxuICB9O1xufTsgLy8gY3NfZ2VvZGV0aWNfdG9fZ2VvY2VudHJpYygpXG5cblxuZXhwb3J0cy5nZW9jZW50cmljVG9HZW9kZXRpYyA9IGZ1bmN0aW9uKHAsIGVzLCBhLCBiKSB7XG4gIC8qIGxvY2FsIGRlZmludGlvbnMgYW5kIHZhcmlhYmxlcyAqL1xuICAvKiBlbmQtY3JpdGVyaXVtIG9mIGxvb3AsIGFjY3VyYWN5IG9mIHNpbihMYXRpdHVkZSkgKi9cbiAgdmFyIGdlbmF1ID0gMWUtMTI7XG4gIHZhciBnZW5hdTIgPSAoZ2VuYXUgKiBnZW5hdSk7XG4gIHZhciBtYXhpdGVyID0gMzA7XG5cbiAgdmFyIFA7IC8qIGRpc3RhbmNlIGJldHdlZW4gc2VtaS1taW5vciBheGlzIGFuZCBsb2NhdGlvbiAqL1xuICB2YXIgUlI7IC8qIGRpc3RhbmNlIGJldHdlZW4gY2VudGVyIGFuZCBsb2NhdGlvbiAqL1xuICB2YXIgQ1Q7IC8qIHNpbiBvZiBnZW9jZW50cmljIGxhdGl0dWRlICovXG4gIHZhciBTVDsgLyogY29zIG9mIGdlb2NlbnRyaWMgbGF0aXR1ZGUgKi9cbiAgdmFyIFJYO1xuICB2YXIgUks7XG4gIHZhciBSTjsgLyogRWFydGggcmFkaXVzIGF0IGxvY2F0aW9uICovXG4gIHZhciBDUEhJMDsgLyogY29zIG9mIHN0YXJ0IG9yIG9sZCBnZW9kZXRpYyBsYXRpdHVkZSBpbiBpdGVyYXRpb25zICovXG4gIHZhciBTUEhJMDsgLyogc2luIG9mIHN0YXJ0IG9yIG9sZCBnZW9kZXRpYyBsYXRpdHVkZSBpbiBpdGVyYXRpb25zICovXG4gIHZhciBDUEhJOyAvKiBjb3Mgb2Ygc2VhcmNoZWQgZ2VvZGV0aWMgbGF0aXR1ZGUgKi9cbiAgdmFyIFNQSEk7IC8qIHNpbiBvZiBzZWFyY2hlZCBnZW9kZXRpYyBsYXRpdHVkZSAqL1xuICB2YXIgU0RQSEk7IC8qIGVuZC1jcml0ZXJpdW06IGFkZGl0aW9uLXRoZW9yZW0gb2Ygc2luKExhdGl0dWRlKGl0ZXIpLUxhdGl0dWRlKGl0ZXItMSkpICovXG4gIHZhciBpdGVyOyAvKiAjIG9mIGNvbnRpbm91cyBpdGVyYXRpb24sIG1heC4gMzAgaXMgYWx3YXlzIGVub3VnaCAocy5hLikgKi9cblxuICB2YXIgWCA9IHAueDtcbiAgdmFyIFkgPSBwLnk7XG4gIHZhciBaID0gcC56ID8gcC56IDogMC4wOyAvL1ogdmFsdWUgbm90IGFsd2F5cyBzdXBwbGllZFxuICB2YXIgTG9uZ2l0dWRlO1xuICB2YXIgTGF0aXR1ZGU7XG4gIHZhciBIZWlnaHQ7XG5cbiAgUCA9IE1hdGguc3FydChYICogWCArIFkgKiBZKTtcbiAgUlIgPSBNYXRoLnNxcnQoWCAqIFggKyBZICogWSArIFogKiBaKTtcblxuICAvKiAgICAgIHNwZWNpYWwgY2FzZXMgZm9yIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKi9cbiAgaWYgKFAgLyBhIDwgZ2VuYXUpIHtcblxuICAgIC8qICBzcGVjaWFsIGNhc2UsIGlmIFA9MC4gKFg9MC4sIFk9MC4pICovXG4gICAgTG9uZ2l0dWRlID0gMC4wO1xuXG4gICAgLyogIGlmIChYLFksWik9KDAuLDAuLDAuKSB0aGVuIEhlaWdodCBiZWNvbWVzIHNlbWktbWlub3IgYXhpc1xuICAgICAqICBvZiBlbGxpcHNvaWQgKD1jZW50ZXIgb2YgbWFzcyksIExhdGl0dWRlIGJlY29tZXMgUEkvMiAqL1xuICAgIGlmIChSUiAvIGEgPCBnZW5hdSkge1xuICAgICAgTGF0aXR1ZGUgPSBIQUxGX1BJO1xuICAgICAgSGVpZ2h0ID0gLWI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwLngsXG4gICAgICAgIHk6IHAueSxcbiAgICAgICAgejogcC56XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvKiAgZWxsaXBzb2lkYWwgKGdlb2RldGljKSBsb25naXR1ZGVcbiAgICAgKiAgaW50ZXJ2YWw6IC1QSSA8IExvbmdpdHVkZSA8PSArUEkgKi9cbiAgICBMb25naXR1ZGUgPSBNYXRoLmF0YW4yKFksIFgpO1xuICB9XG5cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogRm9sbG93aW5nIGl0ZXJhdGl2ZSBhbGdvcml0aG0gd2FzIGRldmVsb3BwZWQgYnlcbiAgICogXCJJbnN0aXR1dCBmb3IgRXJkbWVzc3VuZ1wiLCBVbml2ZXJzaXR5IG9mIEhhbm5vdmVyLCBKdWx5IDE5ODguXG4gICAqIEludGVybmV0OiB3d3cuaWZlLnVuaS1oYW5ub3Zlci5kZVxuICAgKiBJdGVyYXRpdmUgY29tcHV0YXRpb24gb2YgQ1BISSxTUEhJIGFuZCBIZWlnaHQuXG4gICAqIEl0ZXJhdGlvbiBvZiBDUEhJIGFuZCBTUEhJIHRvIDEwKiotMTIgcmFkaWFuIHJlc3AuXG4gICAqIDIqMTAqKi03IGFyY3NlYy5cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG4gIENUID0gWiAvIFJSO1xuICBTVCA9IFAgLyBSUjtcbiAgUlggPSAxLjAgLyBNYXRoLnNxcnQoMS4wIC0gZXMgKiAoMi4wIC0gZXMpICogU1QgKiBTVCk7XG4gIENQSEkwID0gU1QgKiAoMS4wIC0gZXMpICogUlg7XG4gIFNQSEkwID0gQ1QgKiBSWDtcbiAgaXRlciA9IDA7XG5cbiAgLyogbG9vcCB0byBmaW5kIHNpbihMYXRpdHVkZSkgcmVzcC4gTGF0aXR1ZGVcbiAgICogdW50aWwgfHNpbihMYXRpdHVkZShpdGVyKS1MYXRpdHVkZShpdGVyLTEpKXwgPCBnZW5hdSAqL1xuICBkbyB7XG4gICAgaXRlcisrO1xuICAgIFJOID0gYSAvIE1hdGguc3FydCgxLjAgLSBlcyAqIFNQSEkwICogU1BISTApO1xuXG4gICAgLyogIGVsbGlwc29pZGFsIChnZW9kZXRpYykgaGVpZ2h0ICovXG4gICAgSGVpZ2h0ID0gUCAqIENQSEkwICsgWiAqIFNQSEkwIC0gUk4gKiAoMS4wIC0gZXMgKiBTUEhJMCAqIFNQSEkwKTtcblxuICAgIFJLID0gZXMgKiBSTiAvIChSTiArIEhlaWdodCk7XG4gICAgUlggPSAxLjAgLyBNYXRoLnNxcnQoMS4wIC0gUksgKiAoMi4wIC0gUkspICogU1QgKiBTVCk7XG4gICAgQ1BISSA9IFNUICogKDEuMCAtIFJLKSAqIFJYO1xuICAgIFNQSEkgPSBDVCAqIFJYO1xuICAgIFNEUEhJID0gU1BISSAqIENQSEkwIC0gQ1BISSAqIFNQSEkwO1xuICAgIENQSEkwID0gQ1BISTtcbiAgICBTUEhJMCA9IFNQSEk7XG4gIH1cbiAgd2hpbGUgKFNEUEhJICogU0RQSEkgPiBnZW5hdTIgJiYgaXRlciA8IG1heGl0ZXIpO1xuXG4gIC8qICAgICAgZWxsaXBzb2lkYWwgKGdlb2RldGljKSBsYXRpdHVkZSAqL1xuICBMYXRpdHVkZSA9IE1hdGguYXRhbihTUEhJIC8gTWF0aC5hYnMoQ1BISSkpO1xuICByZXR1cm4ge1xuICAgIHg6IExvbmdpdHVkZSxcbiAgICB5OiBMYXRpdHVkZSxcbiAgICB6OiBIZWlnaHRcbiAgfTtcbn07IC8vIGNzX2dlb2NlbnRyaWNfdG9fZ2VvZGV0aWMoKVxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLy8gcGpfZ2VvY2VudGljX3RvX3dnczg0KCBwIClcbi8vICBwID0gcG9pbnQgdG8gdHJhbnNmb3JtIGluIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXMgKHgseSx6KVxuXG5cbi8qKiBwb2ludCBvYmplY3QsIG5vdGhpbmcgZmFuY3ksIGp1c3QgYWxsb3dzIHZhbHVlcyB0byBiZVxuICAgIHBhc3NlZCBiYWNrIGFuZCBmb3J0aCBieSByZWZlcmVuY2UgcmF0aGVyIHRoYW4gYnkgdmFsdWUuXG4gICAgT3RoZXIgcG9pbnQgY2xhc3NlcyBtYXkgYmUgdXNlZCBhcyBsb25nIGFzIHRoZXkgaGF2ZVxuICAgIHggYW5kIHkgcHJvcGVydGllcywgd2hpY2ggd2lsbCBnZXQgbW9kaWZpZWQgaW4gdGhlIHRyYW5zZm9ybSBtZXRob2QuXG4qL1xuZXhwb3J0cy5nZW9jZW50cmljVG9XZ3M4NCA9IGZ1bmN0aW9uKHAsIGRhdHVtX3R5cGUsIGRhdHVtX3BhcmFtcykge1xuXG4gIGlmIChkYXR1bV90eXBlID09PSBQSkRfM1BBUkFNKSB7XG4gICAgLy8gaWYoIHhbaW9dID09PSBIVUdFX1ZBTCApXG4gICAgLy8gICAgY29udGludWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHAueCArIGRhdHVtX3BhcmFtc1swXSxcbiAgICAgIHk6IHAueSArIGRhdHVtX3BhcmFtc1sxXSxcbiAgICAgIHo6IHAueiArIGRhdHVtX3BhcmFtc1syXSxcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRhdHVtX3R5cGUgPT09IFBKRF83UEFSQU0pIHtcbiAgICB2YXIgRHhfQkYgPSBkYXR1bV9wYXJhbXNbMF07XG4gICAgdmFyIER5X0JGID0gZGF0dW1fcGFyYW1zWzFdO1xuICAgIHZhciBEel9CRiA9IGRhdHVtX3BhcmFtc1syXTtcbiAgICB2YXIgUnhfQkYgPSBkYXR1bV9wYXJhbXNbM107XG4gICAgdmFyIFJ5X0JGID0gZGF0dW1fcGFyYW1zWzRdO1xuICAgIHZhciBSel9CRiA9IGRhdHVtX3BhcmFtc1s1XTtcbiAgICB2YXIgTV9CRiA9IGRhdHVtX3BhcmFtc1s2XTtcbiAgICAvLyBpZiggeFtpb10gPT09IEhVR0VfVkFMIClcbiAgICAvLyAgICBjb250aW51ZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTV9CRiAqIChwLnggLSBSel9CRiAqIHAueSArIFJ5X0JGICogcC56KSArIER4X0JGLFxuICAgICAgeTogTV9CRiAqIChSel9CRiAqIHAueCArIHAueSAtIFJ4X0JGICogcC56KSArIER5X0JGLFxuICAgICAgejogTV9CRiAqICgtUnlfQkYgKiBwLnggKyBSeF9CRiAqIHAueSArIHAueikgKyBEel9CRlxuICAgIH07XG4gIH1cbn07IC8vIGNzX2dlb2NlbnRyaWNfdG9fd2dzODRcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vLyBwal9nZW9jZW50aWNfZnJvbV93Z3M4NCgpXG4vLyAgY29vcmRpbmF0ZSBzeXN0ZW0gZGVmaW5pdGlvbixcbi8vICBwb2ludCB0byB0cmFuc2Zvcm0gaW4gZ2VvY2VudHJpYyBjb29yZGluYXRlcyAoeCx5LHopXG5leHBvcnRzLmdlb2NlbnRyaWNGcm9tV2dzODQgPSBmdW5jdGlvbihwLCBkYXR1bV90eXBlLCBkYXR1bV9wYXJhbXMpIHtcblxuICBpZiAoZGF0dW1fdHlwZSA9PT0gUEpEXzNQQVJBTSkge1xuICAgIC8vaWYoIHhbaW9dID09PSBIVUdFX1ZBTCApXG4gICAgLy8gICAgY29udGludWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHAueCAtIGRhdHVtX3BhcmFtc1swXSxcbiAgICAgIHk6IHAueSAtIGRhdHVtX3BhcmFtc1sxXSxcbiAgICAgIHo6IHAueiAtIGRhdHVtX3BhcmFtc1syXSxcbiAgICB9O1xuXG4gIH0gZWxzZSBpZiAoZGF0dW1fdHlwZSA9PT0gUEpEXzdQQVJBTSkge1xuICAgIHZhciBEeF9CRiA9IGRhdHVtX3BhcmFtc1swXTtcbiAgICB2YXIgRHlfQkYgPSBkYXR1bV9wYXJhbXNbMV07XG4gICAgdmFyIER6X0JGID0gZGF0dW1fcGFyYW1zWzJdO1xuICAgIHZhciBSeF9CRiA9IGRhdHVtX3BhcmFtc1szXTtcbiAgICB2YXIgUnlfQkYgPSBkYXR1bV9wYXJhbXNbNF07XG4gICAgdmFyIFJ6X0JGID0gZGF0dW1fcGFyYW1zWzVdO1xuICAgIHZhciBNX0JGID0gZGF0dW1fcGFyYW1zWzZdO1xuICAgIHZhciB4X3RtcCA9IChwLnggLSBEeF9CRikgLyBNX0JGO1xuICAgIHZhciB5X3RtcCA9IChwLnkgLSBEeV9CRikgLyBNX0JGO1xuICAgIHZhciB6X3RtcCA9IChwLnogLSBEel9CRikgLyBNX0JGO1xuICAgIC8vaWYoIHhbaW9dID09PSBIVUdFX1ZBTCApXG4gICAgLy8gICAgY29udGludWU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeF90bXAgKyBSel9CRiAqIHlfdG1wIC0gUnlfQkYgKiB6X3RtcCxcbiAgICAgIHk6IC1Sel9CRiAqIHhfdG1wICsgeV90bXAgKyBSeF9CRiAqIHpfdG1wLFxuICAgICAgejogUnlfQkYgKiB4X3RtcCAtIFJ4X0JGICogeV90bXAgKyB6X3RtcFxuICAgIH07XG4gIH0gLy9jc19nZW9jZW50cmljX2Zyb21fd2dzODQoKVxufTtcbiIsInZhciBQSkRfM1BBUkFNID0gMTtcbnZhciBQSkRfN1BBUkFNID0gMjtcbnZhciBQSkRfTk9EQVRVTSA9IDU7IC8vIFdHUzg0IG9yIGVxdWl2YWxlbnRcbnZhciBkYXR1bSA9IHJlcXVpcmUoJy4vZGF0dW1VdGlscycpO1xuZnVuY3Rpb24gY2hlY2tQYXJhbXModHlwZSkge1xuICByZXR1cm4gKHR5cGUgPT09IFBKRF8zUEFSQU0gfHwgdHlwZSA9PT0gUEpEXzdQQVJBTSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdCwgcG9pbnQpIHtcbiAgLy8gU2hvcnQgY3V0IGlmIHRoZSBkYXR1bXMgYXJlIGlkZW50aWNhbC5cbiAgaWYgKGRhdHVtLmNvbXBhcmVEYXR1bXMoc291cmNlLCBkZXN0KSkge1xuICAgIHJldHVybiBwb2ludDsgLy8gaW4gdGhpcyBjYXNlLCB6ZXJvIGlzIHN1Y2VzcyxcbiAgICAvLyB3aGVyZWFzIGNzX2NvbXBhcmVfZGF0dW1zIHJldHVybnMgMSB0byBpbmRpY2F0ZSBUUlVFXG4gICAgLy8gY29uZnVzaW5nLCBzaG91bGQgZml4IHRoaXNcbiAgfVxuXG4gIC8vIEV4cGxpY2l0bHkgc2tpcCBkYXR1bSB0cmFuc2Zvcm0gYnkgc2V0dGluZyAnZGF0dW09bm9uZScgYXMgcGFyYW1ldGVyIGZvciBlaXRoZXIgc291cmNlIG9yIGRlc3RcbiAgaWYgKHNvdXJjZS5kYXR1bV90eXBlID09PSBQSkRfTk9EQVRVTSB8fCBkZXN0LmRhdHVtX3R5cGUgPT09IFBKRF9OT0RBVFVNKSB7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgLy8gSWYgdGhpcyBkYXR1bSByZXF1aXJlcyBncmlkIHNoaWZ0cywgdGhlbiBhcHBseSBpdCB0byBnZW9kZXRpYyBjb29yZGluYXRlcy5cblxuICAvLyBEbyB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggZ2VvY2VudHJpYyBjb29yZGluYXRlcz9cbiAgaWYgKHNvdXJjZS5lcyA9PT0gZGVzdC5lcyAmJiBzb3VyY2UuYSA9PT0gZGVzdC5hICYmICFjaGVja1BhcmFtcyhzb3VyY2UuZGF0dW1fdHlwZSkgJiYgICFjaGVja1BhcmFtcyhkZXN0LmRhdHVtX3R5cGUpKSB7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgLy8gQ29udmVydCB0byBnZW9jZW50cmljIGNvb3JkaW5hdGVzLlxuICBwb2ludCA9IGRhdHVtLmdlb2RldGljVG9HZW9jZW50cmljKHBvaW50LCBzb3VyY2UuZXMsIHNvdXJjZS5hKTtcbiAgLy8gQ29udmVydCBiZXR3ZWVuIGRhdHVtc1xuICBpZiAoY2hlY2tQYXJhbXMoc291cmNlLmRhdHVtX3R5cGUpKSB7XG4gICAgcG9pbnQgPSBkYXR1bS5nZW9jZW50cmljVG9XZ3M4NChwb2ludCwgc291cmNlLmRhdHVtX3R5cGUsIHNvdXJjZS5kYXR1bV9wYXJhbXMpO1xuICB9XG4gIGlmIChjaGVja1BhcmFtcyhkZXN0LmRhdHVtX3R5cGUpKSB7XG4gICAgcG9pbnQgPSBkYXR1bS5nZW9jZW50cmljRnJvbVdnczg0KHBvaW50LCBkZXN0LmRhdHVtX3R5cGUsIGRlc3QuZGF0dW1fcGFyYW1zKTtcbiAgfVxuICByZXR1cm4gZGF0dW0uZ2VvY2VudHJpY1RvR2VvZGV0aWMocG9pbnQsIGRlc3QuZXMsIGRlc3QuYSwgZGVzdC5iKTtcblxufTtcbiIsInZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi9nbG9iYWwnKTtcbnZhciBwYXJzZVByb2ogPSByZXF1aXJlKCcuL3Byb2pTdHJpbmcnKTtcbnZhciB3a3QgPSByZXF1aXJlKCcuL3drdCcpO1xuXG5mdW5jdGlvbiBkZWZzKG5hbWUpIHtcbiAgLypnbG9iYWwgY29uc29sZSovXG4gIHZhciB0aGF0ID0gdGhpcztcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZGVmID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0eXBlb2YgZGVmID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGRlZi5jaGFyQXQoMCkgPT09ICcrJykge1xuICAgICAgICBkZWZzW25hbWVdID0gcGFyc2VQcm9qKGFyZ3VtZW50c1sxXSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGVmc1tuYW1lXSA9IHdrdChhcmd1bWVudHNbMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWZzW25hbWVdID0gZGVmO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgIHJldHVybiBuYW1lLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgZGVmcy5hcHBseSh0aGF0LCB2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWZzKHYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAobmFtZSBpbiBkZWZzKSB7XG4gICAgICAgIHJldHVybiBkZWZzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgnRVBTRycgaW4gbmFtZSkge1xuICAgICAgZGVmc1snRVBTRzonICsgbmFtZS5FUFNHXSA9IG5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdFU1JJJyBpbiBuYW1lKSB7XG4gICAgICBkZWZzWydFU1JJOicgKyBuYW1lLkVTUkldID0gbmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ0lBVTIwMDAnIGluIG5hbWUpIHtcbiAgICAgIGRlZnNbJ0lBVTIwMDA6JyArIG5hbWUuSUFVMjAwMF0gPSBuYW1lO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuXG59XG5nbG9iYWxzKGRlZnMpO1xubW9kdWxlLmV4cG9ydHMgPSBkZWZzO1xuIiwiLy8gZWxsaXBvaWQgcGpfc2V0X2VsbC5jXG52YXIgU0lYVEggPSAwLjE2NjY2NjY2NjY2NjY2NjY2Njc7XG4vKiAxLzYgKi9cbnZhciBSQTQgPSAwLjA0NzIyMjIyMjIyMjIyMjIyMjIyO1xuLyogMTcvMzYwICovXG52YXIgUkE2ID0gMC4wMjIxNTYwODQ2NTYwODQ2NTYwODtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgRWxsaXBzb2lkID0gcmVxdWlyZSgnLi9jb25zdGFudHMvRWxsaXBzb2lkJyk7XG5cbmV4cG9ydHMuZWNjZW50cmljaXR5ID0gZnVuY3Rpb24oYSwgYiwgcmYsIFJfQSkge1xuICB2YXIgYTIgPSBhICogYTsgLy8gdXNlZCBpbiBnZW9jZW50cmljXG4gIHZhciBiMiA9IGIgKiBiOyAvLyB1c2VkIGluIGdlb2NlbnRyaWNcbiAgdmFyIGVzID0gKGEyIC0gYjIpIC8gYTI7IC8vIGUgXiAyXG4gIHZhciBlID0gMDtcbiAgaWYgKFJfQSkge1xuICAgIGEgKj0gMSAtIGVzICogKFNJWFRIICsgZXMgKiAoUkE0ICsgZXMgKiBSQTYpKTtcbiAgICBhMiA9IGEgKiBhO1xuICAgIGVzID0gMDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5zcXJ0KGVzKTsgLy8gZWNjZW50cmljaXR5XG4gIH1cbiAgdmFyIGVwMiA9IChhMiAtIGIyKSAvIGIyOyAvLyB1c2VkIGluIGdlb2NlbnRyaWNcbiAgcmV0dXJuIHtcbiAgICBlczogZXMsXG4gICAgZTogZSxcbiAgICBlcDI6IGVwMlxuICB9O1xufTtcbmV4cG9ydHMuc3BoZXJlID0gZnVuY3Rpb24gKGEsIGIsIHJmLCBlbGxwcywgc3BoZXJlKSB7XG4gIGlmICghYSkgeyAvLyBkbyB3ZSBoYXZlIGFuIGVsbGlwc29pZD9cbiAgICB2YXIgZWxsaXBzZSA9IEVsbGlwc29pZFtlbGxwc107XG4gICAgaWYgKCFlbGxpcHNlKSB7XG4gICAgICBlbGxpcHNlID0gRWxsaXBzb2lkLldHUzg0O1xuICAgIH1cbiAgICBhID0gZWxsaXBzZS5hO1xuICAgIGIgPSBlbGxpcHNlLmI7XG4gICAgcmYgPSBlbGxpcHNlLnJmO1xuICB9XG5cbiAgaWYgKHJmICYmICFiKSB7XG4gICAgYiA9ICgxLjAgLSAxLjAgLyByZikgKiBhO1xuICB9XG4gIGlmIChyZiA9PT0gMCB8fCBNYXRoLmFicyhhIC0gYikgPCBFUFNMTikge1xuICAgIHNwaGVyZSA9IHRydWU7XG4gICAgYiA9IGE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhOiBhLFxuICAgIGI6IGIsXG4gICAgcmY6IHJmLFxuICAgIHNwaGVyZTogc3BoZXJlXG4gIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gIGRlc3RpbmF0aW9uID0gZGVzdGluYXRpb24gfHwge307XG4gIHZhciB2YWx1ZSwgcHJvcGVydHk7XG4gIGlmICghc291cmNlKSB7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICB9XG4gIGZvciAocHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGVmcykge1xuICBkZWZzKCdFUFNHOjQzMjYnLCBcIit0aXRsZT1XR1MgODQgKGxvbmcvbGF0KSArcHJvaj1sb25nbGF0ICtlbGxwcz1XR1M4NCArZGF0dW09V0dTODQgK3VuaXRzPWRlZ3JlZXNcIik7XG4gIGRlZnMoJ0VQU0c6NDI2OScsIFwiK3RpdGxlPU5BRDgzIChsb25nL2xhdCkgK3Byb2o9bG9uZ2xhdCArYT02Mzc4MTM3LjAgK2I9NjM1Njc1Mi4zMTQxNDAzNiArZWxscHM9R1JTODAgK2RhdHVtPU5BRDgzICt1bml0cz1kZWdyZWVzXCIpO1xuICBkZWZzKCdFUFNHOjM4NTcnLCBcIit0aXRsZT1XR1MgODQgLyBQc2V1ZG8tTWVyY2F0b3IgK3Byb2o9bWVyYyArYT02Mzc4MTM3ICtiPTYzNzgxMzcgK2xhdF90cz0wLjAgK2xvbl8wPTAuMCAreF8wPTAuMCAreV8wPTAgK2s9MS4wICt1bml0cz1tICtuYWRncmlkcz1AbnVsbCArbm9fZGVmc1wiKTtcblxuICBkZWZzLldHUzg0ID0gZGVmc1snRVBTRzo0MzI2J107XG4gIGRlZnNbJ0VQU0c6Mzc4NSddID0gZGVmc1snRVBTRzozODU3J107IC8vIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdCwgb2ZmaWNpYWwgY29kZSBpcyAzODU3XG4gIGRlZnMuR09PR0xFID0gZGVmc1snRVBTRzozODU3J107XG4gIGRlZnNbJ0VQU0c6OTAwOTEzJ10gPSBkZWZzWydFUFNHOjM4NTcnXTtcbiAgZGVmc1snRVBTRzoxMDIxMTMnXSA9IGRlZnNbJ0VQU0c6Mzg1NyddO1xufTtcbiIsInZhciBkZWZzID0gcmVxdWlyZSgnLi9kZWZzJyk7XG52YXIgd2t0ID0gcmVxdWlyZSgnLi93a3QnKTtcbnZhciBwcm9qU3RyID0gcmVxdWlyZSgnLi9wcm9qU3RyaW5nJyk7XG5mdW5jdGlvbiB0ZXN0T2JqKGNvZGUpe1xuICByZXR1cm4gdHlwZW9mIGNvZGUgPT09ICdzdHJpbmcnO1xufVxuZnVuY3Rpb24gdGVzdERlZihjb2RlKXtcbiAgcmV0dXJuIGNvZGUgaW4gZGVmcztcbn1cbnZhciBjb2RlV29yZHMgPSBbJ0dFT0dDUycsJ0dFT0NDUycsJ1BST0pDUycsJ0xPQ0FMX0NTJ107XG5cbmZ1bmN0aW9uIHRlc3RXS1QoY29kZSl7XG4gIHJldHVybiBjb2RlV29yZHMuc29tZShmdW5jdGlvbiAod29yZCkge1xuICAgIHJldHVybiBjb2RlLmluZGV4T2Yod29yZCkgPiAtMTtcbiAgfSk7XG59XG5mdW5jdGlvbiB0ZXN0UHJvaihjb2RlKXtcbiAgcmV0dXJuIGNvZGVbMF0gPT09ICcrJztcbn1cbmZ1bmN0aW9uIHBhcnNlKGNvZGUpe1xuICBpZiAodGVzdE9iaihjb2RlKSkge1xuICAgIC8vY2hlY2sgdG8gc2VlIGlmIHRoaXMgaXMgYSBXS1Qgc3RyaW5nXG4gICAgaWYgKHRlc3REZWYoY29kZSkpIHtcbiAgICAgIHJldHVybiBkZWZzW2NvZGVdO1xuICAgIH1cbiAgICBpZiAodGVzdFdLVChjb2RlKSkge1xuICAgICAgcmV0dXJuIHdrdChjb2RlKTtcbiAgICB9XG4gICAgaWYgKHRlc3RQcm9qKGNvZGUpKSB7XG4gICAgICByZXR1cm4gcHJvalN0cihjb2RlKTtcbiAgICB9XG4gIH1lbHNle1xuICAgIHJldHVybiBjb2RlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG4iLCJ2YXIgRDJSID0gMC4wMTc0NTMyOTI1MTk5NDMyOTU3NztcbnZhciBQcmltZU1lcmlkaWFuID0gcmVxdWlyZSgnLi9jb25zdGFudHMvUHJpbWVNZXJpZGlhbicpO1xudmFyIHVuaXRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMvdW5pdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkZWZEYXRhKSB7XG4gIHZhciBzZWxmID0ge307XG4gIHZhciBwYXJhbU9iaiA9IGRlZkRhdGEuc3BsaXQoJysnKS5tYXAoZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2LnRyaW0oKTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gYTtcbiAgfSkucmVkdWNlKGZ1bmN0aW9uKHAsIGEpIHtcbiAgICB2YXIgc3BsaXQgPSBhLnNwbGl0KCc9Jyk7XG4gICAgc3BsaXQucHVzaCh0cnVlKTtcbiAgICBwW3NwbGl0WzBdLnRvTG93ZXJDYXNlKCldID0gc3BsaXRbMV07XG4gICAgcmV0dXJuIHA7XG4gIH0sIHt9KTtcbiAgdmFyIHBhcmFtTmFtZSwgcGFyYW1WYWwsIHBhcmFtT3V0bmFtZTtcbiAgdmFyIHBhcmFtcyA9IHtcbiAgICBwcm9qOiAncHJvak5hbWUnLFxuICAgIGRhdHVtOiAnZGF0dW1Db2RlJyxcbiAgICByZjogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5yZiA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICBsYXRfMDogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sYXQwID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIGxhdF8xOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxhdDEgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbGF0XzI6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubGF0MiA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBsYXRfdHM6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubGF0X3RzID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIGxvbl8wOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxvbmcwID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIGxvbl8xOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxvbmcxID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIGxvbl8yOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxvbmcyID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIGFscGhhOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmFscGhhID0gcGFyc2VGbG9hdCh2KSAqIEQyUjtcbiAgICB9LFxuICAgIGxvbmM6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubG9uZ2MgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgeF8wOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLngwID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIHlfMDogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi55MCA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICBrXzA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuazAgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgazogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5rMCA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICBhOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmEgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgYjogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5iID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIHJfYTogZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLlJfQSA9IHRydWU7XG4gICAgfSxcbiAgICB6b25lOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLnpvbmUgPSBwYXJzZUludCh2LCAxMCk7XG4gICAgfSxcbiAgICBzb3V0aDogZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnV0bVNvdXRoID0gdHJ1ZTtcbiAgICB9LFxuICAgIHRvd2dzODQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuZGF0dW1fcGFyYW1zID0gdi5zcGxpdChcIixcIikubWFwKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRvX21ldGVyOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLnRvX21ldGVyID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIHVuaXRzOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLnVuaXRzID0gdjtcbiAgICAgIGlmICh1bml0c1t2XSkge1xuICAgICAgICBzZWxmLnRvX21ldGVyID0gdW5pdHNbdl0udG9fbWV0ZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICBmcm9tX2dyZWVud2ljaDogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5mcm9tX2dyZWVud2ljaCA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBwbTogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5mcm9tX2dyZWVud2ljaCA9IChQcmltZU1lcmlkaWFuW3ZdID8gUHJpbWVNZXJpZGlhblt2XSA6IHBhcnNlRmxvYXQodikpICogRDJSO1xuICAgIH0sXG4gICAgbmFkZ3JpZHM6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICh2ID09PSAnQG51bGwnKSB7XG4gICAgICAgIHNlbGYuZGF0dW1Db2RlID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGYubmFkZ3JpZHMgPSB2O1xuICAgICAgfVxuICAgIH0sXG4gICAgYXhpczogZnVuY3Rpb24odikge1xuICAgICAgdmFyIGxlZ2FsQXhpcyA9IFwiZXduc3VkXCI7XG4gICAgICBpZiAodi5sZW5ndGggPT09IDMgJiYgbGVnYWxBeGlzLmluZGV4T2Yodi5zdWJzdHIoMCwgMSkpICE9PSAtMSAmJiBsZWdhbEF4aXMuaW5kZXhPZih2LnN1YnN0cigxLCAxKSkgIT09IC0xICYmIGxlZ2FsQXhpcy5pbmRleE9mKHYuc3Vic3RyKDIsIDEpKSAhPT0gLTEpIHtcbiAgICAgICAgc2VsZi5heGlzID0gdjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZvciAocGFyYW1OYW1lIGluIHBhcmFtT2JqKSB7XG4gICAgcGFyYW1WYWwgPSBwYXJhbU9ialtwYXJhbU5hbWVdO1xuICAgIGlmIChwYXJhbU5hbWUgaW4gcGFyYW1zKSB7XG4gICAgICBwYXJhbU91dG5hbWUgPSBwYXJhbXNbcGFyYW1OYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgcGFyYW1PdXRuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBhcmFtT3V0bmFtZShwYXJhbVZhbCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VsZltwYXJhbU91dG5hbWVdID0gcGFyYW1WYWw7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2VsZltwYXJhbU5hbWVdID0gcGFyYW1WYWw7XG4gICAgfVxuICB9XG4gIGlmKHR5cGVvZiBzZWxmLmRhdHVtQ29kZSA9PT0gJ3N0cmluZycgJiYgc2VsZi5kYXR1bUNvZGUgIT09IFwiV0dTODRcIil7XG4gICAgc2VsZi5kYXR1bUNvZGUgPSBzZWxmLmRhdHVtQ29kZS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIHJldHVybiBzZWxmO1xufTtcbiIsInZhciBwcm9qcyA9IFtcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy9tZXJjJyksXG4gIHJlcXVpcmUoJy4vcHJvamVjdGlvbnMvbG9uZ2xhdCcpXG5dO1xudmFyIG5hbWVzID0ge307XG52YXIgcHJvalN0b3JlID0gW107XG5cbmZ1bmN0aW9uIGFkZChwcm9qLCBpKSB7XG4gIHZhciBsZW4gPSBwcm9qU3RvcmUubGVuZ3RoO1xuICBpZiAoIXByb2oubmFtZXMpIHtcbiAgICBjb25zb2xlLmxvZyhpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBwcm9qU3RvcmVbbGVuXSA9IHByb2o7XG4gIHByb2oubmFtZXMuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgbmFtZXNbbi50b0xvd2VyQ2FzZSgpXSA9IGxlbjtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnRzLmFkZCA9IGFkZDtcblxuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbiA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHR5cGVvZiBuYW1lc1tuXSAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvalN0b3JlW25hbWVzW25dXSkge1xuICAgIHJldHVybiBwcm9qU3RvcmVbbmFtZXNbbl1dO1xuICB9XG59O1xuZXhwb3J0cy5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICBwcm9qcy5mb3JFYWNoKGFkZCk7XG59O1xuIiwiZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIC8vbm8tb3AgZm9yIGxvbmdsYXRcbn07XG5cbmZ1bmN0aW9uIGlkZW50aXR5KHB0KSB7XG4gIHJldHVybiBwdDtcbn1cbmV4cG9ydHMuZm9yd2FyZCA9IGlkZW50aXR5O1xuZXhwb3J0cy5pbnZlcnNlID0gaWRlbnRpdHk7XG5leHBvcnRzLm5hbWVzID0gW1wibG9uZ2xhdFwiLCBcImlkZW50aXR5XCJdO1xuIiwidmFyIG1zZm56ID0gcmVxdWlyZSgnLi4vY29tbW9uL21zZm56Jyk7XG52YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgUjJEID0gNTcuMjk1Nzc5NTEzMDgyMzIwODg7XG52YXIgYWRqdXN0X2xvbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG52YXIgRk9SVFBJID0gTWF0aC5QSS80O1xudmFyIHRzZm56ID0gcmVxdWlyZSgnLi4vY29tbW9uL3RzZm56Jyk7XG52YXIgcGhpMnogPSByZXF1aXJlKCcuLi9jb21tb24vcGhpMnonKTtcbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29uID0gdGhpcy5iIC8gdGhpcy5hO1xuICB0aGlzLmVzID0gMSAtIGNvbiAqIGNvbjtcbiAgaWYoISgneDAnIGluIHRoaXMpKXtcbiAgICB0aGlzLngwID0gMDtcbiAgfVxuICBpZighKCd5MCcgaW4gdGhpcykpe1xuICAgIHRoaXMueTAgPSAwO1xuICB9XG4gIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmVzKTtcbiAgaWYgKHRoaXMubGF0X3RzKSB7XG4gICAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgICB0aGlzLmswID0gTWF0aC5jb3ModGhpcy5sYXRfdHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuazAgPSBtc2Zueih0aGlzLmUsIE1hdGguc2luKHRoaXMubGF0X3RzKSwgTWF0aC5jb3ModGhpcy5sYXRfdHMpKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKCF0aGlzLmswKSB7XG4gICAgICBpZiAodGhpcy5rKSB7XG4gICAgICAgIHRoaXMuazAgPSB0aGlzLms7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5rMCA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKiBNZXJjYXRvciBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIC8vIGNvbnZlcnQgdG8gcmFkaWFuc1xuICBpZiAobGF0ICogUjJEID4gOTAgJiYgbGF0ICogUjJEIDwgLTkwICYmIGxvbiAqIFIyRCA+IDE4MCAmJiBsb24gKiBSMkQgPCAtMTgwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgeCwgeTtcbiAgaWYgKE1hdGguYWJzKE1hdGguYWJzKGxhdCkgLSBIQUxGX1BJKSA8PSBFUFNMTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmICh0aGlzLnNwaGVyZSkge1xuICAgICAgeCA9IHRoaXMueDAgKyB0aGlzLmEgKiB0aGlzLmswICogYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgICAgIHkgPSB0aGlzLnkwICsgdGhpcy5hICogdGhpcy5rMCAqIE1hdGgubG9nKE1hdGgudGFuKEZPUlRQSSArIDAuNSAqIGxhdCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzaW5waGkgPSBNYXRoLnNpbihsYXQpO1xuICAgICAgdmFyIHRzID0gdHNmbnoodGhpcy5lLCBsYXQsIHNpbnBoaSk7XG4gICAgICB4ID0gdGhpcy54MCArIHRoaXMuYSAqIHRoaXMuazAgKiBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICAgICAgeSA9IHRoaXMueTAgLSB0aGlzLmEgKiB0aGlzLmswICogTWF0aC5sb2codHMpO1xuICAgIH1cbiAgICBwLnggPSB4O1xuICAgIHAueSA9IHk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbn07XG5cblxuLyogTWVyY2F0b3IgaW52ZXJzZSBlcXVhdGlvbnMtLW1hcHBpbmcgeCx5IHRvIGxhdC9sb25nXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcblxuICB2YXIgeCA9IHAueCAtIHRoaXMueDA7XG4gIHZhciB5ID0gcC55IC0gdGhpcy55MDtcbiAgdmFyIGxvbiwgbGF0O1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGxhdCA9IEhBTEZfUEkgLSAyICogTWF0aC5hdGFuKE1hdGguZXhwKC15IC8gKHRoaXMuYSAqIHRoaXMuazApKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHRzID0gTWF0aC5leHAoLXkgLyAodGhpcy5hICogdGhpcy5rMCkpO1xuICAgIGxhdCA9IHBoaTJ6KHRoaXMuZSwgdHMpO1xuICAgIGlmIChsYXQgPT09IC05OTk5KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgeCAvICh0aGlzLmEgKiB0aGlzLmswKSk7XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5uYW1lcyA9IFtcIk1lcmNhdG9yXCIsIFwiUG9wdWxhciBWaXN1YWxpc2F0aW9uIFBzZXVkbyBNZXJjYXRvclwiLCBcIk1lcmNhdG9yXzFTUFwiLCBcIk1lcmNhdG9yX0F1eGlsaWFyeV9TcGhlcmVcIiwgXCJtZXJjXCJdO1xuIiwidmFyIEQyUiA9IDAuMDE3NDUzMjkyNTE5OTQzMjk1Nzc7XG52YXIgUjJEID0gNTcuMjk1Nzc5NTEzMDgyMzIwODg7XG52YXIgUEpEXzNQQVJBTSA9IDE7XG52YXIgUEpEXzdQQVJBTSA9IDI7XG52YXIgZGF0dW1fdHJhbnNmb3JtID0gcmVxdWlyZSgnLi9kYXR1bV90cmFuc2Zvcm0nKTtcbnZhciBhZGp1c3RfYXhpcyA9IHJlcXVpcmUoJy4vYWRqdXN0X2F4aXMnKTtcbnZhciBwcm9qID0gcmVxdWlyZSgnLi9Qcm9qJyk7XG52YXIgdG9Qb2ludCA9IHJlcXVpcmUoJy4vY29tbW9uL3RvUG9pbnQnKTtcbmZ1bmN0aW9uIGNoZWNrTm90V0dTKHNvdXJjZSwgZGVzdCkge1xuICByZXR1cm4gKChzb3VyY2UuZGF0dW0uZGF0dW1fdHlwZSA9PT0gUEpEXzNQQVJBTSB8fCBzb3VyY2UuZGF0dW0uZGF0dW1fdHlwZSA9PT0gUEpEXzdQQVJBTSkgJiYgZGVzdC5kYXR1bUNvZGUgIT09ICdXR1M4NCcpIHx8ICgoZGVzdC5kYXR1bS5kYXR1bV90eXBlID09PSBQSkRfM1BBUkFNIHx8IGRlc3QuZGF0dW0uZGF0dW1fdHlwZSA9PT0gUEpEXzdQQVJBTSkgJiYgc291cmNlLmRhdHVtQ29kZSAhPT0gJ1dHUzg0Jyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybShzb3VyY2UsIGRlc3QsIHBvaW50KSB7XG4gIHZhciB3Z3M4NDtcbiAgaWYgKEFycmF5LmlzQXJyYXkocG9pbnQpKSB7XG4gICAgcG9pbnQgPSB0b1BvaW50KHBvaW50KTtcbiAgfVxuXG4gIC8vIFdvcmthcm91bmQgZm9yIGRhdHVtIHNoaWZ0cyB0b3dnczg0LCBpZiBlaXRoZXIgc291cmNlIG9yIGRlc3RpbmF0aW9uIHByb2plY3Rpb24gaXMgbm90IHdnczg0XG4gIGlmIChzb3VyY2UuZGF0dW0gJiYgZGVzdC5kYXR1bSAmJiBjaGVja05vdFdHUyhzb3VyY2UsIGRlc3QpKSB7XG4gICAgd2dzODQgPSBuZXcgcHJvaignV0dTODQnKTtcbiAgICBwb2ludCA9IHRyYW5zZm9ybShzb3VyY2UsIHdnczg0LCBwb2ludCk7XG4gICAgc291cmNlID0gd2dzODQ7XG4gIH1cbiAgLy8gREdSLCAyMDEwLzExLzEyXG4gIGlmIChzb3VyY2UuYXhpcyAhPT0gJ2VudScpIHtcbiAgICBwb2ludCA9IGFkanVzdF9heGlzKHNvdXJjZSwgZmFsc2UsIHBvaW50KTtcbiAgfVxuICAvLyBUcmFuc2Zvcm0gc291cmNlIHBvaW50cyB0byBsb25nL2xhdCwgaWYgdGhleSBhcmVuJ3QgYWxyZWFkeS5cbiAgaWYgKHNvdXJjZS5wcm9qTmFtZSA9PT0gJ2xvbmdsYXQnKSB7XG4gICAgcG9pbnQgPSB7XG4gICAgICB4OiBwb2ludC54ICogRDJSLFxuICAgICAgeTogcG9pbnQueSAqIEQyUlxuICAgIH07XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKHNvdXJjZS50b19tZXRlcikge1xuICAgICAgcG9pbnQgPSB7XG4gICAgICAgIHg6IHBvaW50LnggKiBzb3VyY2UudG9fbWV0ZXIsXG4gICAgICAgIHk6IHBvaW50LnkgKiBzb3VyY2UudG9fbWV0ZXJcbiAgICAgIH07XG4gICAgfVxuICAgIHBvaW50ID0gc291cmNlLmludmVyc2UocG9pbnQpOyAvLyBDb252ZXJ0IENhcnRlc2lhbiB0byBsb25nbGF0XG4gIH1cbiAgLy8gQWRqdXN0IGZvciB0aGUgcHJpbWUgbWVyaWRpYW4gaWYgbmVjZXNzYXJ5XG4gIGlmIChzb3VyY2UuZnJvbV9ncmVlbndpY2gpIHtcbiAgICBwb2ludC54ICs9IHNvdXJjZS5mcm9tX2dyZWVud2ljaDtcbiAgfVxuXG4gIC8vIENvbnZlcnQgZGF0dW1zIGlmIG5lZWRlZCwgYW5kIGlmIHBvc3NpYmxlLlxuICBwb2ludCA9IGRhdHVtX3RyYW5zZm9ybShzb3VyY2UuZGF0dW0sIGRlc3QuZGF0dW0sIHBvaW50KTtcblxuICAvLyBBZGp1c3QgZm9yIHRoZSBwcmltZSBtZXJpZGlhbiBpZiBuZWNlc3NhcnlcbiAgaWYgKGRlc3QuZnJvbV9ncmVlbndpY2gpIHtcbiAgICBwb2ludCA9IHtcbiAgICAgIHg6IHBvaW50LnggLSBkZXN0Lmdyb21fZ3JlZW53aWNoLFxuICAgICAgeTogcG9pbnQueVxuICAgIH07XG4gIH1cblxuICBpZiAoZGVzdC5wcm9qTmFtZSA9PT0gJ2xvbmdsYXQnKSB7XG4gICAgLy8gY29udmVydCByYWRpYW5zIHRvIGRlY2ltYWwgZGVncmVlc1xuICAgIHBvaW50ID0ge1xuICAgICAgeDogcG9pbnQueCAqIFIyRCxcbiAgICAgIHk6IHBvaW50LnkgKiBSMkRcbiAgICB9O1xuICB9IGVsc2UgeyAvLyBlbHNlIHByb2plY3RcbiAgICBwb2ludCA9IGRlc3QuZm9yd2FyZChwb2ludCk7XG4gICAgaWYgKGRlc3QudG9fbWV0ZXIpIHtcbiAgICAgIHBvaW50ID0ge1xuICAgICAgICB4OiBwb2ludC54IC8gZGVzdC50b19tZXRlcixcbiAgICAgICAgeTogcG9pbnQueSAvIGRlc3QudG9fbWV0ZXJcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gREdSLCAyMDEwLzExLzEyXG4gIGlmIChkZXN0LmF4aXMgIT09ICdlbnUnKSB7XG4gICAgcmV0dXJuIGFkanVzdF9heGlzKGRlc3QsIHRydWUsIHBvaW50KTtcbiAgfVxuXG4gIHJldHVybiBwb2ludDtcbn07XG4iLCJ2YXIgRDJSID0gMC4wMTc0NTMyOTI1MTk5NDMyOTU3NztcbnZhciBleHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xuXG5mdW5jdGlvbiBtYXBpdChvYmosIGtleSwgdikge1xuICBvYmpba2V5XSA9IHYubWFwKGZ1bmN0aW9uKGFhKSB7XG4gICAgdmFyIG8gPSB7fTtcbiAgICBzRXhwcihhYSwgbyk7XG4gICAgcmV0dXJuIG87XG4gIH0pLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGV4dGVuZChhLCBiKTtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBzRXhwcih2LCBvYmopIHtcbiAgdmFyIGtleTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgb2JqW3ZdID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxzZSB7XG4gICAga2V5ID0gdi5zaGlmdCgpO1xuICAgIGlmIChrZXkgPT09ICdQQVJBTUVURVInKSB7XG4gICAgICBrZXkgPSB2LnNoaWZ0KCk7XG4gICAgfVxuICAgIGlmICh2Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodlswXSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSB7fTtcbiAgICAgICAgc0V4cHIodlswXSwgb2JqW2tleV0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdlswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoIXYubGVuZ3RoKSB7XG4gICAgICBvYmpba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtleSA9PT0gJ1RPV0dTODQnKSB7XG4gICAgICBvYmpba2V5XSA9IHY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSB7fTtcbiAgICAgIGlmIChbJ1VOSVQnLCAnUFJJTUVNJywgJ1ZFUlRfREFUVU0nXS5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICBvYmpba2V5XSA9IHtcbiAgICAgICAgICBuYW1lOiB2WzBdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgY29udmVydDogdlsxXVxuICAgICAgICB9O1xuICAgICAgICBpZiAodi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICBvYmpba2V5XS5hdXRoID0gdlsyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnU1BIRVJPSUQnKSB7XG4gICAgICAgIG9ialtrZXldID0ge1xuICAgICAgICAgIG5hbWU6IHZbMF0sXG4gICAgICAgICAgYTogdlsxXSxcbiAgICAgICAgICByZjogdlsyXVxuICAgICAgICB9O1xuICAgICAgICBpZiAodi5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICBvYmpba2V5XS5hdXRoID0gdlszXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoWydHRU9HQ1MnLCAnR0VPQ0NTJywgJ0RBVFVNJywgJ1ZFUlRfQ1MnLCAnQ09NUERfQ1MnLCAnTE9DQUxfQ1MnLCAnRklUVEVEX0NTJywgJ0xPQ0FMX0RBVFVNJ10uaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgdlswXSA9IFsnbmFtZScsIHZbMF1dO1xuICAgICAgICBtYXBpdChvYmosIGtleSwgdik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2LmV2ZXJ5KGZ1bmN0aW9uKGFhKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFhKTtcbiAgICAgIH0pKSB7XG4gICAgICAgIG1hcGl0KG9iaiwga2V5LCB2KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzRXhwcih2LCBvYmpba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmFtZShvYmosIHBhcmFtcykge1xuICB2YXIgb3V0TmFtZSA9IHBhcmFtc1swXTtcbiAgdmFyIGluTmFtZSA9IHBhcmFtc1sxXTtcbiAgaWYgKCEob3V0TmFtZSBpbiBvYmopICYmIChpbk5hbWUgaW4gb2JqKSkge1xuICAgIG9ialtvdXROYW1lXSA9IG9ialtpbk5hbWVdO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICBvYmpbb3V0TmFtZV0gPSBwYXJhbXNbMl0ob2JqW291dE5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZDJyKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dCAqIEQyUjtcbn1cblxuZnVuY3Rpb24gY2xlYW5XS1Qod2t0KSB7XG4gIGlmICh3a3QudHlwZSA9PT0gJ0dFT0dDUycpIHtcbiAgICB3a3QucHJvak5hbWUgPSAnbG9uZ2xhdCc7XG4gIH1cbiAgZWxzZSBpZiAod2t0LnR5cGUgPT09ICdMT0NBTF9DUycpIHtcbiAgICB3a3QucHJvak5hbWUgPSAnaWRlbnRpdHknO1xuICAgIHdrdC5sb2NhbCA9IHRydWU7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKHR5cGVvZiB3a3QuUFJPSkVDVElPTiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgd2t0LnByb2pOYW1lID0gT2JqZWN0LmtleXMod2t0LlBST0pFQ1RJT04pWzBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHdrdC5wcm9qTmFtZSA9IHdrdC5QUk9KRUNUSU9OO1xuICAgIH1cbiAgfVxuICBpZiAod2t0LlVOSVQpIHtcbiAgICB3a3QudW5pdHMgPSB3a3QuVU5JVC5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHdrdC51bml0cyA9PT0gJ21ldHJlJykge1xuICAgICAgd2t0LnVuaXRzID0gJ21ldGVyJztcbiAgICB9XG4gICAgaWYgKHdrdC5VTklULmNvbnZlcnQpIHtcbiAgICAgIGlmICh3a3QudHlwZSA9PT0gJ0dFT0dDUycpIHtcbiAgICAgICAgaWYgKHdrdC5EQVRVTSAmJiB3a3QuREFUVU0uU1BIRVJPSUQpIHtcbiAgICAgICAgICB3a3QudG9fbWV0ZXIgPSBwYXJzZUZsb2F0KHdrdC5VTklULmNvbnZlcnQsIDEwKSp3a3QuREFUVU0uU1BIRVJPSUQuYTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2t0LnRvX21ldGVyID0gcGFyc2VGbG9hdCh3a3QuVU5JVC5jb252ZXJ0LCAxMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHdrdC5HRU9HQ1MpIHtcbiAgICAvL2lmKHdrdC5HRU9HQ1MuUFJJTUVNJiZ3a3QuR0VPR0NTLlBSSU1FTS5jb252ZXJ0KXtcbiAgICAvLyAgd2t0LmZyb21fZ3JlZW53aWNoPXdrdC5HRU9HQ1MuUFJJTUVNLmNvbnZlcnQqRDJSO1xuICAgIC8vfVxuICAgIGlmICh3a3QuR0VPR0NTLkRBVFVNKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gd2t0LkdFT0dDUy5EQVRVTS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9IHdrdC5HRU9HQ1MubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAod2t0LmRhdHVtQ29kZS5zbGljZSgwLCAyKSA9PT0gJ2RfJykge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9IHdrdC5kYXR1bUNvZGUuc2xpY2UoMik7XG4gICAgfVxuICAgIGlmICh3a3QuZGF0dW1Db2RlID09PSAnbmV3X3plYWxhbmRfZ2VvZGV0aWNfZGF0dW1fMTk0OScgfHwgd2t0LmRhdHVtQ29kZSA9PT0gJ25ld196ZWFsYW5kXzE5NDknKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gJ256Z2Q0OSc7XG4gICAgfVxuICAgIGlmICh3a3QuZGF0dW1Db2RlID09PSBcIndnc18xOTg0XCIpIHtcbiAgICAgIGlmICh3a3QuUFJPSkVDVElPTiA9PT0gJ01lcmNhdG9yX0F1eGlsaWFyeV9TcGhlcmUnKSB7XG4gICAgICAgIHdrdC5zcGhlcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgd2t0LmRhdHVtQ29kZSA9ICd3Z3M4NCc7XG4gICAgfVxuICAgIGlmICh3a3QuZGF0dW1Db2RlLnNsaWNlKC02KSA9PT0gJ19mZXJybycpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSB3a3QuZGF0dW1Db2RlLnNsaWNlKDAsIC0gNik7XG4gICAgfVxuICAgIGlmICh3a3QuZGF0dW1Db2RlLnNsaWNlKC04KSA9PT0gJ19qYWthcnRhJykge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9IHdrdC5kYXR1bUNvZGUuc2xpY2UoMCwgLSA4KTtcbiAgICB9XG4gICAgaWYgKH53a3QuZGF0dW1Db2RlLmluZGV4T2YoJ2JlbGdlJykpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSBcInJuYjcyXCI7XG4gICAgfVxuICAgIGlmICh3a3QuR0VPR0NTLkRBVFVNICYmIHdrdC5HRU9HQ1MuREFUVU0uU1BIRVJPSUQpIHtcbiAgICAgIHdrdC5lbGxwcyA9IHdrdC5HRU9HQ1MuREFUVU0uU1BIRVJPSUQubmFtZS5yZXBsYWNlKCdfMTknLCAnJykucmVwbGFjZSgvW0NjXWxhcmtlXFxfMTgvLCAnY2xyaycpO1xuICAgICAgaWYgKHdrdC5lbGxwcy50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDEzKSA9PT0gXCJpbnRlcm5hdGlvbmFsXCIpIHtcbiAgICAgICAgd2t0LmVsbHBzID0gJ2ludGwnO1xuICAgICAgfVxuXG4gICAgICB3a3QuYSA9IHdrdC5HRU9HQ1MuREFUVU0uU1BIRVJPSUQuYTtcbiAgICAgIHdrdC5yZiA9IHBhcnNlRmxvYXQod2t0LkdFT0dDUy5EQVRVTS5TUEhFUk9JRC5yZiwgMTApO1xuICAgIH1cbiAgICBpZiAofndrdC5kYXR1bUNvZGUuaW5kZXhPZignb3NnYl8xOTM2JykpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSBcIm9zZ2IzNlwiO1xuICAgIH1cbiAgfVxuICBpZiAod2t0LmIgJiYgIWlzRmluaXRlKHdrdC5iKSkge1xuICAgIHdrdC5iID0gd2t0LmE7XG4gIH1cblxuICBmdW5jdGlvbiB0b01ldGVyKGlucHV0KSB7XG4gICAgdmFyIHJhdGlvID0gd2t0LnRvX21ldGVyIHx8IDE7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoaW5wdXQsIDEwKSAqIHJhdGlvO1xuICB9XG4gIHZhciByZW5hbWVyID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiByZW5hbWUod2t0LCBhKTtcbiAgfTtcbiAgdmFyIGxpc3QgPSBbXG4gICAgWydzdGFuZGFyZF9wYXJhbGxlbF8xJywgJ1N0YW5kYXJkX1BhcmFsbGVsXzEnXSxcbiAgICBbJ3N0YW5kYXJkX3BhcmFsbGVsXzInLCAnU3RhbmRhcmRfUGFyYWxsZWxfMiddLFxuICAgIFsnZmFsc2VfZWFzdGluZycsICdGYWxzZV9FYXN0aW5nJ10sXG4gICAgWydmYWxzZV9ub3J0aGluZycsICdGYWxzZV9Ob3J0aGluZyddLFxuICAgIFsnY2VudHJhbF9tZXJpZGlhbicsICdDZW50cmFsX01lcmlkaWFuJ10sXG4gICAgWydsYXRpdHVkZV9vZl9vcmlnaW4nLCAnTGF0aXR1ZGVfT2ZfT3JpZ2luJ10sXG4gICAgWydsYXRpdHVkZV9vZl9vcmlnaW4nLCAnQ2VudHJhbF9QYXJhbGxlbCddLFxuICAgIFsnc2NhbGVfZmFjdG9yJywgJ1NjYWxlX0ZhY3RvciddLFxuICAgIFsnazAnLCAnc2NhbGVfZmFjdG9yJ10sXG4gICAgWydsYXRpdHVkZV9vZl9jZW50ZXInLCAnTGF0aXR1ZGVfb2ZfY2VudGVyJ10sXG4gICAgWydsYXQwJywgJ2xhdGl0dWRlX29mX2NlbnRlcicsIGQycl0sXG4gICAgWydsb25naXR1ZGVfb2ZfY2VudGVyJywgJ0xvbmdpdHVkZV9PZl9DZW50ZXInXSxcbiAgICBbJ2xvbmdjJywgJ2xvbmdpdHVkZV9vZl9jZW50ZXInLCBkMnJdLFxuICAgIFsneDAnLCAnZmFsc2VfZWFzdGluZycsIHRvTWV0ZXJdLFxuICAgIFsneTAnLCAnZmFsc2Vfbm9ydGhpbmcnLCB0b01ldGVyXSxcbiAgICBbJ2xvbmcwJywgJ2NlbnRyYWxfbWVyaWRpYW4nLCBkMnJdLFxuICAgIFsnbGF0MCcsICdsYXRpdHVkZV9vZl9vcmlnaW4nLCBkMnJdLFxuICAgIFsnbGF0MCcsICdzdGFuZGFyZF9wYXJhbGxlbF8xJywgZDJyXSxcbiAgICBbJ2xhdDEnLCAnc3RhbmRhcmRfcGFyYWxsZWxfMScsIGQycl0sXG4gICAgWydsYXQyJywgJ3N0YW5kYXJkX3BhcmFsbGVsXzInLCBkMnJdLFxuICAgIFsnYWxwaGEnLCAnYXppbXV0aCcsIGQycl0sXG4gICAgWydzcnNDb2RlJywgJ25hbWUnXVxuICBdO1xuICBsaXN0LmZvckVhY2gocmVuYW1lcik7XG4gIGlmICghd2t0LmxvbmcwICYmIHdrdC5sb25nYyAmJiAod2t0LnByb2pOYW1lID09PSAnQWxiZXJzX0NvbmljX0VxdWFsX0FyZWEnIHx8IHdrdC5wcm9qTmFtZSA9PT0gXCJMYW1iZXJ0X0F6aW11dGhhbF9FcXVhbF9BcmVhXCIpKSB7XG4gICAgd2t0LmxvbmcwID0gd2t0LmxvbmdjO1xuICB9XG4gIGlmICghd2t0LmxhdF90cyAmJiB3a3QubGF0MSAmJiAod2t0LnByb2pOYW1lID09PSAnU3RlcmVvZ3JhcGhpY19Tb3V0aF9Qb2xlJyB8fCB3a3QucHJvak5hbWUgPT09ICdQb2xhciBTdGVyZW9ncmFwaGljICh2YXJpYW50IEIpJykpIHtcbiAgICB3a3QubGF0MCA9IGQycih3a3QubGF0MSA+IDAgPyA5MCA6IC05MCk7XG4gICAgd2t0LmxhdF90cyA9IHdrdC5sYXQxO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHdrdCwgc2VsZikge1xuICB2YXIgbGlzcCA9IEpTT04ucGFyc2UoKFwiLFwiICsgd2t0KS5yZXBsYWNlKC9cXHMqXFwsXFxzKihbQS1aXzAtOV0rPykoXFxbKS9nLCAnLFtcIiQxXCIsJykuc2xpY2UoMSkucmVwbGFjZSgvXFxzKlxcLFxccyooW0EtWl8wLTldKz8pXFxdL2csICcsXCIkMVwiXScpLnJlcGxhY2UoLyxcXFtcIlZFUlRDU1wiLisvLCcnKSk7XG4gIHZhciB0eXBlID0gbGlzcC5zaGlmdCgpO1xuICB2YXIgbmFtZSA9IGxpc3Auc2hpZnQoKTtcbiAgbGlzcC51bnNoaWZ0KFsnbmFtZScsIG5hbWVdKTtcbiAgbGlzcC51bnNoaWZ0KFsndHlwZScsIHR5cGVdKTtcbiAgbGlzcC51bnNoaWZ0KCdvdXRwdXQnKTtcbiAgdmFyIG9iaiA9IHt9O1xuICBzRXhwcihsaXNwLCBvYmopO1xuICBjbGVhbldLVChvYmoub3V0cHV0KTtcbiAgcmV0dXJuIGV4dGVuZChzZWxmLCBvYmoub3V0cHV0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFydGlhbFNvcnQ7XG5cbi8vIEZsb3lkLVJpdmVzdCBzZWxlY3Rpb24gYWxnb3JpdGhtOlxuLy8gUmVhcnJhbmdlIGl0ZW1zIHNvIHRoYXQgYWxsIGl0ZW1zIGluIHRoZSBbbGVmdCwga10gcmFuZ2UgYXJlIHNtYWxsZXIgdGhhbiBhbGwgaXRlbXMgaW4gKGssIHJpZ2h0XTtcbi8vIFRoZSBrLXRoIGVsZW1lbnQgd2lsbCBoYXZlIHRoZSAoayAtIGxlZnQgKyAxKXRoIHNtYWxsZXN0IHZhbHVlIGluIFtsZWZ0LCByaWdodF1cblxuZnVuY3Rpb24gcGFydGlhbFNvcnQoYXJyLCBrLCBsZWZ0LCByaWdodCwgY29tcGFyZSkge1xuICAgIGxlZnQgPSBsZWZ0IHx8IDA7XG4gICAgcmlnaHQgPSByaWdodCB8fCAoYXJyLmxlbmd0aCAtIDEpO1xuICAgIGNvbXBhcmUgPSBjb21wYXJlIHx8IGRlZmF1bHRDb21wYXJlO1xuXG4gICAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICB2YXIgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICAgICAgICB2YXIgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICB2YXIgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICB2YXIgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBtKSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHBhcnRpYWxTb3J0KGFyciwgaywgbmV3TGVmdCwgbmV3UmlnaHQsIGNvbXBhcmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBhcnJba107XG4gICAgICAgIHZhciBpID0gbGVmdDtcbiAgICAgICAgdmFyIGogPSByaWdodDtcblxuICAgICAgICBzd2FwKGFyciwgbGVmdCwgayk7XG4gICAgICAgIGlmIChjb21wYXJlKGFycltyaWdodF0sIHQpID4gMCkgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltpXSwgdCkgPCAwKSBpKys7XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbal0sIHQpID4gMCkgai0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW2xlZnRdLCB0KSA9PT0gMCkgc3dhcChhcnIsIGxlZnQsIGopO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHN3YXAoYXJyLCBqLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByYnVzaDtcblxudmFyIHF1aWNrc2VsZWN0ID0gcmVxdWlyZSgncXVpY2tzZWxlY3QnKTtcblxuZnVuY3Rpb24gcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHJidXNoKSkgcmV0dXJuIG5ldyByYnVzaChtYXhFbnRyaWVzLCBmb3JtYXQpO1xuXG4gICAgLy8gbWF4IGVudHJpZXMgaW4gYSBub2RlIGlzIDkgYnkgZGVmYXVsdDsgbWluIG5vZGUgZmlsbCBpcyA0MCUgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGlzLl9tYXhFbnRyaWVzID0gTWF0aC5tYXgoNCwgbWF4RW50cmllcyB8fCA5KTtcbiAgICB0aGlzLl9taW5FbnRyaWVzID0gTWF0aC5tYXgoMiwgTWF0aC5jZWlsKHRoaXMuX21heEVudHJpZXMgKiAwLjQpKTtcblxuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgdGhpcy5faW5pdEZvcm1hdChmb3JtYXQpO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXIoKTtcbn1cblxucmJ1c2gucHJvdG90eXBlID0ge1xuXG4gICAgYWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGwodGhpcy5kYXRhLCBbXSk7XG4gICAgfSxcblxuICAgIHNlYXJjaDogZnVuY3Rpb24gKGJib3gpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgdG9CQm94ID0gdGhpcy50b0JCb3g7XG5cbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUpKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW10sXG4gICAgICAgICAgICBpLCBsZW4sIGNoaWxkLCBjaGlsZEJCb3g7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgdGhpcy5fYWxsKGNoaWxkLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBjb2xsaWRlczogZnVuY3Rpb24gKGJib3gpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIHRvQkJveCA9IHRoaXMudG9CQm94O1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW10sXG4gICAgICAgICAgICBpLCBsZW4sIGNoaWxkLCBjaGlsZEJCb3g7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGxvYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghKGRhdGEgJiYgZGF0YS5sZW5ndGgpKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCB0aGlzLl9taW5FbnRyaWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWN1cnNpdmVseSBidWlsZCB0aGUgdHJlZSB3aXRoIHRoZSBnaXZlbiBkYXRhIGZyb20gc3RyYXRjaCB1c2luZyBPTVQgYWxnb3JpdGhtXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fYnVpbGQoZGF0YS5zbGljZSgpLCAwLCBkYXRhLmxlbmd0aCAtIDEsIDApO1xuXG4gICAgICAgIGlmICghdGhpcy5kYXRhLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc2F2ZSBhcyBpcyBpZiB0cmVlIGlzIGVtcHR5XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmhlaWdodCA9PT0gbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IHJvb3QgaWYgdHJlZXMgaGF2ZSB0aGUgc2FtZSBoZWlnaHRcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0Um9vdCh0aGlzLmRhdGEsIG5vZGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gc3dhcCB0cmVlcyBpZiBpbnNlcnRlZCBvbmUgaXMgYmlnZ2VyXG4gICAgICAgICAgICAgICAgdmFyIHRtcE5vZGUgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gdG1wTm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBzbWFsbCB0cmVlIGludG8gdGhlIGxhcmdlIHRyZWUgYXQgYXBwcm9wcmlhdGUgbGV2ZWxcbiAgICAgICAgICAgIHRoaXMuX2luc2VydChub2RlLCB0aGlzLmRhdGEuaGVpZ2h0IC0gbm9kZS5oZWlnaHQgLSAxLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtKSB0aGlzLl9pbnNlcnQoaXRlbSwgdGhpcy5kYXRhLmhlaWdodCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gY3JlYXRlTm9kZShbXSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uIChpdGVtLCBlcXVhbHNGbikge1xuICAgICAgICBpZiAoIWl0ZW0pIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgYmJveCA9IHRoaXMudG9CQm94KGl0ZW0pLFxuICAgICAgICAgICAgcGF0aCA9IFtdLFxuICAgICAgICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgICAgaSwgcGFyZW50LCBpbmRleCwgZ29pbmdVcDtcblxuICAgICAgICAvLyBkZXB0aC1maXJzdCBpdGVyYXRpdmUgdHJlZSB0cmF2ZXJzYWxcbiAgICAgICAgd2hpbGUgKG5vZGUgfHwgcGF0aC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgaWYgKCFub2RlKSB7IC8vIGdvIHVwXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGkgPSBpbmRleGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGdvaW5nVXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSB7IC8vIGNoZWNrIGN1cnJlbnQgbm9kZVxuICAgICAgICAgICAgICAgIGluZGV4ID0gZmluZEl0ZW0oaXRlbSwgbm9kZS5jaGlsZHJlbiwgZXF1YWxzRm4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpdGVtIGZvdW5kLCByZW1vdmUgdGhlIGl0ZW0gYW5kIGNvbmRlbnNlIHRyZWUgdXB3YXJkc1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uZGVuc2UocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFnb2luZ1VwICYmICFub2RlLmxlYWYgJiYgY29udGFpbnMobm9kZSwgYmJveCkpIHsgLy8gZ28gZG93blxuICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlblswXTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQpIHsgLy8gZ28gcmlnaHRcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH0gZWxzZSBub2RlID0gbnVsbDsgLy8gbm90aGluZyBmb3VuZFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRvQkJveDogZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW07IH0sXG5cbiAgICBjb21wYXJlTWluWDogY29tcGFyZU5vZGVNaW5YLFxuICAgIGNvbXBhcmVNaW5ZOiBjb21wYXJlTm9kZU1pblksXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGF0YTsgfSxcblxuICAgIGZyb21KU09OOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FsbDogZnVuY3Rpb24gKG5vZGUsIHJlc3VsdCkge1xuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdO1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoLmFwcGx5KG5vZGVzVG9TZWFyY2gsIG5vZGUuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBfYnVpbGQ6IGZ1bmN0aW9uIChpdGVtcywgbGVmdCwgcmlnaHQsIGhlaWdodCkge1xuXG4gICAgICAgIHZhciBOID0gcmlnaHQgLSBsZWZ0ICsgMSxcbiAgICAgICAgICAgIE0gPSB0aGlzLl9tYXhFbnRyaWVzLFxuICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICBpZiAoTiA8PSBNKSB7XG4gICAgICAgICAgICAvLyByZWFjaGVkIGxlYWYgbGV2ZWw7IHJldHVybiBsZWFmXG4gICAgICAgICAgICBub2RlID0gY3JlYXRlTm9kZShpdGVtcy5zbGljZShsZWZ0LCByaWdodCArIDEpKTtcbiAgICAgICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHRhcmdldCBoZWlnaHQgb2YgdGhlIGJ1bGstbG9hZGVkIHRyZWVcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGguY2VpbChNYXRoLmxvZyhOKSAvIE1hdGgubG9nKE0pKTtcblxuICAgICAgICAgICAgLy8gdGFyZ2V0IG51bWJlciBvZiByb290IGVudHJpZXMgdG8gbWF4aW1pemUgc3RvcmFnZSB1dGlsaXphdGlvblxuICAgICAgICAgICAgTSA9IE1hdGguY2VpbChOIC8gTWF0aC5wb3coTSwgaGVpZ2h0IC0gMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUoW10pO1xuICAgICAgICBub2RlLmxlYWYgPSBmYWxzZTtcbiAgICAgICAgbm9kZS5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgLy8gc3BsaXQgdGhlIGl0ZW1zIGludG8gTSBtb3N0bHkgc3F1YXJlIHRpbGVzXG5cbiAgICAgICAgdmFyIE4yID0gTWF0aC5jZWlsKE4gLyBNKSxcbiAgICAgICAgICAgIE4xID0gTjIgKiBNYXRoLmNlaWwoTWF0aC5zcXJ0KE0pKSxcbiAgICAgICAgICAgIGksIGosIHJpZ2h0MiwgcmlnaHQzO1xuXG4gICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBsZWZ0LCByaWdodCwgTjEsIHRoaXMuY29tcGFyZU1pblgpO1xuXG4gICAgICAgIGZvciAoaSA9IGxlZnQ7IGkgPD0gcmlnaHQ7IGkgKz0gTjEpIHtcblxuICAgICAgICAgICAgcmlnaHQyID0gTWF0aC5taW4oaSArIE4xIC0gMSwgcmlnaHQpO1xuXG4gICAgICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgaSwgcmlnaHQyLCBOMiwgdGhpcy5jb21wYXJlTWluWSk7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IGk7IGogPD0gcmlnaHQyOyBqICs9IE4yKSB7XG5cbiAgICAgICAgICAgICAgICByaWdodDMgPSBNYXRoLm1pbihqICsgTjIgLSAxLCByaWdodDIpO1xuXG4gICAgICAgICAgICAgICAgLy8gcGFjayBlYWNoIGVudHJ5IHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHRoaXMuX2J1aWxkKGl0ZW1zLCBqLCByaWdodDMsIGhlaWdodCAtIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgX2Nob29zZVN1YnRyZWU6IGZ1bmN0aW9uIChiYm94LCBub2RlLCBsZXZlbCwgcGF0aCkge1xuXG4gICAgICAgIHZhciBpLCBsZW4sIGNoaWxkLCB0YXJnZXROb2RlLCBhcmVhLCBlbmxhcmdlbWVudCwgbWluQXJlYSwgbWluRW5sYXJnZW1lbnQ7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBwYXRoLmxlbmd0aCAtIDEgPT09IGxldmVsKSBicmVhaztcblxuICAgICAgICAgICAgbWluQXJlYSA9IG1pbkVubGFyZ2VtZW50ID0gSW5maW5pdHk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgYXJlYSA9IGJib3hBcmVhKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBlbmxhcmdlbWVudCA9IGVubGFyZ2VkQXJlYShiYm94LCBjaGlsZCkgLSBhcmVhO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hvb3NlIGVudHJ5IHdpdGggdGhlIGxlYXN0IGFyZWEgZW5sYXJnZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoZW5sYXJnZW1lbnQgPCBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5FbmxhcmdlbWVudCA9IGVubGFyZ2VtZW50O1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmxhcmdlbWVudCA9PT0gbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBvbmUgd2l0aCB0aGUgc21hbGxlc3QgYXJlYVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gdGFyZ2V0Tm9kZSB8fCBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIF9pbnNlcnQ6IGZ1bmN0aW9uIChpdGVtLCBsZXZlbCwgaXNOb2RlKSB7XG5cbiAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxuICAgICAgICAgICAgYmJveCA9IGlzTm9kZSA/IGl0ZW0gOiB0b0JCb3goaXRlbSksXG4gICAgICAgICAgICBpbnNlcnRQYXRoID0gW107XG5cbiAgICAgICAgLy8gZmluZCB0aGUgYmVzdCBub2RlIGZvciBhY2NvbW1vZGF0aW5nIHRoZSBpdGVtLCBzYXZpbmcgYWxsIG5vZGVzIGFsb25nIHRoZSBwYXRoIHRvb1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2Nob29zZVN1YnRyZWUoYmJveCwgdGhpcy5kYXRhLCBsZXZlbCwgaW5zZXJ0UGF0aCk7XG5cbiAgICAgICAgLy8gcHV0IHRoZSBpdGVtIGludG8gdGhlIG5vZGVcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGl0ZW0pO1xuICAgICAgICBleHRlbmQobm9kZSwgYmJveCk7XG5cbiAgICAgICAgLy8gc3BsaXQgb24gbm9kZSBvdmVyZmxvdzsgcHJvcGFnYXRlIHVwd2FyZHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHdoaWxlIChsZXZlbCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0UGF0aFtsZXZlbF0uY2hpbGRyZW4ubGVuZ3RoID4gdGhpcy5fbWF4RW50cmllcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NwbGl0KGluc2VydFBhdGgsIGxldmVsKTtcbiAgICAgICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgaW5zZXJ0aW9uIHBhdGhcbiAgICAgICAgdGhpcy5fYWRqdXN0UGFyZW50QkJveGVzKGJib3gsIGluc2VydFBhdGgsIGxldmVsKTtcbiAgICB9LFxuXG4gICAgLy8gc3BsaXQgb3ZlcmZsb3dlZCBub2RlIGludG8gdHdvXG4gICAgX3NwbGl0OiBmdW5jdGlvbiAoaW5zZXJ0UGF0aCwgbGV2ZWwpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IGluc2VydFBhdGhbbGV2ZWxdLFxuICAgICAgICAgICAgTSA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgICAgbSA9IHRoaXMuX21pbkVudHJpZXM7XG5cbiAgICAgICAgdGhpcy5fY2hvb3NlU3BsaXRBeGlzKG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIHZhciBzcGxpdEluZGV4ID0gdGhpcy5fY2hvb3NlU3BsaXRJbmRleChub2RlLCBtLCBNKTtcblxuICAgICAgICB2YXIgbmV3Tm9kZSA9IGNyZWF0ZU5vZGUobm9kZS5jaGlsZHJlbi5zcGxpY2Uoc3BsaXRJbmRleCwgbm9kZS5jaGlsZHJlbi5sZW5ndGggLSBzcGxpdEluZGV4KSk7XG4gICAgICAgIG5ld05vZGUuaGVpZ2h0ID0gbm9kZS5oZWlnaHQ7XG4gICAgICAgIG5ld05vZGUubGVhZiA9IG5vZGUubGVhZjtcblxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgIGNhbGNCQm94KG5ld05vZGUsIHRoaXMudG9CQm94KTtcblxuICAgICAgICBpZiAobGV2ZWwpIGluc2VydFBhdGhbbGV2ZWwgLSAxXS5jaGlsZHJlbi5wdXNoKG5ld05vZGUpO1xuICAgICAgICBlbHNlIHRoaXMuX3NwbGl0Um9vdChub2RlLCBuZXdOb2RlKTtcbiAgICB9LFxuXG4gICAgX3NwbGl0Um9vdDogZnVuY3Rpb24gKG5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgLy8gc3BsaXQgcm9vdCBub2RlXG4gICAgICAgIHRoaXMuZGF0YSA9IGNyZWF0ZU5vZGUoW25vZGUsIG5ld05vZGVdKTtcbiAgICAgICAgdGhpcy5kYXRhLmhlaWdodCA9IG5vZGUuaGVpZ2h0ICsgMTtcbiAgICAgICAgdGhpcy5kYXRhLmxlYWYgPSBmYWxzZTtcbiAgICAgICAgY2FsY0JCb3godGhpcy5kYXRhLCB0aGlzLnRvQkJveCk7XG4gICAgfSxcblxuICAgIF9jaG9vc2VTcGxpdEluZGV4OiBmdW5jdGlvbiAobm9kZSwgbSwgTSkge1xuXG4gICAgICAgIHZhciBpLCBiYm94MSwgYmJveDIsIG92ZXJsYXAsIGFyZWEsIG1pbk92ZXJsYXAsIG1pbkFyZWEsIGluZGV4O1xuXG4gICAgICAgIG1pbk92ZXJsYXAgPSBtaW5BcmVhID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8PSBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBiYm94MSA9IGRpc3RCQm94KG5vZGUsIDAsIGksIHRoaXMudG9CQm94KTtcbiAgICAgICAgICAgIGJib3gyID0gZGlzdEJCb3gobm9kZSwgaSwgTSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgICAgICBvdmVybGFwID0gaW50ZXJzZWN0aW9uQXJlYShiYm94MSwgYmJveDIpO1xuICAgICAgICAgICAgYXJlYSA9IGJib3hBcmVhKGJib3gxKSArIGJib3hBcmVhKGJib3gyKTtcblxuICAgICAgICAgICAgLy8gY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gb3ZlcmxhcFxuICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgbWluT3ZlcmxhcCA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuXG4gICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3ZlcmxhcCA9PT0gbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBhcmVhXG4gICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvLyBzb3J0cyBub2RlIGNoaWxkcmVuIGJ5IHRoZSBiZXN0IGF4aXMgZm9yIHNwbGl0XG4gICAgX2Nob29zZVNwbGl0QXhpczogZnVuY3Rpb24gKG5vZGUsIG0sIE0pIHtcblxuICAgICAgICB2YXIgY29tcGFyZU1pblggPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5YIDogY29tcGFyZU5vZGVNaW5YLFxuICAgICAgICAgICAgY29tcGFyZU1pblkgPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5ZIDogY29tcGFyZU5vZGVNaW5ZLFxuICAgICAgICAgICAgeE1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblgpLFxuICAgICAgICAgICAgeU1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblkpO1xuXG4gICAgICAgIC8vIGlmIHRvdGFsIGRpc3RyaWJ1dGlvbnMgbWFyZ2luIHZhbHVlIGlzIG1pbmltYWwgZm9yIHgsIHNvcnQgYnkgbWluWCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGl0J3MgYWxyZWFkeSBzb3J0ZWQgYnkgbWluWVxuICAgICAgICBpZiAoeE1hcmdpbiA8IHlNYXJnaW4pIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlTWluWCk7XG4gICAgfSxcblxuICAgIC8vIHRvdGFsIG1hcmdpbiBvZiBhbGwgcG9zc2libGUgc3BsaXQgZGlzdHJpYnV0aW9ucyB3aGVyZSBlYWNoIG5vZGUgaXMgYXQgbGVhc3QgbSBmdWxsXG4gICAgX2FsbERpc3RNYXJnaW46IGZ1bmN0aW9uIChub2RlLCBtLCBNLCBjb21wYXJlKSB7XG5cbiAgICAgICAgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmUpO1xuXG4gICAgICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveCxcbiAgICAgICAgICAgIGxlZnRCQm94ID0gZGlzdEJCb3gobm9kZSwgMCwgbSwgdG9CQm94KSxcbiAgICAgICAgICAgIHJpZ2h0QkJveCA9IGRpc3RCQm94KG5vZGUsIE0gLSBtLCBNLCB0b0JCb3gpLFxuICAgICAgICAgICAgbWFyZ2luID0gYmJveE1hcmdpbihsZWZ0QkJveCkgKyBiYm94TWFyZ2luKHJpZ2h0QkJveCksXG4gICAgICAgICAgICBpLCBjaGlsZDtcblxuICAgICAgICBmb3IgKGkgPSBtOyBpIDwgTSAtIG07IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKGxlZnRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4obGVmdEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gTSAtIG0gLSAxOyBpID49IG07IGktLSkge1xuICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKHJpZ2h0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKHJpZ2h0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFyZ2luO1xuICAgIH0sXG5cbiAgICBfYWRqdXN0UGFyZW50QkJveGVzOiBmdW5jdGlvbiAoYmJveCwgcGF0aCwgbGV2ZWwpIHtcbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgZ2l2ZW4gdHJlZSBwYXRoXG4gICAgICAgIGZvciAodmFyIGkgPSBsZXZlbDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGV4dGVuZChwYXRoW2ldLCBiYm94KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY29uZGVuc2U6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHBhdGgsIHJlbW92aW5nIGVtcHR5IG5vZGVzIGFuZCB1cGRhdGluZyBiYm94ZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMSwgc2libGluZ3M7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtpXS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3MgPSBwYXRoW2kgLSAxXS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3Muc3BsaWNlKHNpYmxpbmdzLmluZGV4T2YocGF0aFtpXSksIDEpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuY2xlYXIoKTtcblxuICAgICAgICAgICAgfSBlbHNlIGNhbGNCQm94KHBhdGhbaV0sIHRoaXMudG9CQm94KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfaW5pdEZvcm1hdDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAvLyBkYXRhIGZvcm1hdCAobWluWCwgbWluWSwgbWF4WCwgbWF4WSBhY2Nlc3NvcnMpXG5cbiAgICAgICAgLy8gdXNlcyBldmFsLXR5cGUgZnVuY3Rpb24gY29tcGlsYXRpb24gaW5zdGVhZCBvZiBqdXN0IGFjY2VwdGluZyBhIHRvQkJveCBmdW5jdGlvblxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBhbGdvcml0aG1zIGFyZSB2ZXJ5IHNlbnNpdGl2ZSB0byBzb3J0aW5nIGZ1bmN0aW9ucyBwZXJmb3JtYW5jZSxcbiAgICAgICAgLy8gc28gdGhleSBzaG91bGQgYmUgZGVhZCBzaW1wbGUgYW5kIHdpdGhvdXQgaW5uZXIgY2FsbHNcblxuICAgICAgICB2YXIgY29tcGFyZUFyciA9IFsncmV0dXJuIGEnLCAnIC0gYicsICc7J107XG5cbiAgICAgICAgdGhpcy5jb21wYXJlTWluWCA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFswXSkpO1xuICAgICAgICB0aGlzLmNvbXBhcmVNaW5ZID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzFdKSk7XG5cbiAgICAgICAgdGhpcy50b0JCb3ggPSBuZXcgRnVuY3Rpb24oJ2EnLFxuICAgICAgICAgICAgJ3JldHVybiB7bWluWDogYScgKyBmb3JtYXRbMF0gK1xuICAgICAgICAgICAgJywgbWluWTogYScgKyBmb3JtYXRbMV0gK1xuICAgICAgICAgICAgJywgbWF4WDogYScgKyBmb3JtYXRbMl0gK1xuICAgICAgICAgICAgJywgbWF4WTogYScgKyBmb3JtYXRbM10gKyAnfTsnKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBmaW5kSXRlbShpdGVtLCBpdGVtcywgZXF1YWxzRm4pIHtcbiAgICBpZiAoIWVxdWFsc0ZuKSByZXR1cm4gaXRlbXMuaW5kZXhPZihpdGVtKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVxdWFsc0ZuKGl0ZW0sIGl0ZW1zW2ldKSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLy8gY2FsY3VsYXRlIG5vZGUncyBiYm94IGZyb20gYmJveGVzIG9mIGl0cyBjaGlsZHJlblxuZnVuY3Rpb24gY2FsY0JCb3gobm9kZSwgdG9CQm94KSB7XG4gICAgZGlzdEJCb3gobm9kZSwgMCwgbm9kZS5jaGlsZHJlbi5sZW5ndGgsIHRvQkJveCwgbm9kZSk7XG59XG5cbi8vIG1pbiBib3VuZGluZyByZWN0YW5nbGUgb2Ygbm9kZSBjaGlsZHJlbiBmcm9tIGsgdG8gcC0xXG5mdW5jdGlvbiBkaXN0QkJveChub2RlLCBrLCBwLCB0b0JCb3gsIGRlc3ROb2RlKSB7XG4gICAgaWYgKCFkZXN0Tm9kZSkgZGVzdE5vZGUgPSBjcmVhdGVOb2RlKG51bGwpO1xuICAgIGRlc3ROb2RlLm1pblggPSBJbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5taW5ZID0gSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWF4WCA9IC1JbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5tYXhZID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IGssIGNoaWxkOyBpIDwgcDsgaSsrKSB7XG4gICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgZXh0ZW5kKGRlc3ROb2RlLCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXN0Tm9kZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICBhLm1pblggPSBNYXRoLm1pbihhLm1pblgsIGIubWluWCk7XG4gICAgYS5taW5ZID0gTWF0aC5taW4oYS5taW5ZLCBiLm1pblkpO1xuICAgIGEubWF4WCA9IE1hdGgubWF4KGEubWF4WCwgYi5tYXhYKTtcbiAgICBhLm1heFkgPSBNYXRoLm1heChhLm1heFksIGIubWF4WSk7XG4gICAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWChhLCBiKSB7IHJldHVybiBhLm1pblggLSBiLm1pblg7IH1cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWShhLCBiKSB7IHJldHVybiBhLm1pblkgLSBiLm1pblk7IH1cblxuZnVuY3Rpb24gYmJveEFyZWEoYSkgICB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSAqIChhLm1heFkgLSBhLm1pblkpOyB9XG5mdW5jdGlvbiBiYm94TWFyZ2luKGEpIHsgcmV0dXJuIChhLm1heFggLSBhLm1pblgpICsgKGEubWF4WSAtIGEubWluWSk7IH1cblxuZnVuY3Rpb24gZW5sYXJnZWRBcmVhKGEsIGIpIHtcbiAgICByZXR1cm4gKE1hdGgubWF4KGIubWF4WCwgYS5tYXhYKSAtIE1hdGgubWluKGIubWluWCwgYS5taW5YKSkgKlxuICAgICAgICAgICAoTWF0aC5tYXgoYi5tYXhZLCBhLm1heFkpIC0gTWF0aC5taW4oYi5taW5ZLCBhLm1pblkpKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uQXJlYShhLCBiKSB7XG4gICAgdmFyIG1pblggPSBNYXRoLm1heChhLm1pblgsIGIubWluWCksXG4gICAgICAgIG1pblkgPSBNYXRoLm1heChhLm1pblksIGIubWluWSksXG4gICAgICAgIG1heFggPSBNYXRoLm1pbihhLm1heFgsIGIubWF4WCksXG4gICAgICAgIG1heFkgPSBNYXRoLm1pbihhLm1heFksIGIubWF4WSk7XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbWF4WCAtIG1pblgpICpcbiAgICAgICAgICAgTWF0aC5tYXgoMCwgbWF4WSAtIG1pblkpO1xufVxuXG5mdW5jdGlvbiBjb250YWlucyhhLCBiKSB7XG4gICAgcmV0dXJuIGEubWluWCA8PSBiLm1pblggJiZcbiAgICAgICAgICAgYS5taW5ZIDw9IGIubWluWSAmJlxuICAgICAgICAgICBiLm1heFggPD0gYS5tYXhYICYmXG4gICAgICAgICAgIGIubWF4WSA8PSBhLm1heFk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMoYSwgYikge1xuICAgIHJldHVybiBiLm1pblggPD0gYS5tYXhYICYmXG4gICAgICAgICAgIGIubWluWSA8PSBhLm1heFkgJiZcbiAgICAgICAgICAgYi5tYXhYID49IGEubWluWCAmJlxuICAgICAgICAgICBiLm1heFkgPj0gYS5taW5ZO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgIGxlYWY6IHRydWUsXG4gICAgICAgIG1pblg6IEluZmluaXR5LFxuICAgICAgICBtaW5ZOiBJbmZpbml0eSxcbiAgICAgICAgbWF4WDogLUluZmluaXR5LFxuICAgICAgICBtYXhZOiAtSW5maW5pdHlcbiAgICB9O1xufVxuXG4vLyBzb3J0IGFuIGFycmF5IHNvIHRoYXQgaXRlbXMgY29tZSBpbiBncm91cHMgb2YgbiB1bnNvcnRlZCBpdGVtcywgd2l0aCBncm91cHMgc29ydGVkIGJldHdlZW4gZWFjaCBvdGhlcjtcbi8vIGNvbWJpbmVzIHNlbGVjdGlvbiBhbGdvcml0aG0gd2l0aCBiaW5hcnkgZGl2aWRlICYgY29ucXVlciBhcHByb2FjaFxuXG5mdW5jdGlvbiBtdWx0aVNlbGVjdChhcnIsIGxlZnQsIHJpZ2h0LCBuLCBjb21wYXJlKSB7XG4gICAgdmFyIHN0YWNrID0gW2xlZnQsIHJpZ2h0XSxcbiAgICAgICAgbWlkO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSBuKSBjb250aW51ZTtcblxuICAgICAgICBtaWQgPSBsZWZ0ICsgTWF0aC5jZWlsKChyaWdodCAtIGxlZnQpIC8gbiAvIDIpICogbjtcbiAgICAgICAgcXVpY2tzZWxlY3QoYXJyLCBtaWQsIGxlZnQsIHJpZ2h0LCBjb21wYXJlKTtcblxuICAgICAgICBzdGFjay5wdXNoKGxlZnQsIG1pZCwgbWlkLCByaWdodCk7XG4gICAgfVxufVxuIiwiLyoqXG5zcHJpbnRmKCkgZm9yIEphdmFTY3JpcHQgMC43LWJldGExXG5odHRwOi8vd3d3LmRpdmVpbnRvamF2YXNjcmlwdC5jb20vcHJvamVjdHMvamF2YXNjcmlwdC1zcHJpbnRmXG5cbkNvcHlyaWdodCAoYykgQWxleGFuZHJ1IE1hcmFzdGVhbnUgPGFsZXhhaG9saWMgW2F0KSBnbWFpbCAoZG90XSBjb20+XG5BbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbm1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiBzcHJpbnRmKCkgZm9yIEphdmFTY3JpcHQgbm9yIHRoZVxuICAgICAgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiAgICAgIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBBbGV4YW5kcnUgTWFyYXN0ZWFudSBCRSBMSUFCTEUgRk9SIEFOWVxuRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblxuXG5DaGFuZ2Vsb2c6XG4yMDEwLjExLjA3IC0gMC43LWJldGExLW5vZGVcbiAgLSBjb252ZXJ0ZWQgaXQgdG8gYSBub2RlLmpzIGNvbXBhdGlibGUgbW9kdWxlXG5cbjIwMTAuMDkuMDYgLSAwLjctYmV0YTFcbiAgLSBmZWF0dXJlczogdnNwcmludGYsIHN1cHBvcnQgZm9yIG5hbWVkIHBsYWNlaG9sZGVyc1xuICAtIGVuaGFuY2VtZW50czogZm9ybWF0IGNhY2hlLCByZWR1Y2VkIGdsb2JhbCBuYW1lc3BhY2UgcG9sbHV0aW9uXG5cbjIwMTAuMDUuMjIgLSAwLjY6XG4gLSByZXZlcnRlZCB0byAwLjQgYW5kIGZpeGVkIHRoZSBidWcgcmVnYXJkaW5nIHRoZSBzaWduIG9mIHRoZSBudW1iZXIgMFxuIE5vdGU6XG4gVGhhbmtzIHRvIFJhcGhhZWwgUGlndWxsYSA8cmFwaCAoYXRdIG4zcmQgW2RvdCkgb3JnPiAoaHR0cDovL3d3dy5uM3JkLm9yZy8pXG4gd2hvIHdhcm5lZCBtZSBhYm91dCBhIGJ1ZyBpbiAwLjUsIEkgZGlzY292ZXJlZCB0aGF0IHRoZSBsYXN0IHVwZGF0ZSB3YXNcbiBhIHJlZ3Jlc3MuIEkgYXBwb2xvZ2l6ZSBmb3IgdGhhdC5cblxuMjAxMC4wNS4wOSAtIDAuNTpcbiAtIGJ1ZyBmaXg6IDAgaXMgbm93IHByZWNlZWRlZCB3aXRoIGEgKyBzaWduXG4gLSBidWcgZml4OiB0aGUgc2lnbiB3YXMgbm90IGF0IHRoZSByaWdodCBwb3NpdGlvbiBvbiBwYWRkZWQgcmVzdWx0cyAoS2FtYWwgQWJkYWxpKVxuIC0gc3dpdGNoZWQgZnJvbSBHUEwgdG8gQlNEIGxpY2Vuc2VcblxuMjAwNy4xMC4yMSAtIDAuNDpcbiAtIHVuaXQgdGVzdCBhbmQgcGF0Y2ggKERhdmlkIEJhaXJkKVxuXG4yMDA3LjA5LjE3IC0gMC4zOlxuIC0gYnVnIGZpeDogbm8gbG9uZ2VyIHRocm93cyBleGNlcHRpb24gb24gZW1wdHkgcGFyYW1lbnRlcnMgKEhhbnMgUHVmYWwpXG5cbjIwMDcuMDkuMTEgLSAwLjI6XG4gLSBmZWF0dXJlOiBhZGRlZCBhcmd1bWVudCBzd2FwcGluZ1xuXG4yMDA3LjA0LjAzIC0gMC4xOlxuIC0gaW5pdGlhbCByZWxlYXNlXG4qKi9cblxudmFyIHNwcmludGYgPSAoZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGdldF90eXBlKHZhcmlhYmxlKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YXJpYWJsZSkuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCk7XG5cdH1cblx0ZnVuY3Rpb24gc3RyX3JlcGVhdChpbnB1dCwgbXVsdGlwbGllcikge1xuXHRcdGZvciAodmFyIG91dHB1dCA9IFtdOyBtdWx0aXBsaWVyID4gMDsgb3V0cHV0Wy0tbXVsdGlwbGllcl0gPSBpbnB1dCkgey8qIGRvIG5vdGhpbmcgKi99XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdHZhciBzdHJfZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCFzdHJfZm9ybWF0LmNhY2hlLmhhc093blByb3BlcnR5KGFyZ3VtZW50c1swXSkpIHtcblx0XHRcdHN0cl9mb3JtYXQuY2FjaGVbYXJndW1lbnRzWzBdXSA9IHN0cl9mb3JtYXQucGFyc2UoYXJndW1lbnRzWzBdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0cl9mb3JtYXQuZm9ybWF0LmNhbGwobnVsbCwgc3RyX2Zvcm1hdC5jYWNoZVthcmd1bWVudHNbMF1dLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cdC8vIGNvbnZlcnQgb2JqZWN0IHRvIHNpbXBsZSBvbmUgbGluZSBzdHJpbmcgd2l0aG91dCBpbmRlbnRhdGlvbiBvclxuXHQvLyBuZXdsaW5lcy4gTm90ZSB0aGF0IHRoaXMgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgcHJpbnQgYXJyYXlcblx0Ly8gdmFsdWVzIHRvIHRoZWlyIGFjdHVhbCBwbGFjZSBmb3Igc3BhcnNlIGFycmF5cy4gXG5cdC8vXG5cdC8vIEZvciBleGFtcGxlIHNwYXJzZSBhcnJheSBsaWtlIHRoaXNcblx0Ly8gICAgbCA9IFtdXG5cdC8vICAgIGxbNF0gPSAxXG5cdC8vIFdvdWxkIGJlIHByaW50ZWQgYXMgXCJbMV1cIiBpbnN0ZWFkIG9mIFwiWywgLCAsICwgMV1cIlxuXHQvLyBcblx0Ly8gSWYgYXJndW1lbnQgJ3NlZW4nIGlzIG5vdCBudWxsIGFuZCBhcnJheSB0aGUgZnVuY3Rpb24gd2lsbCBjaGVjayBmb3IgXG5cdC8vIGNpcmN1bGFyIG9iamVjdCByZWZlcmVuY2VzIGZyb20gYXJndW1lbnQuXG5cdHN0cl9mb3JtYXQub2JqZWN0X3N0cmluZ2lmeSA9IGZ1bmN0aW9uKG9iaiwgZGVwdGgsIG1heGRlcHRoLCBzZWVuKSB7XG5cdFx0dmFyIHN0ciA9ICcnO1xuXHRcdGlmIChvYmogIT0gbnVsbCkge1xuXHRcdFx0c3dpdGNoKCB0eXBlb2Yob2JqKSApIHtcblx0XHRcdGNhc2UgJ2Z1bmN0aW9uJzogXG5cdFx0XHRcdHJldHVybiAnW0Z1bmN0aW9uJyArIChvYmoubmFtZSA/ICc6ICcrb2JqLm5hbWUgOiAnJykgKyAnXSc7XG5cdFx0XHQgICAgYnJlYWs7XG5cdFx0XHRjYXNlICdvYmplY3QnOlxuXHRcdFx0XHRpZiAoIG9iaiBpbnN0YW5jZW9mIEVycm9yKSB7IHJldHVybiAnWycgKyBvYmoudG9TdHJpbmcoKSArICddJyB9O1xuXHRcdFx0XHRpZiAoZGVwdGggPj0gbWF4ZGVwdGgpIHJldHVybiAnW09iamVjdF0nXG5cdFx0XHRcdGlmIChzZWVuKSB7XG5cdFx0XHRcdFx0Ly8gYWRkIG9iamVjdCB0byBzZWVuIGxpc3Rcblx0XHRcdFx0XHRzZWVuID0gc2Vlbi5zbGljZSgwKVxuXHRcdFx0XHRcdHNlZW4ucHVzaChvYmopO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvYmoubGVuZ3RoICE9IG51bGwpIHsgLy9hcnJheVxuXHRcdFx0XHRcdHN0ciArPSAnWyc7XG5cdFx0XHRcdFx0dmFyIGFyciA9IFtdXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvYmopIHtcblx0XHRcdFx0XHRcdGlmIChzZWVuICYmIHNlZW4uaW5kZXhPZihvYmpbaV0pID49IDApIGFyci5wdXNoKCdbQ2lyY3VsYXJdJyk7XG5cdFx0XHRcdFx0XHRlbHNlIGFyci5wdXNoKHN0cl9mb3JtYXQub2JqZWN0X3N0cmluZ2lmeShvYmpbaV0sIGRlcHRoKzEsIG1heGRlcHRoLCBzZWVuKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0ciArPSBhcnIuam9pbignLCAnKSArICddJztcblx0XHRcdFx0fSBlbHNlIGlmICgnZ2V0TW9udGgnIGluIG9iaikgeyAvLyBkYXRlXG5cdFx0XHRcdFx0cmV0dXJuICdEYXRlKCcgKyBvYmogKyAnKSc7XG5cdFx0XHRcdH0gZWxzZSB7IC8vIG9iamVjdFxuXHRcdFx0XHRcdHN0ciArPSAneyc7XG5cdFx0XHRcdFx0dmFyIGFyciA9IFtdXG5cdFx0XHRcdFx0Zm9yICh2YXIgayBpbiBvYmopIHsgXG5cdFx0XHRcdFx0XHRpZihvYmouaGFzT3duUHJvcGVydHkoaykpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHNlZW4gJiYgc2Vlbi5pbmRleE9mKG9ialtrXSkgPj0gMCkgYXJyLnB1c2goayArICc6IFtDaXJjdWxhcl0nKTtcblx0XHRcdFx0XHRcdFx0ZWxzZSBhcnIucHVzaChrICsnOiAnICtzdHJfZm9ybWF0Lm9iamVjdF9zdHJpbmdpZnkob2JqW2tdLCBkZXB0aCsxLCBtYXhkZXB0aCwgc2VlbikpOyBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3RyICs9IGFyci5qb2luKCcsICcpICsgJ30nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzdHI7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc3RyaW5nJzpcdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gJ1wiJyArIG9iaiArICdcIic7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAnJyArIG9iajtcblx0fVxuXG5cdHN0cl9mb3JtYXQuZm9ybWF0ID0gZnVuY3Rpb24ocGFyc2VfdHJlZSwgYXJndikge1xuXHRcdHZhciBjdXJzb3IgPSAxLCB0cmVlX2xlbmd0aCA9IHBhcnNlX3RyZWUubGVuZ3RoLCBub2RlX3R5cGUgPSAnJywgYXJnLCBvdXRwdXQgPSBbXSwgaSwgaywgbWF0Y2gsIHBhZCwgcGFkX2NoYXJhY3RlciwgcGFkX2xlbmd0aDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgdHJlZV9sZW5ndGg7IGkrKykge1xuXHRcdFx0bm9kZV90eXBlID0gZ2V0X3R5cGUocGFyc2VfdHJlZVtpXSk7XG5cdFx0XHRpZiAobm9kZV90eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRvdXRwdXQucHVzaChwYXJzZV90cmVlW2ldKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKG5vZGVfdHlwZSA9PT0gJ2FycmF5Jykge1xuXHRcdFx0XHRtYXRjaCA9IHBhcnNlX3RyZWVbaV07IC8vIGNvbnZlbmllbmNlIHB1cnBvc2VzIG9ubHlcblx0XHRcdFx0aWYgKG1hdGNoWzJdKSB7IC8vIGtleXdvcmQgYXJndW1lbnRcblx0XHRcdFx0XHRhcmcgPSBhcmd2W2N1cnNvcl07XG5cdFx0XHRcdFx0Zm9yIChrID0gMDsgayA8IG1hdGNoWzJdLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWFyZy5oYXNPd25Qcm9wZXJ0eShtYXRjaFsyXVtrXSkpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKHNwcmludGYoJ1tzcHJpbnRmXSBwcm9wZXJ0eSBcIiVzXCIgZG9lcyBub3QgZXhpc3QnLCBtYXRjaFsyXVtrXSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YXJnID0gYXJnW21hdGNoWzJdW2tdXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAobWF0Y2hbMV0pIHsgLy8gcG9zaXRpb25hbCBhcmd1bWVudCAoZXhwbGljaXQpXG5cdFx0XHRcdFx0YXJnID0gYXJndlttYXRjaFsxXV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7IC8vIHBvc2l0aW9uYWwgYXJndW1lbnQgKGltcGxpY2l0KVxuXHRcdFx0XHRcdGFyZyA9IGFyZ3ZbY3Vyc29yKytdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKC9bXnNPXS8udGVzdChtYXRjaFs4XSkgJiYgKGdldF90eXBlKGFyZykgIT0gJ251bWJlcicpKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKHNwcmludGYoJ1tzcHJpbnRmXSBleHBlY3RpbmcgbnVtYmVyIGJ1dCBmb3VuZCAlcyBcIicgKyBhcmcgKyAnXCInLCBnZXRfdHlwZShhcmcpKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3dpdGNoIChtYXRjaFs4XSkge1xuXHRcdFx0XHRcdGNhc2UgJ2InOiBhcmcgPSBhcmcudG9TdHJpbmcoMik7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2MnOiBhcmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFyZyk7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2QnOiBhcmcgPSBwYXJzZUludChhcmcsIDEwKTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnZSc6IGFyZyA9IG1hdGNoWzddID8gYXJnLnRvRXhwb25lbnRpYWwobWF0Y2hbN10pIDogYXJnLnRvRXhwb25lbnRpYWwoKTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnZic6IGFyZyA9IG1hdGNoWzddID8gcGFyc2VGbG9hdChhcmcpLnRvRml4ZWQobWF0Y2hbN10pIDogcGFyc2VGbG9hdChhcmcpOyBicmVhaztcblx0XHRcdFx0ICAgIGNhc2UgJ08nOiBhcmcgPSBzdHJfZm9ybWF0Lm9iamVjdF9zdHJpbmdpZnkoYXJnLCAwLCBwYXJzZUludChtYXRjaFs3XSkgfHwgNSk7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ28nOiBhcmcgPSBhcmcudG9TdHJpbmcoOCk7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3MnOiBhcmcgPSAoKGFyZyA9IFN0cmluZyhhcmcpKSAmJiBtYXRjaFs3XSA/IGFyZy5zdWJzdHJpbmcoMCwgbWF0Y2hbN10pIDogYXJnKTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAndSc6IGFyZyA9IE1hdGguYWJzKGFyZyk7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3gnOiBhcmcgPSBhcmcudG9TdHJpbmcoMTYpOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICdYJzogYXJnID0gYXJnLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyBicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRhcmcgPSAoL1tkZWZdLy50ZXN0KG1hdGNoWzhdKSAmJiBtYXRjaFszXSAmJiBhcmcgPj0gMCA/ICcrJysgYXJnIDogYXJnKTtcblx0XHRcdFx0cGFkX2NoYXJhY3RlciA9IG1hdGNoWzRdID8gbWF0Y2hbNF0gPT0gJzAnID8gJzAnIDogbWF0Y2hbNF0uY2hhckF0KDEpIDogJyAnO1xuXHRcdFx0XHRwYWRfbGVuZ3RoID0gbWF0Y2hbNl0gLSBTdHJpbmcoYXJnKS5sZW5ndGg7XG5cdFx0XHRcdHBhZCA9IG1hdGNoWzZdID8gc3RyX3JlcGVhdChwYWRfY2hhcmFjdGVyLCBwYWRfbGVuZ3RoKSA6ICcnO1xuXHRcdFx0XHRvdXRwdXQucHVzaChtYXRjaFs1XSA/IGFyZyArIHBhZCA6IHBhZCArIGFyZyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH07XG5cblx0c3RyX2Zvcm1hdC5jYWNoZSA9IHt9O1xuXG5cdHN0cl9mb3JtYXQucGFyc2UgPSBmdW5jdGlvbihmbXQpIHtcblx0XHR2YXIgX2ZtdCA9IGZtdCwgbWF0Y2ggPSBbXSwgcGFyc2VfdHJlZSA9IFtdLCBhcmdfbmFtZXMgPSAwO1xuXHRcdHdoaWxlIChfZm10KSB7XG5cdFx0XHRpZiAoKG1hdGNoID0gL15bXlxceDI1XSsvLmV4ZWMoX2ZtdCkpICE9PSBudWxsKSB7XG5cdFx0XHRcdHBhcnNlX3RyZWUucHVzaChtYXRjaFswXSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICgobWF0Y2ggPSAvXlxceDI1ezJ9Ly5leGVjKF9mbXQpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRwYXJzZV90cmVlLnB1c2goJyUnKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKChtYXRjaCA9IC9eXFx4MjUoPzooWzEtOV1cXGQqKVxcJHxcXCgoW15cXCldKylcXCkpPyhcXCspPygwfCdbXiRdKT8oLSk/KFxcZCspPyg/OlxcLihcXGQrKSk/KFtiLWZvc091eFhdKS8uZXhlYyhfZm10KSkgIT09IG51bGwpIHtcblx0XHRcdFx0aWYgKG1hdGNoWzJdKSB7XG5cdFx0XHRcdFx0YXJnX25hbWVzIHw9IDE7XG5cdFx0XHRcdFx0dmFyIGZpZWxkX2xpc3QgPSBbXSwgcmVwbGFjZW1lbnRfZmllbGQgPSBtYXRjaFsyXSwgZmllbGRfbWF0Y2ggPSBbXTtcblx0XHRcdFx0XHRpZiAoKGZpZWxkX21hdGNoID0gL14oW2Etel9dW2Etel9cXGRdKikvaS5leGVjKHJlcGxhY2VtZW50X2ZpZWxkKSkgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGZpZWxkX2xpc3QucHVzaChmaWVsZF9tYXRjaFsxXSk7XG5cdFx0XHRcdFx0XHR3aGlsZSAoKHJlcGxhY2VtZW50X2ZpZWxkID0gcmVwbGFjZW1lbnRfZmllbGQuc3Vic3RyaW5nKGZpZWxkX21hdGNoWzBdLmxlbmd0aCkpICE9PSAnJykge1xuXHRcdFx0XHRcdFx0XHRpZiAoKGZpZWxkX21hdGNoID0gL15cXC4oW2Etel9dW2Etel9cXGRdKikvaS5leGVjKHJlcGxhY2VtZW50X2ZpZWxkKSkgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZF9saXN0LnB1c2goZmllbGRfbWF0Y2hbMV0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYgKChmaWVsZF9tYXRjaCA9IC9eXFxbKFxcZCspXFxdLy5leGVjKHJlcGxhY2VtZW50X2ZpZWxkKSkgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZF9saXN0LnB1c2goZmllbGRfbWF0Y2hbMV0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignW3NwcmludGZdICcgKyByZXBsYWNlbWVudF9maWVsZCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tzcHJpbnRmXSAnICsgcmVwbGFjZW1lbnRfZmllbGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtYXRjaFsyXSA9IGZpZWxkX2xpc3Q7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0YXJnX25hbWVzIHw9IDI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGFyZ19uYW1lcyA9PT0gMykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignW3NwcmludGZdIG1peGluZyBwb3NpdGlvbmFsIGFuZCBuYW1lZCBwbGFjZWhvbGRlcnMgaXMgbm90ICh5ZXQpIHN1cHBvcnRlZCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcnNlX3RyZWUucHVzaChtYXRjaCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdbc3ByaW50Zl0gJyArIF9mbXQpO1xuXHRcdFx0fVxuXHRcdFx0X2ZtdCA9IF9mbXQuc3Vic3RyaW5nKG1hdGNoWzBdLmxlbmd0aCk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJzZV90cmVlO1xuXHR9O1xuXG5cdHJldHVybiBzdHJfZm9ybWF0O1xufSkoKTtcblxudmFyIHZzcHJpbnRmID0gZnVuY3Rpb24oZm10LCBhcmd2KSB7XG5cdHZhciBhcmd2Q2xvbmUgPSBhcmd2LnNsaWNlKCk7XG5cdGFyZ3ZDbG9uZS51bnNoaWZ0KGZtdCk7XG5cdHJldHVybiBzcHJpbnRmLmFwcGx5KG51bGwsIGFyZ3ZDbG9uZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNwcmludGY7XG5zcHJpbnRmLnNwcmludGYgPSBzcHJpbnRmO1xuc3ByaW50Zi52c3ByaW50ZiA9IHZzcHJpbnRmO1xuIiwiIWZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gIGlmICh0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIikgZGVmaW5lKGRlZmluaXRpb24pO1xuICBlbHNlIHRoaXMudHogPSBkZWZpbml0aW9uKCk7XG59IChmdW5jdGlvbiAoKSB7XG4vKlxuICBmdW5jdGlvbiBkaWUgKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICByZXR1cm4gcHJvY2Vzcy5leGl0KDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2F5ICgpIHsgcmV0dXJuIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKSB9XG4qL1xuICBmdW5jdGlvbiBhY3R1YWxpemUgKGVudHJ5LCBydWxlLCB5ZWFyKSB7XG4gICAgdmFyIGFjdHVhbGl6ZWQsIGRhdGUgPSBydWxlLmRheVsxXTtcblxuICAgIGRvIHtcbiAgICAgIGFjdHVhbGl6ZWQgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBydWxlLm1vbnRoLCBNYXRoLmFicyhkYXRlKyspKSk7XG4gICAgfSB3aGlsZSAocnVsZS5kYXlbMF0gPCA3ICYmIGFjdHVhbGl6ZWQuZ2V0VVRDRGF5KCkgIT0gcnVsZS5kYXlbMF0pXG5cbiAgICBhY3R1YWxpemVkID0ge1xuICAgICAgY2xvY2s6IHJ1bGUuY2xvY2ssXG4gICAgICBzb3J0OiBhY3R1YWxpemVkLmdldFRpbWUoKSxcbiAgICAgIHJ1bGU6IHJ1bGUsXG4gICAgICBzYXZlOiBydWxlLnNhdmUgKiA2ZTQsXG4gICAgICBvZmZzZXQ6IGVudHJ5Lm9mZnNldFxuICAgIH07XG5cbiAgICBhY3R1YWxpemVkW2FjdHVhbGl6ZWQuY2xvY2tdID0gYWN0dWFsaXplZC5zb3J0ICsgcnVsZS50aW1lICogNmU0O1xuXG4gICAgaWYgKGFjdHVhbGl6ZWQucG9zaXgpIHtcbiAgICAgIGFjdHVhbGl6ZWQud2FsbGNsb2NrID0gYWN0dWFsaXplZFthY3R1YWxpemVkLmNsb2NrXSArIChlbnRyeS5vZmZzZXQgKyBydWxlLnNhdmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0dWFsaXplZC5wb3NpeCA9IGFjdHVhbGl6ZWRbYWN0dWFsaXplZC5jbG9ja10gLSAoZW50cnkub2Zmc2V0ICsgcnVsZS5zYXZlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdHVhbGl6ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kIChyZXF1ZXN0LCBjbG9jaywgdGltZSkge1xuICAgIHZhciBpLCBJLCBlbnRyeSwgZm91bmQsIHpvbmUgPSByZXF1ZXN0W3JlcXVlc3Quem9uZV0sIGFjdHVhbGl6ZWQgPSBbXSwgYWJicmV2LCBydWxlc1xuICAgICAgLCBqLCB5ZWFyID0gbmV3IERhdGUodGltZSkuZ2V0VVRDRnVsbFllYXIoKSwgb2ZmID0gMTtcbiAgICBmb3IgKGkgPSAxLCBJID0gem9uZS5sZW5ndGg7IGkgPCBJOyBpKyspIGlmICh6b25lW2ldW2Nsb2NrXSA8PSB0aW1lKSBicmVhaztcbiAgICBlbnRyeSA9IHpvbmVbaV07XG4gICAgaWYgKGVudHJ5LnJ1bGVzKSB7XG4gICAgICBydWxlcyA9IHJlcXVlc3RbZW50cnkucnVsZXNdO1xuICAgICAgZm9yIChqID0geWVhciArIDE7IGogPj0geWVhciAtIG9mZjsgLS1qKVxuICAgICAgICBmb3IgKGkgPSAwLCBJID0gcnVsZXMubGVuZ3RoOyBpIDwgSTsgaSsrKVxuICAgICAgICAgIGlmIChydWxlc1tpXS5mcm9tIDw9IGogJiYgaiA8PSBydWxlc1tpXS50bykgYWN0dWFsaXplZC5wdXNoKGFjdHVhbGl6ZShlbnRyeSwgcnVsZXNbaV0sIGopKTtcbiAgICAgICAgICBlbHNlIGlmIChydWxlc1tpXS50byA8IGogJiYgb2ZmID09IDEpIG9mZiA9IGogLSBydWxlc1tpXS50bztcbiAgICAgIGFjdHVhbGl6ZWQuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5zb3J0IC0gYi5zb3J0IH0pO1xuICAgICAgZm9yIChpID0gMCwgSSA9IGFjdHVhbGl6ZWQubGVuZ3RoOyBpIDwgSTsgaSsrKSB7XG4gICAgICAgIGlmICh0aW1lID49IGFjdHVhbGl6ZWRbaV1bY2xvY2tdICYmIGFjdHVhbGl6ZWRbaV1bYWN0dWFsaXplZFtpXS5jbG9ja10gPiBlbnRyeVthY3R1YWxpemVkW2ldLmNsb2NrXSkgZm91bmQgPSBhY3R1YWxpemVkW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm91bmQpIHtcbiAgICAgIGlmIChhYmJyZXYgPSAvXiguKilcXC8oLiopJC8uZXhlYyhlbnRyeS5mb3JtYXQpKSB7XG4gICAgICAgIGZvdW5kLmFiYnJldiA9IGFiYnJldltmb3VuZC5zYXZlID8gMiA6IDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmQuYWJicmV2ID0gZW50cnkuZm9ybWF0LnJlcGxhY2UoLyVzLywgZm91bmQucnVsZS5sZXR0ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQgfHwgZW50cnk7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0VG9XYWxsY2xvY2sgKHJlcXVlc3QsIHBvc2l4KSB7XG4gICAgaWYgKHJlcXVlc3Quem9uZSA9PSBcIlVUQ1wiKSByZXR1cm4gcG9zaXg7XG4gICAgcmVxdWVzdC5lbnRyeSA9IGZpbmQocmVxdWVzdCwgXCJwb3NpeFwiLCBwb3NpeCk7XG4gICAgcmV0dXJuIHBvc2l4ICsgcmVxdWVzdC5lbnRyeS5vZmZzZXQgKyByZXF1ZXN0LmVudHJ5LnNhdmU7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0VG9QT1NJWCAocmVxdWVzdCwgd2FsbGNsb2NrKSB7XG4gICAgaWYgKHJlcXVlc3Quem9uZSA9PSBcIlVUQ1wiKSByZXR1cm4gd2FsbGNsb2NrO1xuXG4gICAgdmFyIGVudHJ5LCBkaWZmO1xuICAgIHJlcXVlc3QuZW50cnkgPSBlbnRyeSA9IGZpbmQocmVxdWVzdCwgXCJ3YWxsY2xvY2tcIiwgd2FsbGNsb2NrKTtcbiAgICBkaWZmID0gd2FsbGNsb2NrIC0gZW50cnkud2FsbGNsb2NrO1xuXG4gICAgcmV0dXJuIDAgPCBkaWZmICYmIGRpZmYgPCBlbnRyeS5zYXZlID8gbnVsbCA6IHdhbGxjbG9jayAtIGVudHJ5Lm9mZnNldCAtIGVudHJ5LnNhdmU7XG4gIH1cblxuICBmdW5jdGlvbiBhZGp1c3QgKHJlcXVlc3QsIHBvc2l4LCBtYXRjaCkge1xuICAgIHZhciBpbmNyZW1lbnQgPSArKG1hdGNoWzFdICsgMSkgLy8gY29udmVyc2lvbiBuZWNlc3NhcnkgZm9yIHdlZWsgZGF5IGFkZGl0aW9uXG4gICAgICAsIG9mZnNldCA9IG1hdGNoWzJdICogaW5jcmVtZW50XG4gICAgICAsIGluZGV4ID0gVU5JVFMuaW5kZXhPZihtYXRjaFszXS50b0xvd2VyQ2FzZSgpKVxuICAgICAgLCBkYXRlXG4gICAgICA7XG4gICAgaWYgKGluZGV4ID4gOSkge1xuICAgICAgcG9zaXggKz0gb2Zmc2V0ICogVElNRVtpbmRleCAtIDEwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0ZSA9IG5ldyBEYXRlKGNvbnZlcnRUb1dhbGxjbG9jayhyZXF1ZXN0LCBwb3NpeCkpO1xuICAgICAgaWYgKGluZGV4IDwgNykge1xuICAgICAgICB3aGlsZSAob2Zmc2V0KSB7XG4gICAgICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgaW5jcmVtZW50KTtcbiAgICAgICAgICBpZiAoZGF0ZS5nZXRVVENEYXkoKSA9PSBpbmRleCkgb2Zmc2V0IC09IGluY3JlbWVudDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpbmRleCA9PSA3KSB7XG4gICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT0gOCkge1xuICAgICAgICBkYXRlLnNldFVUQ01vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSArIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBvZmZzZXQpO1xuICAgICAgfVxuICAgICAgaWYgKChwb3NpeCA9IGNvbnZlcnRUb1BPU0lYKHJlcXVlc3QsIGRhdGUuZ2V0VGltZSgpKSkgPT0gbnVsbCkge1xuICAgICAgICBwb3NpeCA9IGNvbnZlcnRUb1BPU0lYKHJlcXVlc3QsIGRhdGUuZ2V0VGltZSgpICsgODY0ZTUgKiBpbmNyZW1lbnQpIC0gODY0ZTUgKiBpbmNyZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwb3NpeDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnQgKHZhcmdzKSB7XG4gICAgaWYgKCF2YXJncy5sZW5ndGgpIHJldHVybiBcIjEuMC42XCI7XG5cbiAgICB2YXIgcmVxdWVzdCA9IE9iamVjdC5jcmVhdGUodGhpcylcbiAgICAgICwgYWRqdXN0bWVudHMgPSBbXVxuICAgICAgLCBpLCBJLCAkLCBhcmd1bWVudCwgZGF0ZVxuICAgICAgO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHZhcmdzLmxlbmd0aDsgaSsrKSB7IC8vIGxlYXZlIHRoZSBmb3IgbG9vcCBhbG9uZSwgaXQgd29ya3MuXG4gICAgICBhcmd1bWVudCA9IHZhcmdzW2ldO1xuICAgICAgLy8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iaWdlYXN5L3N0YXR1cy8yMTUxMTIxODY1NzI0Mzk1NTJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50KSkge1xuICAgICAgICBpZiAoIWkgJiYgIWlzTmFOKGFyZ3VtZW50WzFdKSkge1xuICAgICAgICAgIGRhdGUgPSBhcmd1bWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmd1bWVudC5zcGxpY2UuYXBwbHkodmFyZ3MsIFsgaS0tLCAxIF0uY29uY2F0KGFyZ3VtZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNOYU4oYXJndW1lbnQpKSB7XG4gICAgICAgICQgPSB0eXBlb2YgYXJndW1lbnQ7XG4gICAgICAgIGlmICgkID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAofmFyZ3VtZW50LmluZGV4T2YoXCIlXCIpKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmZvcm1hdCA9IGFyZ3VtZW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWkgJiYgYXJndW1lbnQgPT0gXCIqXCIpIHtcbiAgICAgICAgICAgIGRhdGUgPSBhcmd1bWVudDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFpICYmICgkID0gL14oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KSg/OltUXFxzXShcXGR7Mn0pOihcXGR7Mn0pKD86OihcXGR7Mn0pKD86XFwuKFxcZCspKT8pPyhafCgoWystXSkoXFxkezJ9KDpcXGR7Mn0pezAsMn0pKSk/KT8kLy5leGVjKGFyZ3VtZW50KSkpIHtcbiAgICAgICAgICAgIGRhdGUgPSBbXTtcbiAgICAgICAgICAgIGRhdGUucHVzaC5hcHBseShkYXRlLCAkLnNsaWNlKDEsIDgpKTtcbiAgICAgICAgICAgIGlmICgkWzldKSB7XG4gICAgICAgICAgICAgIGRhdGUucHVzaCgkWzEwXSArIDEpO1xuICAgICAgICAgICAgICBkYXRlLnB1c2guYXBwbHkoZGF0ZSwgJFsxMV0uc3BsaXQoLzovKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRbOF0pIHtcbiAgICAgICAgICAgICAgZGF0ZS5wdXNoKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoL15cXHd7MiwzfV9cXHd7Mn0kLy50ZXN0KGFyZ3VtZW50KSkge1xuICAgICAgICAgICAgcmVxdWVzdC5sb2NhbGUgPSBhcmd1bWVudDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQgPSBVTklUX1JFLmV4ZWMoYXJndW1lbnQpKSB7XG4gICAgICAgICAgICBhZGp1c3RtZW50cy5wdXNoKCQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0LnpvbmUgPSBhcmd1bWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoJCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBpZiAoJCA9IGFyZ3VtZW50LmNhbGwocmVxdWVzdCkpIHJldHVybiAkO1xuICAgICAgICB9IGVsc2UgaWYgKC9eXFx3ezIsM31fXFx3ezJ9JC8udGVzdChhcmd1bWVudC5uYW1lKSkge1xuICAgICAgICAgIHJlcXVlc3RbYXJndW1lbnQubmFtZV0gPSBhcmd1bWVudDtcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudC56b25lcykge1xuICAgICAgICAgIGZvciAoJCBpbiBhcmd1bWVudC56b25lcykgcmVxdWVzdFskXSA9IGFyZ3VtZW50LnpvbmVzWyRdO1xuICAgICAgICAgIGZvciAoJCBpbiBhcmd1bWVudC5ydWxlcykgcmVxdWVzdFskXSA9IGFyZ3VtZW50LnJ1bGVzWyRdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpKSB7XG4gICAgICAgIGRhdGUgPSBhcmd1bWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJlcXVlc3RbcmVxdWVzdC5sb2NhbGVdKSBkZWxldGUgcmVxdWVzdC5sb2NhbGU7XG4gICAgaWYgKCFyZXF1ZXN0W3JlcXVlc3Quem9uZV0pIGRlbGV0ZSByZXF1ZXN0LnpvbmU7XG5cbiAgICBpZiAoZGF0ZSAhPSBudWxsKSB7XG4gICAgICBpZiAoZGF0ZSA9PSBcIipcIikge1xuICAgICAgICBkYXRlID0gcmVxdWVzdC5jbG9jaygpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGUpKSB7XG4gICAgICAgIEkgPSAhZGF0ZVs3XTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDExOyBpKyspIGRhdGVbaV0gPSArKGRhdGVbaV0gfHwgMCk7IC8vIGNvbnZlcnNpb24gbmVjZXNzYXJ5IGZvciBkZWNyZW1lbnRcbiAgICAgICAgLS1kYXRlWzFdOyAvLyBHcnIuLlxuICAgICAgICBkYXRlID0gRGF0ZS5VVEMuYXBwbHkoRGF0ZS5VVEMsIGRhdGUuc2xpY2UoMCwgOCkpICtcbiAgICAgICAgICAtZGF0ZVs3XSAqIChkYXRlWzhdICogMzZlNSArIGRhdGVbOV0gKiA2ZTQgKyBkYXRlWzEwXSAqIDFlMyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlID0gTWF0aC5mbG9vcihkYXRlKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNOYU4oZGF0ZSkpIHtcbiAgICAgICAgaWYgKEkpIGRhdGUgPSBjb252ZXJ0VG9QT1NJWChyZXF1ZXN0LCBkYXRlKTtcblxuICAgICAgICBpZiAoZGF0ZSA9PSBudWxsKSByZXR1cm4gZGF0ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBJID0gYWRqdXN0bWVudHMubGVuZ3RoOyBpIDwgSTsgaSsrKSB7XG4gICAgICAgICAgZGF0ZSA9IGFkanVzdChyZXF1ZXN0LCBkYXRlLCBhZGp1c3RtZW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlcXVlc3QuZm9ybWF0KSByZXR1cm4gZGF0ZTtcblxuICAgICAgICAkID0gbmV3IERhdGUoY29udmVydFRvV2FsbGNsb2NrKHJlcXVlc3QsIGRhdGUpKTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3QuZm9ybWF0LnJlcGxhY2UoLyUoWy0wX15dPykoOnswLDN9KShcXGQqKSguKS9nLFxuICAgICAgICBmdW5jdGlvbiAodmFsdWUsIGZsYWcsIGNvbG9ucywgcGFkZGluZywgc3BlY2lmaWVyKSB7XG4gICAgICAgICAgdmFyIGYsIGZpbGwgPSBcIjBcIiwgcGFkO1xuICAgICAgICAgIGlmIChmID0gcmVxdWVzdFtzcGVjaWZpZXJdKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFN0cmluZyhmLmNhbGwocmVxdWVzdCwgJCwgZGF0ZSwgZmxhZywgY29sb25zLmxlbmd0aCkpO1xuICAgICAgICAgICAgaWYgKChmbGFnIHx8IGYuc3R5bGUpID09IFwiX1wiKSBmaWxsID0gXCIgXCI7XG4gICAgICAgICAgICBwYWQgPSBmbGFnID09IFwiLVwiID8gMCA6IGYucGFkIHx8IDA7XG4gICAgICAgICAgICB3aGlsZSAodmFsdWUubGVuZ3RoIDwgcGFkKSB2YWx1ZSA9IGZpbGwgKyB2YWx1ZTtcbiAgICAgICAgICAgIHBhZCA9IGZsYWcgPT0gXCItXCIgPyAwIDogcGFkZGluZyB8fCBmLnBhZDtcbiAgICAgICAgICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCBwYWQpIHZhbHVlID0gZmlsbCArIHZhbHVlO1xuICAgICAgICAgICAgaWYgKHNwZWNpZmllciA9PSBcIk5cIiAmJiBwYWQgPCB2YWx1ZS5sZW5ndGgpIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgcGFkKTtcbiAgICAgICAgICAgIGlmIChmbGFnID09IFwiXlwiKSB2YWx1ZSA9IHZhbHVlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVlc3QuY29udmVydChhcmd1bWVudHMpIH07XG4gIH1cblxuICB2YXIgY29udGV4dCA9XG4gICAgeyBjbG9jazogZnVuY3Rpb24gKCkgeyByZXR1cm4gKyhuZXcgRGF0ZSgpKSB9XG4gICAgLCB6b25lOiBcIlVUQ1wiXG4gICAgLCBlbnRyeTogeyBhYmJyZXY6IFwiVVRDXCIsIG9mZnNldDogMCwgc2F2ZTogMCB9XG4gICAgLCBVVEM6IDFcbiAgICAsIHo6IGZ1bmN0aW9uKGRhdGUsIHBvc2l4LCBmbGFnLCBkZWxpbWl0ZXJzKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmVudHJ5Lm9mZnNldCArIHRoaXMuZW50cnkuc2F2ZVxuICAgICAgICAgICwgc2Vjb25kcyA9IE1hdGguYWJzKG9mZnNldCAvIDEwMDApLCBwYXJ0cyA9IFtdLCBwYXJ0ID0gMzYwMCwgaSwgejtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgIHBhcnRzLnB1c2goKFwiMFwiICsgTWF0aC5mbG9vcihzZWNvbmRzIC8gcGFydCkpLnNsaWNlKC0yKSk7XG4gICAgICAgICAgc2Vjb25kcyAlPSBwYXJ0O1xuICAgICAgICAgIHBhcnQgLz0gNjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWcgPT0gXCJeXCIgJiYgIW9mZnNldCkgcmV0dXJuIFwiWlwiO1xuICAgICAgICBpZiAoZmxhZyA9PSBcIl5cIikgZGVsaW1pdGVycyA9IDM7XG4gICAgICAgIGlmIChkZWxpbWl0ZXJzID09IDMpIHtcbiAgICAgICAgICB6ID0gcGFydHMuam9pbihcIjpcIik7XG4gICAgICAgICAgeiA9IHoucmVwbGFjZSgvOjAwJC8sIFwiXCIpO1xuICAgICAgICAgIGlmIChmbGFnICE9IFwiXlwiKSB6ID0gei5yZXBsYWNlKC86MDAkLywgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVsaW1pdGVycykge1xuICAgICAgICAgIHogPSBwYXJ0cy5zbGljZSgwLCBkZWxpbWl0ZXJzICsgMSkuam9pbihcIjpcIik7XG4gICAgICAgICAgaWYgKGZsYWcgPT0gXCJeXCIpIHogPSB6LnJlcGxhY2UoLzowMCQvLCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB6ID0gcGFydHMuc2xpY2UoMCwgMikuam9pbihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICB6ID0gKG9mZnNldCA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHo7XG4gICAgICAgIHogPSB6LnJlcGxhY2UoLyhbLStdKSgwKS8sIHsgXCJfXCI6IFwiICQxXCIsIFwiLVwiOiBcIiQxXCIgfVtmbGFnXSB8fCBcIiQxJDJcIik7XG4gICAgICAgIHJldHVybiB6O1xuICAgICAgfVxuICAgICwgXCIlXCI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIFwiJVwiIH1cbiAgICAsIG46IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBcIlxcblwiIH1cbiAgICAsIHQ6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBcIlxcdFwiIH1cbiAgICAsIFU6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiB3ZWVrT2ZZZWFyKGRhdGUsIDApIH1cbiAgICAsIFc6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiB3ZWVrT2ZZZWFyKGRhdGUsIDEpIH1cbiAgICAsIFY6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBpc29XZWVrKGRhdGUpWzBdIH1cbiAgICAsIEc6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBpc29XZWVrKGRhdGUpWzFdIH1cbiAgICAsIGc6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBpc29XZWVrKGRhdGUpWzFdICUgMTAwIH1cbiAgICAsIGo6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBNYXRoLmZsb29yKChkYXRlLmdldFRpbWUoKSAtIERhdGUuVVRDKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgMCkpIC8gODY0ZTUpICsgMSB9XG4gICAgLCBzOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gTWF0aC5mbG9vcihkYXRlLmdldFRpbWUoKSAvIDEwMDApIH1cbiAgICAsIEM6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBNYXRoLmZsb29yKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSAvIDEwMCkgfVxuICAgICwgTjogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VGltZSgpICUgMTAwMCAqIDEwMDAwMDAgfVxuICAgICwgbTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VVRDTW9udGgoKSArIDEgfVxuICAgICwgWTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSB9XG4gICAgLCB5OiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRVVENGdWxsWWVhcigpICUgMTAwIH1cbiAgICAsIEg6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFVUQ0hvdXJzKCkgfVxuICAgICwgTTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VVRDTWludXRlcygpIH1cbiAgICAsIFM6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFVUQ1NlY29uZHMoKSB9XG4gICAgLCBlOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRVVENEYXRlKCkgfVxuICAgICwgZDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VVRDRGF0ZSgpIH1cbiAgICAsIHU6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFVUQ0RheSgpIHx8IDcgfVxuICAgICwgdzogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VVRDRGF5KCkgfVxuICAgICwgbDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VVRDSG91cnMoKSAlIDEyIHx8IDEyIH1cbiAgICAsIEk6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFVUQ0hvdXJzKCkgJSAxMiB8fCAxMiB9XG4gICAgLCBrOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRVVENIb3VycygpIH1cbiAgICAsIFo6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiB0aGlzLmVudHJ5LmFiYnJldiB9XG4gICAgLCBhOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gdGhpc1t0aGlzLmxvY2FsZV0uZGF5LmFiYnJldltkYXRlLmdldFVUQ0RheSgpXSB9XG4gICAgLCBBOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gdGhpc1t0aGlzLmxvY2FsZV0uZGF5LmZ1bGxbZGF0ZS5nZXRVVENEYXkoKV0gfVxuICAgICwgaDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHRoaXNbdGhpcy5sb2NhbGVdLm1vbnRoLmFiYnJldltkYXRlLmdldFVUQ01vbnRoKCldIH1cbiAgICAsIGI6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiB0aGlzW3RoaXMubG9jYWxlXS5tb250aC5hYmJyZXZbZGF0ZS5nZXRVVENNb250aCgpXSB9XG4gICAgLCBCOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gdGhpc1t0aGlzLmxvY2FsZV0ubW9udGguZnVsbFtkYXRlLmdldFVUQ01vbnRoKCldIH1cbiAgICAsIFA6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiB0aGlzW3RoaXMubG9jYWxlXS5tZXJpZGllbVtNYXRoLmZsb29yKGRhdGUuZ2V0VVRDSG91cnMoKSAvIDEyKV0udG9Mb3dlckNhc2UoKSB9XG4gICAgLCBwOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gdGhpc1t0aGlzLmxvY2FsZV0ubWVyaWRpZW1bTWF0aC5mbG9vcihkYXRlLmdldFVUQ0hvdXJzKCkgLyAxMildIH1cbiAgICAsIFI6IGZ1bmN0aW9uIChkYXRlLCBwb3NpeCkgeyByZXR1cm4gdGhpcy5jb252ZXJ0KFsgcG9zaXgsIFwiJUg6JU1cIiBdKSB9XG4gICAgLCBUOiBmdW5jdGlvbiAoZGF0ZSwgcG9zaXgpIHsgcmV0dXJuIHRoaXMuY29udmVydChbIHBvc2l4LCBcIiVIOiVNOiVTXCIgXSkgfVxuICAgICwgRDogZnVuY3Rpb24gKGRhdGUsIHBvc2l4KSB7IHJldHVybiB0aGlzLmNvbnZlcnQoWyBwb3NpeCwgXCIlbS8lZC8leVwiIF0pIH1cbiAgICAsIEY6IGZ1bmN0aW9uIChkYXRlLCBwb3NpeCkgeyByZXR1cm4gdGhpcy5jb252ZXJ0KFsgcG9zaXgsIFwiJVktJW0tJWRcIiBdKSB9XG4gICAgLCB4OiBmdW5jdGlvbiAoZGF0ZSwgcG9zaXgpIHsgcmV0dXJuIHRoaXMuY29udmVydChbIHBvc2l4LCB0aGlzW3RoaXMubG9jYWxlXS5kYXRlIF0pIH1cbiAgICAsIHI6IGZ1bmN0aW9uIChkYXRlLCBwb3NpeCkgeyByZXR1cm4gdGhpcy5jb252ZXJ0KFsgcG9zaXgsIHRoaXNbdGhpcy5sb2NhbGVdLnRpbWUxMiB8fCAnJUk6JU06JVMnIF0pIH1cbiAgICAsIFg6IGZ1bmN0aW9uIChkYXRlLCBwb3NpeCkgeyByZXR1cm4gdGhpcy5jb252ZXJ0KFsgcG9zaXgsIHRoaXNbdGhpcy5sb2NhbGVdLnRpbWUyNCBdKSB9XG4gICAgLCBjOiBmdW5jdGlvbiAoZGF0ZSwgcG9zaXgpIHsgcmV0dXJuIHRoaXMuY29udmVydChbIHBvc2l4LCB0aGlzW3RoaXMubG9jYWxlXS5kYXRlVGltZSBdKSB9XG4gICAgLCBjb252ZXJ0OiBjb252ZXJ0XG4gICAgLCBsb2NhbGU6IFwiZW5fVVNcIlxuICAgICwgZW5fVVM6IHtcbiAgICAgICAgZGF0ZTogXCIlbS8lZC8lWVwiLFxuICAgICAgICB0aW1lMjQ6IFwiJUk6JU06JVMgJXBcIixcbiAgICAgICAgdGltZTEyOiBcIiVJOiVNOiVTICVwXCIsXG4gICAgICAgIGRhdGVUaW1lOiBcIiVhICVkICViICVZICVJOiVNOiVTICVwICVaXCIsXG4gICAgICAgIG1lcmlkaWVtOiBbIFwiQU1cIiwgXCJQTVwiIF0sXG4gICAgICAgIG1vbnRoOiB7XG4gICAgICAgICAgYWJicmV2OiBcIkphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjXCIuc3BsaXQoXCJ8XCIpLFxuICAgICAgICAgIGZ1bGw6IFwiSmFudWFyeXxGZWJydWFyeXxNYXJjaHxBcHJpbHxNYXl8SnVuZXxKdWx5fEF1Z3VzdHxTZXB0ZW1iZXJ8T2N0b2JlcnxOb3ZlbWJlcnxEZWNlbWJlclwiLnNwbGl0KFwifFwiKVxuICAgICAgICB9LFxuICAgICAgICBkYXk6IHtcbiAgICAgICAgICBhYmJyZXY6IFwiU3VufE1vbnxUdWV8V2VkfFRodXxGcml8U2F0XCIuc3BsaXQoXCJ8XCIpLFxuICAgICAgICAgIGZ1bGw6IFwiU3VuZGF5fE1vbmRheXxUdWVzZGF5fFdlZG5lc2RheXxUaHVyc2RheXxGcmlkYXl8U2F0dXJkYXlcIi5zcGxpdChcInxcIilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIHZhciBVTklUUyA9IFwiU3VuZGF5fE1vbmRheXxUdWVzZGF5fFdlZG5lc2RheXxUaHVyc2RheXxGcmlkYXl8U2F0dXJkYXl8eWVhcnxtb250aHxkYXl8aG91cnxtaW51dGV8c2Vjb25kfG1pbGxpc2Vjb25kXCJcbiAgICAsIFVOSVRfUkUgPSBuZXcgUmVnRXhwKFwiXlxcXFxzKihbKy1dKShcXFxcZCspXFxcXHMrKFwiICsgVU5JVFMgKyBcIilzP1xcXFxzKiRcIiwgXCJpXCIpXG4gICAgLCBUSU1FID0gWyAzNmU1LCA2ZTQsIDFlMywgMSBdXG4gICAgO1xuICBVTklUUyA9IFVOSVRTLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCJ8XCIpO1xuXG4gIFwiZGVsbUhNU1VXVmdDSWt5XCIucmVwbGFjZSgvLi9nLCBmdW5jdGlvbiAoZSkgeyBjb250ZXh0W2VdLnBhZCA9IDIgfSk7XG5cbiAgY29udGV4dC5OLnBhZCA9IDk7XG4gIGNvbnRleHQuai5wYWQgPSAzO1xuXG4gIGNvbnRleHQuay5zdHlsZSA9IFwiX1wiO1xuICBjb250ZXh0Lmwuc3R5bGUgPSBcIl9cIjtcbiAgY29udGV4dC5lLnN0eWxlID0gXCJfXCI7XG5cbiAgZnVuY3Rpb24gd2Vla09mWWVhciAoZGF0ZSwgc3RhcnRPZldlZWspIHtcbiAgICB2YXIgZGlmZiwgbnlkLCB3ZWVrU3RhcnQ7XG4gICAgbnlkID0gbmV3IERhdGUoRGF0ZS5VVEMoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCAwKSk7XG4gICAgZGlmZiA9IE1hdGguZmxvb3IoKGRhdGUuZ2V0VGltZSgpIC0gbnlkLmdldFRpbWUoKSkgLyA4NjRlNSk7XG4gICAgaWYgKG55ZC5nZXRVVENEYXkoKSA9PSBzdGFydE9mV2Vlaykge1xuICAgICAgd2Vla1N0YXJ0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Vla1N0YXJ0ID0gNyAtIG55ZC5nZXRVVENEYXkoKSArIHN0YXJ0T2ZXZWVrO1xuICAgICAgaWYgKHdlZWtTdGFydCA9PSA4KSB7XG4gICAgICAgIHdlZWtTdGFydCA9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmID49IHdlZWtTdGFydCA/IE1hdGguZmxvb3IoKGRpZmYgLSB3ZWVrU3RhcnQpIC8gNykgKyAxIDogMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzb1dlZWsgKGRhdGUpIHtcbiAgICB2YXIgbnlkLCBueXksIHdlZWs7XG4gICAgbnl5ID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgIG55ZCA9IG5ldyBEYXRlKERhdGUuVVRDKG55eSwgMCkpLmdldFVUQ0RheSgpO1xuICAgIHdlZWsgPSB3ZWVrT2ZZZWFyKGRhdGUsIDEpICsgKG55ZCA+IDEgJiYgbnlkIDw9IDQgPyAxIDogMCk7XG4gICAgaWYgKCF3ZWVrKSB7XG4gICAgICBueXkgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgLSAxO1xuICAgICAgbnlkID0gbmV3IERhdGUoRGF0ZS5VVEMobnl5LCAwKSkuZ2V0VVRDRGF5KCk7XG4gICAgICB3ZWVrID0gbnlkID09IDQgfHwgKG55ZCA9PSAzICYmIG5ldyBEYXRlKG55eSwgMSwgMjkpLmdldERhdGUoKSA9PSAyOSkgPyA1MyA6IDUyO1xuICAgICAgcmV0dXJuIFt3ZWVrLCBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgLSAxXTtcbiAgICB9IGVsc2UgaWYgKHdlZWsgPT0gNTMgJiYgIShueWQgPT0gNCB8fCAobnlkID09IDMgJiYgbmV3IERhdGUobnl5LCAxLCAyOSkuZ2V0RGF0ZSgpID09IDI5KSkpIHtcbiAgICAgIHJldHVybiBbMSwgZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbd2VlaywgZGF0ZS5nZXRVVENGdWxsWWVhcigpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udGV4dC5jb252ZXJ0KGFyZ3VtZW50cykgfTtcbn0pO1xuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIGdsb2JhbCwgZGVmaW5lLCBTeXN0ZW0sIFJlZmxlY3QsIFByb21pc2UgKi9cclxudmFyIF9fZXh0ZW5kcztcclxudmFyIF9fYXNzaWduO1xyXG52YXIgX19yZXN0O1xyXG52YXIgX19kZWNvcmF0ZTtcclxudmFyIF9fcGFyYW07XHJcbnZhciBfX21ldGFkYXRhO1xyXG52YXIgX19hd2FpdGVyO1xyXG52YXIgX19nZW5lcmF0b3I7XHJcbnZhciBfX2V4cG9ydFN0YXI7XHJcbnZhciBfX3ZhbHVlcztcclxudmFyIF9fcmVhZDtcclxudmFyIF9fc3ByZWFkO1xyXG52YXIgX19hd2FpdDtcclxudmFyIF9fYXN5bmNHZW5lcmF0b3I7XHJcbnZhciBfX2FzeW5jRGVsZWdhdG9yO1xyXG52YXIgX19hc3luY1ZhbHVlcztcclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOiB7fTtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShcInRzbGliXCIsIFtcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChleHBvcnRzKSB7IGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cykpKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIobW9kdWxlLmV4cG9ydHMpKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMsIHByZXZpb3VzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgdikgeyByZXR1cm4gZXhwb3J0c1tpZF0gPSBwcmV2aW91cyA/IHByZXZpb3VzKGlkLCB2KSA6IHY7IH07XHJcbiAgICB9XHJcbn0pXHJcbihmdW5jdGlvbiAoZXhwb3J0ZXIpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19yZXN0ID0gZnVuY3Rpb24gKHMsIGUpIHtcclxuICAgICAgICB2YXIgdCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZGVjb3JhdGUgPSBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3BhcmFtID0gZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdGVyID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZ2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgICAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZXhwb3J0U3RhciA9IGZ1bmN0aW9uIChtLCBleHBvcnRzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgICAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgX19yZWFkID0gZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICAgICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgICAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNHZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgaSwgcDtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAob1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jVmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl07XHJcbiAgICAgICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydGVyKFwiX19leHRlbmRzXCIsIF9fZXh0ZW5kcyk7XHJcbiAgICBleHBvcnRlcihcIl9fYXNzaWduXCIsIF9fYXNzaWduKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZXN0XCIsIF9fcmVzdCk7XHJcbiAgICBleHBvcnRlcihcIl9fZGVjb3JhdGVcIiwgX19kZWNvcmF0ZSk7XHJcbiAgICBleHBvcnRlcihcIl9fcGFyYW1cIiwgX19wYXJhbSk7XHJcbiAgICBleHBvcnRlcihcIl9fbWV0YWRhdGFcIiwgX19tZXRhZGF0YSk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRlclwiLCBfX2F3YWl0ZXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2dlbmVyYXRvclwiLCBfX2dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fZXhwb3J0U3RhclwiLCBfX2V4cG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRcIiwgX19hd2FpdCk7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNHZW5lcmF0b3JcIiwgX19hc3luY0dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNEZWxlZ2F0b3JcIiwgX19hc3luY0RlbGVnYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNWYWx1ZXNcIiwgX19hc3luY1ZhbHVlcyk7XHJcbn0pOyJdfQ=="}